var lA = Object.defineProperty;
var cA = (n, e, t) => e in n ? lA(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var xe = (n, e, t) => cA(n, typeof e != "symbol" ? e + "" : e, t);
import { unref as I, getCurrentInstance as Zr, onMounted as Vs, nextTick as W1, onUnmounted as Q1, getCurrentScope as hA, onScopeDispose as dA, ref as vn, watch as Ua, computed as wt, reactive as sv, defineComponent as Xe, openBlock as q, createElementBlock as ie, Fragment as Ht, renderList as Un, createTextVNode as Ue, createElementVNode as ae, withModifiers as Us, toDisplayString as we, normalizeClass as va, renderSlot as Ri, h as ao, createBlock as ln, createVNode as V, withCtx as se, createCommentVNode as tt, normalizeStyle as pa, createStaticVNode as gA, Transition as K1, withDirectives as id, isRef as Ol, vModelCheckbox as fA, vModelText as z1, onBeforeUnmount as Al, watchEffect as pA, shallowRef as wm, markRaw as mA, customRef as yA, vModelSelect as bA, inject as wA, onBeforeMount as vA, Text as CA } from "vue";
import { Factory as Lt, Source as $1, SourceEmpty as V1, Guest as SA, GuestCast as U1, GuestAware as q1, PatronPool as eS, Patron as kA, PatronOnce as _A, GuestChain as jA, GuestSync as TA, removePatronFromPools as uv, GuestObject as LA } from "patron-oop";
import xA from "html2canvas";
import lv from "konva";
class cl extends Error {
  constructor(e, t) {
    super(e, t);
  }
}
const ef = /* @__PURE__ */ new WeakMap();
class EA {
  constructor(e) {
    this.fileHandler = e;
  }
  content(e) {
    return this.fileHandler.getFile().then((t) => this.readFile(t)).then((t) => {
      e.give(t);
    }).catch((t) => {
      throw new cl("Problem when reading file in SystemFileFromHandler", {
        cause: t
      });
    }), this;
  }
  async readFile(e) {
    let t = "";
    return ef.has(e) ? t = ef.get(e) : (t = await new Response(e).text(), ef.set(e, t)), t;
  }
}
class DA {
  constructor(e) {
    this.fileHandler = e;
  }
  save(e) {
    return this.fileHandler.createWritable().then((t) => (t.write(e).catch((i) => {
      throw new cl("Cant save file in browser", { cause: i });
    }), t)).then((t) => {
      t.close().catch((i) => {
        throw new cl("Cant close written file in browser", { cause: i });
      });
    }), this;
  }
}
class MA {
  constructor(e) {
    this.content = e;
  }
  result() {
    return JSON.parse(this.content);
  }
}
class NA {
  constructor(e) {
    this.content = e;
  }
  result() {
    return JSON.stringify(this.content);
  }
}
class OA {
  constructor(e, t = 100, i = 100) {
    this.svgContent = e, this.width = t, this.height = i;
  }
  markup() {
    return this.svgContent.replaceAll("${width}", String(this.width)).replaceAll("${height}", String(this.height));
  }
}
class AA {
  constructor(e, t) {
    this.type = e, this.factories = t;
  }
  markup() {
    return this.factories.svgImage.create(this.type.svg, this.type.width, this.type.height).markup();
  }
}
class YA {
  constructor(e, t, i) {
    this.chunksCount = e, this.baseNumber = t, this.factories = i;
  }
  chunks(e) {
    return this.baseNumber.value(
      this.factories.guestInTheMiddle.create(e, (t) => {
        const i = Math.round(t / this.chunksCount), a = [];
        for (let o = 1; o <= this.chunksCount; o += 1)
          a.push(o * i);
        e.give(a);
      })
    ), e;
  }
}
class PA {
  constructor(e, t) {
    this.mapUrl = e, this.factories = t;
  }
  name(e) {
    this.mapUrl.value(
      this.factories.guestInTheMiddle.create(e, (t) => {
        let i = t.replace("/", "").replaceAll("/", "_");
        i.match("_") && (i = `_${i}`), e.give(i);
      })
    );
  }
}
class RA {
  constructor(e, t) {
    this.text = e, this.factories = t;
  }
  noHtml(e) {
    return this.text.value(
      this.factories.guestInTheMiddle.create(e, (t) => {
        const i = document.createElement("DIV");
        i.innerHTML = t;
        const a = i.textContent || i.innerText || "";
        e.give(a);
      })
    ), e;
  }
}
var cv;
const ad = typeof window < "u", FA = (n) => typeof n < "u", IA = (n) => typeof n == "function", JA = (n) => typeof n == "string", vm = () => {
};
ad && ((cv = window == null ? void 0 : window.navigator) != null && cv.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function wr(n) {
  return typeof n == "function" ? n() : I(n);
}
function ZA(n) {
  return n;
}
function BA(n) {
  return hA() ? (dA(n), !0) : !1;
}
function tS(n, e = !0) {
  Zr() ? Vs(n) : e ? n() : W1(n);
}
function HA(n) {
  Zr() && Q1(n);
}
function XA(n) {
  var e;
  const t = wr(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const nS = ad ? window : void 0, GA = ad ? window.document : void 0, WA = ad ? window.navigator : void 0;
function Ac(...n) {
  let e, t, i, a;
  if (JA(n[0]) || Array.isArray(n[0]) ? ([t, i, a] = n, e = nS) : [e, t, i, a] = n, !e)
    return vm;
  Array.isArray(t) || (t = [t]), Array.isArray(i) || (i = [i]);
  const o = [], r = () => {
    o.forEach((d) => d()), o.length = 0;
  }, s = (d, f, p, y) => (d.addEventListener(f, p, y), () => d.removeEventListener(f, p, y)), l = Ua(() => [XA(e), wr(a)], ([d, f]) => {
    r(), d && o.push(...t.flatMap((p) => i.map((y) => s(d, p, y, f))));
  }, { immediate: !0, flush: "post" }), h = () => {
    l(), r();
  };
  return BA(h), h;
}
function QA(n, e = !1) {
  const t = vn(), i = () => t.value = !!n();
  return i(), tS(i, e), t;
}
function KA(n) {
  return JSON.parse(JSON.stringify(n));
}
const hv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, dv = "__vueuse_ssr_handlers__";
hv[dv] = hv[dv] || {};
const zA = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
function $A(n = {}) {
  const {
    reactive: e = !1,
    target: t = nS,
    aliasMap: i = zA,
    passive: a = !0,
    onEventFired: o = vm
  } = n, r = sv(/* @__PURE__ */ new Set()), s = {
    toJSON() {
      return {};
    },
    current: r
  }, l = e ? sv(s) : s, h = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
  function f(w, v) {
    w in l && (e ? l[w] = v : l[w].value = v);
  }
  function p() {
    r.clear();
    for (const w of d)
      f(w, !1);
  }
  function y(w, v) {
    var _, L;
    const T = (_ = w.key) == null ? void 0 : _.toLowerCase(), A = [(L = w.code) == null ? void 0 : L.toLowerCase(), T].filter(Boolean);
    T && (v ? r.add(T) : r.delete(T));
    for (const x of A)
      d.add(x), f(x, v);
    T === "meta" && !v ? (h.forEach((x) => {
      r.delete(x), f(x, !1);
    }), h.clear()) : typeof w.getModifierState == "function" && w.getModifierState("Meta") && v && [...r, ...A].forEach((x) => h.add(x));
  }
  Ac(t, "keydown", (w) => (y(w, !0), o(w)), { passive: a }), Ac(t, "keyup", (w) => (y(w, !1), o(w)), { passive: a }), Ac("blur", p, { passive: !0 }), Ac("focus", p, { passive: !0 });
  const m = new Proxy(l, {
    get(w, v, _) {
      if (typeof v != "string")
        return Reflect.get(w, v, _);
      if (v = v.toLowerCase(), v in i && (v = i[v]), !(v in l))
        if (/[+_-]/.test(v)) {
          const T = v.split(/[+_-]/g).map((S) => S.trim());
          l[v] = wt(() => T.every((S) => I(m[S])));
        } else
          l[v] = vn(!1);
      const L = Reflect.get(w, v, _);
      return e ? I(L) : L;
    }
  });
  return m;
}
var gv;
(function(n) {
  n.UP = "UP", n.RIGHT = "RIGHT", n.DOWN = "DOWN", n.LEFT = "LEFT", n.NONE = "NONE";
})(gv || (gv = {}));
function VA(n, e = vm, t = {}) {
  const {
    immediate: i = !0,
    manual: a = !1,
    type: o = "text/javascript",
    async: r = !0,
    crossOrigin: s,
    referrerPolicy: l,
    noModule: h,
    defer: d,
    document: f = GA,
    attrs: p = {}
  } = t, y = vn(null);
  let m = null;
  const w = (L) => new Promise((T, S) => {
    const A = (P) => (y.value = P, T(P), P);
    if (!f) {
      T(!1);
      return;
    }
    let x = !1, M = f.querySelector(`script[src="${wr(n)}"]`);
    M ? M.hasAttribute("data-loaded") && A(M) : (M = f.createElement("script"), M.type = o, M.async = r, M.src = wr(n), d && (M.defer = d), s && (M.crossOrigin = s), h && (M.noModule = h), l && (M.referrerPolicy = l), Object.entries(p).forEach(([P, Y]) => M == null ? void 0 : M.setAttribute(P, Y)), x = !0), M.addEventListener("error", (P) => S(P)), M.addEventListener("abort", (P) => S(P)), M.addEventListener("load", () => {
      M.setAttribute("data-loaded", "true"), e(M), A(M);
    }), x && (M = f.head.appendChild(M)), L || A(M);
  }), v = (L = !0) => (m || (m = w(L)), m), _ = () => {
    if (!f)
      return;
    m = null, y.value && (y.value = null);
    const L = f.querySelector(`script[src="${wr(n)}"]`);
    L && f.head.removeChild(L);
  };
  return i && !a && tS(v), a || HA(_), { scriptTag: y, load: v, unload: _ };
}
var UA = Object.defineProperty, fv = Object.getOwnPropertySymbols, qA = Object.prototype.hasOwnProperty, eY = Object.prototype.propertyIsEnumerable, pv = (n, e, t) => e in n ? UA(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, mv = (n, e) => {
  for (var t in e || (e = {}))
    qA.call(e, t) && pv(n, t, e[t]);
  if (fv)
    for (var t of fv(e))
      eY.call(e, t) && pv(n, t, e[t]);
  return n;
};
function tY(n = {}, e = {}) {
  const { navigator: t = WA } = e, i = t, a = QA(() => i && "canShare" in i);
  return {
    isSupported: a,
    share: async (r = {}) => {
      if (a.value) {
        const s = mv(mv({}, wr(n)), wr(r));
        let l = !0;
        if (s.files && i.canShare && (l = i.canShare({ files: s.files })), l)
          return i.share(s);
      }
    }
  };
}
var nY = Object.defineProperty, yv = Object.getOwnPropertySymbols, iY = Object.prototype.hasOwnProperty, aY = Object.prototype.propertyIsEnumerable, bv = (n, e, t) => e in n ? nY(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, oY = (n, e) => {
  for (var t in e || (e = {}))
    iY.call(e, t) && bv(n, t, e[t]);
  if (yv)
    for (var t of yv(e))
      aY.call(e, t) && bv(n, t, e[t]);
  return n;
};
const rY = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
oY({
  linear: ZA
}, rY);
function od(n, e, t, i = {}) {
  var a, o, r;
  const {
    clone: s = !1,
    passive: l = !1,
    eventName: h,
    deep: d = !1,
    defaultValue: f
  } = i, p = Zr(), y = t || (p == null ? void 0 : p.emit) || ((a = p == null ? void 0 : p.$emit) == null ? void 0 : a.bind(p)) || ((r = (o = p == null ? void 0 : p.proxy) == null ? void 0 : o.$emit) == null ? void 0 : r.bind(p == null ? void 0 : p.proxy));
  let m = h;
  m = h || m || `update:${e.toString()}`;
  const w = (_) => s ? IA(s) ? s(_) : KA(_) : _, v = () => FA(n[e]) ? w(n[e]) : f;
  if (l) {
    const _ = v(), L = vn(_);
    return Ua(() => n[e], (T) => L.value = w(T)), Ua(L, (T) => {
      (T !== n[e] || d) && y(m, T);
    }, { deep: d }), L;
  } else
    return wt({
      get() {
        return v();
      },
      set(_) {
        y(m, _);
      }
    });
}
class sY {
  constructor(e, t, i, a) {
    xe(this, "loadingCache");
    this.callbackName = e, this.url = t, this.emptyValue = i, this.factories = a, this.loadingCache = a.sourceEmpty.create();
  }
  content(e) {
    this.loadingCache.give(!0);
    const t = setTimeout(() => {
      this.loadingCache.give(!1), e.give(this.emptyValue);
    }, 1e4);
    return VA(this.url, () => {
      var a;
      clearInterval(t);
      const i = ((a = window[this.callbackName]) == null ? void 0 : a.call(window)) || this.emptyValue;
      e.give(i), this.loadingCache.give(!1);
    }), e;
  }
  loading(e) {
    return this.loadingCache.value(e), e;
  }
}
class uY {
  constructor(e) {
    this.text = e;
  }
  asString(e) {
    return e.give(this.text), e;
  }
}
class lY {
  constructor(e, t) {
    this.baseText = e, this.factories = t;
  }
  asString(e) {
    return this.baseText.asString(
      this.factories.guestInTheMiddle.create(e, (t) => {
        e.give((t ?? "").replace(/<\/?[^>]+>/gi, " "));
      })
    ), e;
  }
}
var Qa = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function iS(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var np = { exports: {} }, tf, wv;
function cY() {
  if (wv) return tf;
  wv = 1;
  var n = 1e3, e = n * 60, t = e * 60, i = t * 24, a = i * 7, o = i * 365.25;
  tf = function(d, f) {
    f = f || {};
    var p = typeof d;
    if (p === "string" && d.length > 0)
      return r(d);
    if (p === "number" && isFinite(d))
      return f.long ? l(d) : s(d);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(d)
    );
  };
  function r(d) {
    if (d = String(d), !(d.length > 100)) {
      var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        d
      );
      if (f) {
        var p = parseFloat(f[1]), y = (f[2] || "ms").toLowerCase();
        switch (y) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * o;
          case "weeks":
          case "week":
          case "w":
            return p * a;
          case "days":
          case "day":
          case "d":
            return p * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * t;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function s(d) {
    var f = Math.abs(d);
    return f >= i ? Math.round(d / i) + "d" : f >= t ? Math.round(d / t) + "h" : f >= e ? Math.round(d / e) + "m" : f >= n ? Math.round(d / n) + "s" : d + "ms";
  }
  function l(d) {
    var f = Math.abs(d);
    return f >= i ? h(d, f, i, "day") : f >= t ? h(d, f, t, "hour") : f >= e ? h(d, f, e, "minute") : f >= n ? h(d, f, n, "second") : d + " ms";
  }
  function h(d, f, p, y) {
    var m = f >= p * 1.5;
    return Math.round(d / p) + " " + y + (m ? "s" : "");
  }
  return tf;
}
function hY(n) {
  t.debug = t, t.default = t, t.coerce = l, t.disable = o, t.enable = a, t.enabled = r, t.humanize = cY(), t.destroy = h, Object.keys(n).forEach((d) => {
    t[d] = n[d];
  }), t.names = [], t.skips = [], t.formatters = {};
  function e(d) {
    let f = 0;
    for (let p = 0; p < d.length; p++)
      f = (f << 5) - f + d.charCodeAt(p), f |= 0;
    return t.colors[Math.abs(f) % t.colors.length];
  }
  t.selectColor = e;
  function t(d) {
    let f, p = null, y, m;
    function w(...v) {
      if (!w.enabled)
        return;
      const _ = w, L = Number(/* @__PURE__ */ new Date()), T = L - (f || L);
      _.diff = T, _.prev = f, _.curr = L, f = L, v[0] = t.coerce(v[0]), typeof v[0] != "string" && v.unshift("%O");
      let S = 0;
      v[0] = v[0].replace(/%([a-zA-Z%])/g, (x, M) => {
        if (x === "%%")
          return "%";
        S++;
        const P = t.formatters[M];
        if (typeof P == "function") {
          const Y = v[S];
          x = P.call(_, Y), v.splice(S, 1), S--;
        }
        return x;
      }), t.formatArgs.call(_, v), (_.log || t.log).apply(_, v);
    }
    return w.namespace = d, w.useColors = t.useColors(), w.color = t.selectColor(d), w.extend = i, w.destroy = t.destroy, Object.defineProperty(w, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (y !== t.namespaces && (y = t.namespaces, m = t.enabled(d)), m),
      set: (v) => {
        p = v;
      }
    }), typeof t.init == "function" && t.init(w), w;
  }
  function i(d, f) {
    const p = t(this.namespace + (typeof f > "u" ? ":" : f) + d);
    return p.log = this.log, p;
  }
  function a(d) {
    t.save(d), t.namespaces = d, t.names = [], t.skips = [];
    let f;
    const p = (typeof d == "string" ? d : "").split(/[\s,]+/), y = p.length;
    for (f = 0; f < y; f++)
      p[f] && (d = p[f].replace(/\*/g, ".*?"), d[0] === "-" ? t.skips.push(new RegExp("^" + d.slice(1) + "$")) : t.names.push(new RegExp("^" + d + "$")));
  }
  function o() {
    const d = [
      ...t.names.map(s),
      ...t.skips.map(s).map((f) => "-" + f)
    ].join(",");
    return t.enable(""), d;
  }
  function r(d) {
    if (d[d.length - 1] === "*")
      return !0;
    let f, p;
    for (f = 0, p = t.skips.length; f < p; f++)
      if (t.skips[f].test(d))
        return !1;
    for (f = 0, p = t.names.length; f < p; f++)
      if (t.names[f].test(d))
        return !0;
    return !1;
  }
  function s(d) {
    return d.toString().substring(2, d.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(d) {
    return d instanceof Error ? d.stack || d.message : d;
  }
  function h() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return t.enable(t.load()), t;
}
var dY = hY;
(function(n, e) {
  e.formatArgs = i, e.save = a, e.load = o, e.useColors = t, e.storage = r(), e.destroy = /* @__PURE__ */ (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function t() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    l.splice(1, 0, h, "color: inherit");
    let d = 0, f = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (d++, p === "%c" && (f = d));
    }), l.splice(f, 0, h);
  }
  e.log = console.debug || console.log || (() => {
  });
  function a(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function o() {
    let l;
    try {
      l = e.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function r() {
    try {
      return localStorage;
    } catch {
    }
  }
  n.exports = dY(e);
  const { formatters: s } = n.exports;
  s.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(np, np.exports);
var Ie = np.exports;
const aS = /* @__PURE__ */ iS(Ie), gY = Ie.debug("TextNlAsBr");
class fY {
  constructor(e, t) {
    this.baseText = e, this.factories = t;
  }
  asString(e) {
    return this.baseText.asString(
      this.factories.guestInTheMiddle.create(e, (t) => {
        if (typeof t > "u" || t === null)
          return "";
        const i = "<br />";
        return gY(t), e.give((t ?? "").replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, `$1${i}$2`)), !0;
      })
    ), e;
  }
}
const pY = new Lt($1), mY = new Lt($1), yY = new Lt(V1), bY = new Lt(SA), wY = new Lt(U1), vY = new Lt(q1), CY = new Lt(eS), SY = new Lt(kA), kY = new Lt(_A), _Y = new Lt(U1), jY = new Lt(jA), TY = new Lt(TA), Go = {
  cache: pY,
  chain: jY,
  guest: bY,
  guestCast: wY,
  guestAware: vY,
  guestInTheMiddle: _Y,
  guestSync: TY,
  patron: SY,
  patronOnce: kY,
  pool: CY,
  source: mY,
  sourceEmpty: yY
}, LY = new Lt(EA), xY = new Lt(DA), EY = new Lt(NA), DY = new Lt(MA), oS = new Lt(OA), MY = new Lt(AA, { ...Go, svgImage: oS }), NY = new Lt(YA, Go), OY = new Lt(PA, Go), AY = new Lt(RA, Go), YY = new Lt(sY, Go), PY = new Lt(uY), RY = new Lt(lY, Go), FY = new Lt(fY, Go), IY = {
  ...Go,
  fileHandlerContent: LY,
  browserFileSaved: xY,
  transformToString: EY,
  transformToObject: DY,
  svgImage: oS,
  svgMapTypeImage: MY,
  numberChunks: NY,
  mapNameFromUrl: OY,
  textNoHtml: AY,
  jsonp: YY,
  textOf: PY,
  textNlAsBr: FY,
  textWithoutHTML: RY
}, vi = () => IY;
class Cm {
  constructor(e, t, i) {
    this.notification = e, this.check = t, this.factories = i;
  }
  breakOnFail(e, t) {
    return this.check.check(
      e,
      this.factories.guest.create((i) => {
        i === !0 ? t.give(!0) : this.notification.give({
          type: "error",
          text: i
        });
      })
    ), this;
  }
  continueOnFail(e, t) {
    return this.check.check(
      e,
      this.factories.guest.create((i) => {
        t.give(i), i !== !0 && this.notification.give({
          type: "error",
          text: i
        });
      })
    ), this;
  }
}
const nf = Ie.debug("MapCurrent");
class rS {
  constructor(e, t, i) {
    xe(this, "objectsCache");
    xe(this, "settingsCache");
    xe(this, "typesCache");
    this.mapFile = e, this.mapId = t, this.factories = i, this.objectsCache = i.sourceEmpty.create(), this.settingsCache = i.sourceEmpty.create(), this.typesCache = i.sourceEmpty.create(), e.currentMap(
      i.patron.create(
        i.guest.create((a) => {
          nf("current map changed", a), this.settingsCache.give(a.settings), this.objectsCache.give(Object.values(a.objects)), this.typesCache.give(
            Object.entries(a.types).map(([o, r]) => ({
              ...r,
              id: o
            }))
          );
        })
      )
    );
  }
  settings(e) {
    return this.settingsCache.value(e), e;
  }
  objects(e) {
    return nf("notify about new objects"), this.objectsCache.value(e), e;
  }
  types(e) {
    return this.typesCache.value(e), e;
  }
  give(e) {
    return nf("save map document", e), this.mapId.id(
      this.factories.guest.create((t) => {
        this.mapFile.mapFile(
          this.factories.guest.create((i) => {
            this.mapFile.give({
              ...i,
              [t]: e
            });
          })
        );
      })
    ), this;
  }
}
class JY {
  constructor(e) {
    xe(this, "idCache");
    this.idCache = e.cache.create("current");
  }
  id(e) {
    return this.idCache.value(e), e;
  }
  give(e) {
    return this.idCache.give(e), this;
  }
}
const Yc = Ie.debug("MapHistory"), vv = (n) => {
  const e = JSON.parse(JSON.stringify(n));
  return Object.values(e.objects).forEach((t) => {
    t.width = 0, t.height = 0;
  }), JSON.stringify(e);
};
class ZY {
  constructor(e, t, i, a) {
    xe(this, "mapsHistory");
    xe(this, "historyIndex");
    this.mapFile = e, this.map = t, this.mapId = i, this.factories = a, this.mapsHistory = a.cache.create([]), this.historyIndex = a.cache.create(0), this.mapFile.currentMap(a.patron.create(this)), this.mapId.id(
      a.patron.create(
        a.guest.create(() => {
          this.mapsHistory.give([]), this.historyIndex.give(0);
        })
      )
    );
  }
  give(e) {
    return requestIdleCallback(() => {
      this.historyIndex.value(
        this.factories.guest.create((t) => {
          this.mapsHistory.value(
            this.factories.guest.create((i) => {
              Yc("add map to history", i, e);
              const a = i.some(
                (o) => vv(o) === vv(e)
              );
              if (Yc("isMapFromHistory", a), !a) {
                const o = i[t] ? [i[t]] : [];
                this.historyIndex.give(0), this.mapsHistory.give([e, ...o, ...i.slice(0, 9)]);
              }
            })
          );
        })
      );
    }), this;
  }
  isPrevPossible(e) {
    const t = this.factories.chain.create(this);
    return this.historyIndex.value(
      this.factories.guestCast.create(e, t.receiveKey("historyIndex"))
    ), this.mapsHistory.value(this.factories.guestCast.create(e, t.receiveKey("mapsHistory"))), t.result(
      this.factories.guestInTheMiddle.create(
        e,
        ({ historyIndex: i, mapsHistory: a }) => {
          const o = i < a.length - 1;
          Yc("recalculate is prev possible", o), e.give(o);
        }
      )
    ), e;
  }
  prev() {
    this.historyIndex.value(
      this.factories.guest.create((e) => {
        const t = e + 1;
        this.historyIndex.give(t), this.mapsHistory.value(
          this.factories.guest.create((i) => {
            const a = i[t];
            this.map.give(a);
          })
        );
      })
    );
  }
  isNextPossible(e) {
    const t = this.factories.chain.create(this);
    return this.historyIndex.value(
      this.factories.guestCast.create(e, t.receiveKey("historyIndex"))
    ), this.mapsHistory.value(this.factories.guestCast.create(e, t.receiveKey("mapsHistory"))), t.result(
      this.factories.guestInTheMiddle.create(
        e,
        ({ historyIndex: i, mapsHistory: a }) => {
          const o = i > 0 && i <= a.length - 1;
          Yc("recalculate is next possible", o), e.give(o);
        }
      )
    ), e;
  }
  next() {
    this.historyIndex.value(
      this.factories.guest.create((e) => {
        const t = e - 1;
        this.historyIndex.give(t), this.mapsHistory.value(
          this.factories.guest.create((i) => {
            const a = i[t];
            this.map.give(a);
          })
        );
      })
    );
  }
}
class BY {
  constructor(e, t, i) {
    this.mapFile = e, this.mapId = t, this.factories = i;
  }
  give(e) {
    const { guest: t } = this.factories;
    return this.mapFile.mapFile(
      t.create((i) => {
        delete i[e], this.mapFile.give(i), this.mapId.give("current");
      })
    ), this;
  }
}
const Pc = Ie.debug("MapFileOfContent");
class HY {
  constructor(e, t, i) {
    xe(this, "currentMapPatrons");
    xe(this, "mapFileCache");
    this.mapFileContent = e, this.mapId = t, this.factories = i, this.currentMapPatrons = i.pool.create(this), this.mapFileCache = i.cache.create(!1), e.value(
      i.patron.create((a) => {
        if (!a)
          return;
        const o = this.factories.transformToObject.create(a).result();
        Pc("get map file", o), this.mapFileCache.give(o);
      })
    );
  }
  currentMap(e) {
    const t = this.factories.chain.create();
    return this.mapId.id(this.factories.guestCast.create(e, t.receiveKey("mapId"))), this.mapFile(this.factories.guestCast.create(e, t.receiveKey("mapFile"))), t.result(
      this.factories.guestInTheMiddle.create(
        e,
        ({ mapId: i, mapFile: a }) => {
          if (Pc("get current map", i, a, typeof a), !a[i])
            this.createEmptyMapByName(i, e);
          else {
            const o = a[i];
            this.currentMapPatrons.distribute(
              o != null && o.structure ? o.structure : o,
              e
            );
          }
        }
      )
    ), e;
  }
  give(e) {
    return Pc("save map file document", e), this.mapFileContent.give(this.factories.transformToString.create(e).result()), this;
  }
  mapFile(e) {
    return this.mapFileCache.value(e), e;
  }
  createEmptyMapByName(e, t) {
    Pc("creating empty map by name", e);
    const i = this.factories.transformToObject.create(this.generateEmptyMapFile()).result();
    this.mapFile(
      this.factories.guest.create((a) => {
        this.give({
          ...a,
          [e]: i.current
        }), t.give(i.current);
      })
    );
  }
  generateEmptyMapFile() {
    return '{"current":{"progress":0,"settings":{"colored":false,"title":"current"},"objects":{},"types":{},"url":"/current","parent":""}}';
  }
}
const XY = Ie.debug("MapFileForRendering");
class GY {
  constructor(e, t, i) {
    xe(this, "mapCache");
    this.mapId = t, this.factories = i, this.mapCache = i.cache.create({ objects: {}, types: {}, settings: {} }), e.currentMap(i.patron.create(this.mapCache));
  }
  currentMap(e) {
    return this.mapCache.value(e), e;
  }
  mapFile(e) {
    return this.mapCache.value(
      this.factories.guestInTheMiddle.create(e, (t) => {
        this.mapId.id(
          this.factories.guest.create((i) => {
            e.give({ [i]: t });
          })
        );
      })
    ), e;
  }
  give(e) {
    return this.mapId.id(
      this.factories.guest.create((t) => {
        XY("received map file, objects = ", e[t].objects), this.mapCache.give(e[t]);
      })
    ), this;
  }
}
class sS {
  constructor(e, t, i) {
    this.map = e, this.mapFile = t, this.factories = i;
  }
  give(e) {
    return this.mapFile.currentMap(
      this.factories.guest.create((t) => {
        this.map.give({
          ...t,
          objects: {
            ...t.objects,
            [e.id]: {
              ...e,
              createTimestamp: e.createTimestamp ?? Date.now(),
              changeTimestamp: Date.now()
            }
          }
        });
      })
    ), this;
  }
}
const Cv = aS("app:MapObjectCurrent");
class WY {
  constructor(e, t) {
    xe(this, "idCache");
    xe(this, "silenceActivator");
    this.drawer = e, this.factories = t, this.idCache = t.sourceEmpty.create(), this.silenceActivator = t.source.create(!1), this.idCache.value(
      t.patron.create(
        t.guest.create((i) => {
          i && e.give("object");
        })
      )
    );
  }
  silenceOn(e) {
    return this.silenceActivator.give(e), this;
  }
  silenceOff() {
    return this.silenceActivator.give(!1), this;
  }
  objectId(e) {
    return this.idCache.value(e), e;
  }
  give(e) {
    return Cv("new value current object", e), this.silenceActivator.value(
      this.factories.guest.create((t) => {
        Cv("silence activator", t), t ? t.give(e) : this.idCache.give(e);
      })
    ), this;
  }
}
class QY {
  constructor(e, t) {
    this.mapFile = e, this.factories = t;
  }
  check(e, t) {
    return this.mapFile.currentMap(
      this.factories.guest.create((i) => {
        let a = !1;
        Object.values(i.objects).forEach((o) => {
          a = a || o.arrows.some((r) => r.id === e.id);
        }), t.give(!a || "Ð£ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° ÐµÑÑ‚ÑŒ Ð²Ñ…Ð¾Ð´ÑÑ‰Ð¸Ðµ ÑÐ²ÑÐ·Ð¸!");
      })
    ), this;
  }
}
const af = Ie.debug("MapObjectNew");
class KY {
  constructor(e, t, i, a, o) {
    this.map = e, this.mapObject = t, this.canvas = i, this.stagePosition = a, this.factories = o;
  }
  byTypeName(e, t) {
    return af("start to add new type", e, t), this.stagePosition.position(
      this.factories.guest.create((i) => {
        this.map.types(
          this.factories.guest.create((a) => {
            this.canvas.canvas(
              this.factories.guest.create((o) => {
                const r = o.getBoundingClientRect(), s = a.find((d) => d.id === e);
                af("is type found", s);
                const l = t.x - r.left, h = t.y - r.top;
                s && (af("add new type"), this.mapObject.give({
                  additionalName: "",
                  arrows: [],
                  description: "",
                  inMenu: !1,
                  lastClick: Date.now(),
                  linked: !1,
                  menuOrder: 0,
                  name: "",
                  outlink: "",
                  targetBlank: !1,
                  type: e,
                  width: s.width,
                  height: s.height,
                  zindex: 0,
                  id: (/* @__PURE__ */ new Date()).getTime().toString(),
                  createTimestamp: Date.now(),
                  changeTimestamp: Date.now(),
                  position: [
                    l > 0 ? l + i.x : 0,
                    h > 0 ? h + i.y : 0
                  ]
                }));
              })
            );
          })
        );
      })
    ), this;
  }
}
class zY {
  constructor(e, t) {
    this.mapId = e, this.factories = t;
  }
  names(e) {
    return this.mapId.id(
      this.factories.guestInTheMiddle.create(e, (t) => {
        const i = t.split("_").filter((r) => !!r);
        let a = "";
        const o = i.map((r) => {
          const s = `${a}${r}`;
          return a || (a = "_"), a += `${r}_`, s;
        });
        a = "", e.give(o);
      })
    ), e;
  }
}
class $Y {
  constructor(e) {
    this.mapObject = e;
  }
  give(e) {
    const { arrows: t } = e.object;
    return t.splice(e.index, 1), this.mapObject.give({
      ...e.object,
      arrows: t
    }), this;
  }
}
class VY {
  constructor(e, t, i, a) {
    this.map = e, this.mapFile = t, this.checks = i, this.factories = a;
  }
  give(e) {
    const t = this.factories.chain.create(this);
    return this.checks.forEach((i, a) => {
      i.breakOnFail(e, t.receiveKey(String(a)));
    }), t.result(
      this.factories.guest.create(() => {
        this.mapFile.currentMap(
          this.factories.guest.create((i) => {
            delete i.objects[e.id], this.map.give(i);
          })
        );
      })
    ), this;
  }
}
const UY = Ie.debug("MapObjectsLink");
class qY {
  constructor(e, t, i, a, o) {
    xe(this, "objectIdsCache");
    this.mapObjectCurrent = e, this.map = t, this.mapObject = i, this.newArrow = a, this.factories = o, this.objectIdsCache = o.cache.create([]);
  }
  objectIds(e) {
    return this.objectIdsCache.value(e), e;
  }
  startLink() {
    this.mapObjectCurrent.give(""), this.objectIdsCache.value(
      this.factories.guest.create((e) => {
        if (e.length) {
          this.mapObjectCurrent.silenceOff(), this.objectIdsCache.give([]);
          return;
        }
        const t = ["first"];
        this.objectIdsCache.give(t), this.mapObjectCurrent.silenceOn(
          this.factories.guest.create((i) => {
            t.push(i), this.objectIdsCache.give([...t]), UY("object ids", t), t.length === 2 && this.map.objects(
              this.factories.guest.create((a) => {
                const [, o] = t, r = a.find((s) => s.id === o);
                r && this.newArrow.forObject(r);
              })
            ), t.length === 3 && (this.newArrow.dispose(), this.mapObjectCurrent.silenceOff(), this.map.objects(
              this.factories.guest.create((a) => {
                const [, o, r] = t, s = a.find((l) => l.id === o);
                s && r && (this.objectIdsCache.give([]), this.mapObject.give({
                  ...s,
                  arrows: [
                    ...s.arrows,
                    {
                      id: r,
                      label: ""
                    }
                  ]
                }));
              })
            ));
          })
        );
      })
    );
  }
}
let hh = [["\0", "", "", "", "", "", "", "\x07", "\b", "	", `
`, "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", " ", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "", , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , " ", "!", "C/", "PS", "$?", "Y=", "|", "SS", '"', "(c)", "a", "<<", "!", , "(r)", "-", "deg", "+-", "2", "3", "'", "u", "P", "*", ",", "1", "o", ">>", "1/4", "1/2", "3/4", "?", "A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "U", "Th", "ss", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "/", "o", "u", "u", "u", "u", "y", "th", "y"], ["A", "a", "A", "a", "A", "a", "C", "c", "C", "c", "C", "c", "C", "c", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "G", "g", "G", "g", "G", "g", "G", "g", "H", "h", "H", "h", "I", "i", "I", "i", "I", "i", "I", "i", "I", "i", "IJ", "ij", "J", "j", "K", "k", "k", "L", "l", "L", "l", "L", "l", "L", "l", "L", "l", "N", "n", "N", "n", "N", "n", "'n", "NG", "ng", "O", "o", "O", "o", "O", "o", "OE", "oe", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "W", "w", "Y", "y", "Y", "Z", "z", "Z", "z", "Z", "z", "s", "b", "B", "B", "b", "6", "6", "O", "C", "c", "D", "D", "D", "d", "d", "3", "@", "E", "F", "f", "G", "G", "hv", "I", "I", "K", "k", "l", "l", "W", "N", "n", "O", "O", "o", "OI", "oi", "P", "p", "YR", "2", "2", "SH", "sh", "t", "T", "t", "T", "U", "u", "Y", "V", "Y", "y", "Z", "z", "ZH", "ZH", "zh", "zh", "2", "5", "5", "ts", "w", "|", "||", "|=", "!", "DZ", "Dz", "dz", "LJ", "Lj", "lj", "NJ", "Nj", "nj", "A", "a", "I", "i", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "@", "A", "a", "A", "a", "AE", "ae", "G", "g", "G", "g", "K", "k", "O", "o", "O", "o", "ZH", "zh", "j", "DZ", "D", "dz", "G", "g", "HV", "W", "N", "n", "A", "a", "AE", "ae", "O", "o"], ["A", "a", "A", "a", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "R", "r", "R", "r", "U", "u", "U", "u", "S", "s", "T", "t", "Y", "y", "H", "h", "N", "d", "OU", "ou", "Z", "z", "A", "a", "E", "e", "O", "o", "O", "o", "O", "o", "O", "o", "Y", "y", "l", "n", "t", "j", "db", "qp", "A", "C", "c", "L", "T", "s", "z", "?", "?", "B", "U", "V", "E", "e", "J", "j", "Q", "q", "R", "r", "Y", "y", "a", "a", "a", "b", "o", "c", "d", "d", "e", "@", "@", "e", "e", "e", "e", "j", "g", "g", "g", "g", "u", "Y", "h", "h", "i", "i", "I", "l", "l", "l", "lZ", "W", "W", "m", "n", "n", "n", "o", "OE", "O", "F", "R", "R", "R", "R", "r", "r", "R", "R", "R", "s", "S", "j", "S", "S", "t", "t", "U", "U", "v", "^", "W", "Y", "Y", "z", "z", "Z", "Z", "?", "?", "?", "C", "@", "B", "E", "G", "H", "j", "k", "L", "q", "?", "?", "dz", "dZ", "dz", "ts", "tS", "tC", "fN", "ls", "lz", "WW", "]]", "h", "h", "k", "h", "j", "r", "r", "r", "r", "w", "y", "'", '"', "`", "'", "`", "`", "'", "?", "?", "<", ">", "^", "V", "^", "V", "'", "-", "/", "\\", ",", "_", "\\", "/", ":", ".", "`", "'", "^", "V", "+", "-", "V", ".", "@", ",", "~", '"', "R", "X", "G", "l", "s", "x", "?", , , , , , , , "V", "=", '"'], [, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "'", ",", , , , , , , , , "?", , , , , , , , "A", ";", "E", "I", "I", , "O", , "U", "O", "I", "A", "V", "G", "D", "E", "Z", "I", "Th", "I", "K", "L", "M", "N", "X", "O", "P", "R", , "S", "T", "Y", "F", "H", "Ps", "O", "I", "Y", "a", "e", "i", "i", "y", "a", "v", "g", "d", "e", "z", "i", "th", "i", "k", "l", "m", "n", "x", "o", "p", "r", "s", "s", "t", "y", "f", "h", "ps", "o", "i", "y", "o", "y", "o", , "b", "th", "U", "U", "U", "ph", "p", "&", , , "St", "st", "W", "w", "Q", "q", "Sp", "sp", "Sh", "sh", "F", "f", "Kh", "kh", "H", "h", "G", "g", "CH", "ch", "Ti", "ti", "k", "r", "c", "j"], ["Jo", "Yo", "Dj", "Gj", "Ie", "Dz", "I", "Yi", "J", "Lj", "Nj", "Tsh", "Kj", "I", "U", "Dzh", "A", "B", "V", "G", "D", "E", "Zh", "Z", "I", "Y", "K", "L", "M", "N", "O", "P", "R", "S", "T", "U", "F", "H", "C", "Ch", "Sh", "Shch", , "Y", , "E", "Yu", "Ya", "a", "b", "v", "g", "d", "e", "zh", "z", "i", "y", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "f", "h", "c", "ch", "sh", "shch", , "y", , "e", "yu", "ya", "je", "yo", "dj", "gj", "ie", "dz", "i", "yi", "j", "lj", "nj", "tsh", "kj", "i", "u", "dzh", "O", "o", "E", "e", "Ie", "ie", "E", "e", "Ie", "ie", "O", "o", "Io", "io", "Ks", "ks", "Ps", "ps", "F", "f", "Y", "y", "Y", "y", "u", "u", "O", "o", "O", "o", "Ot", "ot", "Q", "q", "*1000*", , , , , , "*100.000*", "*1.000.000*", , , '"', '"', "R'", "r'", "G'", "g'", "G'", "g'", "G'", "g'", "Zh'", "zh'", "Z'", "z'", "K'", "k'", "K'", "k'", "K'", "k'", "K'", "k'", "N'", "n'", "Ng", "ng", "P'", "p'", "Kh", "kh", "S'", "s'", "T'", "t'", "U", "u", "U'", "u'", "Kh'", "kh'", "Tts", "tts", "Ch'", "ch'", "Ch'", "ch'", "H", "h", "Ch", "ch", "Ch'", "ch'", "`", "Zh", "zh", "K'", "k'", , , "N'", "n'", , , "Ch", "ch", , , , "a", "a", "A", "a", "Ae", "ae", "Ie", "ie", "@", "@", "@", "@", "Zh", "zh", "Z", "z", "Dz", "dz", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "E", "e", "U", "u", "U", "u", "U", "u", "Ch", "ch", , , "Y", "y"], [, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "A", "B", "G", "D", "E", "Z", "E", "E", "T`", "Zh", "I", "L", "Kh", "Ts", "K", "H", "Dz", "Gh", "Ch", "M", "Y", "N", "Sh", "O", "Ch`", "P", "J", "Rh", "S", "V", "T", "R", "Ts`", "W", "P`", "K`", "O", "F", , , "<", "'", "/", "!", ",", "?", ".", , "a", "b", "g", "d", "e", "z", "e", "e", "t`", "zh", "i", "l", "kh", "ts", "k", "h", "dz", "gh", "ch", "m", "y", "n", "sh", "o", "ch`", "p", "j", "rh", "s", "v", "t", "r", "ts`", "w", "p`", "k`", "o", "f", "ew", , ".", "-", , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "@", "e", "a", "o", "i", "e", "e", "a", "a", "o", , "u", "'", , , , , , , ":", , , , , , , , , , , , , , "b", "g", "d", "h", "v", "z", "kh", "t", "y", "k", "k", "l", "m", "m", "n", "n", "s", "`", "p", "p", "ts", "ts", "q", "r", "sh", "t", , , , , , "V", "oy", "i", "'", '"'], [, , , , , , , , , , , , ",", , , , , , , , , , , , , , , ";", , , , "?", , , "a", "'", "w'", , "y'", , "b", "@", "t", "th", "j", "H", "kh", "d", "dh", "r", "z", "s", "sh", "S", "D", "T", "Z", "aa", "G", , , , , , , "f", "q", "k", "l", "m", "n", "h", "w", "~", "y", "an", "un", "in", "a", "u", "i", "W", , , "'", "'", , , , , , , , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "%", ".", ",", "*", , , , "'", "'", "'", , "'", "'w", "'u", "'y", "tt", "tth", "b", "t", "T", "p", "th", "bh", "'h", "H", "ny", "dy", "H", "ch", "cch", "dd", "D", "D", "Dt", "dh", "ddh", "d", "D", "D", "rr", "R", "R", "R", "R", "R", "R", "j", "R", "S", "S", "S", "S", "S", "T", "GH", "F", "F", "F", "v", "f", "ph", "Q", "Q", "kh", "k", "K", "K", "ng", "K", "g", "G", "N", "G", "G", "G", "L", "L", "L", "L", "N", "N", "N", "N", "N", "h", "Ch", "hy", "h", "H", "@", "W", "oe", "oe", "u", "yu", "yu", "W", "v", "y", "Y", "Y", "W", , , "y", "y'", ".", "ae", , , , , , , , "@", "#", , , , , , , , , , , "^", , , , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "Sh", "D", "Gh", "&", "+m"], ["//", "/", ",", "!", "!", "-", ",", ",", ";", "?", "~", "{", "}", "*", , , "'", , "b", "g", "g", "d", "d", "h", "w", "z", "H", "t", "t", "y", "yh", "k", "l", "m", "n", "s", "s", "`", "p", "p", "S", "q", "r", "sh", "t", , , , "a", "a", "a", "A", "A", "A", "e", "e", "e", "E", "i", "i", "u", "u", "u", "o", , "`", "'", , , "X", "Q", "@", "@", "|", "+", , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "h", "sh", "n", "r", "b", "L", "k", "'", "v", "m", "f", "dh", "th", "l", "g", "ny", "s", "d", "z", "t", "y", "p", "j", "ch", "tt", "hh", "kh", "th", "z", "sh", "s", "d", "t", "z", "`", "gh", "q", "w", "a", "aa", "i", "ee", "u", "oo", "e", "ey", "o", "oa"], [], [, "N", "N", "H", , "a", "aa", "i", "ii", "u", "uu", "R", "L", "eN", "e", "e", "ai", "oN", "o", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "nnn", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "l", "lll", "v", "sh", "ss", "s", "h", , , "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "e", "e", "ai", "oN", "o", "o", "au", , , , "AUM", "'", "'", "`", "'", , , , "q", "khh", "ghh", "z", "dddh", "rh", "f", "yy", "RR", "LL", "L", "LL", " / ", " // ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", , , , , , , , , , , , , , , , , "N", "N", "H", , "a", "aa", "i", "ii", "u", "uu", "R", "RR", , , "e", "ai", , , "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", , "p", "ph", "b", "bh", "m", "y", "r", , "l", , , , "sh", "ss", "s", "h", , , "'", , "aa", "i", "ii", "u", "uu", "R", "RR", , , "e", "ai", , , "o", "au", , , , , , , , , , , "+", , , , , "rr", "rh", , "yy", "RR", "LL", "L", "LL", , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "r'", "r`", "Rs", "Rs", "1/", "2/", "3/", "4/", " 1 - 1/", "/16"], [, , "N", , , "a", "aa", "i", "ii", "u", "uu", , , , , "ee", "ai", , , "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", , "p", "ph", "b", "bb", "m", "y", "r", , "l", "ll", , "v", "sh", , "s", "h", , , "'", , "aa", "i", "ii", "u", "uu", , , , , "ee", "ai", , , "oo", "au", , , , , , , , , , , , , "khh", "ghh", "z", "rr", , "f", , , , , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "N", "H", , , "G.E.O.", , , , , , , , , , , , , "N", "N", "H", , "a", "aa", "i", "ii", "u", "uu", "R", , "eN", , "e", "ai", "oN", , "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", , "p", "ph", "b", "bh", "m", "ya", "r", , "l", "ll", , "v", "sh", "ss", "s", "h", , , "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", , "e", "ai", "oN", , "o", "au", , , , "AUM", , , , , , , , , , , , , , , , "RR", , , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], [, "N", "N", "H", , "a", "aa", "i", "ii", "u", "uu", "R", "L", , , "e", "ai", , , "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", , "p", "ph", "b", "bh", "m", "y", "r", , "l", "ll", , , "sh", "ss", "s", "h", , , "'", "'", "aa", "i", "ii", "u", "uu", "R", , , , "e", "ai", , , "o", "au", , , , , , , , , , "+", "+", , , , , "rr", "rh", , "yy", "RR", "LL", , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", , , , , , , , , , , , , , , , , , , "N", "H", , "a", "aa", "i", "ii", "u", "uu", , , , "e", "ee", "ai", , "o", "oo", "au", "k", , , , "ng", "c", , "j", , "ny", "tt", , , , "nn", "t", , , , "n", "nnn", "p", , , , "m", "y", "r", "rr", "l", "ll", "lll", "v", , "ss", "s", "h", , , , , "aa", "i", "ii", "u", "uu", , , , "e", "ee", "ai", , "o", "oo", "au", , , , , , , , , , , "+", , , , , , , , , , , , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+10+", "+100+", "+1000+"], [, "N", "N", "H", , "a", "aa", "i", "ii", "u", "uu", "R", "L", , "e", "ee", "ai", , "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", , "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", , "v", "sh", "ss", "s", "h", , , , , "aa", "i", "ii", "u", "uu", "R", "RR", , "e", "ee", "ai", , "o", "oo", "au", , , , , , , , , "+", "+", , , , , , , , , , "RR", "LL", , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", , , , , , , , , , , , , , , , , , , "N", "H", , "a", "aa", "i", "ii", "u", "uu", "R", "L", , "e", "ee", "ai", , "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", , "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", , "v", "sh", "ss", "s", "h", , , , , "aa", "i", "ii", "u", "uu", "R", "RR", , "e", "ee", "ai", , "o", "oo", "au", , , , , , , , , "+", "+", , , , , , , , "lll", , "RR", "LL", , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], [, , "N", "H", , "a", "aa", "i", "ii", "u", "uu", "R", "L", , "e", "ee", "ai", , "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", , "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "lll", "v", "sh", "ss", "s", "h", , , , , "aa", "i", "ii", "u", "uu", "R", , , "e", "ee", "ai", , "o", "oo", "au", , , , , , , , , , , "+", , , , , , , , , "RR", "LL", , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", , , , , , , , , , , , , , , , , , , "N", "H", , "a", "aa", "ae", "aae", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "ai", "o", "oo", "au", , , , "k", "kh", "g", "gh", "ng", "nng", "c", "ch", "j", "jh", "ny", "jny", "nyj", "tt", "tth", "dd", "ddh", "nn", "nndd", "t", "th", "d", "dh", "n", , "nd", "p", "ph", "b", "bh", "m", "mb", "y", "r", , "l", , , "v", "sh", "ss", "s", "h", "ll", "f", , , , , , , , , "aa", "ae", "aae", "i", "ii", "u", , "uu", , "R", "e", "ee", "ai", "o", "oo", "au", "L", , , , , , , , , , , , , , , , , , , "RR", "LL", " . "], [, "k", "kh", "kh", "kh", "kh", "kh", "ng", "cch", "ch", "ch", "ch", "ch", "y", "d", "t", "th", "th", "th", "n", "d", "t", "th", "th", "th", "n", "b", "p", "ph", "f", "ph", "f", "ph", "m", "y", "r", "R", "l", "L", "w", "s", "s", "s", "h", "l", "`", "h", "~", "a", "a", "aa", "am", "i", "ii", "ue", "uue", "u", "uu", "'", , , , , "Bh.", "e", "ae", "o", "ai", "ai", "ao", "+", , , , , , , "M", , " * ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " // ", " /// ", , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "k", "kh", , "kh", , , "ng", "ch", , "s", , , "ny", , , , , , , "d", "h", "th", "th", , "n", "b", "p", "ph", "f", "ph", "f", , "m", "y", "r", , "l", , "w", , , "s", "h", , "`", , "~", "a", , "aa", "am", "i", "ii", "y", "yy", "u", "uu", , "o", "l", "ny", , , "e", "ei", "o", "ay", "ai", , "+", , , , , , , "M", , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", , , "hn", "hm"], ["AUM", , , , , , , , " // ", " * ", , "-", " / ", " / ", " // ", " -/ ", " +/ ", " X/ ", " /XX/ ", " /X/ ", ",", , , , , , , , , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".5", "1.5", "2.5", "3.5", "4.5", "5.5", "6.5", "7.5", "8.5", "-.5", "+", "*", "^", "_", , "~", , "]", "[[", "]]", , , "k", "kh", "g", "gh", "ng", "c", "ch", "j", , "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ssh", "s", "h", "a", "kss", "r", , , , , , , "aa", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "o", "oo", "M", "H", "i", "ii", , , , , , , , , , , , , , , "k", "kh", "g", "gh", "ng", "c", "ch", "j", , "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ss", "s", "h", "a", "kss", "w", "y", "r", , "X", " :X: ", " /O/ ", " /o/ ", " \\o\\ ", " (O) "], ["k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "nny", "tt", "tth", "dd", "ddh", "nn", "tt", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "w", "s", "h", "ll", "a", , "i", "ii", "u", "uu", "e", , "o", "au", , "aa", "i", "ii", "u", "uu", "e", "ai", , , , "N", "'", ":", , , , , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " / ", " // ", "n*", "r*", "l*", "e*", "sh", "ss", "R", "RR", "L", "LL", "R", "RR", "L", "LL", , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "A", "B", "G", "D", "E", "V", "Z", "T`", "I", "K", "L", "M", "N", "O", "P", "Zh", "R", "S", "T", "U", "P`", "K`", "G'", "Q", "Sh", "Ch`", "C`", "Z'", "C", "Ch", "X", "J", "H", "E", "Y", "W", "Xh", "OE", , , , , , , , , , , "a", "b", "g", "d", "e", "v", "z", "t`", "i", "k", "l", "m", "n", "o", "p", "zh", "r", "s", "t", "u", "p`", "k`", "g'", "q", "sh", "ch`", "c`", "z'", "c", "ch", "x", "j", "h", "e", "y", "w", "xh", "oe", "f", , , , , " // "], ["g", "gg", "n", "d", "dd", "r", "m", "b", "bb", "s", "ss", , "j", "jj", "c", "k", "t", "p", "h", "ng", "nn", "nd", "nb", "dg", "rn", "rr", "rh", "rN", "mb", "mN", "bg", "bn", , "bs", "bsg", "bst", "bsb", "bss", "bsj", "bj", "bc", "bt", "bp", "bN", "bbN", "sg", "sn", "sd", "sr", "sm", "sb", "sbg", "sss", "s", "sj", "sc", "sk", "st", "sp", "sh", , , , , "Z", "g", "d", "m", "b", "s", "Z", , "j", "c", "t", "p", "N", "j", , , , , "ck", "ch", , , "pb", "pN", "hh", "Q", , , , , , , , "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "a-o", "a-u", "ya-o", "ya-yo", "eo-o", "eo-u", "eo-eu", "yeo-o", "yeo-u", "o-eo", "o-e", "o-ye", "o-o", "o-u", "yo-ya", "yo-yae", "yo-yeo", "yo-o", "yo-i", "u-a", "u-ae", "u-eo-eu", "u-ye", "u-u", "yu-a", "yu-eo", "yu-e", "yu-yeo", "yu-ye", "yu-u", "yu-i", "eu-u", "eu-eu", "yi-u", "i-a", "i-ya", "i-o", "i-u", "i-eu", "i-U", "U", "U-eo", "U-u", "U-i", "UU", , , , , , "g", "gg", "gs", "n", "nj", "nh", "d", "l", "lg", "lm", "lb", "ls", "lt", "lp", "lh", "m", "b", "bs", "s", "ss", "ng", "j", "c", "k", "t", "p", "h", "gl", "gsg", "ng", "nd", "ns", "nZ", "nt", "dg", "tl", "lgs", "ln", "ld", "lth", "ll", "lmg", "lms", "lbs", "lbh", "rNp", "lss", "lZ", "lk", "lQ", "mg", "ml", "mb", "ms", "mss", "mZ", "mc", "mh", "mN", "bl", "bp", "ph", "pN", "sg", "sd", "sl", "sb", "Z", "g", "ss", , "kh", "N", "Ns", "NZ", "pb", "pN", "hn", "hl", "hm", "hb", "Q"], ["ha", "hu", "hi", "haa", "hee", "he", "ho", , "la", "lu", "li", "laa", "lee", "le", "lo", "lwa", "hha", "hhu", "hhi", "hhaa", "hhee", "hhe", "hho", "hhwa", "ma", "mu", "mi", "maa", "mee", "me", "mo", "mwa", "sza", "szu", "szi", "szaa", "szee", "sze", "szo", "szwa", "ra", "ru", "ri", "raa", "ree", "re", "ro", "rwa", "sa", "su", "si", "saa", "see", "se", "so", "swa", "sha", "shu", "shi", "shaa", "shee", "she", "sho", "shwa", "qa", "qu", "qi", "qaa", "qee", "qe", "qo", , "qwa", , "qwi", "qwaa", "qwee", "qwe", , , "qha", "qhu", "qhi", "qhaa", "qhee", "qhe", "qho", , "qhwa", , "qhwi", "qhwaa", "qhwee", "qhwe", , , "ba", "bu", "bi", "baa", "bee", "be", "bo", "bwa", "va", "vu", "vi", "vaa", "vee", "ve", "vo", "vwa", "ta", "tu", "ti", "taa", "tee", "te", "to", "twa", "ca", "cu", "ci", "caa", "cee", "ce", "co", "cwa", "xa", "xu", "xi", "xaa", "xee", "xe", "xo", , "xwa", , "xwi", "xwaa", "xwee", "xwe", , , "na", "nu", "ni", "naa", "nee", "ne", "no", "nwa", "nya", "nyu", "nyi", "nyaa", "nyee", "nye", "nyo", "nywa", "'a", "'u", , "'aa", "'ee", "'e", "'o", "'wa", "ka", "ku", "ki", "kaa", "kee", "ke", "ko", , "kwa", , "kwi", "kwaa", "kwee", "kwe", , , "kxa", "kxu", "kxi", "kxaa", "kxee", "kxe", "kxo", , "kxwa", , "kxwi", "kxwaa", "kxwee", "kxwe", , , "wa", "wu", "wi", "waa", "wee", "we", "wo", , "`a", "`u", "`i", "`aa", "`ee", "`e", "`o", , "za", "zu", "zi", "zaa", "zee", "ze", "zo", "zwa", "zha", "zhu", "zhi", "zhaa", "zhee", "zhe", "zho", "zhwa", "ya", "yu", "yi", "yaa", "yee", "ye", "yo", , "da", "du", "di", "daa", "dee", "de", "do", "dwa", "dda", "ddu", "ddi", "ddaa", "ddee", "dde", "ddo", "ddwa"], ["ja", "ju", "ji", "jaa", "jee", "je", "jo", "jwa", "ga", "gu", "gi", "gaa", "gee", "ge", "go", , "gwa", , "gwi", "gwaa", "gwee", "gwe", , , "gga", "ggu", "ggi", "ggaa", "ggee", "gge", "ggo", , "tha", "thu", "thi", "thaa", "thee", "the", "tho", "thwa", "cha", "chu", "chi", "chaa", "chee", "che", "cho", "chwa", "pha", "phu", "phi", "phaa", "phee", "phe", "pho", "phwa", "tsa", "tsu", "tsi", "tsaa", "tsee", "tse", "tso", "tswa", "tza", "tzu", "tzi", "tzaa", "tzee", "tze", "tzo", , "fa", "fu", "fi", "faa", "fee", "fe", "fo", "fwa", "pa", "pu", "pi", "paa", "pee", "pe", "po", "pwa", "rya", "mya", "fya", , , , , , , " ", ".", ",", ";", ":", ":: ", "?", "//", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10+", "20+", "30+", "40+", "50+", "60+", "70+", "80+", "90+", "100+", "10,000+", , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "a", "e", "i", "o", "u", "v", "ga", "ka", "ge", "gi", "go", "gu", "gv", "ha", "he", "hi", "ho", "hu", "hv", "la", "le", "li", "lo", "lu", "lv", "ma", "me", "mi", "mo", "mu", "na", "hna", "nah", "ne", "ni", "no", "nu", "nv", "qua", "que", "qui", "quo", "quu", "quv", "sa", "s", "se", "si", "so", "su", "sv", "da", "ta", "de", "te", "di", "ti", "do", "du", "dv", "dla", "tla", "tle", "tli", "tlo", "tlu", "tlv", "tsa", "tse", "tsi", "tso", "tsu", "tsv", "wa", "we", "wi", "wo", "wu", "wv", "ya", "ye", "yi", "yo", "yu", "yv"], [, "ai", "aai", "i", "ii", "u", "uu", "oo", "ee", "i", "a", "aa", "we", "we", "wi", "wi", "wii", "wii", "wo", "wo", "woo", "woo", "woo", "wa", "wa", "waa", "waa", "waa", "ai", "w", "'", "t", "k", "sh", "s", "n", "w", "n", , "w", "c", "?", "l", "en", "in", "on", "an", "pai", "paai", "pi", "pii", "pu", "puu", "poo", "hee", "hi", "pa", "paa", "pwe", "pwe", "pwi", "pwi", "pwii", "pwii", "pwo", "pwo", "pwoo", "pwoo", "pwa", "pwa", "pwaa", "pwaa", "pwaa", "p", "p", "h", "tai", "taai", "ti", "tii", "tu", "tuu", "too", "dee", "di", "ta", "taa", "twe", "twe", "twi", "twi", "twii", "twii", "two", "two", "twoo", "twoo", "twa", "twa", "twaa", "twaa", "twaa", "t", "tte", "tti", "tto", "tta", "kai", "kaai", "ki", "kii", "ku", "kuu", "koo", "ka", "kaa", "kwe", "kwe", "kwi", "kwi", "kwii", "kwii", "kwo", "kwo", "kwoo", "kwoo", "kwa", "kwa", "kwaa", "kwaa", "kwaa", "k", "kw", "keh", "kih", "koh", "kah", "gai", "caai", "gi", "gii", "gu", "guu", "coo", "ga", "gaa", "cwe", "cwe", "cwi", "cwi", "cwii", "cwii", "cwo", "cwo", "cwoo", "cwoo", "cwa", "cwa", "cwaa", "cwaa", "cwaa", "g", "th", "mai", "maai", "mi", "mii", "mu", "muu", "moo", "ma", "maa", "mwe", "mwe", "mwi", "mwi", "mwii", "mwii", "mwo", "mwo", "mwoo", "mwoo", "mwa", "mwa", "mwaa", "mwaa", "mwaa", "m", "m", "mh", "m", "m", "nai", "naai", "ni", "nii", "nu", "nuu", "noo", "na", "naa", "nwe", "nwe", "nwa", "nwa", "nwaa", "nwaa", "nwaa", "n", "ng", "nh", "lai", "laai", "li", "lii", "lu", "luu", "loo", "la", "laa", "lwe", "lwe", "lwi", "lwi", "lwii", "lwii", "lwo", "lwo", "lwoo", "lwoo", "lwa", "lwa", "lwaa", "lwaa", "l", "l", "l", "sai", "saai", "si", "sii", "su", "suu", "soo", "sa", "saa", "swe", "swe", "swi", "swi", "swii", "swii", "swo", "swo", "swoo", "swoo"], ["swa", "swa", "swaa", "swaa", "swaa", "s", "s", "sw", "s", "sk", "skw", "sW", "spwa", "stwa", "skwa", "scwa", "she", "shi", "shii", "sho", "shoo", "sha", "shaa", "shwe", "shwe", "shwi", "shwi", "shwii", "shwii", "shwo", "shwo", "shwoo", "shwoo", "shwa", "shwa", "shwaa", "shwaa", "sh", "jai", "yaai", "ji", "jii", "ju", "juu", "yoo", "ja", "jaa", "ywe", "ywe", "ywi", "ywi", "ywii", "ywii", "ywo", "ywo", "ywoo", "ywoo", "ywa", "ywa", "ywaa", "ywaa", "ywaa", "j", "y", "y", "yi", "re", "rai", "le", "raai", "ri", "rii", "ru", "ruu", "lo", "ra", "raa", "la", "rwaa", "rwaa", "r", "r", "r", "vai", "faai", "vi", "vii", "vu", "vuu", "va", "vaa", "fwaa", "fwaa", "v", "the", "the", "thi", "thi", "thii", "thii", "tho", "thoo", "tha", "thaa", "thwaa", "thwaa", "th", "tthe", "tthi", "ttho", "ttha", "tth", "tye", "tyi", "tyo", "tya", "he", "hi", "hii", "ho", "hoo", "ha", "haa", "h", "h", "hk", "qaai", "qi", "qii", "qu", "quu", "qa", "qaa", "q", "tlhe", "tlhi", "tlho", "tlha", "re", "ri", "ro", "ra", "ngaai", "ngi", "ngii", "ngu", "nguu", "nga", "ngaa", "ng", "nng", "she", "shi", "sho", "sha", "the", "thi", "tho", "tha", "th", "lhi", "lhii", "lho", "lhoo", "lha", "lhaa", "lh", "the", "thi", "thii", "tho", "thoo", "tha", "thaa", "th", "b", "e", "i", "o", "a", "we", "wi", "wo", "wa", "ne", "ni", "no", "na", "ke", "ki", "ko", "ka", "he", "hi", "ho", "ha", "ghu", "gho", "ghe", "ghee", "ghi", "gha", "ru", "ro", "re", "ree", "ri", "ra", "wu", "wo", "we", "wee", "wi", "wa", "hwu", "hwo", "hwe", "hwee", "hwi", "hwa", "thu", "tho", "the", "thee", "thi", "tha", "ttu", "tto", "tte", "ttee", "tti", "tta", "pu", "po", "pe", "pee", "pi", "pa", "p", "gu", "go", "ge", "gee", "gi", "ga", "khu", "kho", "khe", "khee", "khi", "kha", "kku", "kko", "kke", "kkee", "kki"], ["kka", "kk", "nu", "no", "ne", "nee", "ni", "na", "mu", "mo", "me", "mee", "mi", "ma", "yu", "yo", "ye", "yee", "yi", "ya", "ju", "ju", "jo", "je", "jee", "ji", "ji", "ja", "jju", "jjo", "jje", "jjee", "jji", "jja", "lu", "lo", "le", "lee", "li", "la", "dlu", "dlo", "dle", "dlee", "dli", "dla", "lhu", "lho", "lhe", "lhee", "lhi", "lha", "tlhu", "tlho", "tlhe", "tlhee", "tlhi", "tlha", "tlu", "tlo", "tle", "tlee", "tli", "tla", "zu", "zo", "ze", "zee", "zi", "za", "z", "z", "dzu", "dzo", "dze", "dzee", "dzi", "dza", "su", "so", "se", "see", "si", "sa", "shu", "sho", "she", "shee", "shi", "sha", "sh", "tsu", "tso", "tse", "tsee", "tsi", "tsa", "chu", "cho", "che", "chee", "chi", "cha", "ttsu", "ttso", "ttse", "ttsee", "ttsi", "ttsa", "X", ".", "qai", "ngai", "nngi", "nngii", "nngo", "nngoo", "nnga", "nngaa", , , , , , , , , , " ", "b", "l", "f", "s", "n", "h", "d", "t", "c", "q", "m", "g", "ng", "z", "r", "a", "o", "u", "e", "i", "ch", "th", "ph", "p", "x", "p", "<", ">", , , , "f", "v", "u", "yr", "y", "w", "th", "th", "a", "o", "ac", "ae", "o", "o", "o", "oe", "on", "r", "k", "c", "k", "g", "ng", "g", "g", "w", "h", "h", "h", "h", "n", "n", "n", "i", "e", "j", "g", "ae", "a", "eo", "p", "z", "s", "s", "s", "c", "z", "t", "t", "d", "b", "b", "p", "p", "e", "m", "m", "m", "l", "l", "ng", "ng", "d", "o", "ear", "ior", "qu", "qu", "qu", "s", "yr", "yr", "yr", "q", "x", ".", ":", "+", "17", "18", "19"], [, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "t", "tth", "d", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "v", "sh", "ss", "s", "h", "l", "q", "a", "aa", "i", "ii", "u", "uk", "uu", "uuv", "ry", "ryy", "ly", "lyy", "e", "ai", "oo", "oo", "au", "a", "aa", "aa", "i", "ii", "y", "yy", "u", "uu", "ua", "oe", "ya", "ie", "e", "ae", "ai", "oo", "au", "M", "H", "a`", , , , "r", , "!", , , , , , ".", " // ", ":", "+", "++", " * ", " /// ", "KR", "'", , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], [" @ ", " ... ", ",", ". ", ": ", " // ", , "-", ",", ". ", , , , , , , "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", , , , , , , "a", "e", "i", "o", "u", "O", "U", "ee", "n", "ng", "b", "p", "q", "g", "m", "l", "s", "sh", "t", "d", "ch", "j", "y", "r", "w", "f", "k", "kha", "ts", "z", "h", "zr", "lh", "zh", "ch", "-", "e", "i", "o", "u", "O", "U", "ng", "b", "p", "q", "g", "m", "t", "d", "ch", "j", "ts", "y", "w", "k", "g", "h", "jy", "ny", "dz", "e", "i", "iy", "U", "u", "ng", "k", "g", "h", "p", "sh", "t", "d", "j", "f", "g", "h", "ts", "z", "r", "ch", "zh", "i", "k", "r", "f", "zh", , , , , , , , , , "H", "X", "W", "M", " 3 ", " 333 ", "a", "i", "k", "ng", "c", "tt", "tth", "dd", "nn", "t", "d", "p", "ph", "ss", "zh", "z", "a", "t", "zh", "gh", "ng", "c", "jh", "tta", "ddh", "t", "dh", "ss", "cy", "zh", "z", "u", "y", "bh", "'"], [], [], [], [], [], ["A", "a", "B", "b", "B", "b", "B", "b", "C", "c", "D", "d", "D", "d", "D", "d", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "F", "f", "G", "g", "H", "h", "H", "h", "H", "h", "H", "h", "H", "h", "I", "i", "I", "i", "K", "k", "K", "k", "K", "k", "L", "l", "L", "l", "L", "l", "L", "l", "M", "m", "M", "m", "M", "m", "N", "n", "N", "n", "N", "n", "N", "n", "O", "o", "O", "o", "O", "o", "O", "o", "P", "p", "P", "p", "R", "r", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "V", "v", "V", "v", "W", "w", "W", "w", "W", "w", "W", "w", "W", "w", "X", "x", "X", "x", "Y", "y", "Z", "z", "Z", "z", "Z", "z", "h", "t", "w", "y", "a", "S", , , , , "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "Y", "y", "Y", "y", "Y", "y", "Y", "y"], ["a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", , , "E", "E", "E", "E", "E", "E", , , "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "i", "i", "i", "i", "i", "i", "i", "i", "I", "I", "I", "I", "I", "I", "I", "I", "o", "o", "o", "o", "o", "o", , , "O", "O", "O", "O", "O", "O", , , "u", "u", "u", "u", "u", "u", "u", "u", , "U", , "U", , "U", , "U", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "e", "e", "e", "e", "i", "i", "o", "o", "u", "u", "o", "o", , , "a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "a", "a", "a", , "a", "a", "A", "A", "A", "A", "A", "'", "i", "'", "~", '"~', "e", "e", "e", , "e", "e", "E", "E", "E", "E", "E", "'`", "''", "'~", "i", "i", "i", "i", , , "i", "i", "I", "I", "I", "I", , "`'", "`'", "`~", "u", "u", "u", "u", "R", "R", "u", "u", "U", "U", "U", "U", "R", '"`', `"'`, "`", , , "o", "o", "o", , "o", "o", "O", "O", "O", "O", "O", "'", "`"], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", , , , , "-", "-", "-", "-", "--", "--", "||", "_", "'", "'", ",", "'", '"', '"', ",,", '"', "+", "++", "*", "*>", ".", "..", "...", ".", `
`, `

`, , , , , , " ", "%0", "%00", "'", "''", "'''", "`", "``", "```", "^", "<", ">", "*", "!!", "!?", "-", "_", "-", "^", "***", "--", "/", "-[", "]-", , "?!", "!?", "7", "PP", "(]", "[)", , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "0", , , , "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "n", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", , , , , , , , , , , , , , , , , , "ECU", "CL", "Cr", "FF", "L", "mil", "N", "Pts", "Rs", "W", "NS", "D", "EU", "K", "T", "Dr"], [, , "C", , , , , , , , "g", "H", "H", "H", "h", , "I", "I", "L", "l", "lb", "N", "no", "(p)", "P", "P", "Q", "R", "R", "R", , , "(sm)", "(tel)", "(tm)", , "Z", , , "mho", "Z", , , , "B", "C", "e", "e", , "F", , "M", "o", , , , , "i", "Q", "(fax)", "pi", , , "Pi", , "G", "L", "L", "Y", "D", "d", "e", "i", "j", , , "per", , , , , , , " 1/3 ", " 2/3 ", " 1/5 ", " 2/5 ", " 3/5 ", " 4/5 ", " 1/6 ", " 5/6 ", " 1/8 ", " 3/8 ", " 5/8 ", " 7/8 ", " 1/", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "L", "C", "D", "M", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix", "x", "xi", "xii", "l", "c", "d", "m", "(D", "D)", "((|))", ")", , , , , , , , , , , , , "-", "|", "-", "|", "-", "|", "\\", "/", "\\", "/", "-", "-", "~", "~", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "-", "-", "-", "-", "-", "-", "|", "|", "|", "|", "|", "|", "|", "^", "V", "\\", "=", "V", "^", "-", "-", "|", "|", "-", "-", "|", "|", "=", "|", "=", "=", "|", "=", "|", "=", "=", "=", "=", "=", "=", "|", "=", "|", "=", "|", "\\", "/", "\\", "/", "=", "=", "~", "~", "|", "|", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "|", "|", "|", "|", "|", "-", "\\", "\\", "|"], [], [], [], ["-", "-", "|", "|", "-", "-", "|", "|", "-", "-", "|", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-", "|", "|", "-", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "/", "\\", "X", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "-", "|", , , , , , , , , , , "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "^", "^", "^", "^", ">", ">", ">", ">", ">", ">", "V", "V", "V", "V", "<", "<", "<", "<", "<", "<", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "#", "#", "#", "#", "#", "^", "^", "^", "O", "#", "#", "#", "#", "#", "#", "#", "#"], [], [], [" ", "a", "1", "b", "'", "k", "2", "l", "@", "c", "i", "f", "/", "m", "s", "p", '"', "e", "3", "h", "9", "o", "6", "r", "^", "d", "j", "g", ">", "n", "t", "q", ",", "*", "5", "<", "-", "u", "8", "v", ".", "%", "[", "$", "+", "x", "!", "&", ";", ":", "4", "\\", "0", "z", "7", "(", "_", "?", "w", "]", "#", "y", ")", "=", "[d7]", "[d17]", "[d27]", "[d127]", "[d37]", "[d137]", "[d237]", "[d1237]", "[d47]", "[d147]", "[d247]", "[d1247]", "[d347]", "[d1347]", "[d2347]", "[d12347]", "[d57]", "[d157]", "[d257]", "[d1257]", "[d357]", "[d1357]", "[d2357]", "[d12357]", "[d457]", "[d1457]", "[d2457]", "[d12457]", "[d3457]", "[d13457]", "[d23457]", "[d123457]", "[d67]", "[d167]", "[d267]", "[d1267]", "[d367]", "[d1367]", "[d2367]", "[d12367]", "[d467]", "[d1467]", "[d2467]", "[d12467]", "[d3467]", "[d13467]", "[d23467]", "[d123467]", "[d567]", "[d1567]", "[d2567]", "[d12567]", "[d3567]", "[d13567]", "[d23567]", "[d123567]", "[d4567]", "[d14567]", "[d24567]", "[d124567]", "[d34567]", "[d134567]", "[d234567]", "[d1234567]", "[d8]", "[d18]", "[d28]", "[d128]", "[d38]", "[d138]", "[d238]", "[d1238]", "[d48]", "[d148]", "[d248]", "[d1248]", "[d348]", "[d1348]", "[d2348]", "[d12348]", "[d58]", "[d158]", "[d258]", "[d1258]", "[d358]", "[d1358]", "[d2358]", "[d12358]", "[d458]", "[d1458]", "[d2458]", "[d12458]", "[d3458]", "[d13458]", "[d23458]", "[d123458]", "[d68]", "[d168]", "[d268]", "[d1268]", "[d368]", "[d1368]", "[d2368]", "[d12368]", "[d468]", "[d1468]", "[d2468]", "[d12468]", "[d3468]", "[d13468]", "[d23468]", "[d123468]", "[d568]", "[d1568]", "[d2568]", "[d12568]", "[d3568]", "[d13568]", "[d23568]", "[d123568]", "[d4568]", "[d14568]", "[d24568]", "[d124568]", "[d34568]", "[d134568]", "[d234568]", "[d1234568]", "[d78]", "[d178]", "[d278]", "[d1278]", "[d378]", "[d1378]", "[d2378]", "[d12378]", "[d478]", "[d1478]", "[d2478]", "[d12478]", "[d3478]", "[d13478]", "[d23478]", "[d123478]", "[d578]", "[d1578]", "[d2578]", "[d12578]", "[d3578]", "[d13578]", "[d23578]", "[d123578]", "[d4578]", "[d14578]", "[d24578]", "[d124578]", "[d34578]", "[d134578]", "[d234578]", "[d1234578]", "[d678]", "[d1678]", "[d2678]", "[d12678]", "[d3678]", "[d13678]", "[d23678]", "[d123678]", "[d4678]", "[d14678]", "[d24678]", "[d124678]", "[d34678]", "[d134678]", "[d234678]", "[d1234678]", "[d5678]", "[d15678]", "[d25678]", "[d125678]", "[d35678]", "[d135678]", "[d235678]", "[d1235678]", "[d45678]", "[d145678]", "[d245678]", "[d1245678]", "[d345678]", "[d1345678]", "[d2345678]", "[d12345678]"], [], [], [], [], [], [], [], [" ", ",", ". ", '"', "[JIS]", '"', "/", "0", "<", "> ", "<<", ">> ", "[", "] ", "{", "} ", "[(", ")] ", "@", "X ", "[", "] ", "[[", "]] ", "((", ")) ", "[[", "]] ", "~ ", "``", "''", ",,", "@", "1", "2", "3", "4", "5", "6", "7", "8", "9", , , , , , , "~", "+", "+", "+", "+", , "@", " // ", "+10+", "+20+", "+30+", , , , , , , "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", , , , , , , , , '"', '"', , , "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "ka", "ke", "va", "vi", "ve", "vo", , , '"', '"'], [, , , , , "B", "P", "M", "F", "D", "T", "N", "L", "G", "K", "H", "J", "Q", "X", "ZH", "CH", "SH", "R", "Z", "C", "S", "A", "O", "E", "EH", "AI", "EI", "AU", "OU", "AN", "EN", "ANG", "ENG", "ER", "I", "U", "IU", "V", "NG", "GN", , , , , "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", , "j", "jj", "c", "k", "t", "p", "h", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", , "nn", "nd", "ns", "nZ", "lgs", "ld", "lbs", "lZ", "lQ", "mb", "ms", "mZ", "mN", "bg", , "bsg", "bst", "bj", "bt", "bN", "bbN", "sg", "sn", "sd", "sb", "sj", "Z", , "N", "Ns", "NZ", "pN", "hh", "Q", "yo-ya", "yo-yae", "yo-i", "yu-yeo", "yu-ye", "yu-i", "U", "U-i", , , , , , , , , , , , , , , , , , "BU", "ZI", "JI", "GU", "EE", "ENN", "OO", "ONN", "IR", "ANN", "INN", "UNN", "IM", "NGG", "AINN", "AUNN", "AM", "OM", "ONG", "INNN", "P", "T", "K", "H"], ["(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "(ju)", , , , "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Dai) ", "(Hu) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ji) ", "(Xiu) ", "<<", ">>", , , , , , , , , , , , , , , , , , , , , , , , , , , , , "(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", , , , "KIS ", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Mi) ", "(Nan) ", "(Nu) ", "(Shi) ", "(You) ", "(Yin) ", "(Zhu) ", "(Xiang) ", "(Xiu) ", "(Xie) ", "(Zheng) ", "(Shang) ", "(Zhong) ", "(Xia) ", "(Zuo) ", "(You) ", "(Yi) ", "(Zong) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ye) ", , , , , , , , , , , , , , , , "1M", "2M", "3M", "4M", "5M", "6M", "7M", "8M", "9M", "10M", "11M", "12M", , , , , "a", "i", "u", "u", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wi", "we", "wo"], ["apartment", "alpha", "ampere", "are", "inning", "inch", "won", "escudo", "acre", "ounce", "ohm", "kai-ri", "carat", "calorie", "gallon", "gamma", "giga", "guinea", "curie", "guilder", "kilo", "kilogram", "kilometer", "kilowatt", "gram", "gram ton", "cruzeiro", "krone", "case", "koruna", "co-op", "cycle", "centime", "shilling", "centi", "cent", "dozen", "desi", "dollar", "ton", "nano", "knot", "heights", "percent", "parts", "barrel", "piaster", "picul", "pico", "building", "farad", "feet", "bushel", "franc", "hectare", "peso", "pfennig", "hertz", "pence", "page", "beta", "point", "volt", "hon", "pound", "hall", "horn", "micro", "mile", "mach", "mark", "mansion", "micron", "milli", "millibar", "mega", "megaton", "meter", "yard", "yard", "yuan", "liter", "lira", "rupee", "ruble", "rem", "roentgen", "watt", "0h", "1h", "2h", "3h", "4h", "5h", "6h", "7h", "8h", "9h", "10h", "11h", "12h", "13h", "14h", "15h", "16h", "17h", "18h", "19h", "20h", "21h", "22h", "23h", "24h", "HPA", "da", "AU", "bar", "oV", "pc", , , , , "Heisei", "Syouwa", "Taisyou", "Meiji", "Inc.", "pA", "nA", "microamp", "mA", "kA", "kB", "MB", "GB", "cal", "kcal", "pF", "nF", "microFarad", "microgram", "mg", "kg", "Hz", "kHz", "MHz", "GHz", "THz", "microliter", "ml", "dl", "kl", "fm", "nm", "micrometer", "mm", "cm", "km", "mm^2", "cm^2", "m^2", "km^2", "mm^4", "cm^3", "m^3", "km^3", "m/s", "m/s^2", "Pa", "kPa", "MPa", "GPa", "rad", "rad/s", "rad/s^2", "ps", "ns", "microsecond", "ms", "pV", "nV", "microvolt", "mV", "kV", "MV", "pW", "nW", "microwatt", "mW", "kW", "MW", "kOhm", "MOhm", "a.m.", "Bq", "cc", "cd", "C/kg", "Co.", "dB", "Gy", "ha", "HP", "in", "K.K.", "KM", "kt", "lm", "ln", "log", "lx", "mb", "mil", "mol", "pH", "p.m.", "PPM", "PR", "sr", "Sv", "Wb", , , "1d", "2d", "3d", "4d", "5d", "6d", "7d", "8d", "9d", "10d", "11d", "12d", "13d", "14d", "15d", "16d", "17d", "18d", "19d", "20d", "21d", "22d", "23d", "24d", "25d", "26d", "27d", "28d", "29d", "30d", "31d"], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], ["Yi", "Ding", "Kao", "Qi", "Shang", "Xia", , "Wan", "Zhang", "San", "Shang", "Xia", "Ji", "Bu", "Yu", "Mian", "Gai", "Chou", "Chou", "Zhuan", "Qie", "Pi", "Shi", "Shi", "Qiu", "Bing", "Ye", "Cong", "Dong", "Si", "Cheng", "Diu", "Qiu", "Liang", "Diu", "You", "Liang", "Yan", "Bing", "Sang", "Gun", "Jiu", "Ge", "Ya", "Qiang", "Zhong", "Ji", "Jie", "Feng", "Guan", "Chuan", "Chan", "Lin", "Zhuo", "Zhu", "Ha", "Wan", "Dan", "Wei", "Zhu", "Jing", "Li", "Ju", "Pie", "Fu", "Yi", "Yi", "Nai", "Shime", "Jiu", "Jiu", "Zhe", "Me", "Yi", , "Zhi", "Wu", "Zha", "Hu", "Fa", "Le", "Zhong", "Ping", "Pang", "Qiao", "Hu", "Guai", "Cheng", "Cheng", "Yi", "Yin", , "Mie", "Jiu", "Qi", "Ye", "Xi", "Xiang", "Gai", "Diu", "Hal", , "Shu", "Twul", "Shi", "Ji", "Nang", "Jia", "Kel", "Shi", , "Ol", "Mai", "Luan", "Cal", "Ru", "Xue", "Yan", "Fu", "Sha", "Na", "Gan", "Sol", "El", "Cwul", , "Gan", "Chi", "Gui", "Gan", "Luan", "Lin", "Yi", "Jue", "Liao", "Ma", "Yu", "Zheng", "Shi", "Shi", "Er", "Chu", "Yu", "Yu", "Yu", "Yun", "Hu", "Qi", "Wu", "Jing", "Si", "Sui", "Gen", "Gen", "Ya", "Xie", "Ya", "Qi", "Ya", "Ji", "Tou", "Wang", "Kang", "Ta", "Jiao", "Hai", "Yi", "Chan", "Heng", "Mu", , "Xiang", "Jing", "Ting", "Liang", "Xiang", "Jing", "Ye", "Qin", "Bo", "You", "Xie", "Dan", "Lian", "Duo", "Wei", "Ren", "Ren", "Ji", "La", "Wang", "Yi", "Shi", "Ren", "Le", "Ding", "Ze", "Jin", "Pu", "Chou", "Ba", "Zhang", "Jin", "Jie", "Bing", "Reng", "Cong", "Fo", "San", "Lun", "Sya", "Cang", "Zi", "Shi", "Ta", "Zhang", "Fu", "Xian", "Xian", "Tuo", "Hong", "Tong", "Ren", "Qian", "Gan", "Yi", "Di", "Dai", "Ling", "Yi", "Chao", "Chang", "Sa", , "Yi", "Mu", "Men", "Ren", "Jia", "Chao", "Yang", "Qian", "Zhong", "Pi", "Wan", "Wu", "Jian", "Jie", "Yao", "Feng", "Cang", "Ren", "Wang", "Fen", "Di", "Fang"], ["Zhong", "Qi", "Pei", "Yu", "Diao", "Dun", "Wen", "Yi", "Xin", "Kang", "Yi", "Ji", "Ai", "Wu", "Ji", "Fu", "Fa", "Xiu", "Jin", "Bei", "Dan", "Fu", "Tang", "Zhong", "You", "Huo", "Hui", "Yu", "Cui", "Chuan", "San", "Wei", "Chuan", "Che", "Ya", "Xian", "Shang", "Chang", "Lun", "Cang", "Xun", "Xin", "Wei", "Zhu", , "Xuan", "Nu", "Bo", "Gu", "Ni", "Ni", "Xie", "Ban", "Xu", "Ling", "Zhou", "Shen", "Qu", "Si", "Beng", "Si", "Jia", "Pi", "Yi", "Si", "Ai", "Zheng", "Dian", "Han", "Mai", "Dan", "Zhu", "Bu", "Qu", "Bi", "Shao", "Ci", "Wei", "Di", "Zhu", "Zuo", "You", "Yang", "Ti", "Zhan", "He", "Bi", "Tuo", "She", "Yu", "Yi", "Fo", "Zuo", "Kou", "Ning", "Tong", "Ni", "Xuan", "Qu", "Yong", "Wa", "Qian", , "Ka", , "Pei", "Huai", "He", "Lao", "Xiang", "Ge", "Yang", "Bai", "Fa", "Ming", "Jia", "Er", "Bing", "Ji", "Hen", "Huo", "Gui", "Quan", "Tiao", "Jiao", "Ci", "Yi", "Shi", "Xing", "Shen", "Tuo", "Kan", "Zhi", "Gai", "Lai", "Yi", "Chi", "Kua", "Guang", "Li", "Yin", "Shi", "Mi", "Zhu", "Xu", "You", "An", "Lu", "Mou", "Er", "Lun", "Tong", "Cha", "Chi", "Xun", "Gong", "Zhou", "Yi", "Ru", "Jian", "Xia", "Jia", "Zai", "Lu", "Ko", "Jiao", "Zhen", "Ce", "Qiao", "Kuai", "Chai", "Ning", "Nong", "Jin", "Wu", "Hou", "Jiong", "Cheng", "Zhen", "Zuo", "Chou", "Qin", "Lu", "Ju", "Shu", "Ting", "Shen", "Tuo", "Bo", "Nan", "Hao", "Bian", "Tui", "Yu", "Xi", "Cu", "E", "Qiu", "Xu", "Kuang", "Ku", "Wu", "Jun", "Yi", "Fu", "Lang", "Zu", "Qiao", "Li", "Yong", "Hun", "Jing", "Xian", "San", "Pai", "Su", "Fu", "Xi", "Li", "Fu", "Ping", "Bao", "Yu", "Si", "Xia", "Xin", "Xiu", "Yu", "Ti", "Che", "Chou", , "Yan", "Lia", "Li", "Lai", , "Jian", "Xiu", "Fu", "He", "Ju", "Xiao", "Pai", "Jian", "Biao", "Chu", "Fei", "Feng", "Ya", "An", "Bei", "Yu", "Xin", "Bi", "Jian"], ["Chang", "Chi", "Bing", "Zan", "Yao", "Cui", "Lia", "Wan", "Lai", "Cang", "Zong", "Ge", "Guan", "Bei", "Tian", "Shu", "Shu", "Men", "Dao", "Tan", "Jue", "Chui", "Xing", "Peng", "Tang", "Hou", "Yi", "Qi", "Ti", "Gan", "Jing", "Jie", "Sui", "Chang", "Jie", "Fang", "Zhi", "Kong", "Juan", "Zong", "Ju", "Qian", "Ni", "Lun", "Zhuo", "Wei", "Luo", "Song", "Leng", "Hun", "Dong", "Zi", "Ben", "Wu", "Ju", "Nai", "Cai", "Jian", "Zhai", "Ye", "Zhi", "Sha", "Qing", , "Ying", "Cheng", "Jian", "Yan", "Nuan", "Zhong", "Chun", "Jia", "Jie", "Wei", "Yu", "Bing", "Ruo", "Ti", "Wei", "Pian", "Yan", "Feng", "Tang", "Wo", "E", "Xie", "Che", "Sheng", "Kan", "Di", "Zuo", "Cha", "Ting", "Bei", "Ye", "Huang", "Yao", "Zhan", "Chou", "Yan", "You", "Jian", "Xu", "Zha", "Ci", "Fu", "Bi", "Zhi", "Zong", "Mian", "Ji", "Yi", "Xie", "Xun", "Si", "Duan", "Ce", "Zhen", "Ou", "Tou", "Tou", "Bei", "Za", "Lu", "Jie", "Wei", "Fen", "Chang", "Gui", "Sou", "Zhi", "Su", "Xia", "Fu", "Yuan", "Rong", "Li", "Ru", "Yun", "Gou", "Ma", "Bang", "Dian", "Tang", "Hao", "Jie", "Xi", "Shan", "Qian", "Jue", "Cang", "Chu", "San", "Bei", "Xiao", "Yong", "Yao", "Tan", "Suo", "Yang", "Fa", "Bing", "Jia", "Dai", "Zai", "Tang", , "Bin", "Chu", "Nuo", "Can", "Lei", "Cui", "Yong", "Zao", "Zong", "Peng", "Song", "Ao", "Chuan", "Yu", "Zhai", "Cou", "Shang", "Qiang", "Jing", "Chi", "Sha", "Han", "Zhang", "Qing", "Yan", "Di", "Xi", "Lu", "Bei", "Piao", "Jin", "Lian", "Lu", "Man", "Qian", "Xian", "Tan", "Ying", "Dong", "Zhuan", "Xiang", "Shan", "Qiao", "Jiong", "Tui", "Zun", "Pu", "Xi", "Lao", "Chang", "Guang", "Liao", "Qi", "Deng", "Chan", "Wei", "Ji", "Fan", "Hui", "Chuan", "Jian", "Dan", "Jiao", "Jiu", "Seng", "Fen", "Xian", "Jue", "E", "Jiao", "Jian", "Tong", "Lin", "Bo", "Gu", , "Su", "Xian", "Jiang", "Min", "Ye", "Jin", "Jia", "Qiao", "Pi", "Feng", "Zhou", "Ai", "Sai"], ["Yi", "Jun", "Nong", "Chan", "Yi", "Dang", "Jing", "Xuan", "Kuai", "Jian", "Chu", "Dan", "Jiao", "Sha", "Zai", , "Bin", "An", "Ru", "Tai", "Chou", "Chai", "Lan", "Ni", "Jin", "Qian", "Meng", "Wu", "Ning", "Qiong", "Ni", "Chang", "Lie", "Lei", "Lu", "Kuang", "Bao", "Du", "Biao", "Zan", "Zhi", "Si", "You", "Hao", "Chen", "Chen", "Li", "Teng", "Wei", "Long", "Chu", "Chan", "Rang", "Shu", "Hui", "Li", "Luo", "Zan", "Nuo", "Tang", "Yan", "Lei", "Nang", "Er", "Wu", "Yun", "Zan", "Yuan", "Xiong", "Chong", "Zhao", "Xiong", "Xian", "Guang", "Dui", "Ke", "Dui", "Mian", "Tu", "Chang", "Er", "Dui", "Er", "Xin", "Tu", "Si", "Yan", "Yan", "Shi", "Shi", "Dang", "Qian", "Dou", "Fen", "Mao", "Shen", "Dou", "Bai", "Jing", "Li", "Huang", "Ru", "Wang", "Nei", "Quan", "Liang", "Yu", "Ba", "Gong", "Liu", "Xi", , "Lan", "Gong", "Tian", "Guan", "Xing", "Bing", "Qi", "Ju", "Dian", "Zi", "Ppwun", "Yang", "Jian", "Shou", "Ji", "Yi", "Ji", "Chan", "Jiong", "Mao", "Ran", "Nei", "Yuan", "Mao", "Gang", "Ran", "Ce", "Jiong", "Ce", "Zai", "Gua", "Jiong", "Mao", "Zhou", "Mou", "Gou", "Xu", "Mian", "Mi", "Rong", "Yin", "Xie", "Kan", "Jun", "Nong", "Yi", "Mi", "Shi", "Guan", "Meng", "Zhong", "Ju", "Yuan", "Ming", "Kou", "Lam", "Fu", "Xie", "Mi", "Bing", "Dong", "Tai", "Gang", "Feng", "Bing", "Hu", "Chong", "Jue", "Hu", "Kuang", "Ye", "Leng", "Pan", "Fu", "Min", "Dong", "Xian", "Lie", "Xia", "Jian", "Jing", "Shu", "Mei", "Tu", "Qi", "Gu", "Zhun", "Song", "Jing", "Liang", "Qing", "Diao", "Ling", "Dong", "Gan", "Jian", "Yin", "Cou", "Yi", "Li", "Cang", "Ming", "Zhuen", "Cui", "Si", "Duo", "Jin", "Lin", "Lin", "Ning", "Xi", "Du", "Ji", "Fan", "Fan", "Fan", "Feng", "Ju", "Chu", "Tako", "Feng", "Mok", "Ci", "Fu", "Feng", "Ping", "Feng", "Kai", "Huang", "Kai", "Gan", "Deng", "Ping", "Qu", "Xiong", "Kuai", "Tu", "Ao", "Chu", "Ji", "Dang", "Han", "Han", "Zao"], ["Dao", "Diao", "Dao", "Ren", "Ren", "Chuang", "Fen", "Qie", "Yi", "Ji", "Kan", "Qian", "Cun", "Chu", "Wen", "Ji", "Dan", "Xing", "Hua", "Wan", "Jue", "Li", "Yue", "Lie", "Liu", "Ze", "Gang", "Chuang", "Fu", "Chu", "Qu", "Ju", "Shan", "Min", "Ling", "Zhong", "Pan", "Bie", "Jie", "Jie", "Bao", "Li", "Shan", "Bie", "Chan", "Jing", "Gua", "Gen", "Dao", "Chuang", "Kui", "Ku", "Duo", "Er", "Zhi", "Shua", "Quan", "Cha", "Ci", "Ke", "Jie", "Gui", "Ci", "Gui", "Kai", "Duo", "Ji", "Ti", "Jing", "Lou", "Gen", "Ze", "Yuan", "Cuo", "Xue", "Ke", "La", "Qian", "Cha", "Chuang", "Gua", "Jian", "Cuo", "Li", "Ti", "Fei", "Pou", "Chan", "Qi", "Chuang", "Zi", "Gang", "Wan", "Bo", "Ji", "Duo", "Qing", "Yan", "Zhuo", "Jian", "Ji", "Bo", "Yan", "Ju", "Huo", "Sheng", "Jian", "Duo", "Duan", "Wu", "Gua", "Fu", "Sheng", "Jian", "Ge", "Zha", "Kai", "Chuang", "Juan", "Chan", "Tuan", "Lu", "Li", "Fou", "Shan", "Piao", "Kou", "Jiao", "Gua", "Qiao", "Jue", "Hua", "Zha", "Zhuo", "Lian", "Ju", "Pi", "Liu", "Gui", "Jiao", "Gui", "Jian", "Jian", "Tang", "Huo", "Ji", "Jian", "Yi", "Jian", "Zhi", "Chan", "Cuan", "Mo", "Li", "Zhu", "Li", "Ya", "Quan", "Ban", "Gong", "Jia", "Wu", "Mai", "Lie", "Jin", "Keng", "Xie", "Zhi", "Dong", "Zhu", "Nu", "Jie", "Qu", "Shao", "Yi", "Zhu", "Miao", "Li", "Jing", "Lao", "Lao", "Juan", "Kou", "Yang", "Wa", "Xiao", "Mou", "Kuang", "Jie", "Lie", "He", "Shi", "Ke", "Jing", "Hao", "Bo", "Min", "Chi", "Lang", "Yong", "Yong", "Mian", "Ke", "Xun", "Juan", "Qing", "Lu", "Pou", "Meng", "Lai", "Le", "Kai", "Mian", "Dong", "Xu", "Xu", "Kan", "Wu", "Yi", "Xun", "Weng", "Sheng", "Lao", "Mu", "Lu", "Piao", "Shi", "Ji", "Qin", "Qiang", "Jiao", "Quan", "Yang", "Yi", "Jue", "Fan", "Juan", "Tong", "Ju", "Dan", "Xie", "Mai", "Xun", "Xun", "Lu", "Li", "Che", "Rang", "Quan", "Bao", "Shao", "Yun", "Jiu", "Bao", "Gou", "Wu"], ["Yun", "Mwun", "Nay", "Gai", "Gai", "Bao", "Cong", , "Xiong", "Peng", "Ju", "Tao", "Ge", "Pu", "An", "Pao", "Fu", "Gong", "Da", "Jiu", "Qiong", "Bi", "Hua", "Bei", "Nao", "Chi", "Fang", "Jiu", "Yi", "Za", "Jiang", "Kang", "Jiang", "Kuang", "Hu", "Xia", "Qu", "Bian", "Gui", "Qie", "Zang", "Kuang", "Fei", "Hu", "Tou", "Gui", "Gui", "Hui", "Dan", "Gui", "Lian", "Lian", "Suan", "Du", "Jiu", "Qu", "Xi", "Pi", "Qu", "Yi", "Qia", "Yan", "Bian", "Ni", "Qu", "Shi", "Xin", "Qian", "Nian", "Sa", "Zu", "Sheng", "Wu", "Hui", "Ban", "Shi", "Xi", "Wan", "Hua", "Xie", "Wan", "Bei", "Zu", "Zhuo", "Xie", "Dan", "Mai", "Nan", "Dan", "Ji", "Bo", "Shuai", "Bu", "Kuang", "Bian", "Bu", "Zhan", "Qia", "Lu", "You", "Lu", "Xi", "Gua", "Wo", "Xie", "Jie", "Jie", "Wei", "Ang", "Qiong", "Zhi", "Mao", "Yin", "Wei", "Shao", "Ji", "Que", "Luan", "Shi", "Juan", "Xie", "Xu", "Jin", "Que", "Wu", "Ji", "E", "Qing", "Xi", , "Han", "Zhan", "E", "Ting", "Li", "Zhe", "Han", "Li", "Ya", "Ya", "Yan", "She", "Zhi", "Zha", "Pang", , "He", "Ya", "Zhi", "Ce", "Pang", "Ti", "Li", "She", "Hou", "Ting", "Zui", "Cuo", "Fei", "Yuan", "Ce", "Yuan", "Xiang", "Yan", "Li", "Jue", "Sha", "Dian", "Chu", "Jiu", "Qin", "Ao", "Gui", "Yan", "Si", "Li", "Chang", "Lan", "Li", "Yan", "Yan", "Yuan", "Si", "Gong", "Lin", "Qiu", "Qu", "Qu", "Uk", "Lei", "Du", "Xian", "Zhuan", "San", "Can", "Can", "Can", "Can", "Ai", "Dai", "You", "Cha", "Ji", "You", "Shuang", "Fan", "Shou", "Guai", "Ba", "Fa", "Ruo", "Shi", "Shu", "Zhuo", "Qu", "Shou", "Bian", "Xu", "Jia", "Pan", "Sou", "Gao", "Wei", "Sou", "Die", "Rui", "Cong", "Kou", "Gu", "Ju", "Ling", "Gua", "Tao", "Kou", "Zhi", "Jiao", "Zhao", "Ba", "Ding", "Ke", "Tai", "Chi", "Shi", "You", "Qiu", "Po", "Ye", "Hao", "Si", "Tan", "Chi", "Le", "Diao", "Ji", , "Hong"], ["Mie", "Xu", "Mang", "Chi", "Ge", "Xuan", "Yao", "Zi", "He", "Ji", "Diao", "Cun", "Tong", "Ming", "Hou", "Li", "Tu", "Xiang", "Zha", "Xia", "Ye", "Lu", "A", "Ma", "Ou", "Xue", "Yi", "Jun", "Chou", "Lin", "Tun", "Yin", "Fei", "Bi", "Qin", "Qin", "Jie", "Bu", "Fou", "Ba", "Dun", "Fen", "E", "Han", "Ting", "Hang", "Shun", "Qi", "Hong", "Zhi", "Shen", "Wu", "Wu", "Chao", "Ne", "Xue", "Xi", "Chui", "Dou", "Wen", "Hou", "Ou", "Wu", "Gao", "Ya", "Jun", "Lu", "E", "Ge", "Mei", "Ai", "Qi", "Cheng", "Wu", "Gao", "Fu", "Jiao", "Hong", "Chi", "Sheng", "Ne", "Tun", "Fu", "Yi", "Dai", "Ou", "Li", "Bai", "Yuan", "Kuai", , "Qiang", "Wu", "E", "Shi", "Quan", "Pen", "Wen", "Ni", "M", "Ling", "Ran", "You", "Di", "Zhou", "Shi", "Zhou", "Tie", "Xi", "Yi", "Qi", "Ping", "Zi", "Gu", "Zi", "Wei", "Xu", "He", "Nao", "Xia", "Pei", "Yi", "Xiao", "Shen", "Hu", "Ming", "Da", "Qu", "Ju", "Gem", "Za", "Tuo", "Duo", "Pou", "Pao", "Bi", "Fu", "Yang", "He", "Zha", "He", "Hai", "Jiu", "Yong", "Fu", "Que", "Zhou", "Wa", "Ka", "Gu", "Ka", "Zuo", "Bu", "Long", "Dong", "Ning", "Tha", "Si", "Xian", "Huo", "Qi", "Er", "E", "Guang", "Zha", "Xi", "Yi", "Lie", "Zi", "Mie", "Mi", "Zhi", "Yao", "Ji", "Zhou", "Ge", "Shuai", "Zan", "Xiao", "Ke", "Hui", "Kua", "Huai", "Tao", "Xian", "E", "Xuan", "Xiu", "Wai", "Yan", "Lao", "Yi", "Ai", "Pin", "Shen", "Tong", "Hong", "Xiong", "Chi", "Wa", "Ha", "Zai", "Yu", "Di", "Pai", "Xiang", "Ai", "Hen", "Kuang", "Ya", "Da", "Xiao", "Bi", "Yue", , "Hua", "Sasou", "Kuai", "Duo", , "Ji", "Nong", "Mou", "Yo", "Hao", "Yuan", "Long", "Pou", "Mang", "Ge", "E", "Chi", "Shao", "Li", "Na", "Zu", "He", "Ku", "Xiao", "Xian", "Lao", "Bo", "Zhe", "Zha", "Liang", "Ba", "Mie", "Le", "Sui", "Fou", "Bu", "Han", "Heng", "Geng", "Shuo", "Ge"], ["You", "Yan", "Gu", "Gu", "Bai", "Han", "Suo", "Chun", "Yi", "Ai", "Jia", "Tu", "Xian", "Huan", "Li", "Xi", "Tang", "Zuo", "Qiu", "Che", "Wu", "Zao", "Ya", "Dou", "Qi", "Di", "Qin", "Ma", "Mal", "Hong", "Dou", "Kes", "Lao", "Liang", "Suo", "Zao", "Huan", "Lang", "Sha", "Ji", "Zuo", "Wo", "Feng", "Yin", "Hu", "Qi", "Shou", "Wei", "Shua", "Chang", "Er", "Li", "Qiang", "An", "Jie", "Yo", "Nian", "Yu", "Tian", "Lai", "Sha", "Xi", "Tuo", "Hu", "Ai", "Zhou", "Nou", "Ken", "Zhuo", "Zhuo", "Shang", "Di", "Heng", "Lan", "A", "Xiao", "Xiang", "Tun", "Wu", "Wen", "Cui", "Sha", "Hu", "Qi", "Qi", "Tao", "Dan", "Dan", "Ye", "Zi", "Bi", "Cui", "Chuo", "He", "Ya", "Qi", "Zhe", "Pei", "Liang", "Xian", "Pi", "Sha", "La", "Ze", "Qing", "Gua", "Pa", "Zhe", "Se", "Zhuan", "Nie", "Guo", "Luo", "Yan", "Di", "Quan", "Tan", "Bo", "Ding", "Lang", "Xiao", , "Tang", "Chi", "Ti", "An", "Jiu", "Dan", "Ke", "Yong", "Wei", "Nan", "Shan", "Yu", "Zhe", "La", "Jie", "Hou", "Han", "Die", "Zhou", "Chai", "Wai", "Re", "Yu", "Yin", "Zan", "Yao", "Wo", "Mian", "Hu", "Yun", "Chuan", "Hui", "Huan", "Huan", "Xi", "He", "Ji", "Kui", "Zhong", "Wei", "Sha", "Xu", "Huang", "Du", "Nie", "Xuan", "Liang", "Yu", "Sang", "Chi", "Qiao", "Yan", "Dan", "Pen", "Can", "Li", "Yo", "Zha", "Wei", "Miao", "Ying", "Pen", "Phos", "Kui", "Xi", "Yu", "Jie", "Lou", "Ku", "Sao", "Huo", "Ti", "Yao", "He", "A", "Xiu", "Qiang", "Se", "Yong", "Su", "Hong", "Xie", "Yi", "Suo", "Ma", "Cha", "Hai", "Ke", "Ta", "Sang", "Tian", "Ru", "Sou", "Wa", "Ji", "Pang", "Wu", "Xian", "Shi", "Ge", "Zi", "Jie", "Luo", "Weng", "Wa", "Si", "Chi", "Hao", "Suo", "Jia", "Hai", "Suo", "Qin", "Nie", "He", "Cis", "Sai", "Ng", "Ge", "Na", "Dia", "Ai", , "Tong", "Bi", "Ao", "Ao", "Lian", "Cui", "Zhe", "Mo", "Sou", "Sou", "Tan"], ["Di", "Qi", "Jiao", "Chong", "Jiao", "Kai", "Tan", "San", "Cao", "Jia", "Ai", "Xiao", "Piao", "Lou", "Ga", "Gu", "Xiao", "Hu", "Hui", "Guo", "Ou", "Xian", "Ze", "Chang", "Xu", "Po", "De", "Ma", "Ma", "Hu", "Lei", "Du", "Ga", "Tang", "Ye", "Beng", "Ying", "Saai", "Jiao", "Mi", "Xiao", "Hua", "Mai", "Ran", "Zuo", "Peng", "Lao", "Xiao", "Ji", "Zhu", "Chao", "Kui", "Zui", "Xiao", "Si", "Hao", "Fu", "Liao", "Qiao", "Xi", "Xiu", "Tan", "Tan", "Mo", "Xun", "E", "Zun", "Fan", "Chi", "Hui", "Zan", "Chuang", "Cu", "Dan", "Yu", "Tun", "Cheng", "Jiao", "Ye", "Xi", "Qi", "Hao", "Lian", "Xu", "Deng", "Hui", "Yin", "Pu", "Jue", "Qin", "Xun", "Nie", "Lu", "Si", "Yan", "Ying", "Da", "Dan", "Yu", "Zhou", "Jin", "Nong", "Yue", "Hui", "Qi", "E", "Zao", "Yi", "Shi", "Jiao", "Yuan", "Ai", "Yong", "Jue", "Kuai", "Yu", "Pen", "Dao", "Ge", "Xin", "Dun", "Dang", "Sin", "Sai", "Pi", "Pi", "Yin", "Zui", "Ning", "Di", "Lan", "Ta", "Huo", "Ru", "Hao", "Xia", "Ya", "Duo", "Xi", "Chou", "Ji", "Jin", "Hao", "Ti", "Chang", , , "Ca", "Ti", "Lu", "Hui", "Bo", "You", "Nie", "Yin", "Hu", "Mo", "Huang", "Zhe", "Li", "Liu", "Haai", "Nang", "Xiao", "Mo", "Yan", "Li", "Lu", "Long", "Fu", "Dan", "Chen", "Pin", "Pi", "Xiang", "Huo", "Mo", "Xi", "Duo", "Ku", "Yan", "Chan", "Ying", "Rang", "Dian", "La", "Ta", "Xiao", "Jiao", "Chuo", "Huan", "Huo", "Zhuan", "Nie", "Xiao", "Ca", "Li", "Chan", "Chai", "Li", "Yi", "Luo", "Nang", "Zan", "Su", "Xi", "So", "Jian", "Za", "Zhu", "Lan", "Nie", "Nang", , , "Wei", "Hui", "Yin", "Qiu", "Si", "Nin", "Jian", "Hui", "Xin", "Yin", "Nan", "Tuan", "Tuan", "Dun", "Kang", "Yuan", "Jiong", "Pian", "Yun", "Cong", "Hu", "Hui", "Yuan", "You", "Guo", "Kun", "Cong", "Wei", "Tu", "Wei", "Lun", "Guo", "Qun", "Ri", "Ling", "Gu", "Guo", "Tai", "Guo", "Tu", "You"], ["Guo", "Yin", "Hun", "Pu", "Yu", "Han", "Yuan", "Lun", "Quan", "Yu", "Qing", "Guo", "Chuan", "Wei", "Yuan", "Quan", "Ku", "Fu", "Yuan", "Yuan", "E", "Tu", "Tu", "Tu", "Tuan", "Lue", "Hui", "Yi", "Yuan", "Luan", "Luan", "Tu", "Ya", "Tu", "Ting", "Sheng", "Pu", "Lu", "Iri", "Ya", "Zai", "Wei", "Ge", "Yu", "Wu", "Gui", "Pi", "Yi", "Di", "Qian", "Qian", "Zhen", "Zhuo", "Dang", "Qia", "Akutsu", "Yama", "Kuang", "Chang", "Qi", "Nie", "Mo", "Ji", "Jia", "Zhi", "Zhi", "Ban", "Xun", "Tou", "Qin", "Fen", "Jun", "Keng", "Tun", "Fang", "Fen", "Ben", "Tan", "Kan", "Pi", "Zuo", "Keng", "Bi", "Xing", "Di", "Jing", "Ji", "Kuai", "Di", "Jing", "Jian", "Tan", "Li", "Ba", "Wu", "Fen", "Zhui", "Po", "Pan", "Tang", "Kun", "Qu", "Tan", "Zhi", "Tuo", "Gan", "Ping", "Dian", "Gua", "Ni", "Tai", "Pi", "Jiong", "Yang", "Fo", "Ao", "Liu", "Qiu", "Mu", "Ke", "Gou", "Xue", "Ba", "Chi", "Che", "Ling", "Zhu", "Fu", "Hu", "Zhi", "Chui", "La", "Long", "Long", "Lu", "Ao", "Tay", "Pao", , "Xing", "Dong", "Ji", "Ke", "Lu", "Ci", "Chi", "Lei", "Gai", "Yin", "Hou", "Dui", "Zhao", "Fu", "Guang", "Yao", "Duo", "Duo", "Gui", "Cha", "Yang", "Yin", "Fa", "Gou", "Yuan", "Die", "Xie", "Ken", "Jiong", "Shou", "E", "Ha", "Dian", "Hong", "Wu", "Kua", , "Tao", "Dang", "Kai", "Gake", "Nao", "An", "Xing", "Xian", "Huan", "Bang", "Pei", "Ba", "Yi", "Yin", "Han", "Xu", "Chui", "Cen", "Geng", "Ai", "Peng", "Fang", "Que", "Yong", "Xun", "Jia", "Di", "Mai", "Lang", "Xuan", "Cheng", "Yan", "Jin", "Zhe", "Lei", "Lie", "Bu", "Cheng", "Gomi", "Bu", "Shi", "Xun", "Guo", "Jiong", "Ye", "Nian", "Di", "Yu", "Bu", "Ya", "Juan", "Sui", "Pi", "Cheng", "Wan", "Ju", "Lun", "Zheng", "Kong", "Chong", "Dong", "Dai", "Tan", "An", "Cai", "Shu", "Beng", "Kan", "Zhi", "Duo", "Yi", "Zhi", "Yi", "Pei", "Ji", "Zhun", "Qi", "Sao", "Ju", "Ni"], ["Ku", "Ke", "Tang", "Kun", "Ni", "Jian", "Dui", "Jin", "Gang", "Yu", "E", "Peng", "Gu", "Tu", "Leng", , "Ya", "Qian", , "An", , "Duo", "Nao", "Tu", "Cheng", "Yin", "Hun", "Bi", "Lian", "Guo", "Die", "Zhuan", "Hou", "Bao", "Bao", "Yu", "Di", "Mao", "Jie", "Ruan", "E", "Geng", "Kan", "Zong", "Yu", "Huang", "E", "Yao", "Yan", "Bao", "Ji", "Mei", "Chang", "Du", "Tuo", "Yin", "Feng", "Zhong", "Jie", "Zhen", "Feng", "Gang", "Chuan", "Jian", "Pyeng", "Toride", "Xiang", "Huang", "Leng", "Duan", , "Xuan", "Ji", "Ji", "Kuai", "Ying", "Ta", "Cheng", "Yong", "Kai", "Su", "Su", "Shi", "Mi", "Ta", "Weng", "Cheng", "Tu", "Tang", "Que", "Zhong", "Li", "Peng", "Bang", "Sai", "Zang", "Dui", "Tian", "Wu", "Cheng", "Xun", "Ge", "Zhen", "Ai", "Gong", "Yan", "Kan", "Tian", "Yuan", "Wen", "Xie", "Liu", "Ama", "Lang", "Chang", "Peng", "Beng", "Chen", "Cu", "Lu", "Ou", "Qian", "Mei", "Mo", "Zhuan", "Shuang", "Shu", "Lou", "Chi", "Man", "Biao", "Jing", "Qi", "Shu", "Di", "Zhang", "Kan", "Yong", "Dian", "Chen", "Zhi", "Xi", "Guo", "Qiang", "Jin", "Di", "Shang", "Mu", "Cui", "Yan", "Ta", "Zeng", "Qi", "Qiang", "Liang", , "Zhui", "Qiao", "Zeng", "Xu", "Shan", "Shan", "Ba", "Pu", "Kuai", "Dong", "Fan", "Que", "Mo", "Dun", "Dun", "Dun", "Di", "Sheng", "Duo", "Duo", "Tan", "Deng", "Wu", "Fen", "Huang", "Tan", "Da", "Ye", "Sho", "Mama", "Yu", "Qiang", "Ji", "Qiao", "Ken", "Yi", "Pi", "Bi", "Dian", "Jiang", "Ye", "Yong", "Bo", "Tan", "Lan", "Ju", "Huai", "Dang", "Rang", "Qian", "Xun", "Lan", "Xi", "He", "Ai", "Ya", "Dao", "Hao", "Ruan", "Mama", "Lei", "Kuang", "Lu", "Yan", "Tan", "Wei", "Huai", "Long", "Long", "Rui", "Li", "Lin", "Rang", "Ten", "Xun", "Yan", "Lei", "Ba", , "Shi", "Ren", , "Zhuang", "Zhuang", "Sheng", "Yi", "Mai", "Ke", "Zhu", "Zhuang", "Hu", "Hu", "Kun", "Yi", "Hu", "Xu", "Kun", "Shou", "Mang", "Zun"], ["Shou", "Yi", "Zhi", "Gu", "Chu", "Jiang", "Feng", "Bei", "Cay", "Bian", "Sui", "Qun", "Ling", "Fu", "Zuo", "Xia", "Xiong", , "Nao", "Xia", "Kui", "Xi", "Wai", "Yuan", "Mao", "Su", "Duo", "Duo", "Ye", "Qing", "Uys", "Gou", "Gou", "Qi", "Meng", "Meng", "Yin", "Huo", "Chen", "Da", "Ze", "Tian", "Tai", "Fu", "Guai", "Yao", "Yang", "Hang", "Gao", "Shi", "Ben", "Tai", "Tou", "Yan", "Bi", "Yi", "Kua", "Jia", "Duo", "Kwu", "Kuang", "Yun", "Jia", "Pa", "En", "Lian", "Huan", "Di", "Yan", "Pao", "Quan", "Qi", "Nai", "Feng", "Xie", "Fen", "Dian", , "Kui", "Zou", "Huan", "Qi", "Kai", "Zha", "Ben", "Yi", "Jiang", "Tao", "Zang", "Ben", "Xi", "Xiang", "Fei", "Diao", "Xun", "Keng", "Dian", "Ao", "She", "Weng", "Pan", "Ao", "Wu", "Ao", "Jiang", "Lian", "Duo", "Yun", "Jiang", "Shi", "Fen", "Huo", "Bi", "Lian", "Duo", "Nu", "Nu", "Ding", "Nai", "Qian", "Jian", "Ta", "Jiu", "Nan", "Cha", "Hao", "Xian", "Fan", "Ji", "Shuo", "Ru", "Fei", "Wang", "Hong", "Zhuang", "Fu", "Ma", "Dan", "Ren", "Fu", "Jing", "Yan", "Xie", "Wen", "Zhong", "Pa", "Du", "Ji", "Keng", "Zhong", "Yao", "Jin", "Yun", "Miao", "Pei", "Shi", "Yue", "Zhuang", "Niu", "Yan", "Na", "Xin", "Fen", "Bi", "Yu", "Tuo", "Feng", "Yuan", "Fang", "Wu", "Yu", "Gui", "Du", "Ba", "Ni", "Zhou", "Zhuo", "Zhao", "Da", "Nai", "Yuan", "Tou", "Xuan", "Zhi", "E", "Mei", "Mo", "Qi", "Bi", "Shen", "Qie", "E", "He", "Xu", "Fa", "Zheng", "Min", "Ban", "Mu", "Fu", "Ling", "Zi", "Zi", "Shi", "Ran", "Shan", "Yang", "Man", "Jie", "Gu", "Si", "Xing", "Wei", "Zi", "Ju", "Shan", "Pin", "Ren", "Yao", "Tong", "Jiang", "Shu", "Ji", "Gai", "Shang", "Kuo", "Juan", "Jiao", "Gou", "Mu", "Jian", "Jian", "Yi", "Nian", "Zhi", "Ji", "Ji", "Xian", "Heng", "Guang", "Jun", "Kua", "Yan", "Ming", "Lie", "Pei", "Yan", "You", "Yan", "Cha", "Shen", "Yin", "Chi", "Gui", "Quan", "Zi"], ["Song", "Wei", "Hong", "Wa", "Lou", "Ya", "Rao", "Jiao", "Luan", "Ping", "Xian", "Shao", "Li", "Cheng", "Xiao", "Mang", "Fu", "Suo", "Wu", "Wei", "Ke", "Lai", "Chuo", "Ding", "Niang", "Xing", "Nan", "Yu", "Nuo", "Pei", "Nei", "Juan", "Shen", "Zhi", "Han", "Di", "Zhuang", "E", "Pin", "Tui", "Han", "Mian", "Wu", "Yan", "Wu", "Xi", "Yan", "Yu", "Si", "Yu", "Wa", , "Xian", "Ju", "Qu", "Shui", "Qi", "Xian", "Zhui", "Dong", "Chang", "Lu", "Ai", "E", "E", "Lou", "Mian", "Cong", "Pou", "Ju", "Po", "Cai", "Ding", "Wan", "Biao", "Xiao", "Shu", "Qi", "Hui", "Fu", "E", "Wo", "Tan", "Fei", "Wei", "Jie", "Tian", "Ni", "Quan", "Jing", "Hun", "Jing", "Qian", "Dian", "Xing", "Hu", "Wa", "Lai", "Bi", "Yin", "Chou", "Chuo", "Fu", "Jing", "Lun", "Yan", "Lan", "Kun", "Yin", "Ya", "Ju", "Li", "Dian", "Xian", "Hwa", "Hua", "Ying", "Chan", "Shen", "Ting", "Dang", "Yao", "Wu", "Nan", "Ruo", "Jia", "Tou", "Xu", "Yu", "Wei", "Ti", "Rou", "Mei", "Dan", "Ruan", "Qin", "Hui", "Wu", "Qian", "Chun", "Mao", "Fu", "Jie", "Duan", "Xi", "Zhong", "Mei", "Huang", "Mian", "An", "Ying", "Xuan", "Jie", "Wei", "Mei", "Yuan", "Zhen", "Qiu", "Ti", "Xie", "Tuo", "Lian", "Mao", "Ran", "Si", "Pian", "Wei", "Wa", "Jiu", "Hu", "Ao", , "Bou", "Xu", "Tou", "Gui", "Zou", "Yao", "Pi", "Xi", "Yuan", "Ying", "Rong", "Ru", "Chi", "Liu", "Mei", "Pan", "Ao", "Ma", "Gou", "Kui", "Qin", "Jia", "Sao", "Zhen", "Yuan", "Cha", "Yong", "Ming", "Ying", "Ji", "Su", "Niao", "Xian", "Tao", "Pang", "Lang", "Nao", "Bao", "Ai", "Pi", "Pin", "Yi", "Piao", "Yu", "Lei", "Xuan", "Man", "Yi", "Zhang", "Kang", "Yong", "Ni", "Li", "Di", "Gui", "Yan", "Jin", "Zhuan", "Chang", "Ce", "Han", "Nen", "Lao", "Mo", "Zhe", "Hu", "Hu", "Ao", "Nen", "Qiang", "Ma", "Pie", "Gu", "Wu", "Jiao", "Tuo", "Zhan", "Mao", "Xian", "Xian", "Mo", "Liao", "Lian", "Hua"], ["Gui", "Deng", "Zhi", "Xu", "Yi", "Hua", "Xi", "Hui", "Rao", "Xi", "Yan", "Chan", "Jiao", "Mei", "Fan", "Fan", "Xian", "Yi", "Wei", "Jiao", "Fu", "Shi", "Bi", "Shan", "Sui", "Qiang", "Lian", "Huan", "Xin", "Niao", "Dong", "Yi", "Can", "Ai", "Niang", "Neng", "Ma", "Tiao", "Chou", "Jin", "Ci", "Yu", "Pin", "Yong", "Xu", "Nai", "Yan", "Tai", "Ying", "Can", "Niao", "Wo", "Ying", "Mian", "Kaka", "Ma", "Shen", "Xing", "Ni", "Du", "Liu", "Yuan", "Lan", "Yan", "Shuang", "Ling", "Jiao", "Niang", "Lan", "Xian", "Ying", "Shuang", "Shuai", "Quan", "Mi", "Li", "Luan", "Yan", "Zhu", "Lan", "Zi", "Jie", "Jue", "Jue", "Kong", "Yun", "Zi", "Zi", "Cun", "Sun", "Fu", "Bei", "Zi", "Xiao", "Xin", "Meng", "Si", "Tai", "Bao", "Ji", "Gu", "Nu", "Xue", , "Zhuan", "Hai", "Luan", "Sun", "Huai", "Mie", "Cong", "Qian", "Shu", "Chan", "Ya", "Zi", "Ni", "Fu", "Zi", "Li", "Xue", "Bo", "Ru", "Lai", "Nie", "Nie", "Ying", "Luan", "Mian", "Ning", "Rong", "Ta", "Gui", "Zhai", "Qiong", "Yu", "Shou", "An", "Tu", "Song", "Wan", "Rou", "Yao", "Hong", "Yi", "Jing", "Zhun", "Mi", "Zhu", "Dang", "Hong", "Zong", "Guan", "Zhou", "Ding", "Wan", "Yi", "Bao", "Shi", "Shi", "Chong", "Shen", "Ke", "Xuan", "Shi", "You", "Huan", "Yi", "Tiao", "Shi", "Xian", "Gong", "Cheng", "Qun", "Gong", "Xiao", "Zai", "Zha", "Bao", "Hai", "Yan", "Xiao", "Jia", "Shen", "Chen", "Rong", "Huang", "Mi", "Kou", "Kuan", "Bin", "Su", "Cai", "Zan", "Ji", "Yuan", "Ji", "Yin", "Mi", "Kou", "Qing", "Que", "Zhen", "Jian", "Fu", "Ning", "Bing", "Huan", "Mei", "Qin", "Han", "Yu", "Shi", "Ning", "Qin", "Ning", "Zhi", "Yu", "Bao", "Kuan", "Ning", "Qin", "Mo", "Cha", "Ju", "Gua", "Qin", "Hu", "Wu", "Liao", "Shi", "Zhu", "Zhai", "Shen", "Wei", "Xie", "Kuan", "Hui", "Liao", "Jun", "Huan", "Yi", "Yi", "Bao", "Qin", "Chong", "Bao", "Feng", "Cun", "Dui", "Si", "Xun", "Dao", "Lu", "Dui", "Shou"], ["Po", "Feng", "Zhuan", "Fu", "She", "Ke", "Jiang", "Jiang", "Zhuan", "Wei", "Zun", "Xun", "Shu", "Dui", "Dao", "Xiao", "Ji", "Shao", "Er", "Er", "Er", "Ga", "Jian", "Shu", "Chen", "Shang", "Shang", "Mo", "Ga", "Chang", "Liao", "Xian", "Xian", , "Wang", "Wang", "You", "Liao", "Liao", "Yao", "Mang", "Wang", "Wang", "Wang", "Ga", "Yao", "Duo", "Kui", "Zhong", "Jiu", "Gan", "Gu", "Gan", "Tui", "Gan", "Gan", "Shi", "Yin", "Chi", "Kao", "Ni", "Jin", "Wei", "Niao", "Ju", "Pi", "Ceng", "Xi", "Bi", "Ju", "Jie", "Tian", "Qu", "Ti", "Jie", "Wu", "Diao", "Shi", "Shi", "Ping", "Ji", "Xie", "Chen", "Xi", "Ni", "Zhan", "Xi", , "Man", "E", "Lou", "Ping", "Ti", "Fei", "Shu", "Xie", "Tu", "Lu", "Lu", "Xi", "Ceng", "Lu", "Ju", "Xie", "Ju", "Jue", "Liao", "Jue", "Shu", "Xi", "Che", "Tun", "Ni", "Shan", , "Xian", "Li", "Xue", "Nata", , "Long", "Yi", "Qi", "Ren", "Wu", "Han", "Shen", "Yu", "Chu", "Sui", "Qi", , "Yue", "Ban", "Yao", "Ang", "Ya", "Wu", "Jie", "E", "Ji", "Qian", "Fen", "Yuan", "Qi", "Cen", "Qian", "Qi", "Cha", "Jie", "Qu", "Gang", "Xian", "Ao", "Lan", "Dao", "Ba", "Zuo", "Zuo", "Yang", "Ju", "Gang", "Ke", "Gou", "Xue", "Bei", "Li", "Tiao", "Ju", "Yan", "Fu", "Xiu", "Jia", "Ling", "Tuo", "Pei", "You", "Dai", "Kuang", "Yue", "Qu", "Hu", "Po", "Min", "An", "Tiao", "Ling", "Chi", "Yuri", "Dong", "Cem", "Kui", "Xiu", "Mao", "Tong", "Xue", "Yi", "Kura", "He", "Ke", "Luo", "E", "Fu", "Xun", "Die", "Lu", "An", "Er", "Gai", "Quan", "Tong", "Yi", "Mu", "Shi", "An", "Wei", "Hu", "Zhi", "Mi", "Li", "Ji", "Tong", "Wei", "You", "Sang", "Xia", "Li", "Yao", "Jiao", "Zheng", "Luan", "Jiao", "E", "E", "Yu", "Ye", "Bu", "Qiao", "Qun", "Feng", "Feng", "Nao", "Li", "You", "Xian", "Hong", "Dao", "Shen", "Cheng", "Tu", "Geng", "Jun", "Hao", "Xia", "Yin", "Yu"], ["Lang", "Kan", "Lao", "Lai", "Xian", "Que", "Kong", "Chong", "Chong", "Ta", "Lin", "Hua", "Ju", "Lai", "Qi", "Min", "Kun", "Kun", "Zu", "Gu", "Cui", "Ya", "Ya", "Gang", "Lun", "Lun", "Leng", "Jue", "Duo", "Zheng", "Guo", "Yin", "Dong", "Han", "Zheng", "Wei", "Yao", "Pi", "Yan", "Song", "Jie", "Beng", "Zu", "Jue", "Dong", "Zhan", "Gu", "Yin", , "Ze", "Huang", "Yu", "Wei", "Yang", "Feng", "Qiu", "Dun", "Ti", "Yi", "Zhi", "Shi", "Zai", "Yao", "E", "Zhu", "Kan", "Lu", "Yan", "Mei", "Gan", "Ji", "Ji", "Huan", "Ting", "Sheng", "Mei", "Qian", "Wu", "Yu", "Zong", "Lan", "Jue", "Yan", "Yan", "Wei", "Zong", "Cha", "Sui", "Rong", "Yamashina", "Qin", "Yu", "Kewashii", "Lou", "Tu", "Dui", "Xi", "Weng", "Cang", "Dang", "Hong", "Jie", "Ai", "Liu", "Wu", "Song", "Qiao", "Zi", "Wei", "Beng", "Dian", "Cuo", "Qian", "Yong", "Nie", "Cuo", "Ji", , "Tao", "Song", "Zong", "Jiang", "Liao", "Kang", "Chan", "Die", "Cen", "Ding", "Tu", "Lou", "Zhang", "Zhan", "Zhan", "Ao", "Cao", "Qu", "Qiang", "Zui", "Zui", "Dao", "Dao", "Xi", "Yu", "Bo", "Long", "Xiang", "Ceng", "Bo", "Qin", "Jiao", "Yan", "Lao", "Zhan", "Lin", "Liao", "Liao", "Jin", "Deng", "Duo", "Zun", "Jiao", "Gui", "Yao", "Qiao", "Yao", "Jue", "Zhan", "Yi", "Xue", "Nao", "Ye", "Ye", "Yi", "E", "Xian", "Ji", "Xie", "Ke", "Xi", "Di", "Ao", "Zui", , "Ni", "Rong", "Dao", "Ling", "Za", "Yu", "Yue", "Yin", , "Jie", "Li", "Sui", "Long", "Long", "Dian", "Ying", "Xi", "Ju", "Chan", "Ying", "Kui", "Yan", "Wei", "Nao", "Quan", "Chao", "Cuan", "Luan", "Dian", "Dian", , "Yan", "Yan", "Yan", "Nao", "Yan", "Chuan", "Gui", "Chuan", "Zhou", "Huang", "Jing", "Xun", "Chao", "Chao", "Lie", "Gong", "Zuo", "Qiao", "Ju", "Gong", "Kek", "Wu", "Pwu", "Pwu", "Chai", "Qiu", "Qiu", "Ji", "Yi", "Si", "Ba", "Zhi", "Zhao", "Xiang", "Yi", "Jin", "Xun", "Juan", "Phas", "Xun", "Jin", "Fu"], ["Za", "Bi", "Shi", "Bu", "Ding", "Shuai", "Fan", "Nie", "Shi", "Fen", "Pa", "Zhi", "Xi", "Hu", "Dan", "Wei", "Zhang", "Tang", "Dai", "Ma", "Pei", "Pa", "Tie", "Fu", "Lian", "Zhi", "Zhou", "Bo", "Zhi", "Di", "Mo", "Yi", "Yi", "Ping", "Qia", "Juan", "Ru", "Shuai", "Dai", "Zheng", "Shui", "Qiao", "Zhen", "Shi", "Qun", "Xi", "Bang", "Dai", "Gui", "Chou", "Ping", "Zhang", "Sha", "Wan", "Dai", "Wei", "Chang", "Sha", "Qi", "Ze", "Guo", "Mao", "Du", "Hou", "Zheng", "Xu", "Mi", "Wei", "Wo", "Fu", "Yi", "Bang", "Ping", "Tazuna", "Gong", "Pan", "Huang", "Dao", "Mi", "Jia", "Teng", "Hui", "Zhong", "Shan", "Man", "Mu", "Biao", "Guo", "Ze", "Mu", "Bang", "Zhang", "Jiong", "Chan", "Fu", "Zhi", "Hu", "Fan", "Chuang", "Bi", "Hei", , "Mi", "Qiao", "Chan", "Fen", "Meng", "Bang", "Chou", "Mie", "Chu", "Jie", "Xian", "Lan", "Gan", "Ping", "Nian", "Qian", "Bing", "Bing", "Xing", "Gan", "Yao", "Huan", "You", "You", "Ji", "Guang", "Pi", "Ting", "Ze", "Guang", "Zhuang", "Mo", "Qing", "Bi", "Qin", "Dun", "Chuang", "Gui", "Ya", "Bai", "Jie", "Xu", "Lu", "Wu", , "Ku", "Ying", "Di", "Pao", "Dian", "Ya", "Miao", "Geng", "Ci", "Fu", "Tong", "Pang", "Fei", "Xiang", "Yi", "Zhi", "Tiao", "Zhi", "Xiu", "Du", "Zuo", "Xiao", "Tu", "Gui", "Ku", "Pang", "Ting", "You", "Bu", "Ding", "Cheng", "Lai", "Bei", "Ji", "An", "Shu", "Kang", "Yong", "Tuo", "Song", "Shu", "Qing", "Yu", "Yu", "Miao", "Sou", "Ce", "Xiang", "Fei", "Jiu", "He", "Hui", "Liu", "Sha", "Lian", "Lang", "Sou", "Jian", "Pou", "Qing", "Jiu", "Jiu", "Qin", "Ao", "Kuo", "Lou", "Yin", "Liao", "Dai", "Lu", "Yi", "Chu", "Chan", "Tu", "Si", "Xin", "Miao", "Chang", "Wu", "Fei", "Guang", "Koc", "Kuai", "Bi", "Qiang", "Xie", "Lin", "Lin", "Liao", "Lu", , "Ying", "Xian", "Ting", "Yong", "Li", "Ting", "Yin", "Xun", "Yan", "Ting", "Di", "Po", "Jian", "Hui", "Nai", "Hui", "Gong", "Nian"], ["Kai", "Bian", "Yi", "Qi", "Nong", "Fen", "Ju", "Yan", "Yi", "Zang", "Bi", "Yi", "Yi", "Er", "San", "Shi", "Er", "Shi", "Shi", "Gong", "Diao", "Yin", "Hu", "Fu", "Hong", "Wu", "Tui", "Chi", "Jiang", "Ba", "Shen", "Di", "Zhang", "Jue", "Tao", "Fu", "Di", "Mi", "Xian", "Hu", "Chao", "Nu", "Jing", "Zhen", "Yi", "Mi", "Quan", "Wan", "Shao", "Ruo", "Xuan", "Jing", "Dun", "Zhang", "Jiang", "Qiang", "Peng", "Dan", "Qiang", "Bi", "Bi", "She", "Dan", "Jian", "Gou", "Sei", "Fa", "Bi", "Kou", "Nagi", "Bie", "Xiao", "Dan", "Kuo", "Qiang", "Hong", "Mi", "Kuo", "Wan", "Jue", "Ji", "Ji", "Gui", "Dang", "Lu", "Lu", "Tuan", "Hui", "Zhi", "Hui", "Hui", "Yi", "Yi", "Yi", "Yi", "Huo", "Huo", "Shan", "Xing", "Wen", "Tong", "Yan", "Yan", "Yu", "Chi", "Cai", "Biao", "Diao", "Bin", "Peng", "Yong", "Piao", "Zhang", "Ying", "Chi", "Chi", "Zhuo", "Tuo", "Ji", "Pang", "Zhong", "Yi", "Wang", "Che", "Bi", "Chi", "Ling", "Fu", "Wang", "Zheng", "Cu", "Wang", "Jing", "Dai", "Xi", "Xun", "Hen", "Yang", "Huai", "Lu", "Hou", "Wa", "Cheng", "Zhi", "Xu", "Jing", "Tu", "Cong", , "Lai", "Cong", "De", "Pai", "Xi", , "Qi", "Chang", "Zhi", "Cong", "Zhou", "Lai", "Yu", "Xie", "Jie", "Jian", "Chi", "Jia", "Bian", "Huang", "Fu", "Xun", "Wei", "Pang", "Yao", "Wei", "Xi", "Zheng", "Piao", "Chi", "De", "Zheng", "Zheng", "Bie", "De", "Chong", "Che", "Jiao", "Wei", "Jiao", "Hui", "Mei", "Long", "Xiang", "Bao", "Qu", "Xin", "Shu", "Bi", "Yi", "Le", "Ren", "Dao", "Ding", "Gai", "Ji", "Ren", "Ren", "Chan", "Tan", "Te", "Te", "Gan", "Qi", "Shi", "Cun", "Zhi", "Wang", "Mang", "Xi", "Fan", "Ying", "Tian", "Min", "Min", "Zhong", "Chong", "Wu", "Ji", "Wu", "Xi", "Ye", "You", "Wan", "Cong", "Zhong", "Kuai", "Yu", "Bian", "Zhi", "Qi", "Cui", "Chen", "Tai", "Tun", "Qian", "Nian", "Hun", "Xiong", "Niu", "Wang", "Xian", "Xin", "Kang", "Hu", "Kai", "Fen"], ["Huai", "Tai", "Song", "Wu", "Ou", "Chang", "Chuang", "Ju", "Yi", "Bao", "Chao", "Min", "Pei", "Zuo", "Zen", "Yang", "Kou", "Ban", "Nu", "Nao", "Zheng", "Pa", "Bu", "Tie", "Gu", "Hu", "Ju", "Da", "Lian", "Si", "Chou", "Di", "Dai", "Yi", "Tu", "You", "Fu", "Ji", "Peng", "Xing", "Yuan", "Ni", "Guai", "Fu", "Xi", "Bi", "You", "Qie", "Xuan", "Cong", "Bing", "Huang", "Xu", "Chu", "Pi", "Xi", "Xi", "Tan", "Koraeru", "Zong", "Dui", , "Ki", "Yi", "Chi", "Ren", "Xun", "Shi", "Xi", "Lao", "Heng", "Kuang", "Mu", "Zhi", "Xie", "Lian", "Tiao", "Huang", "Die", "Hao", "Kong", "Gui", "Heng", "Xi", "Xiao", "Shu", "S", "Kua", "Qiu", "Yang", "Hui", "Hui", "Chi", "Jia", "Yi", "Xiong", "Guai", "Lin", "Hui", "Zi", "Xu", "Chi", "Xiang", "Nu", "Hen", "En", "Ke", "Tong", "Tian", "Gong", "Quan", "Xi", "Qia", "Yue", "Peng", "Ken", "De", "Hui", "E", "Kyuu", "Tong", "Yan", "Kai", "Ce", "Nao", "Yun", "Mang", "Yong", "Yong", "Yuan", "Pi", "Kun", "Qiao", "Yue", "Yu", "Yu", "Jie", "Xi", "Zhe", "Lin", "Ti", "Han", "Hao", "Qie", "Ti", "Bu", "Yi", "Qian", "Hui", "Xi", "Bei", "Man", "Yi", "Heng", "Song", "Quan", "Cheng", "Hui", "Wu", "Wu", "You", "Li", "Liang", "Huan", "Cong", "Yi", "Yue", "Li", "Nin", "Nao", "E", "Que", "Xuan", "Qian", "Wu", "Min", "Cong", "Fei", "Bei", "Duo", "Cui", "Chang", "Men", "Li", "Ji", "Guan", "Guan", "Xing", "Dao", "Qi", "Kong", "Tian", "Lun", "Xi", "Kan", "Kun", "Ni", "Qing", "Chou", "Dun", "Guo", "Chan", "Liang", "Wan", "Yuan", "Jin", "Ji", "Lin", "Yu", "Huo", "He", "Quan", "Tan", "Ti", "Ti", "Nie", "Wang", "Chuo", "Bu", "Hun", "Xi", "Tang", "Xin", "Wei", "Hui", "E", "Rui", "Zong", "Jian", "Yong", "Dian", "Ju", "Can", "Cheng", "De", "Bei", "Qie", "Can", "Dan", "Guan", "Duo", "Nao", "Yun", "Xiang", "Zhui", "Die", "Huang", "Chun", "Qiong", "Re", "Xing", "Ce", "Bian", "Hun", "Zong", "Ti"], ["Qiao", "Chou", "Bei", "Xuan", "Wei", "Ge", "Qian", "Wei", "Yu", "Yu", "Bi", "Xuan", "Huan", "Min", "Bi", "Yi", "Mian", "Yong", "Kai", "Dang", "Yin", "E", "Chen", "Mou", "Ke", "Ke", "Yu", "Ai", "Qie", "Yan", "Nuo", "Gan", "Yun", "Zong", "Sai", "Leng", "Fen", , "Kui", "Kui", "Que", "Gong", "Yun", "Su", "Su", "Qi", "Yao", "Song", "Huang", "Ji", "Gu", "Ju", "Chuang", "Ni", "Xie", "Kai", "Zheng", "Yong", "Cao", "Sun", "Shen", "Bo", "Kai", "Yuan", "Xie", "Hun", "Yong", "Yang", "Li", "Sao", "Tao", "Yin", "Ci", "Xu", "Qian", "Tai", "Huang", "Yun", "Shen", "Ming", , "She", "Cong", "Piao", "Mo", "Mu", "Guo", "Chi", "Can", "Can", "Can", "Cui", "Min", "Te", "Zhang", "Tong", "Ao", "Shuang", "Man", "Guan", "Que", "Zao", "Jiu", "Hui", "Kai", "Lian", "Ou", "Song", "Jin", "Yin", "Lu", "Shang", "Wei", "Tuan", "Man", "Qian", "She", "Yong", "Qing", "Kang", "Di", "Zhi", "Lou", "Juan", "Qi", "Qi", "Yu", "Ping", "Liao", "Cong", "You", "Chong", "Zhi", "Tong", "Cheng", "Qi", "Qu", "Peng", "Bei", "Bie", "Chun", "Jiao", "Zeng", "Chi", "Lian", "Ping", "Kui", "Hui", "Qiao", "Cheng", "Yin", "Yin", "Xi", "Xi", "Dan", "Tan", "Duo", "Dui", "Dui", "Su", "Jue", "Ce", "Xiao", "Fan", "Fen", "Lao", "Lao", "Chong", "Han", "Qi", "Xian", "Min", "Jing", "Liao", "Wu", "Can", "Jue", "Cu", "Xian", "Tan", "Sheng", "Pi", "Yi", "Chu", "Xian", "Nao", "Dan", "Tan", "Jing", "Song", "Han", "Jiao", "Wai", "Huan", "Dong", "Qin", "Qin", "Qu", "Cao", "Ken", "Xie", "Ying", "Ao", "Mao", "Yi", "Lin", "Se", "Jun", "Huai", "Men", "Lan", "Ai", "Lin", "Yan", "Gua", "Xia", "Chi", "Yu", "Yin", "Dai", "Meng", "Ai", "Meng", "Dui", "Qi", "Mo", "Lan", "Men", "Chou", "Zhi", "Nuo", "Nuo", "Yan", "Yang", "Bo", "Zhi", "Kuang", "Kuang", "You", "Fu", "Liu", "Mie", "Cheng", , "Chan", "Meng", "Lan", "Huai", "Xuan", "Rang", "Chan", "Ji", "Ju", "Huan", "She", "Yi"], ["Lian", "Nan", "Mi", "Tang", "Jue", "Gang", "Gang", "Gang", "Ge", "Yue", "Wu", "Jian", "Xu", "Shu", "Rong", "Xi", "Cheng", "Wo", "Jie", "Ge", "Jian", "Qiang", "Huo", "Qiang", "Zhan", "Dong", "Qi", "Jia", "Die", "Zei", "Jia", "Ji", "Shi", "Kan", "Ji", "Kui", "Gai", "Deng", "Zhan", "Chuang", "Ge", "Jian", "Jie", "Yu", "Jian", "Yan", "Lu", "Xi", "Zhan", "Xi", "Xi", "Chuo", "Dai", "Qu", "Hu", "Hu", "Hu", "E", "Shi", "Li", "Mao", "Hu", "Li", "Fang", "Suo", "Bian", "Dian", "Jiong", "Shang", "Yi", "Yi", "Shan", "Hu", "Fei", "Yan", "Shou", "T", "Cai", "Zha", "Qiu", "Le", "Bu", "Ba", "Da", "Reng", "Fu", "Hameru", "Zai", "Tuo", "Zhang", "Diao", "Kang", "Yu", "Ku", "Han", "Shen", "Cha", "Yi", "Gu", "Kou", "Wu", "Tuo", "Qian", "Zhi", "Ren", "Kuo", "Men", "Sao", "Yang", "Niu", "Ban", "Che", "Rao", "Xi", "Qian", "Ban", "Jia", "Yu", "Fu", "Ao", "Xi", "Pi", "Zhi", "Zi", "E", "Dun", "Zhao", "Cheng", "Ji", "Yan", "Kuang", "Bian", "Chao", "Ju", "Wen", "Hu", "Yue", "Jue", "Ba", "Qin", "Zhen", "Zheng", "Yun", "Wan", "Nu", "Yi", "Shu", "Zhua", "Pou", "Tou", "Dou", "Kang", "Zhe", "Pou", "Fu", "Pao", "Ba", "Ao", "Ze", "Tuan", "Kou", "Lun", "Qiang", , "Hu", "Bao", "Bing", "Zhi", "Peng", "Tan", "Pu", "Pi", "Tai", "Yao", "Zhen", "Zha", "Yang", "Bao", "He", "Ni", "Yi", "Di", "Chi", "Pi", "Za", "Mo", "Mo", "Shen", "Ya", "Chou", "Qu", "Min", "Chu", "Jia", "Fu", "Zhan", "Zhu", "Dan", "Chai", "Mu", "Nian", "La", "Fu", "Pao", "Ban", "Pai", "Ling", "Na", "Guai", "Qian", "Ju", "Tuo", "Ba", "Tuo", "Tuo", "Ao", "Ju", "Zhuo", "Pan", "Zhao", "Bai", "Bai", "Di", "Ni", "Ju", "Kuo", "Long", "Jian", , "Yong", "Lan", "Ning", "Bo", "Ze", "Qian", "Hen", "Gua", "Shi", "Jie", "Zheng", "Nin", "Gong", "Gong", "Quan", "Shuan", "Cun", "Zan", "Kao", "Chi", "Xie", "Ce", "Hui", "Pin", "Zhuai", "Shi", "Na"], ["Bo", "Chi", "Gua", "Zhi", "Kuo", "Duo", "Duo", "Zhi", "Qie", "An", "Nong", "Zhen", "Ge", "Jiao", "Ku", "Dong", "Ru", "Tiao", "Lie", "Zha", "Lu", "Die", "Wa", "Jue", "Mushiru", "Ju", "Zhi", "Luan", "Ya", "Zhua", "Ta", "Xie", "Nao", "Dang", "Jiao", "Zheng", "Ji", "Hui", "Xun", "Ku", "Ai", "Tuo", "Nuo", "Cuo", "Bo", "Geng", "Ti", "Zhen", "Cheng", "Suo", "Suo", "Keng", "Mei", "Long", "Ju", "Peng", "Jian", "Yi", "Ting", "Shan", "Nuo", "Wan", "Xie", "Cha", "Feng", "Jiao", "Wu", "Jun", "Jiu", "Tong", "Kun", "Huo", "Tu", "Zhuo", "Pou", "Le", "Ba", "Han", "Shao", "Nie", "Juan", "Ze", "Song", "Ye", "Jue", "Bu", "Huan", "Bu", "Zun", "Yi", "Zhai", "Lu", "Sou", "Tuo", "Lao", "Sun", "Bang", "Jian", "Huan", "Dao", , "Wan", "Qin", "Peng", "She", "Lie", "Min", "Men", "Fu", "Bai", "Ju", "Dao", "Wo", "Ai", "Juan", "Yue", "Zong", "Chen", "Chui", "Jie", "Tu", "Ben", "Na", "Nian", "Nuo", "Zu", "Wo", "Xi", "Xian", "Cheng", "Dian", "Sao", "Lun", "Qing", "Gang", "Duo", "Shou", "Diao", "Pou", "Di", "Zhang", "Gun", "Ji", "Tao", "Qia", "Qi", "Pai", "Shu", "Qian", "Ling", "Yi", "Ya", "Jue", "Zheng", "Liang", "Gua", "Yi", "Huo", "Shan", "Zheng", "Lue", "Cai", "Tan", "Che", "Bing", "Jie", "Ti", "Kong", "Tui", "Yan", "Cuo", "Zou", "Ju", "Tian", "Qian", "Ken", "Bai", "Shou", "Jie", "Lu", "Guo", "Haba", , "Zhi", "Dan", "Mang", "Xian", "Sao", "Guan", "Peng", "Yuan", "Nuo", "Jian", "Zhen", "Jiu", "Jian", "Yu", "Yan", "Kui", "Nan", "Hong", "Rou", "Pi", "Wei", "Sai", "Zou", "Xuan", "Miao", "Ti", "Nie", "Cha", "Shi", "Zong", "Zhen", "Yi", "Shun", "Heng", "Bian", "Yang", "Huan", "Yan", "Zuan", "An", "Xu", "Ya", "Wo", "Ke", "Chuai", "Ji", "Ti", "La", "La", "Cheng", "Kai", "Jiu", "Jiu", "Tu", "Jie", "Hui", "Geng", "Chong", "Shuo", "She", "Xie", "Yuan", "Qian", "Ye", "Cha", "Zha", "Bei", "Yao", , , "Lan", "Wen", "Qin"], ["Chan", "Ge", "Lou", "Zong", "Geng", "Jiao", "Gou", "Qin", "Yong", "Que", "Chou", "Chi", "Zhan", "Sun", "Sun", "Bo", "Chu", "Rong", "Beng", "Cuo", "Sao", "Ke", "Yao", "Dao", "Zhi", "Nu", "Xie", "Jian", "Sou", "Qiu", "Gao", "Xian", "Shuo", "Sang", "Jin", "Mie", "E", "Chui", "Nuo", "Shan", "Ta", "Jie", "Tang", "Pan", "Ban", "Da", "Li", "Tao", "Hu", "Zhi", "Wa", "Xia", "Qian", "Wen", "Qiang", "Tian", "Zhen", "E", "Xi", "Nuo", "Quan", "Cha", "Zha", "Ge", "Wu", "En", "She", "Kang", "She", "Shu", "Bai", "Yao", "Bin", "Sou", "Tan", "Sa", "Chan", "Suo", "Liao", "Chong", "Chuang", "Guo", "Bing", "Feng", "Shuai", "Di", "Qi", "Sou", "Zhai", "Lian", "Tang", "Chi", "Guan", "Lu", "Luo", "Lou", "Zong", "Gai", "Hu", "Zha", "Chuang", "Tang", "Hua", "Cui", "Nai", "Mo", "Jiang", "Gui", "Ying", "Zhi", "Ao", "Zhi", "Nie", "Man", "Shan", "Kou", "Shu", "Suo", "Tuan", "Jiao", "Mo", "Mo", "Zhe", "Xian", "Keng", "Piao", "Jiang", "Yin", "Gou", "Qian", "Lue", "Ji", "Ying", "Jue", "Pie", "Pie", "Lao", "Dun", "Xian", "Ruan", "Kui", "Zan", "Yi", "Xun", "Cheng", "Cheng", "Sa", "Nao", "Heng", "Si", "Qian", "Huang", "Da", "Zun", "Nian", "Lin", "Zheng", "Hui", "Zhuang", "Jiao", "Ji", "Cao", "Dan", "Dan", "Che", "Bo", "Che", "Jue", "Xiao", "Liao", "Ben", "Fu", "Qiao", "Bo", "Cuo", "Zhuo", "Zhuan", "Tuo", "Pu", "Qin", "Dun", "Nian", , "Xie", "Lu", "Jiao", "Cuan", "Ta", "Han", "Qiao", "Zhua", "Jian", "Gan", "Yong", "Lei", "Kuo", "Lu", "Shan", "Zhuo", "Ze", "Pu", "Chuo", "Ji", "Dang", "Suo", "Cao", "Qing", "Jing", "Huan", "Jie", "Qin", "Kuai", "Dan", "Xi", "Ge", "Pi", "Bo", "Ao", "Ju", "Ye", , "Mang", "Sou", "Mi", "Ji", "Tai", "Zhuo", "Dao", "Xing", "Lan", "Ca", "Ju", "Ye", "Ru", "Ye", "Ye", "Ni", "Hu", "Ji", "Bin", "Ning", "Ge", "Zhi", "Jie", "Kuo", "Mo", "Jian", "Xie", "Lie", "Tan", "Bai", "Sou", "Lu", "Lue", "Rao", "Zhi"], ["Pan", "Yang", "Lei", "Sa", "Shu", "Zan", "Nian", "Xian", "Jun", "Huo", "Li", "La", "Han", "Ying", "Lu", "Long", "Qian", "Qian", "Zan", "Qian", "Lan", "San", "Ying", "Mei", "Rang", "Chan", , "Cuan", "Xi", "She", "Luo", "Jun", "Mi", "Li", "Zan", "Luan", "Tan", "Zuan", "Li", "Dian", "Wa", "Dang", "Jiao", "Jue", "Lan", "Li", "Nang", "Zhi", "Gui", "Gui", "Qi", "Xin", "Pu", "Sui", "Shou", "Kao", "You", "Gai", "Yi", "Gong", "Gan", "Ban", "Fang", "Zheng", "Bo", "Dian", "Kou", "Min", "Wu", "Gu", "He", "Ce", "Xiao", "Mi", "Chu", "Ge", "Di", "Xu", "Jiao", "Min", "Chen", "Jiu", "Zhen", "Duo", "Yu", "Chi", "Ao", "Bai", "Xu", "Jiao", "Duo", "Lian", "Nie", "Bi", "Chang", "Dian", "Duo", "Yi", "Gan", "San", "Ke", "Yan", "Dun", "Qi", "Dou", "Xiao", "Duo", "Jiao", "Jing", "Yang", "Xia", "Min", "Shu", "Ai", "Qiao", "Ai", "Zheng", "Di", "Zhen", "Fu", "Shu", "Liao", "Qu", "Xiong", "Xi", "Jiao", "Sen", "Jiao", "Zhuo", "Yi", "Lian", "Bi", "Li", "Xiao", "Xiao", "Wen", "Xue", "Qi", "Qi", "Zhai", "Bin", "Jue", "Zhai", , "Fei", "Ban", "Ban", "Lan", "Yu", "Lan", "Wei", "Dou", "Sheng", "Liao", "Jia", "Hu", "Xie", "Jia", "Yu", "Zhen", "Jiao", "Wo", "Tou", "Chu", "Jin", "Chi", "Yin", "Fu", "Qiang", "Zhan", "Qu", "Zhuo", "Zhan", "Duan", "Zhuo", "Si", "Xin", "Zhuo", "Zhuo", "Qin", "Lin", "Zhuo", "Chu", "Duan", "Zhu", "Fang", "Xie", "Hang", "Yu", "Shi", "Pei", "You", "Mye", "Pang", "Qi", "Zhan", "Mao", "Lu", "Pei", "Pi", "Liu", "Fu", "Fang", "Xuan", "Jing", "Jing", "Ni", "Zu", "Zhao", "Yi", "Liu", "Shao", "Jian", "Es", "Yi", "Qi", "Zhi", "Fan", "Piao", "Fan", "Zhan", "Guai", "Sui", "Yu", "Wu", "Ji", "Ji", "Ji", "Huo", "Ri", "Dan", "Jiu", "Zhi", "Zao", "Xie", "Tiao", "Xun", "Xu", "Xu", "Xu", "Gan", "Han", "Tai", "Di", "Xu", "Chan", "Shi", "Kuang", "Yang", "Shi", "Wang", "Min", "Min", "Tun", "Chun", "Wu"], ["Yun", "Bei", "Ang", "Ze", "Ban", "Jie", "Kun", "Sheng", "Hu", "Fang", "Hao", "Gui", "Chang", "Xuan", "Ming", "Hun", "Fen", "Qin", "Hu", "Yi", "Xi", "Xin", "Yan", "Ze", "Fang", "Tan", "Shen", "Ju", "Yang", "Zan", "Bing", "Xing", "Ying", "Xuan", "Pei", "Zhen", "Ling", "Chun", "Hao", "Mei", "Zuo", "Mo", "Bian", "Xu", "Hun", "Zhao", "Zong", "Shi", "Shi", "Yu", "Fei", "Die", "Mao", "Ni", "Chang", "Wen", "Dong", "Ai", "Bing", "Ang", "Zhou", "Long", "Xian", "Kuang", "Tiao", "Chao", "Shi", "Huang", "Huang", "Xuan", "Kui", "Xu", "Jiao", "Jin", "Zhi", "Jin", "Shang", "Tong", "Hong", "Yan", "Gai", "Xiang", "Shai", "Xiao", "Ye", "Yun", "Hui", "Han", "Han", "Jun", "Wan", "Xian", "Kun", "Zhou", "Xi", "Cheng", "Sheng", "Bu", "Zhe", "Zhe", "Wu", "Han", "Hui", "Hao", "Chen", "Wan", "Tian", "Zhuo", "Zui", "Zhou", "Pu", "Jing", "Xi", "Shan", "Yi", "Xi", "Qing", "Qi", "Jing", "Gui", "Zhen", "Yi", "Zhi", "An", "Wan", "Lin", "Liang", "Chang", "Wang", "Xiao", "Zan", "Hi", "Xuan", "Xuan", "Yi", "Xia", "Yun", "Hui", "Fu", "Min", "Kui", "He", "Ying", "Du", "Wei", "Shu", "Qing", "Mao", "Nan", "Jian", "Nuan", "An", "Yang", "Chun", "Yao", "Suo", "Jin", "Ming", "Jiao", "Kai", "Gao", "Weng", "Chang", "Qi", "Hao", "Yan", "Li", "Ai", "Ji", "Gui", "Men", "Zan", "Xie", "Hao", "Mu", "Mo", "Cong", "Ni", "Zhang", "Hui", "Bao", "Han", "Xuan", "Chuan", "Liao", "Xian", "Dan", "Jing", "Pie", "Lin", "Tun", "Xi", "Yi", "Ji", "Huang", "Tai", "Ye", "Ye", "Li", "Tan", "Tong", "Xiao", "Fei", "Qin", "Zhao", "Hao", "Yi", "Xiang", "Xing", "Sen", "Jiao", "Bao", "Jing", "Yian", "Ai", "Ye", "Ru", "Shu", "Meng", "Xun", "Yao", "Pu", "Li", "Chen", "Kuang", "Die", , "Yan", "Huo", "Lu", "Xi", "Rong", "Long", "Nang", "Luo", "Luan", "Shai", "Tang", "Yan", "Chu", "Yue", "Yue", "Qu", "Yi", "Geng", "Ye", "Hu", "He", "Shu", "Cao", "Cao", "Noboru", "Man", "Ceng", "Ceng", "Ti"], ["Zui", "Can", "Xu", "Hui", "Yin", "Qie", "Fen", "Pi", "Yue", "You", "Ruan", "Peng", "Ban", "Fu", "Ling", "Fei", "Qu", , "Nu", "Tiao", "Shuo", "Zhen", "Lang", "Lang", "Juan", "Ming", "Huang", "Wang", "Tun", "Zhao", "Ji", "Qi", "Ying", "Zong", "Wang", "Tong", "Lang", , "Meng", "Long", "Mu", "Deng", "Wei", "Mo", "Ben", "Zha", "Zhu", "Shu", , "Zhu", "Ren", "Ba", "Po", "Duo", "Duo", "Dao", "Li", "Qiu", "Ji", "Jiu", "Bi", "Xiu", "Ting", "Ci", "Sha", "Eburi", "Za", "Quan", "Qian", "Yu", "Gan", "Wu", "Cha", "Shan", "Xun", "Fan", "Wu", "Zi", "Li", "Xing", "Cai", "Cun", "Ren", "Shao", "Tuo", "Di", "Zhang", "Mang", "Chi", "Yi", "Gu", "Gong", "Du", "Yi", "Qi", "Shu", "Gang", "Tiao", "Moku", "Soma", "Tochi", "Lai", "Sugi", "Mang", "Yang", "Ma", "Miao", "Si", "Yuan", "Hang", "Fei", "Bei", "Jie", "Dong", "Gao", "Yao", "Xian", "Chu", "Qun", "Pa", "Shu", "Hua", "Xin", "Chou", "Zhu", "Chou", "Song", "Ban", "Song", "Ji", "Yue", "Jin", "Gou", "Ji", "Mao", "Pi", "Bi", "Wang", "Ang", "Fang", "Fen", "Yi", "Fu", "Nan", "Xi", "Hu", "Ya", "Dou", "Xun", "Zhen", "Yao", "Lin", "Rui", "E", "Mei", "Zhao", "Guo", "Zhi", "Cong", "Yun", "Waku", "Dou", "Shu", "Zao", , "Li", "Haze", "Jian", "Cheng", "Matsu", "Qiang", "Feng", "Nan", "Xiao", "Xian", "Ku", "Ping", "Yi", "Xi", "Zhi", "Guai", "Xiao", "Jia", "Jia", "Gou", "Fu", "Mo", "Yi", "Ye", "Ye", "Shi", "Nie", "Bi", "Duo", "Yi", "Ling", "Bing", "Ni", "La", "He", "Pan", "Fan", "Zhong", "Dai", "Ci", "Yang", "Fu", "Bo", "Mou", "Gan", "Qi", "Ran", "Rou", "Mao", "Zhao", "Song", "Zhe", "Xia", "You", "Shen", "Ju", "Tuo", "Zuo", "Nan", "Ning", "Yong", "Di", "Zhi", "Zha", "Cha", "Dan", "Gu", "Pu", "Jiu", "Ao", "Fu", "Jian", "Bo", "Duo", "Ke", "Nai", "Zhu", "Bi", "Liu", "Chai", "Zha", "Si", "Zhu", "Pei", "Shi", "Guai", "Cha", "Yao", "Jue", "Jiu", "Shi"], ["Zhi", "Liu", "Mei", "Hoy", "Rong", "Zha", , "Biao", "Zhan", "Jie", "Long", "Dong", "Lu", "Sayng", "Li", "Lan", "Yong", "Shu", "Xun", "Shuan", "Qi", "Zhen", "Qi", "Li", "Yi", "Xiang", "Zhen", "Li", "Su", "Gua", "Kan", "Bing", "Ren", "Xiao", "Bo", "Ren", "Bing", "Zi", "Chou", "Yi", "Jie", "Xu", "Zhu", "Jian", "Zui", "Er", "Er", "You", "Fa", "Gong", "Kao", "Lao", "Zhan", "Li", "Yin", "Yang", "He", "Gen", "Zhi", "Chi", "Ge", "Zai", "Luan", "Fu", "Jie", "Hang", "Gui", "Tao", "Guang", "Wei", "Kuang", "Ru", "An", "An", "Juan", "Yi", "Zhuo", "Ku", "Zhi", "Qiong", "Tong", "Sang", "Sang", "Huan", "Jie", "Jiu", "Xue", "Duo", "Zhui", "Yu", "Zan", "Kasei", "Ying", "Masu", , "Zhan", "Ya", "Nao", "Zhen", "Dang", "Qi", "Qiao", "Hua", "Kuai", "Jiang", "Zhuang", "Xun", "Suo", "Sha", "Zhen", "Bei", "Ting", "Gua", "Jing", "Bo", "Ben", "Fu", "Rui", "Tong", "Jue", "Xi", "Lang", "Liu", "Feng", "Qi", "Wen", "Jun", "Gan", "Cu", "Liang", "Qiu", "Ting", "You", "Mei", "Bang", "Long", "Peng", "Zhuang", "Di", "Xuan", "Tu", "Zao", "Ao", "Gu", "Bi", "Di", "Han", "Zi", "Zhi", "Ren", "Bei", "Geng", "Jian", "Huan", "Wan", "Nuo", "Jia", "Tiao", "Ji", "Xiao", "Lu", "Huan", "Shao", "Cen", "Fen", "Song", "Meng", "Wu", "Li", "Li", "Dou", "Cen", "Ying", "Suo", "Ju", "Ti", "Jie", "Kun", "Zhuo", "Shu", "Chan", "Fan", "Wei", "Jing", "Li", "Bing", "Fumoto", "Shikimi", "Tao", "Zhi", "Lai", "Lian", "Jian", "Zhuo", "Ling", "Li", "Qi", "Bing", "Zhun", "Cong", "Qian", "Mian", "Qi", "Qi", "Cai", "Gun", "Chan", "Te", "Fei", "Pai", "Bang", "Pou", "Hun", "Zong", "Cheng", "Zao", "Ji", "Li", "Peng", "Yu", "Yu", "Gu", "Hun", "Dong", "Tang", "Gang", "Wang", "Di", "Xi", "Fan", "Cheng", "Zhan", "Qi", "Yuan", "Yan", "Yu", "Quan", "Yi", "Sen", "Ren", "Chui", "Leng", "Qi", "Zhuo", "Fu", "Ke", "Lai", "Zou", "Zou", "Zhuo", "Guan", "Fen", "Fen", "Chen", "Qiong", "Nie"], ["Wan", "Guo", "Lu", "Hao", "Jie", "Yi", "Chou", "Ju", "Ju", "Cheng", "Zuo", "Liang", "Qiang", "Zhi", "Zhui", "Ya", "Ju", "Bei", "Jiao", "Zhuo", "Zi", "Bin", "Peng", "Ding", "Chu", "Chang", "Kunugi", "Momiji", "Jian", "Gui", "Xi", "Du", "Qian", "Kunugi", "Soko", "Shide", "Luo", "Zhi", "Ken", "Myeng", "Tafu", , "Peng", "Zhan", , "Tuo", "Sen", "Duo", "Ye", "Fou", "Wei", "Wei", "Duan", "Jia", "Zong", "Jian", "Yi", "Shen", "Xi", "Yan", "Yan", "Chuan", "Zhan", "Chun", "Yu", "He", "Zha", "Wo", "Pian", "Bi", "Yao", "Huo", "Xu", "Ruo", "Yang", "La", "Yan", "Ben", "Hun", "Kui", "Jie", "Kui", "Si", "Feng", "Xie", "Tuo", "Zhi", "Jian", "Mu", "Mao", "Chu", "Hu", "Hu", "Lian", "Leng", "Ting", "Nan", "Yu", "You", "Mei", "Song", "Xuan", "Xuan", "Ying", "Zhen", "Pian", "Ye", "Ji", "Jie", "Ye", "Chu", "Shun", "Yu", "Cou", "Wei", "Mei", "Di", "Ji", "Jie", "Kai", "Qiu", "Ying", "Rou", "Heng", "Lou", "Le", "Hazou", "Katsura", "Pin", "Muro", "Gai", "Tan", "Lan", "Yun", "Yu", "Chen", "Lu", "Ju", "Sakaki", , "Pi", "Xie", "Jia", "Yi", "Zhan", "Fu", "Nai", "Mi", "Lang", "Rong", "Gu", "Jian", "Ju", "Ta", "Yao", "Zhen", "Bang", "Sha", "Yuan", "Zi", "Ming", "Su", "Jia", "Yao", "Jie", "Huang", "Gan", "Fei", "Zha", "Qian", "Ma", "Sun", "Yuan", "Xie", "Rong", "Shi", "Zhi", "Cui", "Yun", "Ting", "Liu", "Rong", "Tang", "Que", "Zhai", "Si", "Sheng", "Ta", "Ke", "Xi", "Gu", "Qi", "Kao", "Gao", "Sun", "Pan", "Tao", "Ge", "Xun", "Dian", "Nou", "Ji", "Shuo", "Gou", "Chui", "Qiang", "Cha", "Qian", "Huai", "Mei", "Xu", "Gang", "Gao", "Zhuo", "Tuo", "Hashi", "Yang", "Dian", "Jia", "Jian", "Zui", "Kashi", "Ori", "Bin", "Zhu", , "Xi", "Qi", "Lian", "Hui", "Yong", "Qian", "Guo", "Gai", "Gai", "Tuan", "Hua", "Cu", "Sen", "Cui", "Beng", "You", "Hu", "Jiang", "Hu", "Huan", "Kui", "Yi", "Nie", "Gao", "Kang", "Gui", "Gui", "Cao", "Man", "Jin"], ["Di", "Zhuang", "Le", "Lang", "Chen", "Cong", "Li", "Xiu", "Qing", "Shuang", "Fan", "Tong", "Guan", "Ji", "Suo", "Lei", "Lu", "Liang", "Mi", "Lou", "Chao", "Su", "Ke", "Shu", "Tang", "Biao", "Lu", "Jiu", "Shu", "Zha", "Shu", "Zhang", "Men", "Mo", "Niao", "Yang", "Tiao", "Peng", "Zhu", "Sha", "Xi", "Quan", "Heng", "Jian", "Cong", , "Hokuso", "Qiang", "Tara", "Ying", "Er", "Xin", "Zhi", "Qiao", "Zui", "Cong", "Pu", "Shu", "Hua", "Kui", "Zhen", "Zun", "Yue", "Zhan", "Xi", "Xun", "Dian", "Fa", "Gan", "Mo", "Wu", "Qiao", "Nao", "Lin", "Liu", "Qiao", "Xian", "Run", "Fan", "Zhan", "Tuo", "Lao", "Yun", "Shun", "Tui", "Cheng", "Tang", "Meng", "Ju", "Cheng", "Su", "Jue", "Jue", "Tan", "Hui", "Ji", "Nuo", "Xiang", "Tuo", "Ning", "Rui", "Zhu", "Chuang", "Zeng", "Fen", "Qiong", "Ran", "Heng", "Cen", "Gu", "Liu", "Lao", "Gao", "Chu", "Zusa", "Nude", "Ca", "San", "Ji", "Dou", "Shou", "Lu", , , "Yuan", "Ta", "Shu", "Jiang", "Tan", "Lin", "Nong", "Yin", "Xi", "Sui", "Shan", "Zui", "Xuan", "Cheng", "Gan", "Ju", "Zui", "Yi", "Qin", "Pu", "Yan", "Lei", "Feng", "Hui", "Dang", "Ji", "Sui", "Bo", "Bi", "Ding", "Chu", "Zhua", "Kuai", "Ji", "Jie", "Jia", "Qing", "Zhe", "Jian", "Qiang", "Dao", "Yi", "Biao", "Song", "She", "Lin", "Kunugi", "Cha", "Meng", "Yin", "Tao", "Tai", "Mian", "Qi", "Toan", "Bin", "Huo", "Ji", "Qian", "Mi", "Ning", "Yi", "Gao", "Jian", "Yin", "Er", "Qing", "Yan", "Qi", "Mi", "Zhao", "Gui", "Chun", "Ji", "Kui", "Po", "Deng", "Chu", , "Mian", "You", "Zhi", "Guang", "Qian", "Lei", "Lei", "Sa", "Lu", "Li", "Cuan", "Lu", "Mie", "Hui", "Ou", "Lu", "Jie", "Gao", "Du", "Yuan", "Li", "Fei", "Zhuo", "Sou", "Lian", "Tamo", "Chu", , "Zhu", "Lu", "Yan", "Li", "Zhu", "Chen", "Jie", "E", "Su", "Huai", "Nie", "Yu", "Long", "Lai", , "Xian", "Kwi", "Ju", "Xiao", "Ling", "Ying", "Jian", "Yin", "You", "Ying"], ["Xiang", "Nong", "Bo", "Chan", "Lan", "Ju", "Shuang", "She", "Wei", "Cong", "Quan", "Qu", "Cang", , "Yu", "Luo", "Li", "Zan", "Luan", "Dang", "Jue", "Em", "Lan", "Lan", "Zhu", "Lei", "Li", "Ba", "Nang", "Yu", "Ling", "Tsuki", "Qian", "Ci", "Huan", "Xin", "Yu", "Yu", "Qian", "Ou", "Xu", "Chao", "Chu", "Chi", "Kai", "Yi", "Jue", "Xi", "Xu", "Xia", "Yu", "Kuai", "Lang", "Kuan", "Shuo", "Xi", "Ai", "Yi", "Qi", "Hu", "Chi", "Qin", "Kuan", "Kan", "Kuan", "Kan", "Chuan", "Sha", "Gua", "Yin", "Xin", "Xie", "Yu", "Qian", "Xiao", "Yi", "Ge", "Wu", "Tan", "Jin", "Ou", "Hu", "Ti", "Huan", "Xu", "Pen", "Xi", "Xiao", "Xu", "Xi", "Sen", "Lian", "Chu", "Yi", "Kan", "Yu", "Chuo", "Huan", "Zhi", "Zheng", "Ci", "Bu", "Wu", "Qi", "Bu", "Bu", "Wai", "Ju", "Qian", "Chi", "Se", "Chi", "Se", "Zhong", "Sui", "Sui", "Li", "Cuo", "Yu", "Li", "Gui", "Dai", "Dai", "Si", "Jian", "Zhe", "Mo", "Mo", "Yao", "Mo", "Cu", "Yang", "Tian", "Sheng", "Dai", "Shang", "Xu", "Xun", "Shu", "Can", "Jue", "Piao", "Qia", "Qiu", "Su", "Qing", "Yun", "Lian", "Yi", "Fou", "Zhi", "Ye", "Can", "Hun", "Dan", "Ji", "Ye", "Zhen", "Yun", "Wen", "Chou", "Bin", "Ti", "Jin", "Shang", "Yin", "Diao", "Cu", "Hui", "Cuan", "Yi", "Dan", "Du", "Jiang", "Lian", "Bin", "Du", "Tsukusu", "Jian", "Shu", "Ou", "Duan", "Zhu", "Yin", "Qing", "Yi", "Sha", "Que", "Ke", "Yao", "Jun", "Dian", "Hui", "Hui", "Gu", "Que", "Ji", "Yi", "Ou", "Hui", "Duan", "Yi", "Xiao", "Wu", "Guan", "Mu", "Mei", "Mei", "Ai", "Zuo", "Du", "Yu", "Bi", "Bi", "Bi", "Pi", "Pi", "Bi", "Chan", "Mao", , , "Pu", "Mushiru", "Jia", "Zhan", "Sai", "Mu", "Tuo", "Xun", "Er", "Rong", "Xian", "Ju", "Mu", "Hao", "Qiu", "Dou", "Mushiru", "Tan", "Pei", "Ju", "Duo", "Cui", "Bi", "San", , "Mao", "Sui", "Yu", "Yu", "Tuo", "He", "Jian", "Ta", "San"], ["Lu", "Mu", "Li", "Tong", "Rong", "Chang", "Pu", "Luo", "Zhan", "Sao", "Zhan", "Meng", "Luo", "Qu", "Die", "Shi", "Di", "Min", "Jue", "Mang", "Qi", "Pie", "Nai", "Qi", "Dao", "Xian", "Chuan", "Fen", "Ri", "Nei", , "Fu", "Shen", "Dong", "Qing", "Qi", "Yin", "Xi", "Hai", "Yang", "An", "Ya", "Ke", "Qing", "Ya", "Dong", "Dan", "Lu", "Qing", "Yang", "Yun", "Yun", "Shui", "San", "Zheng", "Bing", "Yong", "Dang", "Shitamizu", "Le", "Ni", "Tun", "Fan", "Gui", "Ting", "Zhi", "Qiu", "Bin", "Ze", "Mian", "Cuan", "Hui", "Diao", "Han", "Cha", "Zhuo", "Chuan", "Wan", "Fan", "Dai", "Xi", "Tuo", "Mang", "Qiu", "Qi", "Shan", "Pai", "Han", "Qian", "Wu", "Wu", "Xun", "Si", "Ru", "Gong", "Jiang", "Chi", "Wu", "Tsuchi", , "Tang", "Zhi", "Chi", "Qian", "Mi", "Yu", "Wang", "Qing", "Jing", "Rui", "Jun", "Hong", "Tai", "Quan", "Ji", "Bian", "Bian", "Gan", "Wen", "Zhong", "Fang", "Xiong", "Jue", "Hang", "Niou", "Qi", "Fen", "Xu", "Xu", "Qin", "Yi", "Wo", "Yun", "Yuan", "Hang", "Yan", "Shen", "Chen", "Dan", "You", "Dun", "Hu", "Huo", "Qie", "Mu", "Rou", "Mei", "Ta", "Mian", "Wu", "Chong", "Tian", "Bi", "Sha", "Zhi", "Pei", "Pan", "Zhui", "Za", "Gou", "Liu", "Mei", "Ze", "Feng", "Ou", "Li", "Lun", "Cang", "Feng", "Wei", "Hu", "Mo", "Mei", "Shu", "Ju", "Zan", "Tuo", "Tuo", "Tuo", "He", "Li", "Mi", "Yi", "Fa", "Fei", "You", "Tian", "Zhi", "Zhao", "Gu", "Zhan", "Yan", "Si", "Kuang", "Jiong", "Ju", "Xie", "Qiu", "Yi", "Jia", "Zhong", "Quan", "Bo", "Hui", "Mi", "Ben", "Zhuo", "Chu", "Le", "You", "Gu", "Hong", "Gan", "Fa", "Mao", "Si", "Hu", "Ping", "Ci", "Fan", "Chi", "Su", "Ning", "Cheng", "Ling", "Pao", "Bo", "Qi", "Si", "Ni", "Ju", "Yue", "Zhu", "Sheng", "Lei", "Xuan", "Xue", "Fu", "Pan", "Min", "Tai", "Yang", "Ji", "Yong", "Guan", "Beng", "Xue", "Long", "Lu", , "Bo", "Xie", "Po", "Ze", "Jing", "Yin"], ["Zhou", "Ji", "Yi", "Hui", "Hui", "Zui", "Cheng", "Yin", "Wei", "Hou", "Jian", "Yang", "Lie", "Si", "Ji", "Er", "Xing", "Fu", "Sa", "Suo", "Zhi", "Yin", "Wu", "Xi", "Kao", "Zhu", "Jiang", "Luo", , "An", "Dong", "Yi", "Mou", "Lei", "Yi", "Mi", "Quan", "Jin", "Mo", "Wei", "Xiao", "Xie", "Hong", "Xu", "Shuo", "Kuang", "Tao", "Qie", "Ju", "Er", "Zhou", "Ru", "Ping", "Xun", "Xiong", "Zhi", "Guang", "Huan", "Ming", "Huo", "Wa", "Qia", "Pai", "Wu", "Qu", "Liu", "Yi", "Jia", "Jing", "Qian", "Jiang", "Jiao", "Cheng", "Shi", "Zhuo", "Ce", "Pal", "Kuai", "Ji", "Liu", "Chan", "Hun", "Hu", "Nong", "Xun", "Jin", "Lie", "Qiu", "Wei", "Zhe", "Jun", "Han", "Bang", "Mang", "Zhuo", "You", "Xi", "Bo", "Dou", "Wan", "Hong", "Yi", "Pu", "Ying", "Lan", "Hao", "Lang", "Han", "Li", "Geng", "Fu", "Wu", "Lian", "Chun", "Feng", "Yi", "Yu", "Tong", "Lao", "Hai", "Jin", "Jia", "Chong", "Weng", "Mei", "Sui", "Cheng", "Pei", "Xian", "Shen", "Tu", "Kun", "Pin", "Nie", "Han", "Jing", "Xiao", "She", "Nian", "Tu", "Yong", "Xiao", "Xian", "Ting", "E", "Su", "Tun", "Juan", "Cen", "Ti", "Li", "Shui", "Si", "Lei", "Shui", "Tao", "Du", "Lao", "Lai", "Lian", "Wei", "Wo", "Yun", "Huan", "Di", , "Run", "Jian", "Zhang", "Se", "Fu", "Guan", "Xing", "Shou", "Shuan", "Ya", "Chuo", "Zhang", "Ye", "Kong", "Wo", "Han", "Tuo", "Dong", "He", "Wo", "Ju", "Gan", "Liang", "Hun", "Ta", "Zhuo", "Dian", "Qie", "De", "Juan", "Zi", "Xi", "Yao", "Qi", "Gu", "Guo", "Han", "Lin", "Tang", "Zhou", "Peng", "Hao", "Chang", "Shu", "Qi", "Fang", "Chi", "Lu", "Nao", "Ju", "Tao", "Cong", "Lei", "Zhi", "Peng", "Fei", "Song", "Tian", "Pi", "Dan", "Yu", "Ni", "Yu", "Lu", "Gan", "Mi", "Jing", "Ling", "Lun", "Yin", "Cui", "Qu", "Huai", "Yu", "Nian", "Shen", "Piao", "Chun", "Wa", "Yuan", "Lai", "Hun", "Qing", "Yan", "Qian", "Tian", "Miao", "Zhi", "Yin", "Mi"], ["Ben", "Yuan", "Wen", "Re", "Fei", "Qing", "Yuan", "Ke", "Ji", "She", "Yuan", "Shibui", "Lu", "Zi", "Du", , "Jian", "Min", "Pi", "Tani", "Yu", "Yuan", "Shen", "Shen", "Rou", "Huan", "Zhu", "Jian", "Nuan", "Yu", "Qiu", "Ting", "Qu", "Du", "Feng", "Zha", "Bo", "Wo", "Wo", "Di", "Wei", "Wen", "Ru", "Xie", "Ce", "Wei", "Ge", "Gang", "Yan", "Hong", "Xuan", "Mi", "Ke", "Mao", "Ying", "Yan", "You", "Hong", "Miao", "Xing", "Mei", "Zai", "Hun", "Nai", "Kui", "Shi", "E", "Pai", "Mei", "Lian", "Qi", "Qi", "Mei", "Tian", "Cou", "Wei", "Can", "Tuan", "Mian", "Hui", "Mo", "Xu", "Ji", "Pen", "Jian", "Jian", "Hu", "Feng", "Xiang", "Yi", "Yin", "Zhan", "Shi", "Jie", "Cheng", "Huang", "Tan", "Yu", "Bi", "Min", "Shi", "Tu", "Sheng", "Yong", "Qu", "Zhong", "Suei", "Jiu", "Jiao", "Qiou", "Yin", "Tang", "Long", "Huo", "Yuan", "Nan", "Ban", "You", "Quan", "Chui", "Liang", "Chan", "Yan", "Chun", "Nie", "Zi", "Wan", "Shi", "Man", "Ying", "Ratsu", "Kui", , "Jian", "Xu", "Lu", "Gui", "Gai", , , "Po", "Jin", "Gui", "Tang", "Yuan", "Suo", "Yuan", "Lian", "Yao", "Meng", "Zhun", "Sheng", "Ke", "Tai", "Da", "Wa", "Liu", "Gou", "Sao", "Ming", "Zha", "Shi", "Yi", "Lun", "Ma", "Pu", "Wei", "Li", "Cai", "Wu", "Xi", "Wen", "Qiang", "Ze", "Shi", "Su", "Yi", "Zhen", "Sou", "Yun", "Xiu", "Yin", "Rong", "Hun", "Su", "Su", "Ni", "Ta", "Shi", "Ru", "Wei", "Pan", "Chu", "Chu", "Pang", "Weng", "Cang", "Mie", "He", "Dian", "Hao", "Huang", "Xi", "Zi", "Di", "Zhi", "Ying", "Fu", "Jie", "Hua", "Ge", "Zi", "Tao", "Teng", "Sui", "Bi", "Jiao", "Hui", "Gun", "Yin", "Gao", "Long", "Zhi", "Yan", "She", "Man", "Ying", "Chun", "Lu", "Lan", "Luan", , "Bin", "Tan", "Yu", "Sou", "Hu", "Bi", "Biao", "Zhi", "Jiang", "Kou", "Shen", "Shang", "Di", "Mi", "Ao", "Lu", "Hu", "Hu", "You", "Chan", "Fan", "Yong", "Gun", "Man"], ["Qing", "Yu", "Piao", "Ji", "Ya", "Jiao", "Qi", "Xi", "Ji", "Lu", "Lu", "Long", "Jin", "Guo", "Cong", "Lou", "Zhi", "Gai", "Qiang", "Li", "Yan", "Cao", "Jiao", "Cong", "Qun", "Tuan", "Ou", "Teng", "Ye", "Xi", "Mi", "Tang", "Mo", "Shang", "Han", "Lian", "Lan", "Wa", "Li", "Qian", "Feng", "Xuan", "Yi", "Man", "Zi", "Mang", "Kang", "Lei", "Peng", "Shu", "Zhang", "Zhang", "Chong", "Xu", "Huan", "Kuo", "Jian", "Yan", "Chuang", "Liao", "Cui", "Ti", "Yang", "Jiang", "Cong", "Ying", "Hong", "Xun", "Shu", "Guan", "Ying", "Xiao", , , "Xu", "Lian", "Zhi", "Wei", "Pi", "Jue", "Jiao", "Po", "Dang", "Hui", "Jie", "Wu", "Pa", "Ji", "Pan", "Gui", "Xiao", "Qian", "Qian", "Xi", "Lu", "Xi", "Xuan", "Dun", "Huang", "Min", "Run", "Su", "Liao", "Zhen", "Zhong", "Yi", "Di", "Wan", "Dan", "Tan", "Chao", "Xun", "Kui", "Yie", "Shao", "Tu", "Zhu", "San", "Hei", "Bi", "Shan", "Chan", "Chan", "Shu", "Tong", "Pu", "Lin", "Wei", "Se", "Se", "Cheng", "Jiong", "Cheng", "Hua", "Jiao", "Lao", "Che", "Gan", "Cun", "Heng", "Si", "Shu", "Peng", "Han", "Yun", "Liu", "Hong", "Fu", "Hao", "He", "Xian", "Jian", "Shan", "Xi", "Oki", , "Lan", , "Yu", "Lin", "Min", "Zao", "Dang", "Wan", "Ze", "Xie", "Yu", "Li", "Shi", "Xue", "Ling", "Man", "Zi", "Yong", "Kuai", "Can", "Lian", "Dian", "Ye", "Ao", "Huan", "Zhen", "Chan", "Man", "Dan", "Dan", "Yi", "Sui", "Pi", "Ju", "Ta", "Qin", "Ji", "Zhuo", "Lian", "Nong", "Guo", "Jin", "Fen", "Se", "Ji", "Sui", "Hui", "Chu", "Ta", "Song", "Ding", , "Zhu", "Lai", "Bin", "Lian", "Mi", "Shi", "Shu", "Mi", "Ning", "Ying", "Ying", "Meng", "Jin", "Qi", "Pi", "Ji", "Hao", "Ru", "Zui", "Wo", "Tao", "Yin", "Yin", "Dui", "Ci", "Huo", "Jing", "Lan", "Jun", "Ai", "Pu", "Zhuo", "Wei", "Bin", "Gu", "Qian", "Xing", "Hama", "Kuo", "Fei", , "Boku", "Jian", "Wei", "Luo", "Zan", "Lu", "Li"], ["You", "Yang", "Lu", "Si", "Jie", "Ying", "Du", "Wang", "Hui", "Xie", "Pan", "Shen", "Biao", "Chan", "Mo", "Liu", "Jian", "Pu", "Se", "Cheng", "Gu", "Bin", "Huo", "Xian", "Lu", "Qin", "Han", "Ying", "Yong", "Li", "Jing", "Xiao", "Ying", "Sui", "Wei", "Xie", "Huai", "Hao", "Zhu", "Long", "Lai", "Dui", "Fan", "Hu", "Lai", , , "Ying", "Mi", "Ji", "Lian", "Jian", "Ying", "Fen", "Lin", "Yi", "Jian", "Yue", "Chan", "Dai", "Rang", "Jian", "Lan", "Fan", "Shuang", "Yuan", "Zhuo", "Feng", "She", "Lei", "Lan", "Cong", "Qu", "Yong", "Qian", "Fa", "Guan", "Que", "Yan", "Hao", "Hyeng", "Sa", "Zan", "Luan", "Yan", "Li", "Mi", "Shan", "Tan", "Dang", "Jiao", "Chan", , "Hao", "Ba", "Zhu", "Lan", "Lan", "Nang", "Wan", "Luan", "Xun", "Xian", "Yan", "Gan", "Yan", "Yu", "Huo", "Si", "Mie", "Guang", "Deng", "Hui", "Xiao", "Xiao", "Hu", "Hong", "Ling", "Zao", "Zhuan", "Jiu", "Zha", "Xie", "Chi", "Zhuo", "Zai", "Zai", "Can", "Yang", "Qi", "Zhong", "Fen", "Niu", "Jiong", "Wen", "Po", "Yi", "Lu", "Chui", "Pi", "Kai", "Pan", "Yan", "Kai", "Pang", "Mu", "Chao", "Liao", "Gui", "Kang", "Tun", "Guang", "Xin", "Zhi", "Guang", "Guang", "Wei", "Qiang", , "Da", "Xia", "Zheng", "Zhu", "Ke", "Zhao", "Fu", "Ba", "Duo", "Duo", "Ling", "Zhuo", "Xuan", "Ju", "Tan", "Pao", "Jiong", "Pao", "Tai", "Tai", "Bing", "Yang", "Tong", "Han", "Zhu", "Zha", "Dian", "Wei", "Shi", "Lian", "Chi", "Huang", , "Hu", "Shuo", "Lan", "Jing", "Jiao", "Xu", "Xing", "Quan", "Lie", "Huan", "Yang", "Xiao", "Xiu", "Xian", "Yin", "Wu", "Zhou", "Yao", "Shi", "Wei", "Tong", "Xue", "Zai", "Kai", "Hong", "Luo", "Xia", "Zhu", "Xuan", "Zheng", "Po", "Yan", "Hui", "Guang", "Zhe", "Hui", "Kao", , "Fan", "Shao", "Ye", "Hui", , "Tang", "Jin", "Re", , "Xi", "Fu", "Jiong", "Che", "Pu", "Jing", "Zhuo", "Ting", "Wan", "Hai", "Peng", "Lang", "Shan", "Hu", "Feng", "Chi", "Rong"], ["Hu", "Xi", "Shu", "He", "Xun", "Ku", "Jue", "Xiao", "Xi", "Yan", "Han", "Zhuang", "Jun", "Di", "Xie", "Ji", "Wu", , , "Han", "Yan", "Huan", "Men", "Ju", "Chou", "Bei", "Fen", "Lin", "Kun", "Hun", "Tun", "Xi", "Cui", "Wu", "Hong", "Ju", "Fu", "Wo", "Jiao", "Cong", "Feng", "Ping", "Qiong", "Ruo", "Xi", "Qiong", "Xin", "Zhuo", "Yan", "Yan", "Yi", "Jue", "Yu", "Gang", "Ran", "Pi", "Gu", , "Sheng", "Chang", "Shao", , , , , "Chen", "He", "Kui", "Zhong", "Duan", "Xia", "Hui", "Feng", "Lian", "Xuan", "Xing", "Huang", "Jiao", "Jian", "Bi", "Ying", "Zhu", "Wei", "Tuan", "Tian", "Xi", "Nuan", "Nuan", "Chan", "Yan", "Jiong", "Jiong", "Yu", "Mei", "Sha", "Wei", "Ye", "Xin", "Qiong", "Rou", "Mei", "Huan", "Xu", "Zhao", "Wei", "Fan", "Qiu", "Sui", "Yang", "Lie", "Zhu", "Jie", "Gao", "Gua", "Bao", "Hu", "Yun", "Xia", , , "Bian", "Gou", "Tui", "Tang", "Chao", "Shan", "N", "Bo", "Huang", "Xie", "Xi", "Wu", "Xi", "Yun", "He", "He", "Xi", "Yun", "Xiong", "Nai", "Shan", "Qiong", "Yao", "Xun", "Mi", "Lian", "Ying", "Wen", "Rong", "Oozutsu", , "Qiang", "Liu", "Xi", "Bi", "Biao", "Zong", "Lu", "Jian", "Shou", "Yi", "Lou", "Feng", "Sui", "Yi", "Tong", "Jue", "Zong", "Yun", "Hu", "Yi", "Zhi", "Ao", "Wei", "Liao", "Han", "Ou", "Re", "Jiong", "Man", , "Shang", "Cuan", "Zeng", "Jian", "Xi", "Xi", "Xi", "Yi", "Xiao", "Chi", "Huang", "Chan", "Ye", "Qian", "Ran", "Yan", "Xian", "Qiao", "Zun", "Deng", "Dun", "Shen", "Jiao", "Fen", "Si", "Liao", "Yu", "Lin", "Tong", "Shao", "Fen", "Fan", "Yan", "Xun", "Lan", "Mei", "Tang", "Yi", "Jing", "Men", , , "Ying", "Yu", "Yi", "Xue", "Lan", "Tai", "Zao", "Can", "Sui", "Xi", "Que", "Cong", "Lian", "Hui", "Zhu", "Xie", "Ling", "Wei", "Yi", "Xie", "Zhao", "Hui", "Tatsu", "Nung", "Lan", "Ru", "Xian", "Kao", "Xun", "Jin", "Chou", "Chou", "Yao"], ["He", "Lan", "Biao", "Rong", "Li", "Mo", "Bao", "Ruo", "Lu", "La", "Ao", "Xun", "Kuang", "Shuo", , "Li", "Lu", "Jue", "Liao", "Yan", "Xi", "Xie", "Long", "Ye", , "Rang", "Yue", "Lan", "Cong", "Jue", "Tong", "Guan", , "Che", "Mi", "Tang", "Lan", "Zhu", , "Ling", "Cuan", "Yu", "Zhua", "Tsumekanmuri", "Pa", "Zheng", "Pao", "Cheng", "Yuan", "Ai", "Wei", , "Jue", "Jue", "Fu", "Ye", "Ba", "Die", "Ye", "Yao", "Zu", "Shuang", "Er", "Qiang", "Chuang", "Ge", "Zang", "Die", "Qiang", "Yong", "Qiang", "Pian", "Ban", "Pan", "Shao", "Jian", "Pai", "Du", "Chuang", "Tou", "Zha", "Bian", "Die", "Bang", "Bo", "Chuang", "You", , "Du", "Ya", "Cheng", "Niu", "Ushihen", "Pin", "Jiu", "Mou", "Tuo", "Mu", "Lao", "Ren", "Mang", "Fang", "Mao", "Mu", "Gang", "Wu", "Yan", "Ge", "Bei", "Si", "Jian", "Gu", "You", "Ge", "Sheng", "Mu", "Di", "Qian", "Quan", "Quan", "Zi", "Te", "Xi", "Mang", "Keng", "Qian", "Wu", "Gu", "Xi", "Li", "Li", "Pou", "Ji", "Gang", "Zhi", "Ben", "Quan", "Run", "Du", "Ju", "Jia", "Jian", "Feng", "Pian", "Ke", "Ju", "Kao", "Chu", "Xi", "Bei", "Luo", "Jie", "Ma", "San", "Wei", "Li", "Dun", "Tong", , "Jiang", "Ikenie", "Li", "Du", "Lie", "Pi", "Piao", "Bao", "Xi", "Chou", "Wei", "Kui", "Chou", "Quan", "Fan", "Ba", "Fan", "Qiu", "Ji", "Cai", "Chuo", "An", "Jie", "Zhuang", "Guang", "Ma", "You", "Kang", "Bo", "Hou", "Ya", "Yin", "Huan", "Zhuang", "Yun", "Kuang", "Niu", "Di", "Qing", "Zhong", "Mu", "Bei", "Pi", "Ju", "Ni", "Sheng", "Pao", "Xia", "Tuo", "Hu", "Ling", "Fei", "Pi", "Ni", "Ao", "You", "Gou", "Yue", "Ju", "Dan", "Po", "Gu", "Xian", "Ning", "Huan", "Hen", "Jiao", "He", "Zhao", "Ji", "Xun", "Shan", "Ta", "Rong", "Shou", "Tong", "Lao", "Du", "Xia", "Shi", "Hua", "Zheng", "Yu", "Sun", "Yu", "Bi", "Mang", "Xi", "Juan", "Li", "Xia", "Yin", "Suan", "Lang", "Bei", "Zhi", "Yan"], ["Sha", "Li", "Han", "Xian", "Jing", "Pai", "Fei", "Yao", "Ba", "Qi", "Ni", "Biao", "Yin", "Lai", "Xi", "Jian", "Qiang", "Kun", "Yan", "Guo", "Zong", "Mi", "Chang", "Yi", "Zhi", "Zheng", "Ya", "Meng", "Cai", "Cu", "She", "Kari", "Cen", "Luo", "Hu", "Zong", "Ji", "Wei", "Feng", "Wo", "Yuan", "Xing", "Zhu", "Mao", "Wei", "Yuan", "Xian", "Tuan", "Ya", "Nao", "Xie", "Jia", "Hou", "Bian", "You", "You", "Mei", "Zha", "Yao", "Sun", "Bo", "Ming", "Hua", "Yuan", "Sou", "Ma", "Yuan", "Dai", "Yu", "Shi", "Hao", , "Yi", "Zhen", "Chuang", "Hao", "Man", "Jing", "Jiang", "Mu", "Zhang", "Chan", "Ao", "Ao", "Hao", "Cui", "Fen", "Jue", "Bi", "Bi", "Huang", "Pu", "Lin", "Yu", "Tong", "Yao", "Liao", "Shuo", "Xiao", "Swu", "Ton", "Xi", "Ge", "Juan", "Du", "Hui", "Kuai", "Xian", "Xie", "Ta", "Xian", "Xun", "Ning", "Pin", "Huo", "Nou", "Meng", "Lie", "Nao", "Guang", "Shou", "Lu", "Ta", "Xian", "Mi", "Rang", "Huan", "Nao", "Luo", "Xian", "Qi", "Jue", "Xuan", "Miao", "Zi", "Lu", "Lu", "Yu", "Su", "Wang", "Qiu", "Ga", "Ding", "Le", "Ba", "Ji", "Hong", "Di", "Quan", "Gan", "Jiu", "Yu", "Ji", "Yu", "Yang", "Ma", "Gong", "Wu", "Fu", "Wen", "Jie", "Ya", "Fen", "Bian", "Beng", "Yue", "Jue", "Yun", "Jue", "Wan", "Jian", "Mei", "Dan", "Pi", "Wei", "Huan", "Xian", "Qiang", "Ling", "Dai", "Yi", "An", "Ping", "Dian", "Fu", "Xuan", "Xi", "Bo", "Ci", "Gou", "Jia", "Shao", "Po", "Ci", "Ke", "Ran", "Sheng", "Shen", "Yi", "Zu", "Jia", "Min", "Shan", "Liu", "Bi", "Zhen", "Zhen", "Jue", "Fa", "Long", "Jin", "Jiao", "Jian", "Li", "Guang", "Xian", "Zhou", "Gong", "Yan", "Xiu", "Yang", "Xu", "Luo", "Su", "Zhu", "Qin", "Ken", "Xun", "Bao", "Er", "Xiang", "Yao", "Xia", "Heng", "Gui", "Chong", "Xu", "Ban", "Pei", , "Dang", "Ei", "Hun", "Wen", "E", "Cheng", "Ti", "Wu", "Wu", "Cheng", "Jun", "Mei", "Bei", "Ting", "Xian", "Chuo"], ["Han", "Xuan", "Yan", "Qiu", "Quan", "Lang", "Li", "Xiu", "Fu", "Liu", "Ye", "Xi", "Ling", "Li", "Jin", "Lian", "Suo", "Chiisai", , "Wan", "Dian", "Pin", "Zhan", "Cui", "Min", "Yu", "Ju", "Chen", "Lai", "Wen", "Sheng", "Wei", "Dian", "Chu", "Zhuo", "Pei", "Cheng", "Hu", "Qi", "E", "Kun", "Chang", "Qi", "Beng", "Wan", "Lu", "Cong", "Guan", "Yan", "Diao", "Bei", "Lin", "Qin", "Pi", "Pa", "Que", "Zhuo", "Qin", "Fa", , "Qiong", "Du", "Jie", "Hun", "Yu", "Mao", "Mei", "Chun", "Xuan", "Ti", "Xing", "Dai", "Rou", "Min", "Zhen", "Wei", "Ruan", "Huan", "Jie", "Chuan", "Jian", "Zhuan", "Yang", "Lian", "Quan", "Xia", "Duan", "Yuan", "Ye", "Nao", "Hu", "Ying", "Yu", "Huang", "Rui", "Se", "Liu", "Shi", "Rong", "Suo", "Yao", "Wen", "Wu", "Jin", "Jin", "Ying", "Ma", "Tao", "Liu", "Tang", "Li", "Lang", "Gui", "Zhen", "Qiang", "Cuo", "Jue", "Zhao", "Yao", "Ai", "Bin", "Tu", "Chang", "Kun", "Zhuan", "Cong", "Jin", "Yi", "Cui", "Cong", "Qi", "Li", "Ying", "Suo", "Qiu", "Xuan", "Ao", "Lian", "Man", "Zhang", "Yin", , "Ying", "Zhi", "Lu", "Wu", "Deng", "Xiou", "Zeng", "Xun", "Qu", "Dang", "Lin", "Liao", "Qiong", "Su", "Huang", "Gui", "Pu", "Jing", "Fan", "Jin", "Liu", "Ji", , "Jing", "Ai", "Bi", "Can", "Qu", "Zao", "Dang", "Jiao", "Gun", "Tan", "Hui", "Huan", "Se", "Sui", "Tian", , "Yu", "Jin", "Lu", "Bin", "Shou", "Wen", "Zui", "Lan", "Xi", "Ji", "Xuan", "Ruan", "Huo", "Gai", "Lei", "Du", "Li", "Zhi", "Rou", "Li", "Zan", "Qiong", "Zhe", "Gui", "Sui", "La", "Long", "Lu", "Li", "Zan", "Lan", "Ying", "Mi", "Xiang", "Xi", "Guan", "Dao", "Zan", "Huan", "Gua", "Bo", "Die", "Bao", "Hu", "Zhi", "Piao", "Ban", "Rang", "Li", "Wa", "Dekaguramu", "Jiang", "Qian", "Fan", "Pen", "Fang", "Dan", "Weng", "Ou", "Deshiguramu", "Miriguramu", "Thon", "Hu", "Ling", "Yi", "Ping", "Ci", "Hekutogura", "Juan", "Chang", "Chi", "Sarake", "Dang", "Meng", "Pou"], ["Zhui", "Ping", "Bian", "Zhou", "Zhen", "Senchigura", "Ci", "Ying", "Qi", "Xian", "Lou", "Di", "Ou", "Meng", "Zhuan", "Peng", "Lin", "Zeng", "Wu", "Pi", "Dan", "Weng", "Ying", "Yan", "Gan", "Dai", "Shen", "Tian", "Tian", "Han", "Chang", "Sheng", "Qing", "Sheng", "Chan", "Chan", "Rui", "Sheng", "Su", "Sen", "Yong", "Shuai", "Lu", "Fu", "Yong", "Beng", "Feng", "Ning", "Tian", "You", "Jia", "Shen", "Zha", "Dian", "Fu", "Nan", "Dian", "Ping", "Ting", "Hua", "Ting", "Quan", "Zi", "Meng", "Bi", "Qi", "Liu", "Xun", "Liu", "Chang", "Mu", "Yun", "Fan", "Fu", "Geng", "Tian", "Jie", "Jie", "Quan", "Wei", "Fu", "Tian", "Mu", "Tap", "Pan", "Jiang", "Wa", "Da", "Nan", "Liu", "Ben", "Zhen", "Chu", "Mu", "Mu", "Ce", "Cen", "Gai", "Bi", "Da", "Zhi", "Lue", "Qi", "Lue", "Pan", "Kesa", "Fan", "Hua", "Yu", "Yu", "Mu", "Jun", "Yi", "Liu", "Yu", "Die", "Chou", "Hua", "Dang", "Chuo", "Ji", "Wan", "Jiang", "Sheng", "Chang", "Tuan", "Lei", "Ji", "Cha", "Liu", "Tatamu", "Tuan", "Lin", "Jiang", "Jiang", "Chou", "Bo", "Die", "Die", "Pi", "Nie", "Dan", "Shu", "Shu", "Zhi", "Yi", "Chuang", "Nai", "Ding", "Bi", "Jie", "Liao", "Gong", "Ge", "Jiu", "Zhou", "Xia", "Shan", "Xu", "Nue", "Li", "Yang", "Chen", "You", "Ba", "Jie", "Jue", "Zhi", "Xia", "Cui", "Bi", "Yi", "Li", "Zong", "Chuang", "Feng", "Zhu", "Pao", "Pi", "Gan", "Ke", "Ci", "Xie", "Qi", "Dan", "Zhen", "Fa", "Zhi", "Teng", "Ju", "Ji", "Fei", "Qu", "Dian", "Jia", "Xian", "Cha", "Bing", "Ni", "Zheng", "Yong", "Jing", "Quan", "Chong", "Tong", "Yi", "Kai", "Wei", "Hui", "Duo", "Yang", "Chi", "Zhi", "Hen", "Ya", "Mei", "Dou", "Jing", "Xiao", "Tong", "Tu", "Mang", "Pi", "Xiao", "Suan", "Pu", "Li", "Zhi", "Cuo", "Duo", "Wu", "Sha", "Lao", "Shou", "Huan", "Xian", "Yi", "Peng", "Zhang", "Guan", "Tan", "Fei", "Ma", "Lin", "Chi", "Ji", "Dian", "An", "Chi", "Bi", "Bei", "Min", "Gu", "Dui", "E", "Wei"], ["Yu", "Cui", "Ya", "Zhu", "Cu", "Dan", "Shen", "Zhung", "Ji", "Yu", "Hou", "Feng", "La", "Yang", "Shen", "Tu", "Yu", "Gua", "Wen", "Huan", "Ku", "Jia", "Yin", "Yi", "Lu", "Sao", "Jue", "Chi", "Xi", "Guan", "Yi", "Wen", "Ji", "Chuang", "Ban", "Lei", "Liu", "Chai", "Shou", "Nue", "Dian", "Da", "Pie", "Tan", "Zhang", "Biao", "Shen", "Cu", "Luo", "Yi", "Zong", "Chou", "Zhang", "Zhai", "Sou", "Suo", "Que", "Diao", "Lou", "Lu", "Mo", "Jin", "Yin", "Ying", "Huang", "Fu", "Liao", "Long", "Qiao", "Liu", "Lao", "Xian", "Fei", "Dan", "Yin", "He", "Ai", "Ban", "Xian", "Guan", "Guai", "Nong", "Yu", "Wei", "Yi", "Yong", "Pi", "Lei", "Li", "Shu", "Dan", "Lin", "Dian", "Lin", "Lai", "Pie", "Ji", "Chi", "Yang", "Xian", "Jie", "Zheng", , "Li", "Huo", "Lai", "Shaku", "Dian", "Xian", "Ying", "Yin", "Qu", "Yong", "Tan", "Dian", "Luo", "Luan", "Luan", "Bo", , "Gui", "Po", "Fa", "Deng", "Fa", "Bai", "Bai", "Qie", "Bi", "Zao", "Zao", "Mao", "De", "Pa", "Jie", "Huang", "Gui", "Ci", "Ling", "Gao", "Mo", "Ji", "Jiao", "Peng", "Gao", "Ai", "E", "Hao", "Han", "Bi", "Wan", "Chou", "Qian", "Xi", "Ai", "Jiong", "Hao", "Huang", "Hao", "Ze", "Cui", "Hao", "Xiao", "Ye", "Po", "Hao", "Jiao", "Ai", "Xing", "Huang", "Li", "Piao", "He", "Jiao", "Pi", "Gan", "Pao", "Zhou", "Jun", "Qiu", "Cun", "Que", "Zha", "Gu", "Jun", "Jun", "Zhou", "Zha", "Gu", "Zhan", "Du", "Min", "Qi", "Ying", "Yu", "Bei", "Zhao", "Zhong", "Pen", "He", "Ying", "He", "Yi", "Bo", "Wan", "He", "Ang", "Zhan", "Yan", "Jian", "He", "Yu", "Kui", "Fan", "Gai", "Dao", "Pan", "Fu", "Qiu", "Sheng", "Dao", "Lu", "Zhan", "Meng", "Li", "Jin", "Xu", "Jian", "Pan", "Guan", "An", "Lu", "Shu", "Zhou", "Dang", "An", "Gu", "Li", "Mu", "Cheng", "Gan", "Xu", "Mang", "Mang", "Zhi", "Qi", "Ruan", "Tian", "Xiang", "Dun", "Xin", "Xi", "Pan", "Feng", "Dun", "Min"], ["Ming", "Sheng", "Shi", "Yun", "Mian", "Pan", "Fang", "Miao", "Dan", "Mei", "Mao", "Kan", "Xian", "Ou", "Shi", "Yang", "Zheng", "Yao", "Shen", "Huo", "Da", "Zhen", "Kuang", "Ju", "Shen", "Chi", "Sheng", "Mei", "Mo", "Zhu", "Zhen", "Zhen", "Mian", "Di", "Yuan", "Die", "Yi", "Zi", "Zi", "Chao", "Zha", "Xuan", "Bing", "Mi", "Long", "Sui", "Dong", "Mi", "Die", "Yi", "Er", "Ming", "Xuan", "Chi", "Kuang", "Juan", "Mou", "Zhen", "Tiao", "Yang", "Yan", "Mo", "Zhong", "Mai", "Zhao", "Zheng", "Mei", "Jun", "Shao", "Han", "Huan", "Di", "Cheng", "Cuo", "Juan", "E", "Wan", "Xian", "Xi", "Kun", "Lai", "Jian", "Shan", "Tian", "Hun", "Wan", "Ling", "Shi", "Qiong", "Lie", "Yai", "Jing", "Zheng", "Li", "Lai", "Sui", "Juan", "Shui", "Sui", "Du", "Bi", "Bi", "Mu", "Hun", "Ni", "Lu", "Yi", "Jie", "Cai", "Zhou", "Yu", "Hun", "Ma", "Xia", "Xing", "Xi", "Gun", "Cai", "Chun", "Jian", "Mei", "Du", "Hou", "Xuan", "Ti", "Kui", "Gao", "Rui", "Mou", "Xu", "Fa", "Wen", "Miao", "Chou", "Kui", "Mi", "Weng", "Kou", "Dang", "Chen", "Ke", "Sou", "Xia", "Qiong", "Mao", "Ming", "Man", "Shui", "Ze", "Zhang", "Yi", "Diao", "Ou", "Mo", "Shun", "Cong", "Lou", "Chi", "Man", "Piao", "Cheng", "Ji", "Meng", , "Run", "Pie", "Xi", "Qiao", "Pu", "Zhu", "Deng", "Shen", "Shun", "Liao", "Che", "Xian", "Kan", "Ye", "Xu", "Tong", "Mou", "Lin", "Kui", "Xian", "Ye", "Ai", "Hui", "Zhan", "Jian", "Gu", "Zhao", "Qu", "Wei", "Chou", "Sao", "Ning", "Xun", "Yao", "Huo", "Meng", "Mian", "Bin", "Mian", "Li", "Kuang", "Jue", "Xuan", "Mian", "Huo", "Lu", "Meng", "Long", "Guan", "Man", "Xi", "Chu", "Tang", "Kan", "Zhu", "Mao", "Jin", "Lin", "Yu", "Shuo", "Ce", "Jue", "Shi", "Yi", "Shen", "Zhi", "Hou", "Shen", "Ying", "Ju", "Zhou", "Jiao", "Cuo", "Duan", "Ai", "Jiao", "Zeng", "Huo", "Bai", "Shi", "Ding", "Qi", "Ji", "Zi", "Gan", "Wu", "Tuo", "Ku", "Qiang", "Xi", "Fan", "Kuang"], ["Dang", "Ma", "Sha", "Dan", "Jue", "Li", "Fu", "Min", "Nuo", "Huo", "Kang", "Zhi", "Qi", "Kan", "Jie", "Fen", "E", "Ya", "Pi", "Zhe", "Yan", "Sui", "Zhuan", "Che", "Dun", "Pan", "Yan", , "Feng", "Fa", "Mo", "Zha", "Qu", "Yu", "Luo", "Tuo", "Tuo", "Di", "Zhai", "Zhen", "Ai", "Fei", "Mu", "Zhu", "Li", "Bian", "Nu", "Ping", "Peng", "Ling", "Pao", "Le", "Po", "Bo", "Po", "Shen", "Za", "Nuo", "Li", "Long", "Tong", , "Li", "Aragane", "Chu", "Keng", "Quan", "Zhu", "Kuang", "Huo", "E", "Nao", "Jia", "Lu", "Wei", "Ai", "Luo", "Ken", "Xing", "Yan", "Tong", "Peng", "Xi", , "Hong", "Shuo", "Xia", "Qiao", , "Wei", "Qiao", , "Keng", "Xiao", "Que", "Chan", "Lang", "Hong", "Yu", "Xiao", "Xia", "Mang", "Long", "Iong", "Che", "Che", "E", "Liu", "Ying", "Mang", "Que", "Yan", "Sha", "Kun", "Yu", , "Kaki", "Lu", "Chen", "Jian", "Nue", "Song", "Zhuo", "Keng", "Peng", "Yan", "Zhui", "Kong", "Ceng", "Qi", "Zong", "Qing", "Lin", "Jun", "Bo", "Ding", "Min", "Diao", "Jian", "He", "Lu", "Ai", "Sui", "Que", "Ling", "Bei", "Yin", "Dui", "Wu", "Qi", "Lun", "Wan", "Dian", "Gang", "Pei", "Qi", "Chen", "Ruan", "Yan", "Die", "Ding", "Du", "Tuo", "Jie", "Ying", "Bian", "Ke", "Bi", "Wei", "Shuo", "Zhen", "Duan", "Xia", "Dang", "Ti", "Nao", "Peng", "Jian", "Di", "Tan", "Cha", "Seki", "Qi", , "Feng", "Xuan", "Que", "Que", "Ma", "Gong", "Nian", "Su", "E", "Ci", "Liu", "Si", "Tang", "Bang", "Hua", "Pi", "Wei", "Sang", "Lei", "Cuo", "Zhen", "Xia", "Qi", "Lian", "Pan", "Wei", "Yun", "Dui", "Zhe", "Ke", "La", , "Qing", "Gun", "Zhuan", "Chan", "Qi", "Ao", "Peng", "Lu", "Lu", "Kan", "Qiang", "Chen", "Yin", "Lei", "Biao", "Qi", "Mo", "Qi", "Cui", "Zong", "Qing", "Chuo", , "Ji", "Shan", "Lao", "Qu", "Zeng", "Deng", "Jian", "Xi", "Lin", "Ding", "Dian", "Huang", "Pan", "Za", "Qiao", "Di", "Li"], ["Tani", "Jiao", , "Zhang", "Qiao", "Dun", "Xian", "Yu", "Zhui", "He", "Huo", "Zhai", "Lei", "Ke", "Chu", "Ji", "Que", "Dang", "Yi", "Jiang", "Pi", "Pi", "Yu", "Pin", "Qi", "Ai", "Kai", "Jian", "Yu", "Ruan", "Meng", "Pao", "Ci", , , "Mie", "Ca", "Xian", "Kuang", "Lei", "Lei", "Zhi", "Li", "Li", "Fan", "Que", "Pao", "Ying", "Li", "Long", "Long", "Mo", "Bo", "Shuang", "Guan", "Lan", "Zan", "Yan", "Shi", "Shi", "Li", "Reng", "She", "Yue", "Si", "Qi", "Ta", "Ma", "Xie", "Xian", "Xian", "Zhi", "Qi", "Zhi", "Beng", "Dui", "Zhong", , "Yi", "Shi", "You", "Zhi", "Tiao", "Fu", "Fu", "Mi", "Zu", "Zhi", "Suan", "Mei", "Zuo", "Qu", "Hu", "Zhu", "Shen", "Sui", "Ci", "Chai", "Mi", "Lu", "Yu", "Xiang", "Wu", "Tiao", "Piao", "Zhu", "Gui", "Xia", "Zhi", "Ji", "Gao", "Zhen", "Gao", "Shui", "Jin", "Chen", "Gai", "Kun", "Di", "Dao", "Huo", "Tao", "Qi", "Gu", "Guan", "Zui", "Ling", "Lu", "Bing", "Jin", "Dao", "Zhi", "Lu", "Shan", "Bei", "Zhe", "Hui", "You", "Xi", "Yin", "Zi", "Huo", "Zhen", "Fu", "Yuan", "Wu", "Xian", "Yang", "Ti", "Yi", "Mei", "Si", "Di", , "Zhuo", "Zhen", "Yong", "Ji", "Gao", "Tang", "Si", "Ma", "Ta", , "Xuan", "Qi", "Yu", "Xi", "Ji", "Si", "Chan", "Tan", "Kuai", "Sui", "Li", "Nong", "Ni", "Dao", "Li", "Rang", "Yue", "Ti", "Zan", "Lei", "Rou", "Yu", "Yu", "Chi", "Xie", "Qin", "He", "Tu", "Xiu", "Si", "Ren", "Tu", "Zi", "Cha", "Gan", "Yi", "Xian", "Bing", "Nian", "Qiu", "Qiu", "Zhong", "Fen", "Hao", "Yun", "Ke", "Miao", "Zhi", "Geng", "Bi", "Zhi", "Yu", "Mi", "Ku", "Ban", "Pi", "Ni", "Li", "You", "Zu", "Pi", "Ba", "Ling", "Mo", "Cheng", "Nian", "Qin", "Yang", "Zuo", "Zhi", "Zhi", "Shu", "Ju", "Zi", "Huo", "Ji", "Cheng", "Tong", "Zhi", "Huo", "He", "Yin", "Zi", "Zhi", "Jie", "Ren", "Du", "Yi", "Zhu", "Hui", "Nong", "Fu"], ["Xi", "Kao", "Lang", "Fu", "Ze", "Shui", "Lu", "Kun", "Gan", "Geng", "Ti", "Cheng", "Tu", "Shao", "Shui", "Ya", "Lun", "Lu", "Gu", "Zuo", "Ren", "Zhun", "Bang", "Bai", "Ji", "Zhi", "Zhi", "Kun", "Leng", "Peng", "Ke", "Bing", "Chou", "Zu", "Yu", "Su", "Lue", , "Yi", "Xi", "Bian", "Ji", "Fu", "Bi", "Nuo", "Jie", "Zhong", "Zong", "Xu", "Cheng", "Dao", "Wen", "Lian", "Zi", "Yu", "Ji", "Xu", "Zhen", "Zhi", "Dao", "Jia", "Ji", "Gao", "Gao", "Gu", "Rong", "Sui", "You", "Ji", "Kang", "Mu", "Shan", "Men", "Zhi", "Ji", "Lu", "Su", "Ji", "Ying", "Wen", "Qiu", "Se", , "Yi", "Huang", "Qie", "Ji", "Sui", "Xiao", "Pu", "Jiao", "Zhuo", "Tong", "Sai", "Lu", "Sui", "Nong", "Se", "Hui", "Rang", "Nuo", "Yu", "Bin", "Ji", "Tui", "Wen", "Cheng", "Huo", "Gong", "Lu", "Biao", , "Rang", "Zhuo", "Li", "Zan", "Xue", "Wa", "Jiu", "Qiong", "Xi", "Qiong", "Kong", "Yu", "Sen", "Jing", "Yao", "Chuan", "Zhun", "Tu", "Lao", "Qie", "Zhai", "Yao", "Bian", "Bao", "Yao", "Bing", "Wa", "Zhu", "Jiao", "Qiao", "Diao", "Wu", "Gui", "Yao", "Zhi", "Chuang", "Yao", "Tiao", "Jiao", "Chuang", "Jiong", "Xiao", "Cheng", "Kou", "Cuan", "Wo", "Dan", "Ku", "Ke", "Zhui", "Xu", "Su", "Guan", "Kui", "Dou", , "Yin", "Wo", "Wa", "Ya", "Yu", "Ju", "Qiong", "Yao", "Yao", "Tiao", "Chao", "Yu", "Tian", "Diao", "Ju", "Liao", "Xi", "Wu", "Kui", "Chuang", "Zhao", , "Kuan", "Long", "Cheng", "Cui", "Piao", "Zao", "Cuan", "Qiao", "Qiong", "Dou", "Zao", "Long", "Qie", "Li", "Chu", "Shi", "Fou", "Qian", "Chu", "Hong", "Qi", "Qian", "Gong", "Shi", "Shu", "Miao", "Ju", "Zhan", "Zhu", "Ling", "Long", "Bing", "Jing", "Jing", "Zhang", "Yi", "Si", "Jun", "Hong", "Tong", "Song", "Jing", "Diao", "Yi", "Shu", "Jing", "Qu", "Jie", "Ping", "Duan", "Shao", "Zhuan", "Ceng", "Deng", "Cui", "Huai", "Jing", "Kan", "Jing", "Zhu", "Zhu", "Le", "Peng", "Yu", "Chi", "Gan"], ["Mang", "Zhu", "Utsubo", "Du", "Ji", "Xiao", "Ba", "Suan", "Ji", "Zhen", "Zhao", "Sun", "Ya", "Zhui", "Yuan", "Hu", "Gang", "Xiao", "Cen", "Pi", "Bi", "Jian", "Yi", "Dong", "Shan", "Sheng", "Xia", "Di", "Zhu", "Na", "Chi", "Gu", "Li", "Qie", "Min", "Bao", "Tiao", "Si", "Fu", "Ce", "Ben", "Pei", "Da", "Zi", "Di", "Ling", "Ze", "Nu", "Fu", "Gou", "Fan", "Jia", "Ge", "Fan", "Shi", "Mao", "Po", "Sey", "Jian", "Qiong", "Long", "Souke", "Bian", "Luo", "Gui", "Qu", "Chi", "Yin", "Yao", "Xian", "Bi", "Qiong", "Gua", "Deng", "Jiao", "Jin", "Quan", "Sun", "Ru", "Fa", "Kuang", "Zhu", "Tong", "Ji", "Da", "Xing", "Ce", "Zhong", "Kou", "Lai", "Bi", "Shai", "Dang", "Zheng", "Ce", "Fu", "Yun", "Tu", "Pa", "Li", "Lang", "Ju", "Guan", "Jian", "Han", "Tong", "Xia", "Zhi", "Cheng", "Suan", "Shi", "Zhu", "Zuo", "Xiao", "Shao", "Ting", "Ce", "Yan", "Gao", "Kuai", "Gan", "Chou", "Kago", "Gang", "Yun", "O", "Qian", "Xiao", "Jian", "Pu", "Lai", "Zou", "Bi", "Bi", "Bi", "Ge", "Chi", "Guai", "Yu", "Jian", "Zhao", "Gu", "Chi", "Zheng", "Jing", "Sha", "Zhou", "Lu", "Bo", "Ji", "Lin", "Suan", "Jun", "Fu", "Zha", "Gu", "Kong", "Qian", "Quan", "Jun", "Chui", "Guan", "Yuan", "Ce", "Ju", "Bo", "Ze", "Qie", "Tuo", "Luo", "Dan", "Xiao", "Ruo", "Jian", "Xuan", "Bian", "Sun", "Xiang", "Xian", "Ping", "Zhen", "Sheng", "Hu", "Shi", "Zhu", "Yue", "Chun", "Lu", "Wu", "Dong", "Xiao", "Ji", "Jie", "Huang", "Xing", "Mei", "Fan", "Chui", "Zhuan", "Pian", "Feng", "Zhu", "Hong", "Qie", "Hou", "Qiu", "Miao", "Qian", , "Kui", "Sik", "Lou", "Yun", "He", "Tang", "Yue", "Chou", "Gao", "Fei", "Ruo", "Zheng", "Gou", "Nie", "Qian", "Xiao", "Cuan", "Gong", "Pang", "Du", "Li", "Bi", "Zhuo", "Chu", "Shai", "Chi", "Zhu", "Qiang", "Long", "Lan", "Jian", "Bu", "Li", "Hui", "Bi", "Di", "Cong", "Yan", "Peng", "Sen", "Zhuan", "Pai", "Piao", "Dou", "Yu", "Mie", "Zhuan"], ["Ze", "Xi", "Guo", "Yi", "Hu", "Chan", "Kou", "Cu", "Ping", "Chou", "Ji", "Gui", "Su", "Lou", "Zha", "Lu", "Nian", "Suo", "Cuan", "Sasara", "Suo", "Le", "Duan", "Yana", "Xiao", "Bo", "Mi", "Si", "Dang", "Liao", "Dan", "Dian", "Fu", "Jian", "Min", "Kui", "Dai", "Qiao", "Deng", "Huang", "Sun", "Lao", "Zan", "Xiao", "Du", "Shi", "Zan", , "Pai", "Hata", "Pai", "Gan", "Ju", "Du", "Lu", "Yan", "Bo", "Dang", "Sai", "Ke", "Long", "Qian", "Lian", "Bo", "Zhou", "Lai", , "Lan", "Kui", "Yu", "Yue", "Hao", "Zhen", "Tai", "Ti", "Mi", "Chou", "Ji", , "Hata", "Teng", "Zhuan", "Zhou", "Fan", "Sou", "Zhou", "Kuji", "Zhuo", "Teng", "Lu", "Lu", "Jian", "Tuo", "Ying", "Yu", "Lai", "Long", "Shinshi", "Lian", "Lan", "Qian", "Yue", "Zhong", "Qu", "Lian", "Bian", "Duan", "Zuan", "Li", "Si", "Luo", "Ying", "Yue", "Zhuo", "Xu", "Mi", "Di", "Fan", "Shen", "Zhe", "Shen", "Nu", "Xie", "Lei", "Xian", "Zi", "Ni", "Cun", , "Qian", "Kume", "Bi", "Ban", "Wu", "Sha", "Kang", "Rou", "Fen", "Bi", "Cui", , "Li", "Chi", "Nukamiso", "Ro", "Ba", "Li", "Gan", "Ju", "Po", "Mo", "Cu", "Nian", "Zhou", "Li", "Su", "Tiao", "Li", "Qi", "Su", "Hong", "Tong", "Zi", "Ce", "Yue", "Zhou", "Lin", "Zhuang", "Bai", , "Fen", "Ji", , "Sukumo", "Liang", "Xian", "Fu", "Liang", "Can", "Geng", "Li", "Yue", "Lu", "Ju", "Qi", "Cui", "Bai", "Zhang", "Lin", "Zong", "Jing", "Guo", "Kouji", "San", "San", "Tang", "Bian", "Rou", "Mian", "Hou", "Xu", "Zong", "Hu", "Jian", "Zan", "Ci", "Li", "Xie", "Fu", "Ni", "Bei", "Gu", "Xiu", "Gao", "Tang", "Qiu", "Sukumo", "Cao", "Zhuang", "Tang", "Mi", "San", "Fen", "Zao", "Kang", "Jiang", "Mo", "San", "San", "Nuo", "Xi", "Liang", "Jiang", "Kuai", "Bo", "Huan", , "Zong", "Xian", "Nuo", "Tuan", "Nie", "Li", "Zuo", "Di", "Nie", "Tiao", "Lan", "Mi", "Jiao", "Jiu", "Xi", "Gong", "Zheng", "Jiu", "You"], ["Ji", "Cha", "Zhou", "Xun", "Yue", "Hong", "Yu", "He", "Wan", "Ren", "Wen", "Wen", "Qiu", "Na", "Zi", "Tou", "Niu", "Fou", "Jie", "Shu", "Chun", "Pi", "Yin", "Sha", "Hong", "Zhi", "Ji", "Fen", "Yun", "Ren", "Dan", "Jin", "Su", "Fang", "Suo", "Cui", "Jiu", "Zha", "Kinu", "Jin", "Fu", "Zhi", "Ci", "Zi", "Chou", "Hong", "Zha", "Lei", "Xi", "Fu", "Xie", "Shen", "Bei", "Zhu", "Qu", "Ling", "Zhu", "Shao", "Gan", "Yang", "Fu", "Tuo", "Zhen", "Dai", "Zhuo", "Shi", "Zhong", "Xian", "Zu", "Jiong", "Ban", "Ju", "Mo", "Shu", "Zui", "Wata", "Jing", "Ren", "Heng", "Xie", "Jie", "Zhu", "Chou", "Gua", "Bai", "Jue", "Kuang", "Hu", "Ci", "Geng", "Geng", "Tao", "Xie", "Ku", "Jiao", "Quan", "Gai", "Luo", "Xuan", "Bing", "Xian", "Fu", "Gei", "Tong", "Rong", "Tiao", "Yin", "Lei", "Xie", "Quan", "Xu", "Lun", "Die", "Tong", "Si", "Jiang", "Xiang", "Hui", "Jue", "Zhi", "Jian", "Juan", "Chi", "Mian", "Zhen", "Lu", "Cheng", "Qiu", "Shu", "Bang", "Tong", "Xiao", "Wan", "Qin", "Geng", "Xiu", "Ti", "Xiu", "Xie", "Hong", "Xi", "Fu", "Ting", "Sui", "Dui", "Kun", "Fu", "Jing", "Hu", "Zhi", "Yan", "Jiong", "Feng", "Ji", "Sok", "Kase", "Zong", "Lin", "Duo", "Li", "Lu", "Liang", "Chou", "Quan", "Shao", "Qi", "Qi", "Zhun", "Qi", "Wan", "Qian", "Xian", "Shou", "Wei", "Qi", "Tao", "Wan", "Gang", "Wang", "Beng", "Zhui", "Cai", "Guo", "Cui", "Lun", "Liu", "Qi", "Zhan", "Bei", "Chuo", "Ling", "Mian", "Qi", "Qie", "Tan", "Zong", "Gun", "Zou", "Yi", "Zi", "Xing", "Liang", "Jin", "Fei", "Rui", "Min", "Yu", "Zong", "Fan", "Lu", "Xu", "Yingl", "Zhang", "Kasuri", "Xu", "Xiang", "Jian", "Ke", "Xian", "Ruan", "Mian", "Qi", "Duan", "Zhong", "Di", "Min", "Miao", "Yuan", "Xie", "Bao", "Si", "Qiu", "Bian", "Huan", "Geng", "Cong", "Mian", "Wei", "Fu", "Wei", "Yu", "Gou", "Miao", "Xie", "Lian", "Zong", "Bian", "Yun", "Yin", "Ti", "Gua", "Zhi", "Yun", "Cheng", "Chan", "Dai"], ["Xia", "Yuan", "Zong", "Xu", "Nawa", "Odoshi", "Geng", "Sen", "Ying", "Jin", "Yi", "Zhui", "Ni", "Bang", "Gu", "Pan", "Zhou", "Jian", "Cuo", "Quan", "Shuang", "Yun", "Xia", "Shuai", "Xi", "Rong", "Tao", "Fu", "Yun", "Zhen", "Gao", "Ru", "Hu", "Zai", "Teng", "Xian", "Su", "Zhen", "Zong", "Tao", "Horo", "Cai", "Bi", "Feng", "Cu", "Li", "Suo", "Yin", "Xi", "Zong", "Lei", "Zhuan", "Qian", "Man", "Zhi", "Lu", "Mo", "Piao", "Lian", "Mi", "Xuan", "Zong", "Ji", "Shan", "Sui", "Fan", "Shuai", "Beng", "Yi", "Sao", "Mou", "Zhou", "Qiang", "Hun", "Sem", "Xi", "Jung", "Xiu", "Ran", "Xuan", "Hui", "Qiao", "Zeng", "Zuo", "Zhi", "Shan", "San", "Lin", "Yu", "Fan", "Liao", "Chuo", "Zun", "Jian", "Rao", "Chan", "Rui", "Xiu", "Hui", "Hua", "Zuan", "Xi", "Qiang", "Un", "Da", "Sheng", "Hui", "Xi", "Se", "Jian", "Jiang", "Huan", "Zao", "Cong", "Jie", "Jiao", "Bo", "Chan", "Yi", "Nao", "Sui", "Yi", "Shai", "Xu", "Ji", "Bin", "Qian", "Lan", "Pu", "Xun", "Zuan", "Qi", "Peng", "Li", "Mo", "Lei", "Xie", "Zuan", "Kuang", "You", "Xu", "Lei", "Xian", "Chan", "Kou", "Lu", "Chan", "Ying", "Cai", "Xiang", "Xian", "Zui", "Zuan", "Luo", "Xi", "Dao", "Lan", "Lei", "Lian", "Si", "Jiu", "Yu", "Hong", "Zhou", "Xian", "He", "Yue", "Ji", "Wan", "Kuang", "Ji", "Ren", "Wei", "Yun", "Hong", "Chun", "Pi", "Sha", "Gang", "Na", "Ren", "Zong", "Lun", "Fen", "Zhi", "Wen", "Fang", "Zhu", "Yin", "Niu", "Shu", "Xian", "Gan", "Xie", "Fu", "Lian", "Zu", "Shen", "Xi", "Zhi", "Zhong", "Zhou", "Ban", "Fu", "Zhuo", "Shao", "Yi", "Jing", "Dai", "Bang", "Rong", "Jie", "Ku", "Rao", "Die", "Heng", "Hui", "Gei", "Xuan", "Jiang", "Luo", "Jue", "Jiao", "Tong", "Geng", "Xiao", "Juan", "Xiu", "Xi", "Sui", "Tao", "Ji", "Ti", "Ji", "Xu", "Ling", , "Xu", "Qi", "Fei", "Chuo", "Zhang", "Gun", "Sheng", "Wei", "Mian", "Shou", "Beng", "Chou", "Tao", "Liu", "Quan", "Zong", "Zhan", "Wan", "Lu"], ["Zhui", "Zi", "Ke", "Xiang", "Jian", "Mian", "Lan", "Ti", "Miao", "Qi", "Yun", "Hui", "Si", "Duo", "Duan", "Bian", "Xian", "Gou", "Zhui", "Huan", "Di", "Lu", "Bian", "Min", "Yuan", "Jin", "Fu", "Ru", "Zhen", "Feng", "Shuai", "Gao", "Chan", "Li", "Yi", "Jian", "Bin", "Piao", "Man", "Lei", "Ying", "Suo", "Mou", "Sao", "Xie", "Liao", "Shan", "Zeng", "Jiang", "Qian", "Zao", "Huan", "Jiao", "Zuan", "Fou", "Xie", "Gang", "Fou", "Que", "Fou", "Kaakeru", "Bo", "Ping", "Hou", , "Gang", "Ying", "Ying", "Qing", "Xia", "Guan", "Zun", "Tan", "Chang", "Qi", "Weng", "Ying", "Lei", "Tan", "Lu", "Guan", "Wang", "Wang", "Gang", "Wang", "Han", , "Luo", "Fu", "Mi", "Fa", "Gu", "Zhu", "Ju", "Mao", "Gu", "Min", "Gang", "Ba", "Gua", "Ti", "Juan", "Fu", "Lin", "Yan", "Zhao", "Zui", "Gua", "Zhuo", "Yu", "Zhi", "An", "Fa", "Nan", "Shu", "Si", "Pi", "Ma", "Liu", "Ba", "Fa", "Li", "Chao", "Wei", "Bi", "Ji", "Zeng", "Tong", "Liu", "Ji", "Juan", "Mi", "Zhao", "Luo", "Pi", "Ji", "Ji", "Luan", "Yang", "Mie", "Qiang", "Ta", "Mei", "Yang", "You", "You", "Fen", "Ba", "Gao", "Yang", "Gu", "Qiang", "Zang", "Gao", "Ling", "Yi", "Zhu", "Di", "Xiu", "Qian", "Yi", "Xian", "Rong", "Qun", "Qun", "Qian", "Huan", "Zui", "Xian", "Yi", "Yashinau", "Qiang", "Xian", "Yu", "Geng", "Jie", "Tang", "Yuan", "Xi", "Fan", "Shan", "Fen", "Shan", "Lian", "Lei", "Geng", "Nou", "Qiang", "Chan", "Yu", "Gong", "Yi", "Chong", "Weng", "Fen", "Hong", "Chi", "Chi", "Cui", "Fu", "Xia", "Pen", "Yi", "La", "Yi", "Pi", "Ling", "Liu", "Zhi", "Qu", "Xi", "Xie", "Xiang", "Xi", "Xi", "Qi", "Qiao", "Hui", "Hui", "Xiao", "Se", "Hong", "Jiang", "Di", "Cui", "Fei", "Tao", "Sha", "Chi", "Zhu", "Jian", "Xuan", "Shi", "Pian", "Zong", "Wan", "Hui", "Hou", "He", "He", "Han", "Ao", "Piao", "Yi", "Lian", "Qu", , "Lin", "Pen", "Qiao", "Ao", "Fan", "Yi", "Hui", "Xuan", "Dao"], ["Yao", "Lao", , "Kao", "Mao", "Zhe", "Qi", "Gou", "Gou", "Gou", "Die", "Die", "Er", "Shua", "Ruan", "Er", "Nai", "Zhuan", "Lei", "Ting", "Zi", "Geng", "Chao", "Hao", "Yun", "Pa", "Pi", "Chi", "Si", "Chu", "Jia", "Ju", "He", "Chu", "Lao", "Lun", "Ji", "Tang", "Ou", "Lou", "Nou", "Gou", "Pang", "Ze", "Lou", "Ji", "Lao", "Huo", "You", "Mo", "Huai", "Er", "Zhe", "Ting", "Ye", "Da", "Song", "Qin", "Yun", "Chi", "Dan", "Dan", "Hong", "Geng", "Zhi", , "Nie", "Dan", "Zhen", "Che", "Ling", "Zheng", "You", "Wa", "Liao", "Long", "Zhi", "Ning", "Tiao", "Er", "Ya", "Die", "Gua", , "Lian", "Hao", "Sheng", "Lie", "Pin", "Jing", "Ju", "Bi", "Di", "Guo", "Wen", "Xu", "Ping", "Cong", "Shikato", , "Ting", "Yu", "Cong", "Kui", "Tsuraneru", "Kui", "Cong", "Lian", "Weng", "Kui", "Lian", "Lian", "Cong", "Ao", "Sheng", "Song", "Ting", "Kui", "Nie", "Zhi", "Dan", "Ning", "Qie", "Ji", "Ting", "Ting", "Long", "Yu", "Yu", "Zhao", "Si", "Su", "Yi", "Su", "Si", "Zhao", "Zhao", "Rou", "Yi", "Le", "Ji", "Qiu", "Ken", "Cao", "Ge", "Di", "Huan", "Huang", "Yi", "Ren", "Xiao", "Ru", "Zhou", "Yuan", "Du", "Gang", "Rong", "Gan", "Cha", "Wo", "Chang", "Gu", "Zhi", "Han", "Fu", "Fei", "Fen", "Pei", "Pang", "Jian", "Fang", "Zhun", "You", "Na", "Hang", "Ken", "Ran", "Gong", "Yu", "Wen", "Yao", "Jin", "Pi", "Qian", "Xi", "Xi", "Fei", "Ken", "Jing", "Tai", "Shen", "Zhong", "Zhang", "Xie", "Shen", "Wei", "Zhou", "Die", "Dan", "Fei", "Ba", "Bo", "Qu", "Tian", "Bei", "Gua", "Tai", "Zi", "Ku", "Zhi", "Ni", "Ping", "Zi", "Fu", "Pang", "Zhen", "Xian", "Zuo", "Pei", "Jia", "Sheng", "Zhi", "Bao", "Mu", "Qu", "Hu", "Ke", "Yi", "Yin", "Xu", "Yang", "Long", "Dong", "Ka", "Lu", "Jing", "Nu", "Yan", "Pang", "Kua", "Yi", "Guang", "Gai", "Ge", "Dong", "Zhi", "Xiao", "Xiong", "Xiong", "Er", "E", "Xing", "Pian", "Neng", "Zi", "Gui"], ["Cheng", "Tiao", "Zhi", "Cui", "Mei", "Xie", "Cui", "Xie", "Mo", "Mai", "Ji", "Obiyaakasu", , "Kuai", "Sa", "Zang", "Qi", "Nao", "Mi", "Nong", "Luan", "Wan", "Bo", "Wen", "Guan", "Qiu", "Jiao", "Jing", "Rou", "Heng", "Cuo", "Lie", "Shan", "Ting", "Mei", "Chun", "Shen", "Xie", "De", "Zui", "Cu", "Xiu", "Xin", "Tuo", "Pao", "Cheng", "Nei", "Fu", "Dou", "Tuo", "Niao", "Noy", "Pi", "Gu", "Gua", "Li", "Lian", "Zhang", "Cui", "Jie", "Liang", "Zhou", "Pi", "Biao", "Lun", "Pian", "Guo", "Kui", "Chui", "Dan", "Tian", "Nei", "Jing", "Jie", "La", "Yi", "An", "Ren", "Shen", "Chuo", "Fu", "Fu", "Ju", "Fei", "Qiang", "Wan", "Dong", "Pi", "Guo", "Zong", "Ding", "Wu", "Mei", "Ruan", "Zhuan", "Zhi", "Cou", "Gua", "Ou", "Di", "An", "Xing", "Nao", "Yu", "Chuan", "Nan", "Yun", "Zhong", "Rou", "E", "Sai", "Tu", "Yao", "Jian", "Wei", "Jiao", "Yu", "Jia", "Duan", "Bi", "Chang", "Fu", "Xian", "Ni", "Mian", "Wa", "Teng", "Tui", "Bang", "Qian", "Lu", "Wa", "Sou", "Tang", "Su", "Zhui", "Ge", "Yi", "Bo", "Liao", "Ji", "Pi", "Xie", "Gao", "Lu", "Bin", "Ou", "Chang", "Lu", "Guo", "Pang", "Chuai", "Piao", "Jiang", "Fu", "Tang", "Mo", "Xi", "Zhuan", "Lu", "Jiao", "Ying", "Lu", "Zhi", "Tara", "Chun", "Lian", "Tong", "Peng", "Ni", "Zha", "Liao", "Cui", "Gui", "Xiao", "Teng", "Fan", "Zhi", "Jiao", "Shan", "Wu", "Cui", "Run", "Xiang", "Sui", "Fen", "Ying", "Tan", "Zhua", "Dan", "Kuai", "Nong", "Tun", "Lian", "Bi", "Yong", "Jue", "Chu", "Yi", "Juan", "La", "Lian", "Sao", "Tun", "Gu", "Qi", "Cui", "Bin", "Xun", "Ru", "Huo", "Zang", "Xian", "Biao", "Xing", "Kuan", "La", "Yan", "Lu", "Huo", "Zang", "Luo", "Qu", "Zang", "Luan", "Ni", "Zang", "Chen", "Qian", "Wo", "Guang", "Zang", "Lin", "Guang", "Zi", "Jiao", "Nie", "Chou", "Ji", "Gao", "Chou", "Mian", "Nie", "Zhi", "Zhi", "Ge", "Jian", "Die", "Zhi", "Xiu", "Tai", "Zhen", "Jiu", "Xian", "Yu", "Cha"], ["Yao", "Yu", "Chong", "Xi", "Xi", "Jiu", "Yu", "Yu", "Xing", "Ju", "Jiu", "Xin", "She", "She", "Yadoru", "Jiu", "Shi", "Tan", "Shu", "Shi", "Tian", "Dan", "Pu", "Pu", "Guan", "Hua", "Tan", "Chuan", "Shun", "Xia", "Wu", "Zhou", "Dao", "Gang", "Shan", "Yi", , "Pa", "Tai", "Fan", "Ban", "Chuan", "Hang", "Fang", "Ban", "Que", "Hesaki", "Zhong", "Jian", "Cang", "Ling", "Zhu", "Ze", "Duo", "Bo", "Xian", "Ge", "Chuan", "Jia", "Lu", "Hong", "Pang", "Xi", , "Fu", "Zao", "Feng", "Li", "Shao", "Yu", "Lang", "Ting", , "Wei", "Bo", "Meng", "Nian", "Ju", "Huang", "Shou", "Zong", "Bian", "Mao", "Die", , "Bang", "Cha", "Yi", "Sao", "Cang", "Cao", "Lou", "Dai", "Sori", "Yao", "Tong", "Yofune", "Dang", "Tan", "Lu", "Yi", "Jie", "Jian", "Huo", "Meng", "Qi", "Lu", "Lu", "Chan", "Shuang", "Gen", "Liang", "Jian", "Jian", "Se", "Yan", "Fu", "Ping", "Yan", "Yan", "Cao", "Cao", "Yi", "Le", "Ting", "Qiu", "Ai", "Nai", "Tiao", "Jiao", "Jie", "Peng", "Wan", "Yi", "Chai", "Mian", "Mie", "Gan", "Qian", "Yu", "Yu", "Shuo", "Qiong", "Tu", "Xia", "Qi", "Mang", "Zi", "Hui", "Sui", "Zhi", "Xiang", "Bi", "Fu", "Tun", "Wei", "Wu", "Zhi", "Qi", "Shan", "Wen", "Qian", "Ren", "Fou", "Kou", "Jie", "Lu", "Xu", "Ji", "Qin", "Qi", "Yuan", "Fen", "Ba", "Rui", "Xin", "Ji", "Hua", "Hua", "Fang", "Wu", "Jue", "Gou", "Zhi", "Yun", "Qin", "Ao", "Chu", "Mao", "Ya", "Fei", "Reng", "Hang", "Cong", "Yin", "You", "Bian", "Yi", "Susa", "Wei", "Li", "Pi", "E", "Xian", "Chang", "Cang", "Meng", "Su", "Yi", "Yuan", "Ran", "Ling", "Tai", "Tiao", "Di", "Miao", "Qiong", "Li", "Yong", "Ke", "Mu", "Pei", "Bao", "Gou", "Min", "Yi", "Yi", "Ju", "Pi", "Ruo", "Ku", "Zhu", "Ni", "Bo", "Bing", "Shan", "Qiu", "Yao", "Xian", "Ben", "Hong", "Ying", "Zha", "Dong", "Ju", "Die", "Nie", "Gan", "Hu", "Ping", "Mei", "Fu", "Sheng", "Gu", "Bi", "Wei"], ["Fu", "Zhuo", "Mao", "Fan", "Qie", "Mao", "Mao", "Ba", "Zi", "Mo", "Zi", "Di", "Chi", "Ji", "Jing", "Long", , "Niao", , "Xue", "Ying", "Qiong", "Ge", "Ming", "Li", "Rong", "Yin", "Gen", "Qian", "Chai", "Chen", "Yu", "Xiu", "Zi", "Lie", "Wu", "Ji", "Kui", "Ce", "Chong", "Ci", "Gou", "Guang", "Mang", "Chi", "Jiao", "Jiao", "Fu", "Yu", "Zhu", "Zi", "Jiang", "Hui", "Yin", "Cha", "Fa", "Rong", "Ru", "Chong", "Mang", "Tong", "Zhong", , "Zhu", "Xun", "Huan", "Kua", "Quan", "Gai", "Da", "Jing", "Xing", "Quan", "Cao", "Jing", "Er", "An", "Shou", "Chi", "Ren", "Jian", "Ti", "Huang", "Ping", "Li", "Jin", "Lao", "Shu", "Zhuang", "Da", "Jia", "Rao", "Bi", "Ze", "Qiao", "Hui", "Qi", "Dang", , "Rong", "Hun", "Ying", "Luo", "Ying", "Xun", "Jin", "Sun", "Yin", "Mai", "Hong", "Zhou", "Yao", "Du", "Wei", "Chu", "Dou", "Fu", "Ren", "Yin", "He", "Bi", "Bu", "Yun", "Di", "Tu", "Sui", "Sui", "Cheng", "Chen", "Wu", "Bie", "Xi", "Geng", "Li", "Fu", "Zhu", "Mo", "Li", "Zhuang", "Ji", "Duo", "Qiu", "Sha", "Suo", "Chen", "Feng", "Ju", "Mei", "Meng", "Xing", "Jing", "Che", "Xin", "Jun", "Yan", "Ting", "Diao", "Cuo", "Wan", "Han", "You", "Cuo", "Jia", "Wang", "You", "Niu", "Shao", "Xian", "Lang", "Fu", "E", "Mo", "Wen", "Jie", "Nan", "Mu", "Kan", "Lai", "Lian", "Shi", "Wo", "Usagi", "Lian", "Huo", "You", "Ying", "Ying", "Nuc", "Chun", "Mang", "Mang", "Ci", "Wan", "Jing", "Di", "Qu", "Dong", "Jian", "Zou", "Gu", "La", "Lu", "Ju", "Wei", "Jun", "Nie", "Kun", "He", "Pu", "Zi", "Gao", "Guo", "Fu", "Lun", "Chang", "Chou", "Song", "Chui", "Zhan", "Men", "Cai", "Ba", "Li", "Tu", "Bo", "Han", "Bao", "Qin", "Juan", "Xi", "Qin", "Di", "Jie", "Pu", "Dang", "Jin", "Zhao", "Tai", "Geng", "Hua", "Gu", "Ling", "Fei", "Jin", "An", "Wang", "Beng", "Zhou", "Yan", "Ju", "Jian", "Lin", "Tan", "Shu", "Tian", "Dao"], ["Hu", "Qi", "He", "Cui", "Tao", "Chun", "Bei", "Chang", "Huan", "Fei", "Lai", "Qi", "Meng", "Ping", "Wei", "Dan", "Sha", "Huan", "Yan", "Yi", "Tiao", "Qi", "Wan", "Ce", "Nai", "Kutabireru", "Tuo", "Jiu", "Tie", "Luo", , , "Meng", , "Yaji", , "Ying", "Ying", "Ying", "Xiao", "Sa", "Qiu", "Ke", "Xiang", "Wan", "Yu", "Yu", "Fu", "Lian", "Xuan", "Yuan", "Nan", "Ze", "Wo", "Chun", "Xiao", "Yu", "Pian", "Mao", "An", "E", "Luo", "Ying", "Huo", "Gua", "Jiang", "Mian", "Zuo", "Zuo", "Ju", "Bao", "Rou", "Xi", "Xie", "An", "Qu", "Jian", "Fu", "Lu", "Jing", "Pen", "Feng", "Hong", "Hong", "Hou", "Yan", "Tu", "Zhu", "Zi", "Xiang", "Shen", "Ge", "Jie", "Jing", "Mi", "Huang", "Shen", "Pu", "Gai", "Dong", "Zhou", "Qian", "Wei", "Bo", "Wei", "Pa", "Ji", "Hu", "Zang", "Jia", "Duan", "Yao", "Jun", "Cong", "Quan", "Wei", "Xian", "Kui", "Ting", "Hun", "Xi", "Shi", "Qi", "Lan", "Zong", "Yao", "Yuan", "Mei", "Yun", "Shu", "Di", "Zhuan", "Guan", "Sukumo", "Xue", "Chan", "Kai", "Kui", , "Jiang", "Lou", "Wei", "Pai", , "Sou", "Yin", "Shi", "Chun", "Shi", "Yun", "Zhen", "Lang", "Nu", "Meng", "He", "Que", "Suan", "Yuan", "Li", "Ju", "Xi", "Pang", "Chu", "Xu", "Tu", "Liu", "Wo", "Zhen", "Qian", "Zu", "Po", "Cuo", "Yuan", "Chu", "Yu", "Kuai", "Pan", "Pu", "Pu", "Na", "Shuo", "Xi", "Fen", "Yun", "Zheng", "Jian", "Ji", "Ruo", "Cang", "En", "Mi", "Hao", "Sun", "Zhen", "Ming", "Sou", "Xu", "Liu", "Xi", "Gu", "Lang", "Rong", "Weng", "Gai", "Cuo", "Shi", "Tang", "Luo", "Ru", "Suo", "Xian", "Bei", "Yao", "Gui", "Bi", "Zong", "Gun", "Za", "Xiu", "Ce", "Hai", "Lan", , "Ji", "Li", "Can", "Lang", "Yu", , "Ying", "Mo", "Diao", "Tiao", "Mao", "Tong", "Zhu", "Peng", "An", "Lian", "Cong", "Xi", "Ping", "Qiu", "Jin", "Chun", "Jie", "Wei", "Tui", "Cao", "Yu", "Yi", "Ji", "Liao", "Bi", "Lu", "Su"], ["Bu", "Zhang", "Luo", "Jiang", "Man", "Yan", "Ling", "Ji", "Piao", "Gun", "Han", "Di", "Su", "Lu", "She", "Shang", "Di", "Mie", "Xun", "Man", "Bo", "Di", "Cuo", "Zhe", "Sen", "Xuan", "Wei", "Hu", "Ao", "Mi", "Lou", "Cu", "Zhong", "Cai", "Po", "Jiang", "Mi", "Cong", "Niao", "Hui", "Jun", "Yin", "Jian", "Yan", "Shu", "Yin", "Kui", "Chen", "Hu", "Sha", "Kou", "Qian", "Ma", "Zang", "Sonoko", "Qiang", "Dou", "Lian", "Lin", "Kou", "Ai", "Bi", "Li", "Wei", "Ji", "Xun", "Sheng", "Fan", "Meng", "Ou", "Chan", "Dian", "Xun", "Jiao", "Rui", "Rui", "Lei", "Yu", "Qiao", "Chu", "Hua", "Jian", "Mai", "Yun", "Bao", "You", "Qu", "Lu", "Rao", "Hui", "E", "Teng", "Fei", "Jue", "Zui", "Fa", "Ru", "Fen", "Kui", "Shun", "Rui", "Ya", "Xu", "Fu", "Jue", "Dang", "Wu", "Tong", "Si", "Xiao", "Xi", "Long", "Yun", , "Qi", "Jian", "Yun", "Sun", "Ling", "Yu", "Xia", "Yong", "Ji", "Hong", "Si", "Nong", "Lei", "Xuan", "Yun", "Yu", "Xi", "Hao", "Bo", "Hao", "Ai", "Wei", "Hui", "Wei", "Ji", "Ci", "Xiang", "Luan", "Mie", "Yi", "Leng", "Jiang", "Can", "Shen", "Qiang", "Lian", "Ke", "Yuan", "Da", "Ti", "Tang", "Xie", "Bi", "Zhan", "Sun", "Lian", "Fan", "Ding", "Jie", "Gu", "Xie", "Shu", "Jian", "Kao", "Hong", "Sa", "Xin", "Xun", "Yao", "Hie", "Sou", "Shu", "Xun", "Dui", "Pin", "Wei", "Neng", "Chou", "Mai", "Ru", "Piao", "Tai", "Qi", "Zao", "Chen", "Zhen", "Er", "Ni", "Ying", "Gao", "Cong", "Xiao", "Qi", "Fa", "Jian", "Xu", "Kui", "Jie", "Bian", "Diao", "Mi", "Lan", "Jin", "Cang", "Miao", "Qiong", "Qie", "Xian", , "Ou", "Xian", "Su", "Lu", "Yi", "Xu", "Xie", "Li", "Yi", "La", "Lei", "Xiao", "Di", "Zhi", "Bei", "Teng", "Yao", "Mo", "Huan", "Piao", "Fan", "Sou", "Tan", "Tui", "Qiong", "Qiao", "Wei", "Liu", "Hui", , "Gao", "Yun", , "Li", "Shu", "Chu", "Ai", "Lin", "Zao", "Xuan", "Chen", "Lai", "Huo"], ["Tuo", "Wu", "Rui", "Rui", "Qi", "Heng", "Lu", "Su", "Tui", "Mang", "Yun", "Pin", "Yu", "Xun", "Ji", "Jiong", "Xian", "Mo", "Hagi", "Su", "Jiong", , "Nie", "Bo", "Rang", "Yi", "Xian", "Yu", "Ju", "Lian", "Lian", "Yin", "Qiang", "Ying", "Long", "Tong", "Wei", "Yue", "Ling", "Qu", "Yao", "Fan", "Mi", "Lan", "Kui", "Lan", "Ji", "Dang", "Katsura", "Lei", "Lei", "Hua", "Feng", "Zhi", "Wei", "Kui", "Zhan", "Huai", "Li", "Ji", "Mi", "Lei", "Huai", "Luo", "Ji", "Kui", "Lu", "Jian", "San", , "Lei", "Quan", "Xiao", "Yi", "Luan", "Men", "Bie", "Hu", "Hu", "Lu", "Nue", "Lu", "Si", "Xiao", "Qian", "Chu", "Hu", "Xu", "Cuo", "Fu", "Xu", "Xu", "Lu", "Hu", "Yu", "Hao", "Jiao", "Ju", "Guo", "Bao", "Yan", "Zhan", "Zhan", "Kui", "Ban", "Xi", "Shu", "Chong", "Qiu", "Diao", "Ji", "Qiu", "Cheng", "Shi", , "Di", "Zhe", "She", "Yu", "Gan", "Zi", "Hong", "Hui", "Meng", "Ge", "Sui", "Xia", "Chai", "Shi", "Yi", "Ma", "Xiang", "Fang", "E", "Pa", "Chi", "Qian", "Wen", "Wen", "Rui", "Bang", "Bi", "Yue", "Yue", "Jun", "Qi", "Ran", "Yin", "Qi", "Tian", "Yuan", "Jue", "Hui", "Qin", "Qi", "Zhong", "Ya", "Ci", "Mu", "Wang", "Fen", "Fen", "Hang", "Gong", "Zao", "Fu", "Ran", "Jie", "Fu", "Chi", "Dou", "Piao", "Xian", "Ni", "Te", "Qiu", "You", "Zha", "Ping", "Chi", "You", "He", "Han", "Ju", "Li", "Fu", "Ran", "Zha", "Gou", "Pi", "Bo", "Xian", "Zhu", "Diao", "Bie", "Bing", "Gu", "Ran", "Qu", "She", "Tie", "Ling", "Gu", "Dan", "Gu", "Ying", "Li", "Cheng", "Qu", "Mou", "Ge", "Ci", "Hui", "Hui", "Mang", "Fu", "Yang", "Wa", "Lie", "Zhu", "Yi", "Xian", "Kuo", "Jiao", "Li", "Yi", "Ping", "Ji", "Ha", "She", "Yi", "Wang", "Mo", "Qiong", "Qie", "Gui", "Gong", "Zhi", "Man", "Ebi", "Zhi", "Jia", "Rao", "Si", "Qi", "Xing", "Lie", "Qiu", "Shao", "Yong", "Jia", "Shui", "Che", "Bai", "E", "Han"], ["Shu", "Xuan", "Feng", "Shen", "Zhen", "Fu", "Xian", "Zhe", "Wu", "Fu", "Li", "Lang", "Bi", "Chu", "Yuan", "You", "Jie", "Dan", "Yan", "Ting", "Dian", "Shui", "Hui", "Gua", "Zhi", "Song", "Fei", "Ju", "Mi", "Qi", "Qi", "Yu", "Jun", "Zha", "Meng", "Qiang", "Si", "Xi", "Lun", "Li", "Die", "Tiao", "Tao", "Kun", "Gan", "Han", "Yu", "Bang", "Fei", "Pi", "Wei", "Dun", "Yi", "Yuan", "Su", "Quan", "Qian", "Rui", "Ni", "Qing", "Wei", "Liang", "Guo", "Wan", "Dong", "E", "Ban", "Di", "Wang", "Can", "Yang", "Ying", "Guo", "Chan", , "La", "Ke", "Ji", "He", "Ting", "Mai", "Xu", "Mian", "Yu", "Jie", "Shi", "Xuan", "Huang", "Yan", "Bian", "Rou", "Wei", "Fu", "Yuan", "Mei", "Wei", "Fu", "Ruan", "Xie", "You", "Qiu", "Mao", "Xia", "Ying", "Shi", "Chong", "Tang", "Zhu", "Zong", "Ti", "Fu", "Yuan", "Hui", "Meng", "La", "Du", "Hu", "Qiu", "Die", "Li", "Gua", "Yun", "Ju", "Nan", "Lou", "Qun", "Rong", "Ying", "Jiang", , "Lang", "Pang", "Si", "Xi", "Ci", "Xi", "Yuan", "Weng", "Lian", "Sou", "Ban", "Rong", "Rong", "Ji", "Wu", "Qiu", "Han", "Qin", "Yi", "Bi", "Hua", "Tang", "Yi", "Du", "Nai", "He", "Hu", "Hui", "Ma", "Ming", "Yi", "Wen", "Ying", "Teng", "Yu", "Cang", "So", "Ebi", "Man", , "Shang", "Zhe", "Cao", "Chi", "Di", "Ao", "Lu", "Wei", "Zhi", "Tang", "Chen", "Piao", "Qu", "Pi", "Yu", "Jian", "Luo", "Lou", "Qin", "Zhong", "Yin", "Jiang", "Shuai", "Wen", "Jiao", "Wan", "Zhi", "Zhe", "Ma", "Ma", "Guo", "Liu", "Mao", "Xi", "Cong", "Li", "Man", "Xiao", "Kamakiri", "Zhang", "Mang", "Xiang", "Mo", "Zui", "Si", "Qiu", "Te", "Zhi", "Peng", "Peng", "Jiao", "Qu", "Bie", "Liao", "Pan", "Gui", "Xi", "Ji", "Zhuan", "Huang", "Fei", "Lao", "Jue", "Jue", "Hui", "Yin", "Chan", "Jiao", "Shan", "Rao", "Xiao", "Mou", "Chong", "Xun", "Si", , "Cheng", "Dang", "Li", "Xie", "Shan", "Yi", "Jing", "Da", "Chan", "Qi"], ["Ci", "Xiang", "She", "Luo", "Qin", "Ying", "Chai", "Li", "Ze", "Xuan", "Lian", "Zhu", "Ze", "Xie", "Mang", "Xie", "Qi", "Rong", "Jian", "Meng", "Hao", "Ruan", "Huo", "Zhuo", "Jie", "Bin", "He", "Mie", "Fan", "Lei", "Jie", "La", "Mi", "Li", "Chun", "Li", "Qiu", "Nie", "Lu", "Du", "Xiao", "Zhu", "Long", "Li", "Long", "Feng", "Ye", "Beng", "Shang", "Gu", "Juan", "Ying", , "Xi", "Can", "Qu", "Quan", "Du", "Can", "Man", "Jue", "Jie", "Zhu", "Zha", "Xie", "Huang", "Niu", "Pei", "Nu", "Xin", "Zhong", "Mo", "Er", "Ke", "Mie", "Xi", "Xing", "Yan", "Kan", "Yuan", , "Ling", "Xuan", "Shu", "Xian", "Tong", "Long", "Jie", "Xian", "Ya", "Hu", "Wei", "Dao", "Chong", "Wei", "Dao", "Zhun", "Heng", "Qu", "Yi", "Yi", "Bu", "Gan", "Yu", "Biao", "Cha", "Yi", "Shan", "Chen", "Fu", "Gun", "Fen", "Shuai", "Jie", "Na", "Zhong", "Dan", "Ri", "Zhong", "Zhong", "Xie", "Qi", "Xie", "Ran", "Zhi", "Ren", "Qin", "Jin", "Jun", "Yuan", "Mei", "Chai", "Ao", "Niao", "Hui", "Ran", "Jia", "Tuo", "Ling", "Dai", "Bao", "Pao", "Yao", "Zuo", "Bi", "Shao", "Tan", "Ju", "He", "Shu", "Xiu", "Zhen", "Yi", "Pa", "Bo", "Di", "Wa", "Fu", "Gun", "Zhi", "Zhi", "Ran", "Pan", "Yi", "Mao", "Tuo", "Na", "Kou", "Xian", "Chan", "Qu", "Bei", "Gun", "Xi", "Ne", "Bo", "Horo", "Fu", "Yi", "Chi", "Ku", "Ren", "Jiang", "Jia", "Cun", "Mo", "Jie", "Er", "Luo", "Ru", "Zhu", "Gui", "Yin", "Cai", "Lie", "Kamishimo", "Yuki", "Zhuang", "Dang", , "Kun", "Ken", "Niao", "Shu", "Jia", "Kun", "Cheng", "Li", "Juan", "Shen", "Pou", "Ge", "Yi", "Yu", "Zhen", "Liu", "Qiu", "Qun", "Ji", "Yi", "Bu", "Zhuang", "Shui", "Sha", "Qun", "Li", "Lian", "Lian", "Ku", "Jian", "Fou", "Chan", "Bi", "Gun", "Tao", "Yuan", "Ling", "Chi", "Chang", "Chou", "Duo", "Biao", "Liang", "Chang", "Pei", "Pei", "Fei", "Yuan", "Luo", "Guo", "Yan", "Du", "Xi", "Zhi", "Ju", "Qi"], ["Ji", "Zhi", "Gua", "Ken", "Che", "Ti", "Ti", "Fu", "Chong", "Xie", "Bian", "Die", "Kun", "Duan", "Xiu", "Xiu", "He", "Yuan", "Bao", "Bao", "Fu", "Yu", "Tuan", "Yan", "Hui", "Bei", "Chu", "Lu", "Ena", "Hitoe", "Yun", "Da", "Gou", "Da", "Huai", "Rong", "Yuan", "Ru", "Nai", "Jiong", "Suo", "Ban", "Tun", "Chi", "Sang", "Niao", "Ying", "Jie", "Qian", "Huai", "Ku", "Lian", "Bao", "Li", "Zhe", "Shi", "Lu", "Yi", "Die", "Xie", "Xian", "Wei", "Biao", "Cao", "Ji", "Jiang", "Sen", "Bao", "Xiang", "Chihaya", "Pu", "Jian", "Zhuan", "Jian", "Zui", "Ji", "Dan", "Za", "Fan", "Bo", "Xiang", "Xin", "Bie", "Rao", "Man", "Lan", "Ao", "Duo", "Gui", "Cao", "Sui", "Nong", "Chan", "Lian", "Bi", "Jin", "Dang", "Shu", "Tan", "Bi", "Lan", "Pu", "Ru", "Zhi", , "Shu", "Wa", "Shi", "Bai", "Xie", "Bo", "Chen", "Lai", "Long", "Xi", "Xian", "Lan", "Zhe", "Dai", "Tasuki", "Zan", "Shi", "Jian", "Pan", "Yi", "Ran", "Ya", "Xi", "Xi", "Yao", "Feng", "Tan", , "Biao", "Fu", "Ba", "He", "Ji", "Ji", "Jian", "Guan", "Bian", "Yan", "Gui", "Jue", "Pian", "Mao", "Mi", "Mi", "Mie", "Shi", "Si", "Zhan", "Luo", "Jue", "Mi", "Tiao", "Lian", "Yao", "Zhi", "Jun", "Xi", "Shan", "Wei", "Xi", "Tian", "Yu", "Lan", "E", "Du", "Qin", "Pang", "Ji", "Ming", "Ying", "Gou", "Qu", "Zhan", "Jin", "Guan", "Deng", "Jian", "Luo", "Qu", "Jian", "Wei", "Jue", "Qu", "Luo", "Lan", "Shen", "Di", "Guan", "Jian", "Guan", "Yan", "Gui", "Mi", "Shi", "Zhan", "Lan", "Jue", "Ji", "Xi", "Di", "Tian", "Yu", "Gou", "Jin", "Qu", "Jiao", "Jiu", "Jin", "Cu", "Jue", "Zhi", "Chao", "Ji", "Gu", "Dan", "Zui", "Di", "Shang", "Hua", "Quan", "Ge", "Chi", "Jie", "Gui", "Gong", "Chu", "Jie", "Hun", "Qiu", "Xing", "Su", "Ni", "Ji", "Lu", "Zhi", "Zha", "Bi", "Xing", "Hu", "Shang", "Gong", "Zhi", "Xue", "Chu", "Xi", "Yi", "Lu", "Jue", "Xi", "Yan", "Xi"], ["Yan", "Yan", "Ding", "Fu", "Qiu", "Qiu", "Jiao", "Hong", "Ji", "Fan", "Xun", "Diao", "Hong", "Cha", "Tao", "Xu", "Jie", "Yi", "Ren", "Xun", "Yin", "Shan", "Qi", "Tuo", "Ji", "Xun", "Yin", "E", "Fen", "Ya", "Yao", "Song", "Shen", "Yin", "Xin", "Jue", "Xiao", "Ne", "Chen", "You", "Zhi", "Xiong", "Fang", "Xin", "Chao", "She", "Xian", "Sha", "Tun", "Xu", "Yi", "Yi", "Su", "Chi", "He", "Shen", "He", "Xu", "Zhen", "Zhu", "Zheng", "Gou", "Zi", "Zi", "Zhan", "Gu", "Fu", "Quan", "Die", "Ling", "Di", "Yang", "Li", "Nao", "Pan", "Zhou", "Gan", "Yi", "Ju", "Ao", "Zha", "Tuo", "Yi", "Qu", "Zhao", "Ping", "Bi", "Xiong", "Qu", "Ba", "Da", "Zu", "Tao", "Zhu", "Ci", "Zhe", "Yong", "Xu", "Xun", "Yi", "Huang", "He", "Shi", "Cha", "Jiao", "Shi", "Hen", "Cha", "Gou", "Gui", "Quan", "Hui", "Jie", "Hua", "Gai", "Xiang", "Wei", "Shen", "Chou", "Tong", "Mi", "Zhan", "Ming", "E", "Hui", "Yan", "Xiong", "Gua", "Er", "Beng", "Tiao", "Chi", "Lei", "Zhu", "Kuang", "Kua", "Wu", "Yu", "Teng", "Ji", "Zhi", "Ren", "Su", "Lang", "E", "Kuang", "E", "Shi", "Ting", "Dan", "Bo", "Chan", "You", "Heng", "Qiao", "Qin", "Shua", "An", "Yu", "Xiao", "Cheng", "Jie", "Xian", "Wu", "Wu", "Gao", "Song", "Pu", "Hui", "Jing", "Shuo", "Zhen", "Shuo", "Du", "Yasashi", "Chang", "Shui", "Jie", "Ke", "Qu", "Cong", "Xiao", "Sui", "Wang", "Xuan", "Fei", "Chi", "Ta", "Yi", "Na", "Yin", "Diao", "Pi", "Chuo", "Chan", "Chen", "Zhun", "Ji", "Qi", "Tan", "Zhui", "Wei", "Ju", "Qing", "Jian", "Zheng", "Ze", "Zou", "Qian", "Zhuo", "Liang", "Jian", "Zhu", "Hao", "Lun", "Shen", "Biao", "Huai", "Pian", "Yu", "Die", "Xu", "Pian", "Shi", "Xuan", "Shi", "Hun", "Hua", "E", "Zhong", "Di", "Xie", "Fu", "Pu", "Ting", "Jian", "Qi", "Yu", "Zi", "Chuan", "Xi", "Hui", "Yin", "An", "Xian", "Nan", "Chen", "Feng", "Zhu", "Yang", "Yan", "Heng", "Xuan", "Ge", "Nuo", "Qi"], ["Mou", "Ye", "Wei", , "Teng", "Zou", "Shan", "Jian", "Bo", "Ku", "Huang", "Huo", "Ge", "Ying", "Mi", "Xiao", "Mi", "Xi", "Qiang", "Chen", "Nue", "Ti", "Su", "Bang", "Chi", "Qian", "Shi", "Jiang", "Yuan", "Xie", "Xue", "Tao", "Yao", "Yao", , "Yu", "Biao", "Cong", "Qing", "Li", "Mo", "Mo", "Shang", "Zhe", "Miu", "Jian", "Ze", "Jie", "Lian", "Lou", "Can", "Ou", "Guan", "Xi", "Zhuo", "Ao", "Ao", "Jin", "Zhe", "Yi", "Hu", "Jiang", "Man", "Chao", "Han", "Hua", "Chan", "Xu", "Zeng", "Se", "Xi", "She", "Dui", "Zheng", "Nao", "Lan", "E", "Ying", "Jue", "Ji", "Zun", "Jiao", "Bo", "Hui", "Zhuan", "Mu", "Zen", "Zha", "Shi", "Qiao", "Tan", "Zen", "Pu", "Sheng", "Xuan", "Zao", "Tan", "Dang", "Sui", "Qian", "Ji", "Jiao", "Jing", "Lian", "Nou", "Yi", "Ai", "Zhan", "Pi", "Hui", "Hua", "Yi", "Yi", "Shan", "Rang", "Nou", "Qian", "Zhui", "Ta", "Hu", "Zhou", "Hao", "Ye", "Ying", "Jian", "Yu", "Jian", "Hui", "Du", "Zhe", "Xuan", "Zan", "Lei", "Shen", "Wei", "Chan", "Li", "Yi", "Bian", "Zhe", "Yan", "E", "Chou", "Wei", "Chou", "Yao", "Chan", "Rang", "Yin", "Lan", "Chen", "Huo", "Zhe", "Huan", "Zan", "Yi", "Dang", "Zhan", "Yan", "Du", "Yan", "Ji", "Ding", "Fu", "Ren", "Ji", "Jie", "Hong", "Tao", "Rang", "Shan", "Qi", "Tuo", "Xun", "Yi", "Xun", "Ji", "Ren", "Jiang", "Hui", "Ou", "Ju", "Ya", "Ne", "Xu", "E", "Lun", "Xiong", "Song", "Feng", "She", "Fang", "Jue", "Zheng", "Gu", "He", "Ping", "Zu", "Shi", "Xiong", "Zha", "Su", "Zhen", "Di", "Zou", "Ci", "Qu", "Zhao", "Bi", "Yi", "Yi", "Kuang", "Lei", "Shi", "Gua", "Shi", "Jie", "Hui", "Cheng", "Zhu", "Shen", "Hua", "Dan", "Gou", "Quan", "Gui", "Xun", "Yi", "Zheng", "Gai", "Xiang", "Cha", "Hun", "Xu", "Zhou", "Jie", "Wu", "Yu", "Qiao", "Wu", "Gao", "You", "Hui", "Kuang", "Shuo", "Song", "Ai", "Qing", "Zhu", "Zou", "Nuo", "Du", "Zhuo", "Fei", "Ke", "Wei"], ["Yu", "Shui", "Shen", "Diao", "Chan", "Liang", "Zhun", "Sui", "Tan", "Shen", "Yi", "Mou", "Chen", "Die", "Huang", "Jian", "Xie", "Nue", "Ye", "Wei", "E", "Yu", "Xuan", "Chan", "Zi", "An", "Yan", "Di", "Mi", "Pian", "Xu", "Mo", "Dang", "Su", "Xie", "Yao", "Bang", "Shi", "Qian", "Mi", "Jin", "Man", "Zhe", "Jian", "Miu", "Tan", "Zen", "Qiao", "Lan", "Pu", "Jue", "Yan", "Qian", "Zhan", "Chen", "Gu", "Qian", "Hong", "Xia", "Jue", "Hong", "Han", "Hong", "Xi", "Xi", "Huo", "Liao", "Han", "Du", "Long", "Dou", "Jiang", "Qi", "Shi", "Li", "Deng", "Wan", "Bi", "Shu", "Xian", "Feng", "Zhi", "Zhi", "Yan", "Yan", "Shi", "Chu", "Hui", "Tun", "Yi", "Tun", "Yi", "Jian", "Ba", "Hou", "E", "Cu", "Xiang", "Huan", "Jian", "Ken", "Gai", "Qu", "Fu", "Xi", "Bin", "Hao", "Yu", "Zhu", "Jia", , "Xi", "Bo", "Wen", "Huan", "Bin", "Di", "Zong", "Fen", "Yi", "Zhi", "Bao", "Chai", "Han", "Pi", "Na", "Pi", "Gou", "Na", "You", "Diao", "Mo", "Si", "Xiu", "Huan", "Kun", "He", "He", "Mo", "Han", "Mao", "Li", "Ni", "Bi", "Yu", "Jia", "Tuan", "Mao", "Pi", "Xi", "E", "Ju", "Mo", "Chu", "Tan", "Huan", "Jue", "Bei", "Zhen", "Yuan", "Fu", "Cai", "Gong", "Te", "Yi", "Hang", "Wan", "Pin", "Huo", "Fan", "Tan", "Guan", "Ze", "Zhi", "Er", "Zhu", "Shi", "Bi", "Zi", "Er", "Gui", "Pian", "Bian", "Mai", "Dai", "Sheng", "Kuang", "Fei", "Tie", "Yi", "Chi", "Mao", "He", "Bi", "Lu", "Ren", "Hui", "Gai", "Pian", "Zi", "Jia", "Xu", "Zei", "Jiao", "Gai", "Zang", "Jian", "Ying", "Xun", "Zhen", "She", "Bin", "Bin", "Qiu", "She", "Chuan", "Zang", "Zhou", "Lai", "Zan", "Si", "Chen", "Shang", "Tian", "Pei", "Geng", "Xian", "Mai", "Jian", "Sui", "Fu", "Tan", "Cong", "Cong", "Zhi", "Ji", "Zhang", "Du", "Jin", "Xiong", "Shun", "Yun", "Bao", "Zai", "Lai", "Feng", "Cang", "Ji", "Sheng", "Ai", "Zhuan", "Fu", "Gou", "Sai", "Ze", "Liao"], ["Wei", "Bai", "Chen", "Zhuan", "Zhi", "Zhui", "Biao", "Yun", "Zeng", "Tan", "Zan", "Yan", , "Shan", "Wan", "Ying", "Jin", "Gan", "Xian", "Zang", "Bi", "Du", "Shu", "Yan", , "Xuan", "Long", "Gan", "Zang", "Bei", "Zhen", "Fu", "Yuan", "Gong", "Cai", "Ze", "Xian", "Bai", "Zhang", "Huo", "Zhi", "Fan", "Tan", "Pin", "Bian", "Gou", "Zhu", "Guan", "Er", "Jian", "Bi", "Shi", "Tie", "Gui", "Kuang", "Dai", "Mao", "Fei", "He", "Yi", "Zei", "Zhi", "Jia", "Hui", "Zi", "Ren", "Lu", "Zang", "Zi", "Gai", "Jin", "Qiu", "Zhen", "Lai", "She", "Fu", "Du", "Ji", "Shu", "Shang", "Si", "Bi", "Zhou", "Geng", "Pei", "Tan", "Lai", "Feng", "Zhui", "Fu", "Zhuan", "Sai", "Ze", "Yan", "Zan", "Yun", "Zeng", "Shan", "Ying", "Gan", "Chi", "Xi", "She", "Nan", "Xiong", "Xi", "Cheng", "He", "Cheng", "Zhe", "Xia", "Tang", "Zou", "Zou", "Li", "Jiu", "Fu", "Zhao", "Gan", "Qi", "Shan", "Qiong", "Qin", "Xian", "Ci", "Jue", "Qin", "Chi", "Ci", "Chen", "Chen", "Die", "Ju", "Chao", "Di", "Se", "Zhan", "Zhu", "Yue", "Qu", "Jie", "Chi", "Chu", "Gua", "Xue", "Ci", "Tiao", "Duo", "Lie", "Gan", "Suo", "Cu", "Xi", "Zhao", "Su", "Yin", "Ju", "Jian", "Que", "Tang", "Chuo", "Cui", "Lu", "Qu", "Dang", "Qiu", "Zi", "Ti", "Qu", "Chi", "Huang", "Qiao", "Qiao", "Yao", "Zao", "Ti", , "Zan", "Zan", "Zu", "Pa", "Bao", "Ku", "Ke", "Dun", "Jue", "Fu", "Chen", "Jian", "Fang", "Zhi", "Sa", "Yue", "Pa", "Qi", "Yue", "Qiang", "Tuo", "Tai", "Yi", "Nian", "Ling", "Mei", "Ba", "Die", "Ku", "Tuo", "Jia", "Ci", "Pao", "Qia", "Zhu", "Ju", "Die", "Zhi", "Fu", "Pan", "Ju", "Shan", "Bo", "Ni", "Ju", "Li", "Gen", "Yi", "Ji", "Dai", "Xian", "Jiao", "Duo", "Zhu", "Zhuan", "Kua", "Zhuai", "Gui", "Qiong", "Kui", "Xiang", "Chi", "Lu", "Beng", "Zhi", "Jia", "Tiao", "Cai", "Jian", "Ta", "Qiao", "Bi", "Xian", "Duo", "Ji", "Ju", "Ji", "Shu", "Tu"], ["Chu", "Jing", "Nie", "Xiao", "Bo", "Chi", "Qun", "Mou", "Shu", "Lang", "Yong", "Jiao", "Chou", "Qiao", , "Ta", "Jian", "Qi", "Wo", "Wei", "Zhuo", "Jie", "Ji", "Nie", "Ju", "Ju", "Lun", "Lu", "Leng", "Huai", "Ju", "Chi", "Wan", "Quan", "Ti", "Bo", "Zu", "Qie", "Ji", "Cu", "Zong", "Cai", "Zong", "Peng", "Zhi", "Zheng", "Dian", "Zhi", "Yu", "Duo", "Dun", "Chun", "Yong", "Zhong", "Di", "Zhe", "Chen", "Chuai", "Jian", "Gua", "Tang", "Ju", "Fu", "Zu", "Die", "Pian", "Rou", "Nuo", "Ti", "Cha", "Tui", "Jian", "Dao", "Cuo", "Xi", "Ta", "Qiang", "Zhan", "Dian", "Ti", "Ji", "Nie", "Man", "Liu", "Zhan", "Bi", "Chong", "Lu", "Liao", "Cu", "Tang", "Dai", "Suo", "Xi", "Kui", "Ji", "Zhi", "Qiang", "Di", "Man", "Zong", "Lian", "Beng", "Zao", "Nian", "Bie", "Tui", "Ju", "Deng", "Ceng", "Xian", "Fan", "Chu", "Zhong", "Dun", "Bo", "Cu", "Zu", "Jue", "Jue", "Lin", "Ta", "Qiao", "Qiao", "Pu", "Liao", "Dun", "Cuan", "Kuang", "Zao", "Ta", "Bi", "Bi", "Zhu", "Ju", "Chu", "Qiao", "Dun", "Chou", "Ji", "Wu", "Yue", "Nian", "Lin", "Lie", "Zhi", "Li", "Zhi", "Chan", "Chu", "Duan", "Wei", "Long", "Lin", "Xian", "Wei", "Zuan", "Lan", "Xie", "Rang", "Xie", "Nie", "Ta", "Qu", "Jie", "Cuan", "Zuan", "Xi", "Kui", "Jue", "Lin", "Shen", "Gong", "Dan", "Segare", "Qu", "Ti", "Duo", "Duo", "Gong", "Lang", "Nerau", "Luo", "Ai", "Ji", "Ju", "Tang", "Utsuke", , "Yan", "Shitsuke", "Kang", "Qu", "Lou", "Lao", "Tuo", "Zhi", "Yagate", "Ti", "Dao", "Yagate", "Yu", "Che", "Ya", "Gui", "Jun", "Wei", "Yue", "Xin", "Di", "Xuan", "Fan", "Ren", "Shan", "Qiang", "Shu", "Tun", "Chen", "Dai", "E", "Na", "Qi", "Mao", "Ruan", "Ren", "Fan", "Zhuan", "Hong", "Hu", "Qu", "Huang", "Di", "Ling", "Dai", "Ao", "Zhen", "Fan", "Kuang", "Ang", "Peng", "Bei", "Gu", "Ku", "Pao", "Zhu", "Rong", "E", "Ba", "Zhou", "Zhi", "Yao", "Ke", "Yi", "Qing", "Shi", "Ping"], ["Er", "Qiong", "Ju", "Jiao", "Guang", "Lu", "Kai", "Quan", "Zhou", "Zai", "Zhi", "She", "Liang", "Yu", "Shao", "You", "Huan", "Yun", "Zhe", "Wan", "Fu", "Qing", "Zhou", "Ni", "Ling", "Zhe", "Zhan", "Liang", "Zi", "Hui", "Wang", "Chuo", "Guo", "Kan", "Yi", "Peng", "Qian", "Gun", "Nian", "Pian", "Guan", "Bei", "Lun", "Pai", "Liang", "Ruan", "Rou", "Ji", "Yang", "Xian", "Chuan", "Cou", "Qun", "Ge", "You", "Hong", "Shu", "Fu", "Zi", "Fu", "Wen", "Ben", "Zhan", "Yu", "Wen", "Tao", "Gu", "Zhen", "Xia", "Yuan", "Lu", "Jiu", "Chao", "Zhuan", "Wei", "Hun", "Sori", "Che", "Jiao", "Zhan", "Pu", "Lao", "Fen", "Fan", "Lin", "Ge", "Se", "Kan", "Huan", "Yi", "Ji", "Dui", "Er", "Yu", "Xian", "Hong", "Lei", "Pei", "Li", "Li", "Lu", "Lin", "Che", "Ya", "Gui", "Xuan", "Di", "Ren", "Zhuan", "E", "Lun", "Ruan", "Hong", "Ku", "Ke", "Lu", "Zhou", "Zhi", "Yi", "Hu", "Zhen", "Li", "Yao", "Qing", "Shi", "Zai", "Zhi", "Jiao", "Zhou", "Quan", "Lu", "Jiao", "Zhe", "Fu", "Liang", "Nian", "Bei", "Hui", "Gun", "Wang", "Liang", "Chuo", "Zi", "Cou", "Fu", "Ji", "Wen", "Shu", "Pei", "Yuan", "Xia", "Zhan", "Lu", "Che", "Lin", "Xin", "Gu", "Ci", "Ci", "Pi", "Zui", "Bian", "La", "La", "Ci", "Xue", "Ban", "Bian", "Bian", "Bian", , "Bian", "Ban", "Ci", "Bian", "Bian", "Chen", "Ru", "Nong", "Nong", "Zhen", "Chuo", "Chuo", "Suberu", "Reng", "Bian", "Bian", "Sip", "Ip", "Liao", "Da", "Chan", "Gan", "Qian", "Yu", "Yu", "Qi", "Xun", "Yi", "Guo", "Mai", "Qi", "Za", "Wang", "Jia", "Zhun", "Ying", "Ti", "Yun", "Jin", "Hang", "Ya", "Fan", "Wu", "Da", "E", "Huan", "Zhe", "Totemo", "Jin", "Yuan", "Wei", "Lian", "Chi", "Che", "Ni", "Tiao", "Zhi", "Yi", "Jiong", "Jia", "Chen", "Dai", "Er", "Di", "Po", "Wang", "Die", "Ze", "Tao", "Shu", "Tuo", "Kep", "Jing", "Hui", "Tong", "You", "Mi", "Beng", "Ji", "Nai", "Yi", "Jie", "Zhui", "Lie", "Xun"], ["Tui", "Song", "Gua", "Tao", "Pang", "Hou", "Ni", "Dun", "Jiong", "Xuan", "Xun", "Bu", "You", "Xiao", "Qiu", "Tou", "Zhu", "Qiu", "Di", "Di", "Tu", "Jing", "Ti", "Dou", "Yi", "Zhe", "Tong", "Guang", "Wu", "Shi", "Cheng", "Su", "Zao", "Qun", "Feng", "Lian", "Suo", "Hui", "Li", "Sako", "Lai", "Ben", "Cuo", "Jue", "Beng", "Huan", "Dai", "Lu", "You", "Zhou", "Jin", "Yu", "Chuo", "Kui", "Wei", "Ti", "Yi", "Da", "Yuan", "Luo", "Bi", "Nuo", "Yu", "Dang", "Sui", "Dun", "Sui", "Yan", "Chuan", "Chi", "Ti", "Yu", "Shi", "Zhen", "You", "Yun", "E", "Bian", "Guo", "E", "Xia", "Huang", "Qiu", "Dao", "Da", "Wei", "Appare", "Yi", "Gou", "Yao", "Chu", "Liu", "Xun", "Ta", "Di", "Chi", "Yuan", "Su", "Ta", "Qian", , "Yao", "Guan", "Zhang", "Ao", "Shi", "Ce", "Chi", "Su", "Zao", "Zhe", "Dun", "Di", "Lou", "Chi", "Cuo", "Lin", "Zun", "Rao", "Qian", "Xuan", "Yu", "Yi", "Wu", "Liao", "Ju", "Shi", "Bi", "Yao", "Mai", "Xie", "Sui", "Huan", "Zhan", "Teng", "Er", "Miao", "Bian", "Bian", "La", "Li", "Yuan", "Yao", "Luo", "Li", "Yi", "Ting", "Deng", "Qi", "Yong", "Shan", "Han", "Yu", "Mang", "Ru", "Qiong", , "Kuang", "Fu", "Kang", "Bin", "Fang", "Xing", "Na", "Xin", "Shen", "Bang", "Yuan", "Cun", "Huo", "Xie", "Bang", "Wu", "Ju", "You", "Han", "Tai", "Qiu", "Bi", "Pei", "Bing", "Shao", "Bei", "Wa", "Di", "Zou", "Ye", "Lin", "Kuang", "Gui", "Zhu", "Shi", "Ku", "Yu", "Gai", "Ge", "Xi", "Zhi", "Ji", "Xun", "Hou", "Xing", "Jiao", "Xi", "Gui", "Nuo", "Lang", "Jia", "Kuai", "Zheng", "Otoko", "Yun", "Yan", "Cheng", "Dou", "Chi", "Lu", "Fu", "Wu", "Fu", "Gao", "Hao", "Lang", "Jia", "Geng", "Jun", "Ying", "Bo", "Xi", "Bei", "Li", "Yun", "Bu", "Xiao", "Qi", "Pi", "Qing", "Guo", "Zhou", "Tan", "Zou", "Ping", "Lai", "Ni", "Chen", "You", "Bu", "Xiang", "Dan", "Ju", "Yong", "Qiao", "Yi", "Du", "Yan", "Mei"], ["Ruo", "Bei", "E", "Yu", "Juan", "Yu", "Yun", "Hou", "Kui", "Xiang", "Xiang", "Sou", "Tang", "Ming", "Xi", "Ru", "Chu", "Zi", "Zou", "Ju", "Wu", "Xiang", "Yun", "Hao", "Yong", "Bi", "Mo", "Chao", "Fu", "Liao", "Yin", "Zhuan", "Hu", "Qiao", "Yan", "Zhang", "Fan", "Qiao", "Xu", "Deng", "Bi", "Xin", "Bi", "Ceng", "Wei", "Zheng", "Mao", "Shan", "Lin", "Po", "Dan", "Meng", "Ye", "Cao", "Kuai", "Feng", "Meng", "Zou", "Kuang", "Lian", "Zan", "Chan", "You", "Qi", "Yan", "Chan", "Zan", "Ling", "Huan", "Xi", "Feng", "Zan", "Li", "You", "Ding", "Qiu", "Zhuo", "Pei", "Zhou", "Yi", "Hang", "Yu", "Jiu", "Yan", "Zui", "Mao", "Dan", "Xu", "Tou", "Zhen", "Fen", "Sakenomoto", , "Yun", "Tai", "Tian", "Qia", "Tuo", "Zuo", "Han", "Gu", "Su", "Po", "Chou", "Zai", "Ming", "Luo", "Chuo", "Chou", "You", "Tong", "Zhi", "Xian", "Jiang", "Cheng", "Yin", "Tu", "Xiao", "Mei", "Ku", "Suan", "Lei", "Pu", "Zui", "Hai", "Yan", "Xi", "Niang", "Wei", "Lu", "Lan", "Yan", "Tao", "Pei", "Zhan", "Chun", "Tan", "Zui", "Chuo", "Cu", "Kun", "Ti", "Mian", "Du", "Hu", "Xu", "Xing", "Tan", "Jiu", "Chun", "Yun", "Po", "Ke", "Sou", "Mi", "Quan", "Chou", "Cuo", "Yun", "Yong", "Ang", "Zha", "Hai", "Tang", "Jiang", "Piao", "Shan", "Yu", "Li", "Zao", "Lao", "Yi", "Jiang", "Pu", "Jiao", "Xi", "Tan", "Po", "Nong", "Yi", "Li", "Ju", "Jiao", "Yi", "Niang", "Ru", "Xun", "Chou", "Yan", "Ling", "Mi", "Mi", "Niang", "Xin", "Jiao", "Xi", "Mi", "Yan", "Bian", "Cai", "Shi", "You", "Shi", "Shi", "Li", "Chong", "Ye", "Liang", "Li", "Jin", "Jin", "Qiu", "Yi", "Diao", "Dao", "Zhao", "Ding", "Po", "Qiu", "He", "Fu", "Zhen", "Zhi", "Ba", "Luan", "Fu", "Nai", "Diao", "Shan", "Qiao", "Kou", "Chuan", "Zi", "Fan", "Yu", "Hua", "Han", "Gong", "Qi", "Mang", "Ri", "Di", "Si", "Xi", "Yi", "Chai", "Shi", "Tu", "Xi", "Nu", "Qian", "Ishiyumi", "Jian", "Pi", "Ye", "Yin"], ["Ba", "Fang", "Chen", "Xing", "Tou", "Yue", "Yan", "Fu", "Pi", "Na", "Xin", "E", "Jue", "Dun", "Gou", "Yin", "Qian", "Ban", "Ji", "Ren", "Chao", "Niu", "Fen", "Yun", "Ji", "Qin", "Pi", "Guo", "Hong", "Yin", "Jun", "Shi", "Yi", "Zhong", "Nie", "Gai", "Ri", "Huo", "Tai", "Kang", "Habaki", "Irori", "Ngaak", , "Duo", "Zi", "Ni", "Tu", "Shi", "Min", "Gu", "E", "Ling", "Bing", "Yi", "Gu", "Ba", "Pi", "Yu", "Si", "Zuo", "Bu", "You", "Dian", "Jia", "Zhen", "Shi", "Shi", "Tie", "Ju", "Zhan", "Shi", "She", "Xuan", "Zhao", "Bao", "He", "Bi", "Sheng", "Chu", "Shi", "Bo", "Zhu", "Chi", "Za", "Po", "Tong", "Qian", "Fu", "Zhai", "Liu", "Qian", "Fu", "Li", "Yue", "Pi", "Yang", "Ban", "Bo", "Jie", "Gou", "Shu", "Zheng", "Mu", "Ni", "Nie", "Di", "Jia", "Mu", "Dan", "Shen", "Yi", "Si", "Kuang", "Ka", "Bei", "Jian", "Tong", "Xing", "Hong", "Jiao", "Chi", "Er", "Ge", "Bing", "Shi", "Mou", "Jia", "Yin", "Jun", "Zhou", "Chong", "Shang", "Tong", "Mo", "Lei", "Ji", "Yu", "Xu", "Ren", "Zun", "Zhi", "Qiong", "Shan", "Chi", "Xian", "Xing", "Quan", "Pi", "Tie", "Zhu", "Hou", "Ming", "Kua", "Yao", "Xian", "Xian", "Xiu", "Jun", "Cha", "Lao", "Ji", "Pi", "Ru", "Mi", "Yi", "Yin", "Guang", "An", "Diou", "You", "Se", "Kao", "Qian", "Luan", "Kasugai", "Ai", "Diao", "Han", "Rui", "Shi", "Keng", "Qiu", "Xiao", "Zhe", "Xiu", "Zang", "Ti", "Cuo", "Gua", "Gong", "Zhong", "Dou", "Lu", "Mei", "Lang", "Wan", "Xin", "Yun", "Bei", "Wu", "Su", "Yu", "Chan", "Ting", "Bo", "Han", "Jia", "Hong", "Cuan", "Feng", "Chan", "Wan", "Zhi", "Si", "Xuan", "Wu", "Wu", "Tiao", "Gong", "Zhuo", "Lue", "Xing", "Qian", "Shen", "Han", "Lue", "Xie", "Chu", "Zheng", "Ju", "Xian", "Tie", "Mang", "Pu", "Li", "Pan", "Rui", "Cheng", "Gao", "Li", "Te", "Pyeng", "Zhu", , "Tu", "Liu", "Zui", "Ju", "Chang", "Yuan", "Jian", "Gang", "Diao", "Tao", "Chang"], ["Lun", "Kua", "Ling", "Bei", "Lu", "Li", "Qiang", "Pou", "Juan", "Min", "Zui", "Peng", "An", "Pi", "Xian", "Ya", "Zhui", "Lei", "A", "Kong", "Ta", "Kun", "Du", "Wei", "Chui", "Zi", "Zheng", "Ben", "Nie", "Cong", "Qun", "Tan", "Ding", "Qi", "Qian", "Zhuo", "Qi", "Yu", "Jin", "Guan", "Mao", "Chang", "Tian", "Xi", "Lian", "Tao", "Gu", "Cuo", "Shu", "Zhen", "Lu", "Meng", "Lu", "Hua", "Biao", "Ga", "Lai", "Ken", "Kazari", "Bu", "Nai", "Wan", "Zan", , "De", "Xian", , "Huo", "Liang", , "Men", "Kai", "Ying", "Di", "Lian", "Guo", "Xian", "Du", "Tu", "Wei", "Cong", "Fu", "Rou", "Ji", "E", "Rou", "Chen", "Ti", "Zha", "Hong", "Yang", "Duan", "Xia", "Yu", "Keng", "Xing", "Huang", "Wei", "Fu", "Zhao", "Cha", "Qie", "She", "Hong", "Kui", "Tian", "Mou", "Qiao", "Qiao", "Hou", "Tou", "Cong", "Huan", "Ye", "Min", "Jian", "Duan", "Jian", "Song", "Kui", "Hu", "Xuan", "Duo", "Jie", "Zhen", "Bian", "Zhong", "Zi", "Xiu", "Ye", "Mei", "Pai", "Ai", "Jie", , "Mei", "Chuo", "Ta", "Bang", "Xia", "Lian", "Suo", "Xi", "Liu", "Zu", "Ye", "Nou", "Weng", "Rong", "Tang", "Suo", "Qiang", "Ge", "Shuo", "Chui", "Bo", "Pan", "Sa", "Bi", "Sang", "Gang", "Zi", "Wu", "Ying", "Huang", "Tiao", "Liu", "Kai", "Sun", "Sha", "Sou", "Wan", "Hao", "Zhen", "Zhen", "Luo", "Yi", "Yuan", "Tang", "Nie", "Xi", "Jia", "Ge", "Ma", "Juan", "Kasugai", "Habaki", "Suo", , , , "Na", "Lu", "Suo", "Ou", "Zu", "Tuan", "Xiu", "Guan", "Xuan", "Lian", "Shou", "Ao", "Man", "Mo", "Luo", "Bi", "Wei", "Liu", "Di", "Qiao", "Cong", "Yi", "Lu", "Ao", "Keng", "Qiang", "Cui", "Qi", "Chang", "Tang", "Man", "Yong", "Chan", "Feng", "Jing", "Biao", "Shu", "Lou", "Xiu", "Cong", "Long", "Zan", "Jian", "Cao", "Li", "Xia", "Xi", "Kang", , "Beng", , , "Zheng", "Lu", "Hua", "Ji", "Pu", "Hui", "Qiang", "Po", "Lin", "Suo", "Xiu", "San", "Cheng"], ["Kui", "Si", "Liu", "Nao", "Heng", "Pie", "Sui", "Fan", "Qiao", "Quan", "Yang", "Tang", "Xiang", "Jue", "Jiao", "Zun", "Liao", "Jie", "Lao", "Dui", "Tan", "Zan", "Ji", "Jian", "Zhong", "Deng", "Ya", "Ying", "Dui", "Jue", "Nou", "Ti", "Pu", "Tie", , , "Ding", "Shan", "Kai", "Jian", "Fei", "Sui", "Lu", "Juan", "Hui", "Yu", "Lian", "Zhuo", "Qiao", "Qian", "Zhuo", "Lei", "Bi", "Tie", "Huan", "Ye", "Duo", "Guo", "Dang", "Ju", "Fen", "Da", "Bei", "Yi", "Ai", "Zong", "Xun", "Diao", "Zhu", "Heng", "Zhui", "Ji", "Nie", "Ta", "Huo", "Qing", "Bin", "Ying", "Kui", "Ning", "Xu", "Jian", "Jian", "Yari", "Cha", "Zhi", "Mie", "Li", "Lei", "Ji", "Zuan", "Kuang", "Shang", "Peng", "La", "Du", "Shuo", "Chuo", "Lu", "Biao", "Bao", "Lu", , , "Long", "E", "Lu", "Xin", "Jian", "Lan", "Bo", "Jian", "Yao", "Chan", "Xiang", "Jian", "Xi", "Guan", "Cang", "Nie", "Lei", "Cuan", "Qu", "Pan", "Luo", "Zuan", "Luan", "Zao", "Nie", "Jue", "Tang", "Shu", "Lan", "Jin", "Qiu", "Yi", "Zhen", "Ding", "Zhao", "Po", "Diao", "Tu", "Qian", "Chuan", "Shan", "Ji", "Fan", "Diao", "Men", "Nu", "Xi", "Chai", "Xing", "Gai", "Bu", "Tai", "Ju", "Dun", "Chao", "Zhong", "Na", "Bei", "Gang", "Ban", "Qian", "Yao", "Qin", "Jun", "Wu", "Gou", "Kang", "Fang", "Huo", "Tou", "Niu", "Ba", "Yu", "Qian", "Zheng", "Qian", "Gu", "Bo", "E", "Po", "Bu", "Ba", "Yue", "Zuan", "Mu", "Dan", "Jia", "Dian", "You", "Tie", "Bo", "Ling", "Shuo", "Qian", "Liu", "Bao", "Shi", "Xuan", "She", "Bi", "Ni", "Pi", "Duo", "Xing", "Kao", "Lao", "Er", "Mang", "Ya", "You", "Cheng", "Jia", "Ye", "Nao", "Zhi", "Dang", "Tong", "Lu", "Diao", "Yin", "Kai", "Zha", "Zhu", "Xian", "Ting", "Diu", "Xian", "Hua", "Quan", "Sha", "Jia", "Yao", "Ge", "Ming", "Zheng", "Se", "Jiao", "Yi", "Chan", "Chong", "Tang", "An", "Yin", "Ru", "Zhu", "Lao", "Pu", "Wu", "Lai", "Te", "Lian", "Keng"], ["Xiao", "Suo", "Li", "Zheng", "Chu", "Guo", "Gao", "Tie", "Xiu", "Cuo", "Lue", "Feng", "Xin", "Liu", "Kai", "Jian", "Rui", "Ti", "Lang", "Qian", "Ju", "A", "Qiang", "Duo", "Tian", "Cuo", "Mao", "Ben", "Qi", "De", "Kua", "Kun", "Chang", "Xi", "Gu", "Luo", "Chui", "Zhui", "Jin", "Zhi", "Xian", "Juan", "Huo", "Pou", "Tan", "Ding", "Jian", "Ju", "Meng", "Zi", "Qie", "Ying", "Kai", "Qiang", "Song", "E", "Cha", "Qiao", "Zhong", "Duan", "Sou", "Huang", "Huan", "Ai", "Du", "Mei", "Lou", "Zi", "Fei", "Mei", "Mo", "Zhen", "Bo", "Ge", "Nie", "Tang", "Juan", "Nie", "Na", "Liu", "Hao", "Bang", "Yi", "Jia", "Bin", "Rong", "Biao", "Tang", "Man", "Luo", "Beng", "Yong", "Jing", "Di", "Zu", "Xuan", "Liu", "Tan", "Jue", "Liao", "Pu", "Lu", "Dui", "Lan", "Pu", "Cuan", "Qiang", "Deng", "Huo", "Lei", "Huan", "Zhuo", "Lian", "Yi", "Cha", "Biao", "La", "Chan", "Xiang", "Chang", "Chang", "Jiu", "Ao", "Die", "Qu", "Liao", "Mi", "Chang", "Men", "Ma", "Shuan", "Shan", "Huo", "Men", "Yan", "Bi", "Han", "Bi", "San", "Kai", "Kang", "Beng", "Hong", "Run", "San", "Xian", "Xian", "Jian", "Min", "Xia", "Yuru", "Dou", "Zha", "Nao", "Jian", "Peng", "Xia", "Ling", "Bian", "Bi", "Run", "He", "Guan", "Ge", "Ge", "Fa", "Chu", "Hong", "Gui", "Min", "Se", "Kun", "Lang", "Lu", "Ting", "Sha", "Ju", "Yue", "Yue", "Chan", "Qu", "Lin", "Chang", "Shai", "Kun", "Yan", "Min", "Yan", "E", "Hun", "Yu", "Wen", "Xiang", "Bao", "Xiang", "Qu", "Yao", "Wen", "Ban", "An", "Wei", "Yin", "Kuo", "Que", "Lan", "Du", , "Phwung", "Tian", "Nie", "Ta", "Kai", "He", "Que", "Chuang", "Guan", "Dou", "Qi", "Kui", "Tang", "Guan", "Piao", "Kan", "Xi", "Hui", "Chan", "Pi", "Dang", "Huan", "Ta", "Wen", , "Men", "Shuan", "Shan", "Yan", "Han", "Bi", "Wen", "Chuang", "Run", "Wei", "Xian", "Hong", "Jian", "Min", "Kang", "Men", "Zha", "Nao", "Gui", "Wen", "Ta", "Min", "Lu", "Kai"], ["Fa", "Ge", "He", "Kun", "Jiu", "Yue", "Lang", "Du", "Yu", "Yan", "Chang", "Xi", "Wen", "Hun", "Yan", "E", "Chan", "Lan", "Qu", "Hui", "Kuo", "Que", "Ge", "Tian", "Ta", "Que", "Kan", "Huan", "Fu", "Fu", "Le", "Dui", "Xin", "Qian", "Wu", "Yi", "Tuo", "Yin", "Yang", "Dou", "E", "Sheng", "Ban", "Pei", "Keng", "Yun", "Ruan", "Zhi", "Pi", "Jing", "Fang", "Yang", "Yin", "Zhen", "Jie", "Cheng", "E", "Qu", "Di", "Zu", "Zuo", "Dian", "Ling", "A", "Tuo", "Tuo", "Po", "Bing", "Fu", "Ji", "Lu", "Long", "Chen", "Xing", "Duo", "Lou", "Mo", "Jiang", "Shu", "Duo", "Xian", "Er", "Gui", "Yu", "Gai", "Shan", "Xun", "Qiao", "Xing", "Chun", "Fu", "Bi", "Xia", "Shan", "Sheng", "Zhi", "Pu", "Dou", "Yuan", "Zhen", "Chu", "Xian", "Tou", "Nie", "Yun", "Xian", "Pei", "Pei", "Zou", "Yi", "Dui", "Lun", "Yin", "Ju", "Chui", "Chen", "Pi", "Ling", "Tao", "Xian", "Lu", "Sheng", "Xian", "Yin", "Zhu", "Yang", "Reng", "Shan", "Chong", "Yan", "Yin", "Yu", "Ti", "Yu", "Long", "Wei", "Wei", "Nie", "Dui", "Sui", "An", "Huang", "Jie", "Sui", "Yin", "Gai", "Yan", "Hui", "Ge", "Yun", "Wu", "Wei", "Ai", "Xi", "Tang", "Ji", "Zhang", "Dao", "Ao", "Xi", "Yin", , "Rao", "Lin", "Tui", "Deng", "Pi", "Sui", "Sui", "Yu", "Xian", "Fen", "Ni", "Er", "Ji", "Dao", "Xi", "Yin", "E", "Hui", "Long", "Xi", "Li", "Li", "Li", "Zhui", "He", "Zhi", "Zhun", "Jun", "Nan", "Yi", "Que", "Yan", "Qian", "Ya", "Xiong", "Ya", "Ji", "Gu", "Huan", "Zhi", "Gou", "Jun", "Ci", "Yong", "Ju", "Chu", "Hu", "Za", "Luo", "Yu", "Chou", "Diao", "Sui", "Han", "Huo", "Shuang", "Guan", "Chu", "Za", "Yong", "Ji", "Xi", "Chou", "Liu", "Li", "Nan", "Xue", "Za", "Ji", "Ji", "Yu", "Yu", "Xue", "Na", "Fou", "Se", "Mu", "Wen", "Fen", "Pang", "Yun", "Li", "Li", "Ang", "Ling", "Lei", "An", "Bao", "Meng", "Dian", "Dang", "Xing", "Wu", "Zhao"], ["Xu", "Ji", "Mu", "Chen", "Xiao", "Zha", "Ting", "Zhen", "Pei", "Mei", "Ling", "Qi", "Chou", "Huo", "Sha", "Fei", "Weng", "Zhan", "Yin", "Ni", "Chou", "Tun", "Lin", , "Dong", "Ying", "Wu", "Ling", "Shuang", "Ling", "Xia", "Hong", "Yin", "Mo", "Mai", "Yun", "Liu", "Meng", "Bin", "Wu", "Wei", "Huo", "Yin", "Xi", "Yi", "Ai", "Dan", "Deng", "Xian", "Yu", "Lu", "Long", "Dai", "Ji", "Pang", "Yang", "Ba", "Pi", "Wei", , "Xi", "Ji", "Mai", "Meng", "Meng", "Lei", "Li", "Huo", "Ai", "Fei", "Dai", "Long", "Ling", "Ai", "Feng", "Li", "Bao", , "He", "He", "Bing", "Qing", "Qing", "Jing", "Tian", "Zhen", "Jing", "Cheng", "Qing", "Jing", "Jing", "Dian", "Jing", "Tian", "Fei", "Fei", "Kao", "Mi", "Mian", "Mian", "Pao", "Ye", "Tian", "Hui", "Ye", "Ge", "Ding", "Cha", "Jian", "Ren", "Di", "Du", "Wu", "Ren", "Qin", "Jin", "Xue", "Niu", "Ba", "Yin", "Sa", "Na", "Mo", "Zu", "Da", "Ban", "Yi", "Yao", "Tao", "Tuo", "Jia", "Hong", "Pao", "Yang", "Tomo", "Yin", "Jia", "Tao", "Ji", "Xie", "An", "An", "Hen", "Gong", "Kohaze", "Da", "Qiao", "Ting", "Wan", "Ying", "Sui", "Tiao", "Qiao", "Xuan", "Kong", "Beng", "Ta", "Zhang", "Bing", "Kuo", "Ju", "La", "Xie", "Rou", "Bang", "Yi", "Qiu", "Qiu", "He", "Xiao", "Mu", "Ju", "Jian", "Bian", "Di", "Jian", "On", "Tao", "Gou", "Ta", "Bei", "Xie", "Pan", "Ge", "Bi", "Kuo", "Tang", "Lou", "Gui", "Qiao", "Xue", "Ji", "Jian", "Jiang", "Chan", "Da", "Huo", "Xian", "Qian", "Du", "Wa", "Jian", "Lan", "Wei", "Ren", "Fu", "Mei", "Juan", "Ge", "Wei", "Qiao", "Han", "Chang", , "Rou", "Xun", "She", "Wei", "Ge", "Bei", "Tao", "Gou", "Yun", , "Bi", "Wei", "Hui", "Du", "Wa", "Du", "Wei", "Ren", "Fu", "Han", "Wei", "Yun", "Tao", "Jiu", "Jiu", "Xian", "Xie", "Xian", "Ji", "Yin", "Za", "Yun", "Shao", "Le", "Peng", "Heng", "Ying", "Yun", "Peng", "Yin", "Yin", "Xiang"], ["Hu", "Ye", "Ding", "Qing", "Pan", "Xiang", "Shun", "Han", "Xu", "Yi", "Xu", "Gu", "Song", "Kui", "Qi", "Hang", "Yu", "Wan", "Ban", "Dun", "Di", "Dan", "Pan", "Po", "Ling", "Ce", "Jing", "Lei", "He", "Qiao", "E", "E", "Wei", "Jie", "Gua", "Shen", "Yi", "Shen", "Hai", "Dui", "Pian", "Ping", "Lei", "Fu", "Jia", "Tou", "Hui", "Kui", "Jia", "Le", "Tian", "Cheng", "Ying", "Jun", "Hu", "Han", "Jing", "Tui", "Tui", "Pin", "Lai", "Tui", "Zi", "Zi", "Chui", "Ding", "Lai", "Yan", "Han", "Jian", "Ke", "Cui", "Jiong", "Qin", "Yi", "Sai", "Ti", "E", "E", "Yan", "Hun", "Kan", "Yong", "Zhuan", "Yan", "Xian", "Xin", "Yi", "Yuan", "Sang", "Dian", "Dian", "Jiang", "Ku", "Lei", "Liao", "Piao", "Yi", "Man", "Qi", "Rao", "Hao", "Qiao", "Gu", "Xun", "Qian", "Hui", "Zhan", "Ru", "Hong", "Bin", "Xian", "Pin", "Lu", "Lan", "Nie", "Quan", "Ye", "Ding", "Qing", "Han", "Xiang", "Shun", "Xu", "Xu", "Wan", "Gu", "Dun", "Qi", "Ban", "Song", "Hang", "Yu", "Lu", "Ling", "Po", "Jing", "Jie", "Jia", "Tian", "Han", "Ying", "Jiong", "Hai", "Yi", "Pin", "Hui", "Tui", "Han", "Ying", "Ying", "Ke", "Ti", "Yong", "E", "Zhuan", "Yan", "E", "Nie", "Man", "Dian", "Sang", "Hao", "Lei", "Zhan", "Ru", "Pin", "Quan", "Feng", "Biao", "Oroshi", "Fu", "Xia", "Zhan", "Biao", "Sa", "Ba", "Tai", "Lie", "Gua", "Xuan", "Shao", "Ju", "Bi", "Si", "Wei", "Yang", "Yao", "Sou", "Kai", "Sao", "Fan", "Liu", "Xi", "Liao", "Piao", "Piao", "Liu", "Biao", "Biao", "Biao", "Liao", , "Se", "Feng", "Biao", "Feng", "Yang", "Zhan", "Biao", "Sa", "Ju", "Si", "Sou", "Yao", "Liu", "Piao", "Biao", "Biao", "Fei", "Fan", "Fei", "Fei", "Shi", "Shi", "Can", "Ji", "Ding", "Si", "Tuo", "Zhan", "Sun", "Xiang", "Tun", "Ren", "Yu", "Juan", "Chi", "Yin", "Fan", "Fan", "Sun", "Yin", "Zhu", "Yi", "Zhai", "Bi", "Jie", "Tao", "Liu", "Ci", "Tie", "Si", "Bao", "Shi", "Duo"], ["Hai", "Ren", "Tian", "Jiao", "Jia", "Bing", "Yao", "Tong", "Ci", "Xiang", "Yang", "Yang", "Er", "Yan", "Le", "Yi", "Can", "Bo", "Nei", "E", "Bu", "Jun", "Dou", "Su", "Yu", "Shi", "Yao", "Hun", "Guo", "Shi", "Jian", "Zhui", "Bing", "Xian", "Bu", "Ye", "Tan", "Fei", "Zhang", "Wei", "Guan", "E", "Nuan", "Hun", "Hu", "Huang", "Tie", "Hui", "Jian", "Hou", "He", "Xing", "Fen", "Wei", "Gu", "Cha", "Song", "Tang", "Bo", "Gao", "Xi", "Kui", "Liu", "Sou", "Tao", "Ye", "Yun", "Mo", "Tang", "Man", "Bi", "Yu", "Xiu", "Jin", "San", "Kui", "Zhuan", "Shan", "Chi", "Dan", "Yi", "Ji", "Rao", "Cheng", "Yong", "Tao", "Hui", "Xiang", "Zhan", "Fen", "Hai", "Meng", "Yan", "Mo", "Chan", "Xiang", "Luo", "Zuan", "Nang", "Shi", "Ding", "Ji", "Tuo", "Xing", "Tun", "Xi", "Ren", "Yu", "Chi", "Fan", "Yin", "Jian", "Shi", "Bao", "Si", "Duo", "Yi", "Er", "Rao", "Xiang", "Jia", "Le", "Jiao", "Yi", "Bing", "Bo", "Dou", "E", "Yu", "Nei", "Jun", "Guo", "Hun", "Xian", "Guan", "Cha", "Kui", "Gu", "Sou", "Chan", "Ye", "Mo", "Bo", "Liu", "Xiu", "Jin", "Man", "San", "Zhuan", "Nang", "Shou", "Kui", "Guo", "Xiang", "Fen", "Ba", "Ni", "Bi", "Bo", "Tu", "Han", "Fei", "Jian", "An", "Ai", "Fu", "Xian", "Wen", "Xin", "Fen", "Bin", "Xing", "Ma", "Yu", "Feng", "Han", "Di", "Tuo", "Tuo", "Chi", "Xun", "Zhu", "Zhi", "Pei", "Xin", "Ri", "Sa", "Yin", "Wen", "Zhi", "Dan", "Lu", "You", "Bo", "Bao", "Kuai", "Tuo", "Yi", "Qu", , "Qu", "Jiong", "Bo", "Zhao", "Yuan", "Peng", "Zhou", "Ju", "Zhu", "Nu", "Ju", "Pi", "Zang", "Jia", "Ling", "Zhen", "Tai", "Fu", "Yang", "Shi", "Bi", "Tuo", "Tuo", "Si", "Liu", "Ma", "Pian", "Tao", "Zhi", "Rong", "Teng", "Dong", "Xun", "Quan", "Shen", "Jiong", "Er", "Hai", "Bo", "Zhu", "Yin", "Luo", "Shuu", "Dan", "Xie", "Liu", "Ju", "Song", "Qin", "Mang", "Liang", "Han", "Tu", "Xuan", "Tui", "Jun"], ["E", "Cheng", "Xin", "Ai", "Lu", "Zhui", "Zhou", "She", "Pian", "Kun", "Tao", "Lai", "Zong", "Ke", "Qi", "Qi", "Yan", "Fei", "Sao", "Yan", "Jie", "Yao", "Wu", "Pian", "Cong", "Pian", "Qian", "Fei", "Huang", "Jian", "Huo", "Yu", "Ti", "Quan", "Xia", "Zong", "Kui", "Rou", "Si", "Gua", "Tuo", "Kui", "Sou", "Qian", "Cheng", "Zhi", "Liu", "Pang", "Teng", "Xi", "Cao", "Du", "Yan", "Yuan", "Zou", "Sao", "Shan", "Li", "Zhi", "Shuang", "Lu", "Xi", "Luo", "Zhang", "Mo", "Ao", "Can", "Piao", "Cong", "Qu", "Bi", "Zhi", "Yu", "Xu", "Hua", "Bo", "Su", "Xiao", "Lin", "Chan", "Dun", "Liu", "Tuo", "Zeng", "Tan", "Jiao", "Tie", "Yan", "Luo", "Zhan", "Jing", "Yi", "Ye", "Tuo", "Bin", "Zou", "Yan", "Peng", "Lu", "Teng", "Xiang", "Ji", "Shuang", "Ju", "Xi", "Huan", "Li", "Biao", "Ma", "Yu", "Tuo", "Xun", "Chi", "Qu", "Ri", "Bo", "Lu", "Zang", "Shi", "Si", "Fu", "Ju", "Zou", "Zhu", "Tuo", "Nu", "Jia", "Yi", "Tai", "Xiao", "Ma", "Yin", "Jiao", "Hua", "Luo", "Hai", "Pian", "Biao", "Li", "Cheng", "Yan", "Xin", "Qin", "Jun", "Qi", "Qi", "Ke", "Zhui", "Zong", "Su", "Can", "Pian", "Zhi", "Kui", "Sao", "Wu", "Ao", "Liu", "Qian", "Shan", "Piao", "Luo", "Cong", "Chan", "Zou", "Ji", "Shuang", "Xiang", "Gu", "Wei", "Wei", "Wei", "Yu", "Gan", "Yi", "Ang", "Tou", "Xie", "Bao", "Bi", "Chi", "Ti", "Di", "Ku", "Hai", "Qiao", "Gou", "Kua", "Ge", "Tui", "Geng", "Pian", "Bi", "Ke", "Ka", "Yu", "Sui", "Lou", "Bo", "Xiao", "Pang", "Bo", "Ci", "Kuan", "Bin", "Mo", "Liao", "Lou", "Nao", "Du", "Zang", "Sui", "Ti", "Bin", "Kuan", "Lu", "Gao", "Gao", "Qiao", "Kao", "Qiao", "Lao", "Zao", "Biao", "Kun", "Kun", "Ti", "Fang", "Xiu", "Ran", "Mao", "Dan", "Kun", "Bin", "Fa", "Tiao", "Peng", "Zi", "Fa", "Ran", "Ti", "Pao", "Pi", "Mao", "Fu", "Er", "Rong", "Qu", "Gong", "Xiu", "Gua", "Ji", "Peng", "Zhua", "Shao", "Sha"], ["Ti", "Li", "Bin", "Zong", "Ti", "Peng", "Song", "Zheng", "Quan", "Zong", "Shun", "Jian", "Duo", "Hu", "La", "Jiu", "Qi", "Lian", "Zhen", "Bin", "Peng", "Mo", "San", "Man", "Man", "Seng", "Xu", "Lie", "Qian", "Qian", "Nong", "Huan", "Kuai", "Ning", "Bin", "Lie", "Rang", "Dou", "Dou", "Nao", "Hong", "Xi", "Dou", "Han", "Dou", "Dou", "Jiu", "Chang", "Yu", "Yu", "Li", "Juan", "Fu", "Qian", "Gui", "Zong", "Liu", "Gui", "Shang", "Yu", "Gui", "Mei", "Ji", "Qi", "Jie", "Kui", "Hun", "Ba", "Po", "Mei", "Xu", "Yan", "Xiao", "Liang", "Yu", "Tui", "Qi", "Wang", "Liang", "Wei", "Jian", "Chi", "Piao", "Bi", "Mo", "Ji", "Xu", "Chou", "Yan", "Zhan", "Yu", "Dao", "Ren", "Ji", "Eri", "Gong", "Tuo", "Diao", "Ji", "Xu", "E", "E", "Sha", "Hang", "Tun", "Mo", "Jie", "Shen", "Fan", "Yuan", "Bi", "Lu", "Wen", "Hu", "Lu", "Za", "Fang", "Fen", "Na", "You", "Namazu", "Todo", "He", "Xia", "Qu", "Han", "Pi", "Ling", "Tuo", "Bo", "Qiu", "Ping", "Fu", "Bi", "Ji", "Wei", "Ju", "Diao", "Bo", "You", "Gun", "Pi", "Nian", "Xing", "Tai", "Bao", "Fu", "Zha", "Ju", "Gu", "Kajika", "Tong", , "Ta", "Jie", "Shu", "Hou", "Xiang", "Er", "An", "Wei", "Tiao", "Zhu", "Yin", "Lie", "Luo", "Tong", "Yi", "Qi", "Bing", "Wei", "Jiao", "Bu", "Gui", "Xian", "Ge", "Hui", "Bora", "Mate", "Kao", "Gori", "Duo", "Jun", "Ti", "Man", "Xiao", "Za", "Sha", "Qin", "Yu", "Nei", "Zhe", "Gun", "Geng", "Su", "Wu", "Qiu", "Ting", "Fu", "Wan", "You", "Li", "Sha", "Sha", "Gao", "Meng", "Ugui", "Asari", "Subashiri", "Kazunoko", "Yong", "Ni", "Zi", "Qi", "Qing", "Xiang", "Nei", "Chun", "Ji", "Diao", "Qie", "Gu", "Zhou", "Dong", "Lai", "Fei", "Ni", "Yi", "Kun", "Lu", "Jiu", "Chang", "Jing", "Lun", "Ling", "Zou", "Li", "Meng", "Zong", "Zhi", "Nian", "Shachi", "Dojou", "Sukesou", "Shi", "Shen", "Hun", "Shi", "Hou", "Xing", "Zhu", "La", "Zong", "Ji", "Bian", "Bian"], ["Huan", "Quan", "Ze", "Wei", "Wei", "Yu", "Qun", "Rou", "Die", "Huang", "Lian", "Yan", "Qiu", "Qiu", "Jian", "Bi", "E", "Yang", "Fu", "Sai", "Jian", "Xia", "Tuo", "Hu", "Muroaji", "Ruo", "Haraka", "Wen", "Jian", "Hao", "Wu", "Fang", "Sao", "Liu", "Ma", "Shi", "Shi", "Yin", "Z", "Teng", "Ta", "Yao", "Ge", "Rong", "Qian", "Qi", "Wen", "Ruo", "Hatahata", "Lian", "Ao", "Le", "Hui", "Min", "Ji", "Tiao", "Qu", "Jian", "Sao", "Man", "Xi", "Qiu", "Biao", "Ji", "Ji", "Zhu", "Jiang", "Qiu", "Zhuan", "Yong", "Zhang", "Kang", "Xue", "Bie", "Jue", "Qu", "Xiang", "Bo", "Jiao", "Xun", "Su", "Huang", "Zun", "Shan", "Shan", "Fan", "Jue", "Lin", "Xun", "Miao", "Xi", "Eso", "Kyou", "Fen", "Guan", "Hou", "Kuai", "Zei", "Sao", "Zhan", "Gan", "Gui", "Sheng", "Li", "Chang", "Hatahata", "Shiira", "Mutsu", "Ru", "Ji", "Xu", "Huo", "Shiira", "Li", "Lie", "Li", "Mie", "Zhen", "Xiang", "E", "Lu", "Guan", "Li", "Xian", "Yu", "Dao", "Ji", "You", "Tun", "Lu", "Fang", "Ba", "He", "Bo", "Ping", "Nian", "Lu", "You", "Zha", "Fu", "Bo", "Bao", "Hou", "Pi", "Tai", "Gui", "Jie", "Kao", "Wei", "Er", "Tong", "Ze", "Hou", "Kuai", "Ji", "Jiao", "Xian", "Za", "Xiang", "Xun", "Geng", "Li", "Lian", "Jian", "Li", "Shi", "Tiao", "Gun", "Sha", "Wan", "Jun", "Ji", "Yong", "Qing", "Ling", "Qi", "Zou", "Fei", "Kun", "Chang", "Gu", "Ni", "Nian", "Diao", "Jing", "Shen", "Shi", "Zi", "Fen", "Die", "Bi", "Chang", "Shi", "Wen", "Wei", "Sai", "E", "Qiu", "Fu", "Huang", "Quan", "Jiang", "Bian", "Sao", "Ao", "Qi", "Ta", "Yin", "Yao", "Fang", "Jian", "Le", "Biao", "Xue", "Bie", "Man", "Min", "Yong", "Wei", "Xi", "Jue", "Shan", "Lin", "Zun", "Huo", "Gan", "Li", "Zhan", "Guan", "Niao", "Yi", "Fu", "Li", "Jiu", "Bu", "Yan", "Fu", "Diao", "Ji", "Feng", "Nio", "Gan", "Shi", "Feng", "Ming", "Bao", "Yuan", "Zhi", "Hu", "Qin", "Fu", "Fen", "Wen", "Jian", "Shi", "Yu"], ["Fou", "Yiao", "Jue", "Jue", "Pi", "Huan", "Zhen", "Bao", "Yan", "Ya", "Zheng", "Fang", "Feng", "Wen", "Ou", "Te", "Jia", "Nu", "Ling", "Mie", "Fu", "Tuo", "Wen", "Li", "Bian", "Zhi", "Ge", "Yuan", "Zi", "Qu", "Xiao", "Zhi", "Dan", "Ju", "You", "Gu", "Zhong", "Yu", "Yang", "Rong", "Ya", "Tie", "Yu", "Shigi", "Ying", "Zhui", "Wu", "Er", "Gua", "Ai", "Zhi", "Yan", "Heng", "Jiao", "Ji", "Lie", "Zhu", "Ren", "Yi", "Hong", "Luo", "Ru", "Mou", "Ge", "Ren", "Jiao", "Xiu", "Zhou", "Zhi", "Luo", "Chidori", "Toki", "Ten", "Luan", "Jia", "Ji", "Yu", "Huan", "Tuo", "Bu", "Wu", "Juan", "Yu", "Bo", "Xun", "Xun", "Bi", "Xi", "Jun", "Ju", "Tu", "Jing", "Ti", "E", "E", "Kuang", "Hu", "Wu", "Shen", "Lai", "Ikaruga", "Kakesu", "Lu", "Ping", "Shu", "Fu", "An", "Zhao", "Peng", "Qin", "Qian", "Bei", "Diao", "Lu", "Que", "Jian", "Ju", "Tu", "Ya", "Yuan", "Qi", "Li", "Ye", "Zhui", "Kong", "Zhui", "Kun", "Sheng", "Qi", "Jing", "Yi", "Yi", "Jing", "Zi", "Lai", "Dong", "Qi", "Chun", "Geng", "Ju", "Qu", "Isuka", "Kikuitadaki", "Ji", "Shu", , "Chi", "Miao", "Rou", "An", "Qiu", "Ti", "Hu", "Ti", "E", "Jie", "Mao", "Fu", "Chun", "Tu", "Yan", "He", "Yuan", "Pian", "Yun", "Mei", "Hu", "Ying", "Dun", "Mu", "Ju", "Tsugumi", "Cang", "Fang", "Gu", "Ying", "Yuan", "Xuan", "Weng", "Shi", "He", "Chu", "Tang", "Xia", "Ruo", "Liu", "Ji", "Gu", "Jian", "Zhun", "Han", "Zi", "Zi", "Ni", "Yao", "Yan", "Ji", "Li", "Tian", "Kou", "Ti", "Ti", "Ni", "Tu", "Ma", "Jiao", "Gao", "Tian", "Chen", "Li", "Zhuan", "Zhe", "Ao", "Yao", "Yi", "Ou", "Chi", "Zhi", "Liao", "Rong", "Lou", "Bi", "Shuang", "Zhuo", "Yu", "Wu", "Jue", "Yin", "Quan", "Si", "Jiao", "Yi", "Hua", "Bi", "Ying", "Su", "Huang", "Fan", "Jiao", "Liao", "Yan", "Kao", "Jiu", "Xian", "Xian", "Tu", "Mai", "Zun", "Yu", "Ying", "Lu", "Tuan", "Xian", "Xue", "Yi", "Pi"], ["Shu", "Luo", "Qi", "Yi", "Ji", "Zhe", "Yu", "Zhan", "Ye", "Yang", "Pi", "Ning", "Huo", "Mi", "Ying", "Meng", "Di", "Yue", "Yu", "Lei", "Bao", "Lu", "He", "Long", "Shuang", "Yue", "Ying", "Guan", "Qu", "Li", "Luan", "Niao", "Jiu", "Ji", "Yuan", "Ming", "Shi", "Ou", "Ya", "Cang", "Bao", "Zhen", "Gu", "Dong", "Lu", "Ya", "Xiao", "Yang", "Ling", "Zhi", "Qu", "Yuan", "Xue", "Tuo", "Si", "Zhi", "Er", "Gua", "Xiu", "Heng", "Zhou", "Ge", "Luan", "Hong", "Wu", "Bo", "Li", "Juan", "Hu", "E", "Yu", "Xian", "Ti", "Wu", "Que", "Miao", "An", "Kun", "Bei", "Peng", "Qian", "Chun", "Geng", "Yuan", "Su", "Hu", "He", "E", "Gu", "Qiu", "Zi", "Mei", "Mu", "Ni", "Yao", "Weng", "Liu", "Ji", "Ni", "Jian", "He", "Yi", "Ying", "Zhe", "Liao", "Liao", "Jiao", "Jiu", "Yu", "Lu", "Xuan", "Zhan", "Ying", "Huo", "Meng", "Guan", "Shuang", "Lu", "Jin", "Ling", "Jian", "Xian", "Cuo", "Jian", "Jian", "Yan", "Cuo", "Lu", "You", "Cu", "Ji", "Biao", "Cu", "Biao", "Zhu", "Jun", "Zhu", "Jian", "Mi", "Mi", "Wu", "Liu", "Chen", "Jun", "Lin", "Ni", "Qi", "Lu", "Jiu", "Jun", "Jing", "Li", "Xiang", "Yan", "Jia", "Mi", "Li", "She", "Zhang", "Lin", "Jing", "Ji", "Ling", "Yan", "Cu", "Mai", "Mai", "Ge", "Chao", "Fu", "Mian", "Mian", "Fu", "Pao", "Qu", "Qu", "Mou", "Fu", "Xian", "Lai", "Qu", "Mian", , "Feng", "Fu", "Qu", "Mian", "Ma", "Mo", "Mo", "Hui", "Ma", "Zou", "Nen", "Fen", "Huang", "Huang", "Jin", "Guang", "Tian", "Tou", "Heng", "Xi", "Kuang", "Heng", "Shu", "Li", "Nian", "Chi", "Hei", "Hei", "Yi", "Qian", "Dan", "Xi", "Tuan", "Mo", "Mo", "Qian", "Dai", "Chu", "You", "Dian", "Yi", "Xia", "Yan", "Qu", "Mei", "Yan", "Jing", "Yu", "Li", "Dang", "Du", "Can", "Yin", "An", "Yan", "Tan", "An", "Zhen", "Dai", "Can", "Yi", "Mei", "Dan", "Yan", "Du", "Lu", "Zhi", "Fen", "Fu", "Fu", "Min", "Min", "Yuan"], ["Cu", "Qu", "Chao", "Wa", "Zhu", "Zhi", "Mang", "Ao", "Bie", "Tuo", "Bi", "Yuan", "Chao", "Tuo", "Ding", "Mi", "Nai", "Ding", "Zi", "Gu", "Gu", "Dong", "Fen", "Tao", "Yuan", "Pi", "Chang", "Gao", "Qi", "Yuan", "Tang", "Teng", "Shu", "Shu", "Fen", "Fei", "Wen", "Ba", "Diao", "Tuo", "Tong", "Qu", "Sheng", "Shi", "You", "Shi", "Ting", "Wu", "Nian", "Jing", "Hun", "Ju", "Yan", "Tu", "Ti", "Xi", "Xian", "Yan", "Lei", "Bi", "Yao", "Qiu", "Han", "Wu", "Wu", "Hou", "Xi", "Ge", "Zha", "Xiu", "Weng", "Zha", "Nong", "Nang", "Qi", "Zhai", "Ji", "Zi", "Ji", "Ji", "Qi", "Ji", "Chi", "Chen", "Chen", "He", "Ya", "Ken", "Xie", "Pao", "Cuo", "Shi", "Zi", "Chi", "Nian", "Ju", "Tiao", "Ling", "Ling", "Chu", "Quan", "Xie", "Ken", "Nie", "Jiu", "Yao", "Chuo", "Kun", "Yu", "Chu", "Yi", "Ni", "Cuo", "Zou", "Qu", "Nen", "Xian", "Ou", "E", "Wo", "Yi", "Chuo", "Zou", "Dian", "Chu", "Jin", "Ya", "Chi", "Chen", "He", "Ken", "Ju", "Ling", "Pao", "Tiao", "Zi", "Ken", "Yu", "Chuo", "Qu", "Wo", "Long", "Pang", "Gong", "Pang", "Yan", "Long", "Long", "Gong", "Kan", "Ta", "Ling", "Ta", "Long", "Gong", "Kan", "Gui", "Qiu", "Bie", "Gui", "Yue", "Chui", "He", "Jue", "Xie", "Yu"], ["it", "ix", "i", "ip", "iet", "iex", "ie", "iep", "at", "ax", "a", "ap", "uox", "uo", "uop", "ot", "ox", "o", "op", "ex", "e", "wu", "bit", "bix", "bi", "bip", "biet", "biex", "bie", "biep", "bat", "bax", "ba", "bap", "buox", "buo", "buop", "bot", "box", "bo", "bop", "bex", "be", "bep", "but", "bux", "bu", "bup", "burx", "bur", "byt", "byx", "by", "byp", "byrx", "byr", "pit", "pix", "pi", "pip", "piex", "pie", "piep", "pat", "pax", "pa", "pap", "puox", "puo", "puop", "pot", "pox", "po", "pop", "put", "pux", "pu", "pup", "purx", "pur", "pyt", "pyx", "py", "pyp", "pyrx", "pyr", "bbit", "bbix", "bbi", "bbip", "bbiet", "bbiex", "bbie", "bbiep", "bbat", "bbax", "bba", "bbap", "bbuox", "bbuo", "bbuop", "bbot", "bbox", "bbo", "bbop", "bbex", "bbe", "bbep", "bbut", "bbux", "bbu", "bbup", "bburx", "bbur", "bbyt", "bbyx", "bby", "bbyp", "nbit", "nbix", "nbi", "nbip", "nbiex", "nbie", "nbiep", "nbat", "nbax", "nba", "nbap", "nbot", "nbox", "nbo", "nbop", "nbut", "nbux", "nbu", "nbup", "nburx", "nbur", "nbyt", "nbyx", "nby", "nbyp", "nbyrx", "nbyr", "hmit", "hmix", "hmi", "hmip", "hmiex", "hmie", "hmiep", "hmat", "hmax", "hma", "hmap", "hmuox", "hmuo", "hmuop", "hmot", "hmox", "hmo", "hmop", "hmut", "hmux", "hmu", "hmup", "hmurx", "hmur", "hmyx", "hmy", "hmyp", "hmyrx", "hmyr", "mit", "mix", "mi", "mip", "miex", "mie", "miep", "mat", "max", "ma", "map", "muot", "muox", "muo", "muop", "mot", "mox", "mo", "mop", "mex", "me", "mut", "mux", "mu", "mup", "murx", "mur", "myt", "myx", "my", "myp", "fit", "fix", "fi", "fip", "fat", "fax", "fa", "fap", "fox", "fo", "fop", "fut", "fux", "fu", "fup", "furx", "fur", "fyt", "fyx", "fy", "fyp", "vit", "vix", "vi", "vip", "viet", "viex", "vie", "viep", "vat", "vax", "va", "vap", "vot", "vox", "vo", "vop", "vex", "vep", "vut", "vux", "vu", "vup", "vurx", "vur", "vyt", "vyx", "vy", "vyp", "vyrx", "vyr"], ["dit", "dix", "di", "dip", "diex", "die", "diep", "dat", "dax", "da", "dap", "duox", "duo", "dot", "dox", "do", "dop", "dex", "de", "dep", "dut", "dux", "du", "dup", "durx", "dur", "tit", "tix", "ti", "tip", "tiex", "tie", "tiep", "tat", "tax", "ta", "tap", "tuot", "tuox", "tuo", "tuop", "tot", "tox", "to", "top", "tex", "te", "tep", "tut", "tux", "tu", "tup", "turx", "tur", "ddit", "ddix", "ddi", "ddip", "ddiex", "ddie", "ddiep", "ddat", "ddax", "dda", "ddap", "dduox", "dduo", "dduop", "ddot", "ddox", "ddo", "ddop", "ddex", "dde", "ddep", "ddut", "ddux", "ddu", "ddup", "ddurx", "ddur", "ndit", "ndix", "ndi", "ndip", "ndiex", "ndie", "ndat", "ndax", "nda", "ndap", "ndot", "ndox", "ndo", "ndop", "ndex", "nde", "ndep", "ndut", "ndux", "ndu", "ndup", "ndurx", "ndur", "hnit", "hnix", "hni", "hnip", "hniet", "hniex", "hnie", "hniep", "hnat", "hnax", "hna", "hnap", "hnuox", "hnuo", "hnot", "hnox", "hnop", "hnex", "hne", "hnep", "hnut", "nit", "nix", "ni", "nip", "niex", "nie", "niep", "nax", "na", "nap", "nuox", "nuo", "nuop", "not", "nox", "no", "nop", "nex", "ne", "nep", "nut", "nux", "nu", "nup", "nurx", "nur", "hlit", "hlix", "hli", "hlip", "hliex", "hlie", "hliep", "hlat", "hlax", "hla", "hlap", "hluox", "hluo", "hluop", "hlox", "hlo", "hlop", "hlex", "hle", "hlep", "hlut", "hlux", "hlu", "hlup", "hlurx", "hlur", "hlyt", "hlyx", "hly", "hlyp", "hlyrx", "hlyr", "lit", "lix", "li", "lip", "liet", "liex", "lie", "liep", "lat", "lax", "la", "lap", "luot", "luox", "luo", "luop", "lot", "lox", "lo", "lop", "lex", "le", "lep", "lut", "lux", "lu", "lup", "lurx", "lur", "lyt", "lyx", "ly", "lyp", "lyrx", "lyr", "git", "gix", "gi", "gip", "giet", "giex", "gie", "giep", "gat", "gax", "ga", "gap", "guot", "guox", "guo", "guop", "got", "gox", "go", "gop", "get", "gex", "ge", "gep", "gut", "gux", "gu", "gup", "gurx", "gur", "kit", "kix", "ki", "kip", "kiex", "kie", "kiep", "kat"], ["kax", "ka", "kap", "kuox", "kuo", "kuop", "kot", "kox", "ko", "kop", "ket", "kex", "ke", "kep", "kut", "kux", "ku", "kup", "kurx", "kur", "ggit", "ggix", "ggi", "ggiex", "ggie", "ggiep", "ggat", "ggax", "gga", "ggap", "gguot", "gguox", "gguo", "gguop", "ggot", "ggox", "ggo", "ggop", "gget", "ggex", "gge", "ggep", "ggut", "ggux", "ggu", "ggup", "ggurx", "ggur", "mgiex", "mgie", "mgat", "mgax", "mga", "mgap", "mguox", "mguo", "mguop", "mgot", "mgox", "mgo", "mgop", "mgex", "mge", "mgep", "mgut", "mgux", "mgu", "mgup", "mgurx", "mgur", "hxit", "hxix", "hxi", "hxip", "hxiet", "hxiex", "hxie", "hxiep", "hxat", "hxax", "hxa", "hxap", "hxuot", "hxuox", "hxuo", "hxuop", "hxot", "hxox", "hxo", "hxop", "hxex", "hxe", "hxep", "ngiex", "ngie", "ngiep", "ngat", "ngax", "nga", "ngap", "nguot", "nguox", "nguo", "ngot", "ngox", "ngo", "ngop", "ngex", "nge", "ngep", "hit", "hiex", "hie", "hat", "hax", "ha", "hap", "huot", "huox", "huo", "huop", "hot", "hox", "ho", "hop", "hex", "he", "hep", "wat", "wax", "wa", "wap", "wuox", "wuo", "wuop", "wox", "wo", "wop", "wex", "we", "wep", "zit", "zix", "zi", "zip", "ziex", "zie", "ziep", "zat", "zax", "za", "zap", "zuox", "zuo", "zuop", "zot", "zox", "zo", "zop", "zex", "ze", "zep", "zut", "zux", "zu", "zup", "zurx", "zur", "zyt", "zyx", "zy", "zyp", "zyrx", "zyr", "cit", "cix", "ci", "cip", "ciet", "ciex", "cie", "ciep", "cat", "cax", "ca", "cap", "cuox", "cuo", "cuop", "cot", "cox", "co", "cop", "cex", "ce", "cep", "cut", "cux", "cu", "cup", "curx", "cur", "cyt", "cyx", "cy", "cyp", "cyrx", "cyr", "zzit", "zzix", "zzi", "zzip", "zziet", "zziex", "zzie", "zziep", "zzat", "zzax", "zza", "zzap", "zzox", "zzo", "zzop", "zzex", "zze", "zzep", "zzux", "zzu", "zzup", "zzurx", "zzur", "zzyt", "zzyx", "zzy", "zzyp", "zzyrx", "zzyr", "nzit", "nzix", "nzi", "nzip", "nziex", "nzie", "nziep", "nzat", "nzax", "nza", "nzap", "nzuox", "nzuo", "nzox", "nzop", "nzex", "nze", "nzux", "nzu"], ["nzup", "nzurx", "nzur", "nzyt", "nzyx", "nzy", "nzyp", "nzyrx", "nzyr", "sit", "six", "si", "sip", "siex", "sie", "siep", "sat", "sax", "sa", "sap", "suox", "suo", "suop", "sot", "sox", "so", "sop", "sex", "se", "sep", "sut", "sux", "su", "sup", "surx", "sur", "syt", "syx", "sy", "syp", "syrx", "syr", "ssit", "ssix", "ssi", "ssip", "ssiex", "ssie", "ssiep", "ssat", "ssax", "ssa", "ssap", "ssot", "ssox", "sso", "ssop", "ssex", "sse", "ssep", "ssut", "ssux", "ssu", "ssup", "ssyt", "ssyx", "ssy", "ssyp", "ssyrx", "ssyr", "zhat", "zhax", "zha", "zhap", "zhuox", "zhuo", "zhuop", "zhot", "zhox", "zho", "zhop", "zhet", "zhex", "zhe", "zhep", "zhut", "zhux", "zhu", "zhup", "zhurx", "zhur", "zhyt", "zhyx", "zhy", "zhyp", "zhyrx", "zhyr", "chat", "chax", "cha", "chap", "chuot", "chuox", "chuo", "chuop", "chot", "chox", "cho", "chop", "chet", "chex", "che", "chep", "chux", "chu", "chup", "churx", "chur", "chyt", "chyx", "chy", "chyp", "chyrx", "chyr", "rrax", "rra", "rruox", "rruo", "rrot", "rrox", "rro", "rrop", "rret", "rrex", "rre", "rrep", "rrut", "rrux", "rru", "rrup", "rrurx", "rrur", "rryt", "rryx", "rry", "rryp", "rryrx", "rryr", "nrat", "nrax", "nra", "nrap", "nrox", "nro", "nrop", "nret", "nrex", "nre", "nrep", "nrut", "nrux", "nru", "nrup", "nrurx", "nrur", "nryt", "nryx", "nry", "nryp", "nryrx", "nryr", "shat", "shax", "sha", "shap", "shuox", "shuo", "shuop", "shot", "shox", "sho", "shop", "shet", "shex", "she", "shep", "shut", "shux", "shu", "shup", "shurx", "shur", "shyt", "shyx", "shy", "shyp", "shyrx", "shyr", "rat", "rax", "ra", "rap", "ruox", "ruo", "ruop", "rot", "rox", "ro", "rop", "rex", "re", "rep", "rut", "rux", "ru", "rup", "rurx", "rur", "ryt", "ryx", "ry", "ryp", "ryrx", "ryr", "jit", "jix", "ji", "jip", "jiet", "jiex", "jie", "jiep", "juot", "juox", "juo", "juop", "jot", "jox", "jo", "jop", "jut", "jux", "ju", "jup", "jurx", "jur", "jyt", "jyx", "jy", "jyp", "jyrx", "jyr", "qit", "qix", "qi", "qip"], ["qiet", "qiex", "qie", "qiep", "quot", "quox", "quo", "quop", "qot", "qox", "qo", "qop", "qut", "qux", "qu", "qup", "qurx", "qur", "qyt", "qyx", "qy", "qyp", "qyrx", "qyr", "jjit", "jjix", "jji", "jjip", "jjiet", "jjiex", "jjie", "jjiep", "jjuox", "jjuo", "jjuop", "jjot", "jjox", "jjo", "jjop", "jjut", "jjux", "jju", "jjup", "jjurx", "jjur", "jjyt", "jjyx", "jjy", "jjyp", "njit", "njix", "nji", "njip", "njiet", "njiex", "njie", "njiep", "njuox", "njuo", "njot", "njox", "njo", "njop", "njux", "nju", "njup", "njurx", "njur", "njyt", "njyx", "njy", "njyp", "njyrx", "njyr", "nyit", "nyix", "nyi", "nyip", "nyiet", "nyiex", "nyie", "nyiep", "nyuox", "nyuo", "nyuop", "nyot", "nyox", "nyo", "nyop", "nyut", "nyux", "nyu", "nyup", "xit", "xix", "xi", "xip", "xiet", "xiex", "xie", "xiep", "xuox", "xuo", "xot", "xox", "xo", "xop", "xyt", "xyx", "xy", "xyp", "xyrx", "xyr", "yit", "yix", "yi", "yip", "yiet", "yiex", "yie", "yiep", "yuot", "yuox", "yuo", "yuop", "yot", "yox", "yo", "yop", "yut", "yux", "yu", "yup", "yurx", "yur", "yyt", "yyx", "yy", "yyp", "yyrx", "yyr", , , , "Qot", "Li", "Kit", "Nyip", "Cyp", "Ssi", "Ggop", "Gep", "Mi", "Hxit", "Lyr", "Bbut", "Mop", "Yo", "Put", "Hxuo", "Tat", "Ga", , , "Ddur", "Bur", "Gguo", "Nyop", "Tu", "Op", "Jjut", "Zot", "Pyt", "Hmo", "Yit", "Vur", "Shy", "Vep", "Za", "Jo", , "Jjy", "Got", "Jjie", "Wo", "Du", "Shur", "Lie", "Cy", "Cuop", "Cip", "Hxop", "Shat", , "Shop", "Che", "Zziet", , "Ke"], [], [], [, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "A", "a", "A", "a", "HENG", "heng", "TZ", "tz", "3", "3", "4", "4", "4", "4", "F", "S", "AA", "aa", "AO", "ao", "AU", "au", "AV", "av", "AV-", "av-", "AY", "ay", "C", "c", "K", "k", "K", "k", "K", "k", "L", "l", "L", "l", "O", "o", "O", "o", "OO", "oo", "P", "p", "P", "p", "P", "p", "Q", "q", "Q", "q", "R", "r", "R", "r", "V", "v", "VY", "vy", "Z", "z", "TH", "th", "TH", "th", "Y", "y", "ET", "et", "IS", "is", "CON", "con", "US", "us", "dum", "lum", "num", "rum", "RUM", "tum", "um", "D", "d", "F", "f", "G", "G", "g", "L", "l", "R", "r", "S", "s", "T", "t", "^", ":", "=", "'", "'", "H", "l", ".", "N", "n", "C", "c", "c", "h", "B", "b", "F", "f", "AE", "ae", "OE", "oe", "UE", "ue", "G", "g", "K", "k", "N", "n", "R", "r", "S", "s", "H", "E", "G", "L", "I", "Q", "K", "T", "J", "CHI", "B", "b", "O", "o", "U", "u", , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "I", "H", "oe", "M", "F", "P", "M", "I", "M1"], [], [], [], [], ["ga", "gag", "gagg", "gags", "gan", "ganj", "ganh", "gad", "gal", "galg", "galm", "galb", "gals", "galt", "galp", "galh", "gam", "gab", "gabs", "gas", "gass", "gang", "gaj", "gac", "gak", "gat", "gap", "gah", "gae", "gaeg", "gaegg", "gaegs", "gaen", "gaenj", "gaenh", "gaed", "gael", "gaelg", "gaelm", "gaelb", "gaels", "gaelt", "gaelp", "gaelh", "gaem", "gaeb", "gaebs", "gaes", "gaess", "gaeng", "gaej", "gaec", "gaek", "gaet", "gaep", "gaeh", "gya", "gyag", "gyagg", "gyags", "gyan", "gyanj", "gyanh", "gyad", "gyal", "gyalg", "gyalm", "gyalb", "gyals", "gyalt", "gyalp", "gyalh", "gyam", "gyab", "gyabs", "gyas", "gyass", "gyang", "gyaj", "gyac", "gyak", "gyat", "gyap", "gyah", "gyae", "gyaeg", "gyaegg", "gyaegs", "gyaen", "gyaenj", "gyaenh", "gyaed", "gyael", "gyaelg", "gyaelm", "gyaelb", "gyaels", "gyaelt", "gyaelp", "gyaelh", "gyaem", "gyaeb", "gyaebs", "gyaes", "gyaess", "gyaeng", "gyaej", "gyaec", "gyaek", "gyaet", "gyaep", "gyaeh", "geo", "geog", "geogg", "geogs", "geon", "geonj", "geonh", "geod", "geol", "geolg", "geolm", "geolb", "geols", "geolt", "geolp", "geolh", "geom", "geob", "geobs", "geos", "geoss", "geong", "geoj", "geoc", "geok", "geot", "geop", "geoh", "ge", "geg", "gegg", "gegs", "gen", "genj", "genh", "ged", "gel", "gelg", "gelm", "gelb", "gels", "gelt", "gelp", "gelh", "gem", "geb", "gebs", "ges", "gess", "geng", "gej", "gec", "gek", "get", "gep", "geh", "gyeo", "gyeog", "gyeogg", "gyeogs", "gyeon", "gyeonj", "gyeonh", "gyeod", "gyeol", "gyeolg", "gyeolm", "gyeolb", "gyeols", "gyeolt", "gyeolp", "gyeolh", "gyeom", "gyeob", "gyeobs", "gyeos", "gyeoss", "gyeong", "gyeoj", "gyeoc", "gyeok", "gyeot", "gyeop", "gyeoh", "gye", "gyeg", "gyegg", "gyegs", "gyen", "gyenj", "gyenh", "gyed", "gyel", "gyelg", "gyelm", "gyelb", "gyels", "gyelt", "gyelp", "gyelh", "gyem", "gyeb", "gyebs", "gyes", "gyess", "gyeng", "gyej", "gyec", "gyek", "gyet", "gyep", "gyeh", "go", "gog", "gogg", "gogs", "gon", "gonj", "gonh", "god", "gol", "golg", "golm", "golb", "gols", "golt", "golp", "golh", "gom", "gob", "gobs", "gos", "goss", "gong", "goj", "goc", "gok", "got", "gop", "goh", "gwa", "gwag", "gwagg", "gwags"], ["gwan", "gwanj", "gwanh", "gwad", "gwal", "gwalg", "gwalm", "gwalb", "gwals", "gwalt", "gwalp", "gwalh", "gwam", "gwab", "gwabs", "gwas", "gwass", "gwang", "gwaj", "gwac", "gwak", "gwat", "gwap", "gwah", "gwae", "gwaeg", "gwaegg", "gwaegs", "gwaen", "gwaenj", "gwaenh", "gwaed", "gwael", "gwaelg", "gwaelm", "gwaelb", "gwaels", "gwaelt", "gwaelp", "gwaelh", "gwaem", "gwaeb", "gwaebs", "gwaes", "gwaess", "gwaeng", "gwaej", "gwaec", "gwaek", "gwaet", "gwaep", "gwaeh", "goe", "goeg", "goegg", "goegs", "goen", "goenj", "goenh", "goed", "goel", "goelg", "goelm", "goelb", "goels", "goelt", "goelp", "goelh", "goem", "goeb", "goebs", "goes", "goess", "goeng", "goej", "goec", "goek", "goet", "goep", "goeh", "gyo", "gyog", "gyogg", "gyogs", "gyon", "gyonj", "gyonh", "gyod", "gyol", "gyolg", "gyolm", "gyolb", "gyols", "gyolt", "gyolp", "gyolh", "gyom", "gyob", "gyobs", "gyos", "gyoss", "gyong", "gyoj", "gyoc", "gyok", "gyot", "gyop", "gyoh", "gu", "gug", "gugg", "gugs", "gun", "gunj", "gunh", "gud", "gul", "gulg", "gulm", "gulb", "guls", "gult", "gulp", "gulh", "gum", "gub", "gubs", "gus", "guss", "gung", "guj", "guc", "guk", "gut", "gup", "guh", "gweo", "gweog", "gweogg", "gweogs", "gweon", "gweonj", "gweonh", "gweod", "gweol", "gweolg", "gweolm", "gweolb", "gweols", "gweolt", "gweolp", "gweolh", "gweom", "gweob", "gweobs", "gweos", "gweoss", "gweong", "gweoj", "gweoc", "gweok", "gweot", "gweop", "gweoh", "gwe", "gweg", "gwegg", "gwegs", "gwen", "gwenj", "gwenh", "gwed", "gwel", "gwelg", "gwelm", "gwelb", "gwels", "gwelt", "gwelp", "gwelh", "gwem", "gweb", "gwebs", "gwes", "gwess", "gweng", "gwej", "gwec", "gwek", "gwet", "gwep", "gweh", "gwi", "gwig", "gwigg", "gwigs", "gwin", "gwinj", "gwinh", "gwid", "gwil", "gwilg", "gwilm", "gwilb", "gwils", "gwilt", "gwilp", "gwilh", "gwim", "gwib", "gwibs", "gwis", "gwiss", "gwing", "gwij", "gwic", "gwik", "gwit", "gwip", "gwih", "gyu", "gyug", "gyugg", "gyugs", "gyun", "gyunj", "gyunh", "gyud", "gyul", "gyulg", "gyulm", "gyulb", "gyuls", "gyult", "gyulp", "gyulh", "gyum", "gyub", "gyubs", "gyus", "gyuss", "gyung", "gyuj", "gyuc", "gyuk", "gyut", "gyup", "gyuh", "geu", "geug", "geugg", "geugs", "geun", "geunj", "geunh", "geud"], ["geul", "geulg", "geulm", "geulb", "geuls", "geult", "geulp", "geulh", "geum", "geub", "geubs", "geus", "geuss", "geung", "geuj", "geuc", "geuk", "geut", "geup", "geuh", "gyi", "gyig", "gyigg", "gyigs", "gyin", "gyinj", "gyinh", "gyid", "gyil", "gyilg", "gyilm", "gyilb", "gyils", "gyilt", "gyilp", "gyilh", "gyim", "gyib", "gyibs", "gyis", "gyiss", "gying", "gyij", "gyic", "gyik", "gyit", "gyip", "gyih", "gi", "gig", "gigg", "gigs", "gin", "ginj", "ginh", "gid", "gil", "gilg", "gilm", "gilb", "gils", "gilt", "gilp", "gilh", "gim", "gib", "gibs", "gis", "giss", "ging", "gij", "gic", "gik", "git", "gip", "gih", "gga", "ggag", "ggagg", "ggags", "ggan", "gganj", "gganh", "ggad", "ggal", "ggalg", "ggalm", "ggalb", "ggals", "ggalt", "ggalp", "ggalh", "ggam", "ggab", "ggabs", "ggas", "ggass", "ggang", "ggaj", "ggac", "ggak", "ggat", "ggap", "ggah", "ggae", "ggaeg", "ggaegg", "ggaegs", "ggaen", "ggaenj", "ggaenh", "ggaed", "ggael", "ggaelg", "ggaelm", "ggaelb", "ggaels", "ggaelt", "ggaelp", "ggaelh", "ggaem", "ggaeb", "ggaebs", "ggaes", "ggaess", "ggaeng", "ggaej", "ggaec", "ggaek", "ggaet", "ggaep", "ggaeh", "ggya", "ggyag", "ggyagg", "ggyags", "ggyan", "ggyanj", "ggyanh", "ggyad", "ggyal", "ggyalg", "ggyalm", "ggyalb", "ggyals", "ggyalt", "ggyalp", "ggyalh", "ggyam", "ggyab", "ggyabs", "ggyas", "ggyass", "ggyang", "ggyaj", "ggyac", "ggyak", "ggyat", "ggyap", "ggyah", "ggyae", "ggyaeg", "ggyaegg", "ggyaegs", "ggyaen", "ggyaenj", "ggyaenh", "ggyaed", "ggyael", "ggyaelg", "ggyaelm", "ggyaelb", "ggyaels", "ggyaelt", "ggyaelp", "ggyaelh", "ggyaem", "ggyaeb", "ggyaebs", "ggyaes", "ggyaess", "ggyaeng", "ggyaej", "ggyaec", "ggyaek", "ggyaet", "ggyaep", "ggyaeh", "ggeo", "ggeog", "ggeogg", "ggeogs", "ggeon", "ggeonj", "ggeonh", "ggeod", "ggeol", "ggeolg", "ggeolm", "ggeolb", "ggeols", "ggeolt", "ggeolp", "ggeolh", "ggeom", "ggeob", "ggeobs", "ggeos", "ggeoss", "ggeong", "ggeoj", "ggeoc", "ggeok", "ggeot", "ggeop", "ggeoh", "gge", "ggeg", "ggegg", "ggegs", "ggen", "ggenj", "ggenh", "gged", "ggel", "ggelg", "ggelm", "ggelb", "ggels", "ggelt", "ggelp", "ggelh", "ggem", "ggeb", "ggebs", "gges", "ggess", "ggeng", "ggej", "ggec", "ggek", "gget", "ggep", "ggeh", "ggyeo", "ggyeog", "ggyeogg", "ggyeogs", "ggyeon", "ggyeonj", "ggyeonh", "ggyeod", "ggyeol", "ggyeolg", "ggyeolm", "ggyeolb"], ["ggyeols", "ggyeolt", "ggyeolp", "ggyeolh", "ggyeom", "ggyeob", "ggyeobs", "ggyeos", "ggyeoss", "ggyeong", "ggyeoj", "ggyeoc", "ggyeok", "ggyeot", "ggyeop", "ggyeoh", "ggye", "ggyeg", "ggyegg", "ggyegs", "ggyen", "ggyenj", "ggyenh", "ggyed", "ggyel", "ggyelg", "ggyelm", "ggyelb", "ggyels", "ggyelt", "ggyelp", "ggyelh", "ggyem", "ggyeb", "ggyebs", "ggyes", "ggyess", "ggyeng", "ggyej", "ggyec", "ggyek", "ggyet", "ggyep", "ggyeh", "ggo", "ggog", "ggogg", "ggogs", "ggon", "ggonj", "ggonh", "ggod", "ggol", "ggolg", "ggolm", "ggolb", "ggols", "ggolt", "ggolp", "ggolh", "ggom", "ggob", "ggobs", "ggos", "ggoss", "ggong", "ggoj", "ggoc", "ggok", "ggot", "ggop", "ggoh", "ggwa", "ggwag", "ggwagg", "ggwags", "ggwan", "ggwanj", "ggwanh", "ggwad", "ggwal", "ggwalg", "ggwalm", "ggwalb", "ggwals", "ggwalt", "ggwalp", "ggwalh", "ggwam", "ggwab", "ggwabs", "ggwas", "ggwass", "ggwang", "ggwaj", "ggwac", "ggwak", "ggwat", "ggwap", "ggwah", "ggwae", "ggwaeg", "ggwaegg", "ggwaegs", "ggwaen", "ggwaenj", "ggwaenh", "ggwaed", "ggwael", "ggwaelg", "ggwaelm", "ggwaelb", "ggwaels", "ggwaelt", "ggwaelp", "ggwaelh", "ggwaem", "ggwaeb", "ggwaebs", "ggwaes", "ggwaess", "ggwaeng", "ggwaej", "ggwaec", "ggwaek", "ggwaet", "ggwaep", "ggwaeh", "ggoe", "ggoeg", "ggoegg", "ggoegs", "ggoen", "ggoenj", "ggoenh", "ggoed", "ggoel", "ggoelg", "ggoelm", "ggoelb", "ggoels", "ggoelt", "ggoelp", "ggoelh", "ggoem", "ggoeb", "ggoebs", "ggoes", "ggoess", "ggoeng", "ggoej", "ggoec", "ggoek", "ggoet", "ggoep", "ggoeh", "ggyo", "ggyog", "ggyogg", "ggyogs", "ggyon", "ggyonj", "ggyonh", "ggyod", "ggyol", "ggyolg", "ggyolm", "ggyolb", "ggyols", "ggyolt", "ggyolp", "ggyolh", "ggyom", "ggyob", "ggyobs", "ggyos", "ggyoss", "ggyong", "ggyoj", "ggyoc", "ggyok", "ggyot", "ggyop", "ggyoh", "ggu", "ggug", "ggugg", "ggugs", "ggun", "ggunj", "ggunh", "ggud", "ggul", "ggulg", "ggulm", "ggulb", "gguls", "ggult", "ggulp", "ggulh", "ggum", "ggub", "ggubs", "ggus", "gguss", "ggung", "gguj", "gguc", "gguk", "ggut", "ggup", "gguh", "ggweo", "ggweog", "ggweogg", "ggweogs", "ggweon", "ggweonj", "ggweonh", "ggweod", "ggweol", "ggweolg", "ggweolm", "ggweolb", "ggweols", "ggweolt", "ggweolp", "ggweolh", "ggweom", "ggweob", "ggweobs", "ggweos", "ggweoss", "ggweong", "ggweoj", "ggweoc", "ggweok", "ggweot", "ggweop", "ggweoh", "ggwe", "ggweg", "ggwegg", "ggwegs", "ggwen", "ggwenj", "ggwenh", "ggwed", "ggwel", "ggwelg", "ggwelm", "ggwelb", "ggwels", "ggwelt", "ggwelp", "ggwelh"], ["ggwem", "ggweb", "ggwebs", "ggwes", "ggwess", "ggweng", "ggwej", "ggwec", "ggwek", "ggwet", "ggwep", "ggweh", "ggwi", "ggwig", "ggwigg", "ggwigs", "ggwin", "ggwinj", "ggwinh", "ggwid", "ggwil", "ggwilg", "ggwilm", "ggwilb", "ggwils", "ggwilt", "ggwilp", "ggwilh", "ggwim", "ggwib", "ggwibs", "ggwis", "ggwiss", "ggwing", "ggwij", "ggwic", "ggwik", "ggwit", "ggwip", "ggwih", "ggyu", "ggyug", "ggyugg", "ggyugs", "ggyun", "ggyunj", "ggyunh", "ggyud", "ggyul", "ggyulg", "ggyulm", "ggyulb", "ggyuls", "ggyult", "ggyulp", "ggyulh", "ggyum", "ggyub", "ggyubs", "ggyus", "ggyuss", "ggyung", "ggyuj", "ggyuc", "ggyuk", "ggyut", "ggyup", "ggyuh", "ggeu", "ggeug", "ggeugg", "ggeugs", "ggeun", "ggeunj", "ggeunh", "ggeud", "ggeul", "ggeulg", "ggeulm", "ggeulb", "ggeuls", "ggeult", "ggeulp", "ggeulh", "ggeum", "ggeub", "ggeubs", "ggeus", "ggeuss", "ggeung", "ggeuj", "ggeuc", "ggeuk", "ggeut", "ggeup", "ggeuh", "ggyi", "ggyig", "ggyigg", "ggyigs", "ggyin", "ggyinj", "ggyinh", "ggyid", "ggyil", "ggyilg", "ggyilm", "ggyilb", "ggyils", "ggyilt", "ggyilp", "ggyilh", "ggyim", "ggyib", "ggyibs", "ggyis", "ggyiss", "ggying", "ggyij", "ggyic", "ggyik", "ggyit", "ggyip", "ggyih", "ggi", "ggig", "ggigg", "ggigs", "ggin", "gginj", "gginh", "ggid", "ggil", "ggilg", "ggilm", "ggilb", "ggils", "ggilt", "ggilp", "ggilh", "ggim", "ggib", "ggibs", "ggis", "ggiss", "gging", "ggij", "ggic", "ggik", "ggit", "ggip", "ggih", "na", "nag", "nagg", "nags", "nan", "nanj", "nanh", "nad", "nal", "nalg", "nalm", "nalb", "nals", "nalt", "nalp", "nalh", "nam", "nab", "nabs", "nas", "nass", "nang", "naj", "nac", "nak", "nat", "nap", "nah", "nae", "naeg", "naegg", "naegs", "naen", "naenj", "naenh", "naed", "nael", "naelg", "naelm", "naelb", "naels", "naelt", "naelp", "naelh", "naem", "naeb", "naebs", "naes", "naess", "naeng", "naej", "naec", "naek", "naet", "naep", "naeh", "nya", "nyag", "nyagg", "nyags", "nyan", "nyanj", "nyanh", "nyad", "nyal", "nyalg", "nyalm", "nyalb", "nyals", "nyalt", "nyalp", "nyalh", "nyam", "nyab", "nyabs", "nyas", "nyass", "nyang", "nyaj", "nyac", "nyak", "nyat", "nyap", "nyah", "nyae", "nyaeg", "nyaegg", "nyaegs", "nyaen", "nyaenj", "nyaenh", "nyaed", "nyael", "nyaelg", "nyaelm", "nyaelb", "nyaels", "nyaelt", "nyaelp", "nyaelh", "nyaem", "nyaeb", "nyaebs", "nyaes"], ["nyaess", "nyaeng", "nyaej", "nyaec", "nyaek", "nyaet", "nyaep", "nyaeh", "neo", "neog", "neogg", "neogs", "neon", "neonj", "neonh", "neod", "neol", "neolg", "neolm", "neolb", "neols", "neolt", "neolp", "neolh", "neom", "neob", "neobs", "neos", "neoss", "neong", "neoj", "neoc", "neok", "neot", "neop", "neoh", "ne", "neg", "negg", "negs", "nen", "nenj", "nenh", "ned", "nel", "nelg", "nelm", "nelb", "nels", "nelt", "nelp", "nelh", "nem", "neb", "nebs", "nes", "ness", "neng", "nej", "nec", "nek", "net", "nep", "neh", "nyeo", "nyeog", "nyeogg", "nyeogs", "nyeon", "nyeonj", "nyeonh", "nyeod", "nyeol", "nyeolg", "nyeolm", "nyeolb", "nyeols", "nyeolt", "nyeolp", "nyeolh", "nyeom", "nyeob", "nyeobs", "nyeos", "nyeoss", "nyeong", "nyeoj", "nyeoc", "nyeok", "nyeot", "nyeop", "nyeoh", "nye", "nyeg", "nyegg", "nyegs", "nyen", "nyenj", "nyenh", "nyed", "nyel", "nyelg", "nyelm", "nyelb", "nyels", "nyelt", "nyelp", "nyelh", "nyem", "nyeb", "nyebs", "nyes", "nyess", "nyeng", "nyej", "nyec", "nyek", "nyet", "nyep", "nyeh", "no", "nog", "nogg", "nogs", "non", "nonj", "nonh", "nod", "nol", "nolg", "nolm", "nolb", "nols", "nolt", "nolp", "nolh", "nom", "nob", "nobs", "nos", "noss", "nong", "noj", "noc", "nok", "not", "nop", "noh", "nwa", "nwag", "nwagg", "nwags", "nwan", "nwanj", "nwanh", "nwad", "nwal", "nwalg", "nwalm", "nwalb", "nwals", "nwalt", "nwalp", "nwalh", "nwam", "nwab", "nwabs", "nwas", "nwass", "nwang", "nwaj", "nwac", "nwak", "nwat", "nwap", "nwah", "nwae", "nwaeg", "nwaegg", "nwaegs", "nwaen", "nwaenj", "nwaenh", "nwaed", "nwael", "nwaelg", "nwaelm", "nwaelb", "nwaels", "nwaelt", "nwaelp", "nwaelh", "nwaem", "nwaeb", "nwaebs", "nwaes", "nwaess", "nwaeng", "nwaej", "nwaec", "nwaek", "nwaet", "nwaep", "nwaeh", "noe", "noeg", "noegg", "noegs", "noen", "noenj", "noenh", "noed", "noel", "noelg", "noelm", "noelb", "noels", "noelt", "noelp", "noelh", "noem", "noeb", "noebs", "noes", "noess", "noeng", "noej", "noec", "noek", "noet", "noep", "noeh", "nyo", "nyog", "nyogg", "nyogs", "nyon", "nyonj", "nyonh", "nyod", "nyol", "nyolg", "nyolm", "nyolb", "nyols", "nyolt", "nyolp", "nyolh", "nyom", "nyob", "nyobs", "nyos", "nyoss", "nyong", "nyoj", "nyoc"], ["nyok", "nyot", "nyop", "nyoh", "nu", "nug", "nugg", "nugs", "nun", "nunj", "nunh", "nud", "nul", "nulg", "nulm", "nulb", "nuls", "nult", "nulp", "nulh", "num", "nub", "nubs", "nus", "nuss", "nung", "nuj", "nuc", "nuk", "nut", "nup", "nuh", "nweo", "nweog", "nweogg", "nweogs", "nweon", "nweonj", "nweonh", "nweod", "nweol", "nweolg", "nweolm", "nweolb", "nweols", "nweolt", "nweolp", "nweolh", "nweom", "nweob", "nweobs", "nweos", "nweoss", "nweong", "nweoj", "nweoc", "nweok", "nweot", "nweop", "nweoh", "nwe", "nweg", "nwegg", "nwegs", "nwen", "nwenj", "nwenh", "nwed", "nwel", "nwelg", "nwelm", "nwelb", "nwels", "nwelt", "nwelp", "nwelh", "nwem", "nweb", "nwebs", "nwes", "nwess", "nweng", "nwej", "nwec", "nwek", "nwet", "nwep", "nweh", "nwi", "nwig", "nwigg", "nwigs", "nwin", "nwinj", "nwinh", "nwid", "nwil", "nwilg", "nwilm", "nwilb", "nwils", "nwilt", "nwilp", "nwilh", "nwim", "nwib", "nwibs", "nwis", "nwiss", "nwing", "nwij", "nwic", "nwik", "nwit", "nwip", "nwih", "nyu", "nyug", "nyugg", "nyugs", "nyun", "nyunj", "nyunh", "nyud", "nyul", "nyulg", "nyulm", "nyulb", "nyuls", "nyult", "nyulp", "nyulh", "nyum", "nyub", "nyubs", "nyus", "nyuss", "nyung", "nyuj", "nyuc", "nyuk", "nyut", "nyup", "nyuh", "neu", "neug", "neugg", "neugs", "neun", "neunj", "neunh", "neud", "neul", "neulg", "neulm", "neulb", "neuls", "neult", "neulp", "neulh", "neum", "neub", "neubs", "neus", "neuss", "neung", "neuj", "neuc", "neuk", "neut", "neup", "neuh", "nyi", "nyig", "nyigg", "nyigs", "nyin", "nyinj", "nyinh", "nyid", "nyil", "nyilg", "nyilm", "nyilb", "nyils", "nyilt", "nyilp", "nyilh", "nyim", "nyib", "nyibs", "nyis", "nyiss", "nying", "nyij", "nyic", "nyik", "nyit", "nyip", "nyih", "ni", "nig", "nigg", "nigs", "nin", "ninj", "ninh", "nid", "nil", "nilg", "nilm", "nilb", "nils", "nilt", "nilp", "nilh", "nim", "nib", "nibs", "nis", "niss", "ning", "nij", "nic", "nik", "nit", "nip", "nih", "da", "dag", "dagg", "dags", "dan", "danj", "danh", "dad", "dal", "dalg", "dalm", "dalb", "dals", "dalt", "dalp", "dalh", "dam", "dab", "dabs", "das", "dass", "dang", "daj", "dac", "dak", "dat", "dap", "dah"], ["dae", "daeg", "daegg", "daegs", "daen", "daenj", "daenh", "daed", "dael", "daelg", "daelm", "daelb", "daels", "daelt", "daelp", "daelh", "daem", "daeb", "daebs", "daes", "daess", "daeng", "daej", "daec", "daek", "daet", "daep", "daeh", "dya", "dyag", "dyagg", "dyags", "dyan", "dyanj", "dyanh", "dyad", "dyal", "dyalg", "dyalm", "dyalb", "dyals", "dyalt", "dyalp", "dyalh", "dyam", "dyab", "dyabs", "dyas", "dyass", "dyang", "dyaj", "dyac", "dyak", "dyat", "dyap", "dyah", "dyae", "dyaeg", "dyaegg", "dyaegs", "dyaen", "dyaenj", "dyaenh", "dyaed", "dyael", "dyaelg", "dyaelm", "dyaelb", "dyaels", "dyaelt", "dyaelp", "dyaelh", "dyaem", "dyaeb", "dyaebs", "dyaes", "dyaess", "dyaeng", "dyaej", "dyaec", "dyaek", "dyaet", "dyaep", "dyaeh", "deo", "deog", "deogg", "deogs", "deon", "deonj", "deonh", "deod", "deol", "deolg", "deolm", "deolb", "deols", "deolt", "deolp", "deolh", "deom", "deob", "deobs", "deos", "deoss", "deong", "deoj", "deoc", "deok", "deot", "deop", "deoh", "de", "deg", "degg", "degs", "den", "denj", "denh", "ded", "del", "delg", "delm", "delb", "dels", "delt", "delp", "delh", "dem", "deb", "debs", "des", "dess", "deng", "dej", "dec", "dek", "det", "dep", "deh", "dyeo", "dyeog", "dyeogg", "dyeogs", "dyeon", "dyeonj", "dyeonh", "dyeod", "dyeol", "dyeolg", "dyeolm", "dyeolb", "dyeols", "dyeolt", "dyeolp", "dyeolh", "dyeom", "dyeob", "dyeobs", "dyeos", "dyeoss", "dyeong", "dyeoj", "dyeoc", "dyeok", "dyeot", "dyeop", "dyeoh", "dye", "dyeg", "dyegg", "dyegs", "dyen", "dyenj", "dyenh", "dyed", "dyel", "dyelg", "dyelm", "dyelb", "dyels", "dyelt", "dyelp", "dyelh", "dyem", "dyeb", "dyebs", "dyes", "dyess", "dyeng", "dyej", "dyec", "dyek", "dyet", "dyep", "dyeh", "do", "dog", "dogg", "dogs", "don", "donj", "donh", "dod", "dol", "dolg", "dolm", "dolb", "dols", "dolt", "dolp", "dolh", "dom", "dob", "dobs", "dos", "doss", "dong", "doj", "doc", "dok", "dot", "dop", "doh", "dwa", "dwag", "dwagg", "dwags", "dwan", "dwanj", "dwanh", "dwad", "dwal", "dwalg", "dwalm", "dwalb", "dwals", "dwalt", "dwalp", "dwalh", "dwam", "dwab", "dwabs", "dwas", "dwass", "dwang", "dwaj", "dwac", "dwak", "dwat", "dwap", "dwah", "dwae", "dwaeg", "dwaegg", "dwaegs"], ["dwaen", "dwaenj", "dwaenh", "dwaed", "dwael", "dwaelg", "dwaelm", "dwaelb", "dwaels", "dwaelt", "dwaelp", "dwaelh", "dwaem", "dwaeb", "dwaebs", "dwaes", "dwaess", "dwaeng", "dwaej", "dwaec", "dwaek", "dwaet", "dwaep", "dwaeh", "doe", "doeg", "doegg", "doegs", "doen", "doenj", "doenh", "doed", "doel", "doelg", "doelm", "doelb", "doels", "doelt", "doelp", "doelh", "doem", "doeb", "doebs", "does", "doess", "doeng", "doej", "doec", "doek", "doet", "doep", "doeh", "dyo", "dyog", "dyogg", "dyogs", "dyon", "dyonj", "dyonh", "dyod", "dyol", "dyolg", "dyolm", "dyolb", "dyols", "dyolt", "dyolp", "dyolh", "dyom", "dyob", "dyobs", "dyos", "dyoss", "dyong", "dyoj", "dyoc", "dyok", "dyot", "dyop", "dyoh", "du", "dug", "dugg", "dugs", "dun", "dunj", "dunh", "dud", "dul", "dulg", "dulm", "dulb", "duls", "dult", "dulp", "dulh", "dum", "dub", "dubs", "dus", "duss", "dung", "duj", "duc", "duk", "dut", "dup", "duh", "dweo", "dweog", "dweogg", "dweogs", "dweon", "dweonj", "dweonh", "dweod", "dweol", "dweolg", "dweolm", "dweolb", "dweols", "dweolt", "dweolp", "dweolh", "dweom", "dweob", "dweobs", "dweos", "dweoss", "dweong", "dweoj", "dweoc", "dweok", "dweot", "dweop", "dweoh", "dwe", "dweg", "dwegg", "dwegs", "dwen", "dwenj", "dwenh", "dwed", "dwel", "dwelg", "dwelm", "dwelb", "dwels", "dwelt", "dwelp", "dwelh", "dwem", "dweb", "dwebs", "dwes", "dwess", "dweng", "dwej", "dwec", "dwek", "dwet", "dwep", "dweh", "dwi", "dwig", "dwigg", "dwigs", "dwin", "dwinj", "dwinh", "dwid", "dwil", "dwilg", "dwilm", "dwilb", "dwils", "dwilt", "dwilp", "dwilh", "dwim", "dwib", "dwibs", "dwis", "dwiss", "dwing", "dwij", "dwic", "dwik", "dwit", "dwip", "dwih", "dyu", "dyug", "dyugg", "dyugs", "dyun", "dyunj", "dyunh", "dyud", "dyul", "dyulg", "dyulm", "dyulb", "dyuls", "dyult", "dyulp", "dyulh", "dyum", "dyub", "dyubs", "dyus", "dyuss", "dyung", "dyuj", "dyuc", "dyuk", "dyut", "dyup", "dyuh", "deu", "deug", "deugg", "deugs", "deun", "deunj", "deunh", "deud", "deul", "deulg", "deulm", "deulb", "deuls", "deult", "deulp", "deulh", "deum", "deub", "deubs", "deus", "deuss", "deung", "deuj", "deuc", "deuk", "deut", "deup", "deuh", "dyi", "dyig", "dyigg", "dyigs", "dyin", "dyinj", "dyinh", "dyid"], ["dyil", "dyilg", "dyilm", "dyilb", "dyils", "dyilt", "dyilp", "dyilh", "dyim", "dyib", "dyibs", "dyis", "dyiss", "dying", "dyij", "dyic", "dyik", "dyit", "dyip", "dyih", "di", "dig", "digg", "digs", "din", "dinj", "dinh", "did", "dil", "dilg", "dilm", "dilb", "dils", "dilt", "dilp", "dilh", "dim", "dib", "dibs", "dis", "diss", "ding", "dij", "dic", "dik", "dit", "dip", "dih", "dda", "ddag", "ddagg", "ddags", "ddan", "ddanj", "ddanh", "ddad", "ddal", "ddalg", "ddalm", "ddalb", "ddals", "ddalt", "ddalp", "ddalh", "ddam", "ddab", "ddabs", "ddas", "ddass", "ddang", "ddaj", "ddac", "ddak", "ddat", "ddap", "ddah", "ddae", "ddaeg", "ddaegg", "ddaegs", "ddaen", "ddaenj", "ddaenh", "ddaed", "ddael", "ddaelg", "ddaelm", "ddaelb", "ddaels", "ddaelt", "ddaelp", "ddaelh", "ddaem", "ddaeb", "ddaebs", "ddaes", "ddaess", "ddaeng", "ddaej", "ddaec", "ddaek", "ddaet", "ddaep", "ddaeh", "ddya", "ddyag", "ddyagg", "ddyags", "ddyan", "ddyanj", "ddyanh", "ddyad", "ddyal", "ddyalg", "ddyalm", "ddyalb", "ddyals", "ddyalt", "ddyalp", "ddyalh", "ddyam", "ddyab", "ddyabs", "ddyas", "ddyass", "ddyang", "ddyaj", "ddyac", "ddyak", "ddyat", "ddyap", "ddyah", "ddyae", "ddyaeg", "ddyaegg", "ddyaegs", "ddyaen", "ddyaenj", "ddyaenh", "ddyaed", "ddyael", "ddyaelg", "ddyaelm", "ddyaelb", "ddyaels", "ddyaelt", "ddyaelp", "ddyaelh", "ddyaem", "ddyaeb", "ddyaebs", "ddyaes", "ddyaess", "ddyaeng", "ddyaej", "ddyaec", "ddyaek", "ddyaet", "ddyaep", "ddyaeh", "ddeo", "ddeog", "ddeogg", "ddeogs", "ddeon", "ddeonj", "ddeonh", "ddeod", "ddeol", "ddeolg", "ddeolm", "ddeolb", "ddeols", "ddeolt", "ddeolp", "ddeolh", "ddeom", "ddeob", "ddeobs", "ddeos", "ddeoss", "ddeong", "ddeoj", "ddeoc", "ddeok", "ddeot", "ddeop", "ddeoh", "dde", "ddeg", "ddegg", "ddegs", "dden", "ddenj", "ddenh", "dded", "ddel", "ddelg", "ddelm", "ddelb", "ddels", "ddelt", "ddelp", "ddelh", "ddem", "ddeb", "ddebs", "ddes", "ddess", "ddeng", "ddej", "ddec", "ddek", "ddet", "ddep", "ddeh", "ddyeo", "ddyeog", "ddyeogg", "ddyeogs", "ddyeon", "ddyeonj", "ddyeonh", "ddyeod", "ddyeol", "ddyeolg", "ddyeolm", "ddyeolb", "ddyeols", "ddyeolt", "ddyeolp", "ddyeolh", "ddyeom", "ddyeob", "ddyeobs", "ddyeos", "ddyeoss", "ddyeong", "ddyeoj", "ddyeoc", "ddyeok", "ddyeot", "ddyeop", "ddyeoh", "ddye", "ddyeg", "ddyegg", "ddyegs", "ddyen", "ddyenj", "ddyenh", "ddyed", "ddyel", "ddyelg", "ddyelm", "ddyelb"], ["ddyels", "ddyelt", "ddyelp", "ddyelh", "ddyem", "ddyeb", "ddyebs", "ddyes", "ddyess", "ddyeng", "ddyej", "ddyec", "ddyek", "ddyet", "ddyep", "ddyeh", "ddo", "ddog", "ddogg", "ddogs", "ddon", "ddonj", "ddonh", "ddod", "ddol", "ddolg", "ddolm", "ddolb", "ddols", "ddolt", "ddolp", "ddolh", "ddom", "ddob", "ddobs", "ddos", "ddoss", "ddong", "ddoj", "ddoc", "ddok", "ddot", "ddop", "ddoh", "ddwa", "ddwag", "ddwagg", "ddwags", "ddwan", "ddwanj", "ddwanh", "ddwad", "ddwal", "ddwalg", "ddwalm", "ddwalb", "ddwals", "ddwalt", "ddwalp", "ddwalh", "ddwam", "ddwab", "ddwabs", "ddwas", "ddwass", "ddwang", "ddwaj", "ddwac", "ddwak", "ddwat", "ddwap", "ddwah", "ddwae", "ddwaeg", "ddwaegg", "ddwaegs", "ddwaen", "ddwaenj", "ddwaenh", "ddwaed", "ddwael", "ddwaelg", "ddwaelm", "ddwaelb", "ddwaels", "ddwaelt", "ddwaelp", "ddwaelh", "ddwaem", "ddwaeb", "ddwaebs", "ddwaes", "ddwaess", "ddwaeng", "ddwaej", "ddwaec", "ddwaek", "ddwaet", "ddwaep", "ddwaeh", "ddoe", "ddoeg", "ddoegg", "ddoegs", "ddoen", "ddoenj", "ddoenh", "ddoed", "ddoel", "ddoelg", "ddoelm", "ddoelb", "ddoels", "ddoelt", "ddoelp", "ddoelh", "ddoem", "ddoeb", "ddoebs", "ddoes", "ddoess", "ddoeng", "ddoej", "ddoec", "ddoek", "ddoet", "ddoep", "ddoeh", "ddyo", "ddyog", "ddyogg", "ddyogs", "ddyon", "ddyonj", "ddyonh", "ddyod", "ddyol", "ddyolg", "ddyolm", "ddyolb", "ddyols", "ddyolt", "ddyolp", "ddyolh", "ddyom", "ddyob", "ddyobs", "ddyos", "ddyoss", "ddyong", "ddyoj", "ddyoc", "ddyok", "ddyot", "ddyop", "ddyoh", "ddu", "ddug", "ddugg", "ddugs", "ddun", "ddunj", "ddunh", "ddud", "ddul", "ddulg", "ddulm", "ddulb", "dduls", "ddult", "ddulp", "ddulh", "ddum", "ddub", "ddubs", "ddus", "dduss", "ddung", "dduj", "dduc", "dduk", "ddut", "ddup", "dduh", "ddweo", "ddweog", "ddweogg", "ddweogs", "ddweon", "ddweonj", "ddweonh", "ddweod", "ddweol", "ddweolg", "ddweolm", "ddweolb", "ddweols", "ddweolt", "ddweolp", "ddweolh", "ddweom", "ddweob", "ddweobs", "ddweos", "ddweoss", "ddweong", "ddweoj", "ddweoc", "ddweok", "ddweot", "ddweop", "ddweoh", "ddwe", "ddweg", "ddwegg", "ddwegs", "ddwen", "ddwenj", "ddwenh", "ddwed", "ddwel", "ddwelg", "ddwelm", "ddwelb", "ddwels", "ddwelt", "ddwelp", "ddwelh", "ddwem", "ddweb", "ddwebs", "ddwes", "ddwess", "ddweng", "ddwej", "ddwec", "ddwek", "ddwet", "ddwep", "ddweh", "ddwi", "ddwig", "ddwigg", "ddwigs", "ddwin", "ddwinj", "ddwinh", "ddwid", "ddwil", "ddwilg", "ddwilm", "ddwilb", "ddwils", "ddwilt", "ddwilp", "ddwilh"], ["ddwim", "ddwib", "ddwibs", "ddwis", "ddwiss", "ddwing", "ddwij", "ddwic", "ddwik", "ddwit", "ddwip", "ddwih", "ddyu", "ddyug", "ddyugg", "ddyugs", "ddyun", "ddyunj", "ddyunh", "ddyud", "ddyul", "ddyulg", "ddyulm", "ddyulb", "ddyuls", "ddyult", "ddyulp", "ddyulh", "ddyum", "ddyub", "ddyubs", "ddyus", "ddyuss", "ddyung", "ddyuj", "ddyuc", "ddyuk", "ddyut", "ddyup", "ddyuh", "ddeu", "ddeug", "ddeugg", "ddeugs", "ddeun", "ddeunj", "ddeunh", "ddeud", "ddeul", "ddeulg", "ddeulm", "ddeulb", "ddeuls", "ddeult", "ddeulp", "ddeulh", "ddeum", "ddeub", "ddeubs", "ddeus", "ddeuss", "ddeung", "ddeuj", "ddeuc", "ddeuk", "ddeut", "ddeup", "ddeuh", "ddyi", "ddyig", "ddyigg", "ddyigs", "ddyin", "ddyinj", "ddyinh", "ddyid", "ddyil", "ddyilg", "ddyilm", "ddyilb", "ddyils", "ddyilt", "ddyilp", "ddyilh", "ddyim", "ddyib", "ddyibs", "ddyis", "ddyiss", "ddying", "ddyij", "ddyic", "ddyik", "ddyit", "ddyip", "ddyih", "ddi", "ddig", "ddigg", "ddigs", "ddin", "ddinj", "ddinh", "ddid", "ddil", "ddilg", "ddilm", "ddilb", "ddils", "ddilt", "ddilp", "ddilh", "ddim", "ddib", "ddibs", "ddis", "ddiss", "dding", "ddij", "ddic", "ddik", "ddit", "ddip", "ddih", "ra", "rag", "ragg", "rags", "ran", "ranj", "ranh", "rad", "ral", "ralg", "ralm", "ralb", "rals", "ralt", "ralp", "ralh", "ram", "rab", "rabs", "ras", "rass", "rang", "raj", "rac", "rak", "rat", "rap", "rah", "rae", "raeg", "raegg", "raegs", "raen", "raenj", "raenh", "raed", "rael", "raelg", "raelm", "raelb", "raels", "raelt", "raelp", "raelh", "raem", "raeb", "raebs", "raes", "raess", "raeng", "raej", "raec", "raek", "raet", "raep", "raeh", "rya", "ryag", "ryagg", "ryags", "ryan", "ryanj", "ryanh", "ryad", "ryal", "ryalg", "ryalm", "ryalb", "ryals", "ryalt", "ryalp", "ryalh", "ryam", "ryab", "ryabs", "ryas", "ryass", "ryang", "ryaj", "ryac", "ryak", "ryat", "ryap", "ryah", "ryae", "ryaeg", "ryaegg", "ryaegs", "ryaen", "ryaenj", "ryaenh", "ryaed", "ryael", "ryaelg", "ryaelm", "ryaelb", "ryaels", "ryaelt", "ryaelp", "ryaelh", "ryaem", "ryaeb", "ryaebs", "ryaes", "ryaess", "ryaeng", "ryaej", "ryaec", "ryaek", "ryaet", "ryaep", "ryaeh", "reo", "reog", "reogg", "reogs", "reon", "reonj", "reonh", "reod", "reol", "reolg", "reolm", "reolb", "reols", "reolt", "reolp", "reolh", "reom", "reob", "reobs", "reos"], ["reoss", "reong", "reoj", "reoc", "reok", "reot", "reop", "reoh", "re", "reg", "regg", "regs", "ren", "renj", "renh", "red", "rel", "relg", "relm", "relb", "rels", "relt", "relp", "relh", "rem", "reb", "rebs", "res", "ress", "reng", "rej", "rec", "rek", "ret", "rep", "reh", "ryeo", "ryeog", "ryeogg", "ryeogs", "ryeon", "ryeonj", "ryeonh", "ryeod", "ryeol", "ryeolg", "ryeolm", "ryeolb", "ryeols", "ryeolt", "ryeolp", "ryeolh", "ryeom", "ryeob", "ryeobs", "ryeos", "ryeoss", "ryeong", "ryeoj", "ryeoc", "ryeok", "ryeot", "ryeop", "ryeoh", "rye", "ryeg", "ryegg", "ryegs", "ryen", "ryenj", "ryenh", "ryed", "ryel", "ryelg", "ryelm", "ryelb", "ryels", "ryelt", "ryelp", "ryelh", "ryem", "ryeb", "ryebs", "ryes", "ryess", "ryeng", "ryej", "ryec", "ryek", "ryet", "ryep", "ryeh", "ro", "rog", "rogg", "rogs", "ron", "ronj", "ronh", "rod", "rol", "rolg", "rolm", "rolb", "rols", "rolt", "rolp", "rolh", "rom", "rob", "robs", "ros", "ross", "rong", "roj", "roc", "rok", "rot", "rop", "roh", "rwa", "rwag", "rwagg", "rwags", "rwan", "rwanj", "rwanh", "rwad", "rwal", "rwalg", "rwalm", "rwalb", "rwals", "rwalt", "rwalp", "rwalh", "rwam", "rwab", "rwabs", "rwas", "rwass", "rwang", "rwaj", "rwac", "rwak", "rwat", "rwap", "rwah", "rwae", "rwaeg", "rwaegg", "rwaegs", "rwaen", "rwaenj", "rwaenh", "rwaed", "rwael", "rwaelg", "rwaelm", "rwaelb", "rwaels", "rwaelt", "rwaelp", "rwaelh", "rwaem", "rwaeb", "rwaebs", "rwaes", "rwaess", "rwaeng", "rwaej", "rwaec", "rwaek", "rwaet", "rwaep", "rwaeh", "roe", "roeg", "roegg", "roegs", "roen", "roenj", "roenh", "roed", "roel", "roelg", "roelm", "roelb", "roels", "roelt", "roelp", "roelh", "roem", "roeb", "roebs", "roes", "roess", "roeng", "roej", "roec", "roek", "roet", "roep", "roeh", "ryo", "ryog", "ryogg", "ryogs", "ryon", "ryonj", "ryonh", "ryod", "ryol", "ryolg", "ryolm", "ryolb", "ryols", "ryolt", "ryolp", "ryolh", "ryom", "ryob", "ryobs", "ryos", "ryoss", "ryong", "ryoj", "ryoc", "ryok", "ryot", "ryop", "ryoh", "ru", "rug", "rugg", "rugs", "run", "runj", "runh", "rud", "rul", "rulg", "rulm", "rulb", "ruls", "rult", "rulp", "rulh", "rum", "rub", "rubs", "rus", "russ", "rung", "ruj", "ruc"], ["ruk", "rut", "rup", "ruh", "rweo", "rweog", "rweogg", "rweogs", "rweon", "rweonj", "rweonh", "rweod", "rweol", "rweolg", "rweolm", "rweolb", "rweols", "rweolt", "rweolp", "rweolh", "rweom", "rweob", "rweobs", "rweos", "rweoss", "rweong", "rweoj", "rweoc", "rweok", "rweot", "rweop", "rweoh", "rwe", "rweg", "rwegg", "rwegs", "rwen", "rwenj", "rwenh", "rwed", "rwel", "rwelg", "rwelm", "rwelb", "rwels", "rwelt", "rwelp", "rwelh", "rwem", "rweb", "rwebs", "rwes", "rwess", "rweng", "rwej", "rwec", "rwek", "rwet", "rwep", "rweh", "rwi", "rwig", "rwigg", "rwigs", "rwin", "rwinj", "rwinh", "rwid", "rwil", "rwilg", "rwilm", "rwilb", "rwils", "rwilt", "rwilp", "rwilh", "rwim", "rwib", "rwibs", "rwis", "rwiss", "rwing", "rwij", "rwic", "rwik", "rwit", "rwip", "rwih", "ryu", "ryug", "ryugg", "ryugs", "ryun", "ryunj", "ryunh", "ryud", "ryul", "ryulg", "ryulm", "ryulb", "ryuls", "ryult", "ryulp", "ryulh", "ryum", "ryub", "ryubs", "ryus", "ryuss", "ryung", "ryuj", "ryuc", "ryuk", "ryut", "ryup", "ryuh", "reu", "reug", "reugg", "reugs", "reun", "reunj", "reunh", "reud", "reul", "reulg", "reulm", "reulb", "reuls", "reult", "reulp", "reulh", "reum", "reub", "reubs", "reus", "reuss", "reung", "reuj", "reuc", "reuk", "reut", "reup", "reuh", "ryi", "ryig", "ryigg", "ryigs", "ryin", "ryinj", "ryinh", "ryid", "ryil", "ryilg", "ryilm", "ryilb", "ryils", "ryilt", "ryilp", "ryilh", "ryim", "ryib", "ryibs", "ryis", "ryiss", "rying", "ryij", "ryic", "ryik", "ryit", "ryip", "ryih", "ri", "rig", "rigg", "rigs", "rin", "rinj", "rinh", "rid", "ril", "rilg", "rilm", "rilb", "rils", "rilt", "rilp", "rilh", "rim", "rib", "ribs", "ris", "riss", "ring", "rij", "ric", "rik", "rit", "rip", "rih", "ma", "mag", "magg", "mags", "man", "manj", "manh", "mad", "mal", "malg", "malm", "malb", "mals", "malt", "malp", "malh", "mam", "mab", "mabs", "mas", "mass", "mang", "maj", "mac", "mak", "mat", "map", "mah", "mae", "maeg", "maegg", "maegs", "maen", "maenj", "maenh", "maed", "mael", "maelg", "maelm", "maelb", "maels", "maelt", "maelp", "maelh", "maem", "maeb", "maebs", "maes", "maess", "maeng", "maej", "maec", "maek", "maet", "maep", "maeh"], ["mya", "myag", "myagg", "myags", "myan", "myanj", "myanh", "myad", "myal", "myalg", "myalm", "myalb", "myals", "myalt", "myalp", "myalh", "myam", "myab", "myabs", "myas", "myass", "myang", "myaj", "myac", "myak", "myat", "myap", "myah", "myae", "myaeg", "myaegg", "myaegs", "myaen", "myaenj", "myaenh", "myaed", "myael", "myaelg", "myaelm", "myaelb", "myaels", "myaelt", "myaelp", "myaelh", "myaem", "myaeb", "myaebs", "myaes", "myaess", "myaeng", "myaej", "myaec", "myaek", "myaet", "myaep", "myaeh", "meo", "meog", "meogg", "meogs", "meon", "meonj", "meonh", "meod", "meol", "meolg", "meolm", "meolb", "meols", "meolt", "meolp", "meolh", "meom", "meob", "meobs", "meos", "meoss", "meong", "meoj", "meoc", "meok", "meot", "meop", "meoh", "me", "meg", "megg", "megs", "men", "menj", "menh", "med", "mel", "melg", "melm", "melb", "mels", "melt", "melp", "melh", "mem", "meb", "mebs", "mes", "mess", "meng", "mej", "mec", "mek", "met", "mep", "meh", "myeo", "myeog", "myeogg", "myeogs", "myeon", "myeonj", "myeonh", "myeod", "myeol", "myeolg", "myeolm", "myeolb", "myeols", "myeolt", "myeolp", "myeolh", "myeom", "myeob", "myeobs", "myeos", "myeoss", "myeong", "myeoj", "myeoc", "myeok", "myeot", "myeop", "myeoh", "mye", "myeg", "myegg", "myegs", "myen", "myenj", "myenh", "myed", "myel", "myelg", "myelm", "myelb", "myels", "myelt", "myelp", "myelh", "myem", "myeb", "myebs", "myes", "myess", "myeng", "myej", "myec", "myek", "myet", "myep", "myeh", "mo", "mog", "mogg", "mogs", "mon", "monj", "monh", "mod", "mol", "molg", "molm", "molb", "mols", "molt", "molp", "molh", "mom", "mob", "mobs", "mos", "moss", "mong", "moj", "moc", "mok", "mot", "mop", "moh", "mwa", "mwag", "mwagg", "mwags", "mwan", "mwanj", "mwanh", "mwad", "mwal", "mwalg", "mwalm", "mwalb", "mwals", "mwalt", "mwalp", "mwalh", "mwam", "mwab", "mwabs", "mwas", "mwass", "mwang", "mwaj", "mwac", "mwak", "mwat", "mwap", "mwah", "mwae", "mwaeg", "mwaegg", "mwaegs", "mwaen", "mwaenj", "mwaenh", "mwaed", "mwael", "mwaelg", "mwaelm", "mwaelb", "mwaels", "mwaelt", "mwaelp", "mwaelh", "mwaem", "mwaeb", "mwaebs", "mwaes", "mwaess", "mwaeng", "mwaej", "mwaec", "mwaek", "mwaet", "mwaep", "mwaeh", "moe", "moeg", "moegg", "moegs"], ["moen", "moenj", "moenh", "moed", "moel", "moelg", "moelm", "moelb", "moels", "moelt", "moelp", "moelh", "moem", "moeb", "moebs", "moes", "moess", "moeng", "moej", "moec", "moek", "moet", "moep", "moeh", "myo", "myog", "myogg", "myogs", "myon", "myonj", "myonh", "myod", "myol", "myolg", "myolm", "myolb", "myols", "myolt", "myolp", "myolh", "myom", "myob", "myobs", "myos", "myoss", "myong", "myoj", "myoc", "myok", "myot", "myop", "myoh", "mu", "mug", "mugg", "mugs", "mun", "munj", "munh", "mud", "mul", "mulg", "mulm", "mulb", "muls", "mult", "mulp", "mulh", "mum", "mub", "mubs", "mus", "muss", "mung", "muj", "muc", "muk", "mut", "mup", "muh", "mweo", "mweog", "mweogg", "mweogs", "mweon", "mweonj", "mweonh", "mweod", "mweol", "mweolg", "mweolm", "mweolb", "mweols", "mweolt", "mweolp", "mweolh", "mweom", "mweob", "mweobs", "mweos", "mweoss", "mweong", "mweoj", "mweoc", "mweok", "mweot", "mweop", "mweoh", "mwe", "mweg", "mwegg", "mwegs", "mwen", "mwenj", "mwenh", "mwed", "mwel", "mwelg", "mwelm", "mwelb", "mwels", "mwelt", "mwelp", "mwelh", "mwem", "mweb", "mwebs", "mwes", "mwess", "mweng", "mwej", "mwec", "mwek", "mwet", "mwep", "mweh", "mwi", "mwig", "mwigg", "mwigs", "mwin", "mwinj", "mwinh", "mwid", "mwil", "mwilg", "mwilm", "mwilb", "mwils", "mwilt", "mwilp", "mwilh", "mwim", "mwib", "mwibs", "mwis", "mwiss", "mwing", "mwij", "mwic", "mwik", "mwit", "mwip", "mwih", "myu", "myug", "myugg", "myugs", "myun", "myunj", "myunh", "myud", "myul", "myulg", "myulm", "myulb", "myuls", "myult", "myulp", "myulh", "myum", "myub", "myubs", "myus", "myuss", "myung", "myuj", "myuc", "myuk", "myut", "myup", "myuh", "meu", "meug", "meugg", "meugs", "meun", "meunj", "meunh", "meud", "meul", "meulg", "meulm", "meulb", "meuls", "meult", "meulp", "meulh", "meum", "meub", "meubs", "meus", "meuss", "meung", "meuj", "meuc", "meuk", "meut", "meup", "meuh", "myi", "myig", "myigg", "myigs", "myin", "myinj", "myinh", "myid", "myil", "myilg", "myilm", "myilb", "myils", "myilt", "myilp", "myilh", "myim", "myib", "myibs", "myis", "myiss", "mying", "myij", "myic", "myik", "myit", "myip", "myih", "mi", "mig", "migg", "migs", "min", "minj", "minh", "mid"], ["mil", "milg", "milm", "milb", "mils", "milt", "milp", "milh", "mim", "mib", "mibs", "mis", "miss", "ming", "mij", "mic", "mik", "mit", "mip", "mih", "ba", "bag", "bagg", "bags", "ban", "banj", "banh", "bad", "bal", "balg", "balm", "balb", "bals", "balt", "balp", "balh", "bam", "bab", "babs", "bas", "bass", "bang", "baj", "bac", "bak", "bat", "bap", "bah", "bae", "baeg", "baegg", "baegs", "baen", "baenj", "baenh", "baed", "bael", "baelg", "baelm", "baelb", "baels", "baelt", "baelp", "baelh", "baem", "baeb", "baebs", "baes", "baess", "baeng", "baej", "baec", "baek", "baet", "baep", "baeh", "bya", "byag", "byagg", "byags", "byan", "byanj", "byanh", "byad", "byal", "byalg", "byalm", "byalb", "byals", "byalt", "byalp", "byalh", "byam", "byab", "byabs", "byas", "byass", "byang", "byaj", "byac", "byak", "byat", "byap", "byah", "byae", "byaeg", "byaegg", "byaegs", "byaen", "byaenj", "byaenh", "byaed", "byael", "byaelg", "byaelm", "byaelb", "byaels", "byaelt", "byaelp", "byaelh", "byaem", "byaeb", "byaebs", "byaes", "byaess", "byaeng", "byaej", "byaec", "byaek", "byaet", "byaep", "byaeh", "beo", "beog", "beogg", "beogs", "beon", "beonj", "beonh", "beod", "beol", "beolg", "beolm", "beolb", "beols", "beolt", "beolp", "beolh", "beom", "beob", "beobs", "beos", "beoss", "beong", "beoj", "beoc", "beok", "beot", "beop", "beoh", "be", "beg", "begg", "begs", "ben", "benj", "benh", "bed", "bel", "belg", "belm", "belb", "bels", "belt", "belp", "belh", "bem", "beb", "bebs", "bes", "bess", "beng", "bej", "bec", "bek", "bet", "bep", "beh", "byeo", "byeog", "byeogg", "byeogs", "byeon", "byeonj", "byeonh", "byeod", "byeol", "byeolg", "byeolm", "byeolb", "byeols", "byeolt", "byeolp", "byeolh", "byeom", "byeob", "byeobs", "byeos", "byeoss", "byeong", "byeoj", "byeoc", "byeok", "byeot", "byeop", "byeoh", "bye", "byeg", "byegg", "byegs", "byen", "byenj", "byenh", "byed", "byel", "byelg", "byelm", "byelb", "byels", "byelt", "byelp", "byelh", "byem", "byeb", "byebs", "byes", "byess", "byeng", "byej", "byec", "byek", "byet", "byep", "byeh", "bo", "bog", "bogg", "bogs", "bon", "bonj", "bonh", "bod", "bol", "bolg", "bolm", "bolb"], ["bols", "bolt", "bolp", "bolh", "bom", "bob", "bobs", "bos", "boss", "bong", "boj", "boc", "bok", "bot", "bop", "boh", "bwa", "bwag", "bwagg", "bwags", "bwan", "bwanj", "bwanh", "bwad", "bwal", "bwalg", "bwalm", "bwalb", "bwals", "bwalt", "bwalp", "bwalh", "bwam", "bwab", "bwabs", "bwas", "bwass", "bwang", "bwaj", "bwac", "bwak", "bwat", "bwap", "bwah", "bwae", "bwaeg", "bwaegg", "bwaegs", "bwaen", "bwaenj", "bwaenh", "bwaed", "bwael", "bwaelg", "bwaelm", "bwaelb", "bwaels", "bwaelt", "bwaelp", "bwaelh", "bwaem", "bwaeb", "bwaebs", "bwaes", "bwaess", "bwaeng", "bwaej", "bwaec", "bwaek", "bwaet", "bwaep", "bwaeh", "boe", "boeg", "boegg", "boegs", "boen", "boenj", "boenh", "boed", "boel", "boelg", "boelm", "boelb", "boels", "boelt", "boelp", "boelh", "boem", "boeb", "boebs", "boes", "boess", "boeng", "boej", "boec", "boek", "boet", "boep", "boeh", "byo", "byog", "byogg", "byogs", "byon", "byonj", "byonh", "byod", "byol", "byolg", "byolm", "byolb", "byols", "byolt", "byolp", "byolh", "byom", "byob", "byobs", "byos", "byoss", "byong", "byoj", "byoc", "byok", "byot", "byop", "byoh", "bu", "bug", "bugg", "bugs", "bun", "bunj", "bunh", "bud", "bul", "bulg", "bulm", "bulb", "buls", "bult", "bulp", "bulh", "bum", "bub", "bubs", "bus", "buss", "bung", "buj", "buc", "buk", "but", "bup", "buh", "bweo", "bweog", "bweogg", "bweogs", "bweon", "bweonj", "bweonh", "bweod", "bweol", "bweolg", "bweolm", "bweolb", "bweols", "bweolt", "bweolp", "bweolh", "bweom", "bweob", "bweobs", "bweos", "bweoss", "bweong", "bweoj", "bweoc", "bweok", "bweot", "bweop", "bweoh", "bwe", "bweg", "bwegg", "bwegs", "bwen", "bwenj", "bwenh", "bwed", "bwel", "bwelg", "bwelm", "bwelb", "bwels", "bwelt", "bwelp", "bwelh", "bwem", "bweb", "bwebs", "bwes", "bwess", "bweng", "bwej", "bwec", "bwek", "bwet", "bwep", "bweh", "bwi", "bwig", "bwigg", "bwigs", "bwin", "bwinj", "bwinh", "bwid", "bwil", "bwilg", "bwilm", "bwilb", "bwils", "bwilt", "bwilp", "bwilh", "bwim", "bwib", "bwibs", "bwis", "bwiss", "bwing", "bwij", "bwic", "bwik", "bwit", "bwip", "bwih", "byu", "byug", "byugg", "byugs", "byun", "byunj", "byunh", "byud", "byul", "byulg", "byulm", "byulb", "byuls", "byult", "byulp", "byulh"], ["byum", "byub", "byubs", "byus", "byuss", "byung", "byuj", "byuc", "byuk", "byut", "byup", "byuh", "beu", "beug", "beugg", "beugs", "beun", "beunj", "beunh", "beud", "beul", "beulg", "beulm", "beulb", "beuls", "beult", "beulp", "beulh", "beum", "beub", "beubs", "beus", "beuss", "beung", "beuj", "beuc", "beuk", "beut", "beup", "beuh", "byi", "byig", "byigg", "byigs", "byin", "byinj", "byinh", "byid", "byil", "byilg", "byilm", "byilb", "byils", "byilt", "byilp", "byilh", "byim", "byib", "byibs", "byis", "byiss", "bying", "byij", "byic", "byik", "byit", "byip", "byih", "bi", "big", "bigg", "bigs", "bin", "binj", "binh", "bid", "bil", "bilg", "bilm", "bilb", "bils", "bilt", "bilp", "bilh", "bim", "bib", "bibs", "bis", "biss", "bing", "bij", "bic", "bik", "bit", "bip", "bih", "bba", "bbag", "bbagg", "bbags", "bban", "bbanj", "bbanh", "bbad", "bbal", "bbalg", "bbalm", "bbalb", "bbals", "bbalt", "bbalp", "bbalh", "bbam", "bbab", "bbabs", "bbas", "bbass", "bbang", "bbaj", "bbac", "bbak", "bbat", "bbap", "bbah", "bbae", "bbaeg", "bbaegg", "bbaegs", "bbaen", "bbaenj", "bbaenh", "bbaed", "bbael", "bbaelg", "bbaelm", "bbaelb", "bbaels", "bbaelt", "bbaelp", "bbaelh", "bbaem", "bbaeb", "bbaebs", "bbaes", "bbaess", "bbaeng", "bbaej", "bbaec", "bbaek", "bbaet", "bbaep", "bbaeh", "bbya", "bbyag", "bbyagg", "bbyags", "bbyan", "bbyanj", "bbyanh", "bbyad", "bbyal", "bbyalg", "bbyalm", "bbyalb", "bbyals", "bbyalt", "bbyalp", "bbyalh", "bbyam", "bbyab", "bbyabs", "bbyas", "bbyass", "bbyang", "bbyaj", "bbyac", "bbyak", "bbyat", "bbyap", "bbyah", "bbyae", "bbyaeg", "bbyaegg", "bbyaegs", "bbyaen", "bbyaenj", "bbyaenh", "bbyaed", "bbyael", "bbyaelg", "bbyaelm", "bbyaelb", "bbyaels", "bbyaelt", "bbyaelp", "bbyaelh", "bbyaem", "bbyaeb", "bbyaebs", "bbyaes", "bbyaess", "bbyaeng", "bbyaej", "bbyaec", "bbyaek", "bbyaet", "bbyaep", "bbyaeh", "bbeo", "bbeog", "bbeogg", "bbeogs", "bbeon", "bbeonj", "bbeonh", "bbeod", "bbeol", "bbeolg", "bbeolm", "bbeolb", "bbeols", "bbeolt", "bbeolp", "bbeolh", "bbeom", "bbeob", "bbeobs", "bbeos", "bbeoss", "bbeong", "bbeoj", "bbeoc", "bbeok", "bbeot", "bbeop", "bbeoh", "bbe", "bbeg", "bbegg", "bbegs", "bben", "bbenj", "bbenh", "bbed", "bbel", "bbelg", "bbelm", "bbelb", "bbels", "bbelt", "bbelp", "bbelh", "bbem", "bbeb", "bbebs", "bbes"], ["bbess", "bbeng", "bbej", "bbec", "bbek", "bbet", "bbep", "bbeh", "bbyeo", "bbyeog", "bbyeogg", "bbyeogs", "bbyeon", "bbyeonj", "bbyeonh", "bbyeod", "bbyeol", "bbyeolg", "bbyeolm", "bbyeolb", "bbyeols", "bbyeolt", "bbyeolp", "bbyeolh", "bbyeom", "bbyeob", "bbyeobs", "bbyeos", "bbyeoss", "bbyeong", "bbyeoj", "bbyeoc", "bbyeok", "bbyeot", "bbyeop", "bbyeoh", "bbye", "bbyeg", "bbyegg", "bbyegs", "bbyen", "bbyenj", "bbyenh", "bbyed", "bbyel", "bbyelg", "bbyelm", "bbyelb", "bbyels", "bbyelt", "bbyelp", "bbyelh", "bbyem", "bbyeb", "bbyebs", "bbyes", "bbyess", "bbyeng", "bbyej", "bbyec", "bbyek", "bbyet", "bbyep", "bbyeh", "bbo", "bbog", "bbogg", "bbogs", "bbon", "bbonj", "bbonh", "bbod", "bbol", "bbolg", "bbolm", "bbolb", "bbols", "bbolt", "bbolp", "bbolh", "bbom", "bbob", "bbobs", "bbos", "bboss", "bbong", "bboj", "bboc", "bbok", "bbot", "bbop", "bboh", "bbwa", "bbwag", "bbwagg", "bbwags", "bbwan", "bbwanj", "bbwanh", "bbwad", "bbwal", "bbwalg", "bbwalm", "bbwalb", "bbwals", "bbwalt", "bbwalp", "bbwalh", "bbwam", "bbwab", "bbwabs", "bbwas", "bbwass", "bbwang", "bbwaj", "bbwac", "bbwak", "bbwat", "bbwap", "bbwah", "bbwae", "bbwaeg", "bbwaegg", "bbwaegs", "bbwaen", "bbwaenj", "bbwaenh", "bbwaed", "bbwael", "bbwaelg", "bbwaelm", "bbwaelb", "bbwaels", "bbwaelt", "bbwaelp", "bbwaelh", "bbwaem", "bbwaeb", "bbwaebs", "bbwaes", "bbwaess", "bbwaeng", "bbwaej", "bbwaec", "bbwaek", "bbwaet", "bbwaep", "bbwaeh", "bboe", "bboeg", "bboegg", "bboegs", "bboen", "bboenj", "bboenh", "bboed", "bboel", "bboelg", "bboelm", "bboelb", "bboels", "bboelt", "bboelp", "bboelh", "bboem", "bboeb", "bboebs", "bboes", "bboess", "bboeng", "bboej", "bboec", "bboek", "bboet", "bboep", "bboeh", "bbyo", "bbyog", "bbyogg", "bbyogs", "bbyon", "bbyonj", "bbyonh", "bbyod", "bbyol", "bbyolg", "bbyolm", "bbyolb", "bbyols", "bbyolt", "bbyolp", "bbyolh", "bbyom", "bbyob", "bbyobs", "bbyos", "bbyoss", "bbyong", "bbyoj", "bbyoc", "bbyok", "bbyot", "bbyop", "bbyoh", "bbu", "bbug", "bbugg", "bbugs", "bbun", "bbunj", "bbunh", "bbud", "bbul", "bbulg", "bbulm", "bbulb", "bbuls", "bbult", "bbulp", "bbulh", "bbum", "bbub", "bbubs", "bbus", "bbuss", "bbung", "bbuj", "bbuc", "bbuk", "bbut", "bbup", "bbuh", "bbweo", "bbweog", "bbweogg", "bbweogs", "bbweon", "bbweonj", "bbweonh", "bbweod", "bbweol", "bbweolg", "bbweolm", "bbweolb", "bbweols", "bbweolt", "bbweolp", "bbweolh", "bbweom", "bbweob", "bbweobs", "bbweos", "bbweoss", "bbweong", "bbweoj", "bbweoc"], ["bbweok", "bbweot", "bbweop", "bbweoh", "bbwe", "bbweg", "bbwegg", "bbwegs", "bbwen", "bbwenj", "bbwenh", "bbwed", "bbwel", "bbwelg", "bbwelm", "bbwelb", "bbwels", "bbwelt", "bbwelp", "bbwelh", "bbwem", "bbweb", "bbwebs", "bbwes", "bbwess", "bbweng", "bbwej", "bbwec", "bbwek", "bbwet", "bbwep", "bbweh", "bbwi", "bbwig", "bbwigg", "bbwigs", "bbwin", "bbwinj", "bbwinh", "bbwid", "bbwil", "bbwilg", "bbwilm", "bbwilb", "bbwils", "bbwilt", "bbwilp", "bbwilh", "bbwim", "bbwib", "bbwibs", "bbwis", "bbwiss", "bbwing", "bbwij", "bbwic", "bbwik", "bbwit", "bbwip", "bbwih", "bbyu", "bbyug", "bbyugg", "bbyugs", "bbyun", "bbyunj", "bbyunh", "bbyud", "bbyul", "bbyulg", "bbyulm", "bbyulb", "bbyuls", "bbyult", "bbyulp", "bbyulh", "bbyum", "bbyub", "bbyubs", "bbyus", "bbyuss", "bbyung", "bbyuj", "bbyuc", "bbyuk", "bbyut", "bbyup", "bbyuh", "bbeu", "bbeug", "bbeugg", "bbeugs", "bbeun", "bbeunj", "bbeunh", "bbeud", "bbeul", "bbeulg", "bbeulm", "bbeulb", "bbeuls", "bbeult", "bbeulp", "bbeulh", "bbeum", "bbeub", "bbeubs", "bbeus", "bbeuss", "bbeung", "bbeuj", "bbeuc", "bbeuk", "bbeut", "bbeup", "bbeuh", "bbyi", "bbyig", "bbyigg", "bbyigs", "bbyin", "bbyinj", "bbyinh", "bbyid", "bbyil", "bbyilg", "bbyilm", "bbyilb", "bbyils", "bbyilt", "bbyilp", "bbyilh", "bbyim", "bbyib", "bbyibs", "bbyis", "bbyiss", "bbying", "bbyij", "bbyic", "bbyik", "bbyit", "bbyip", "bbyih", "bbi", "bbig", "bbigg", "bbigs", "bbin", "bbinj", "bbinh", "bbid", "bbil", "bbilg", "bbilm", "bbilb", "bbils", "bbilt", "bbilp", "bbilh", "bbim", "bbib", "bbibs", "bbis", "bbiss", "bbing", "bbij", "bbic", "bbik", "bbit", "bbip", "bbih", "sa", "sag", "sagg", "sags", "san", "sanj", "sanh", "sad", "sal", "salg", "salm", "salb", "sals", "salt", "salp", "salh", "sam", "sab", "sabs", "sas", "sass", "sang", "saj", "sac", "sak", "sat", "sap", "sah", "sae", "saeg", "saegg", "saegs", "saen", "saenj", "saenh", "saed", "sael", "saelg", "saelm", "saelb", "saels", "saelt", "saelp", "saelh", "saem", "saeb", "saebs", "saes", "saess", "saeng", "saej", "saec", "saek", "saet", "saep", "saeh", "sya", "syag", "syagg", "syags", "syan", "syanj", "syanh", "syad", "syal", "syalg", "syalm", "syalb", "syals", "syalt", "syalp", "syalh", "syam", "syab", "syabs", "syas", "syass", "syang", "syaj", "syac", "syak", "syat", "syap", "syah"], ["syae", "syaeg", "syaegg", "syaegs", "syaen", "syaenj", "syaenh", "syaed", "syael", "syaelg", "syaelm", "syaelb", "syaels", "syaelt", "syaelp", "syaelh", "syaem", "syaeb", "syaebs", "syaes", "syaess", "syaeng", "syaej", "syaec", "syaek", "syaet", "syaep", "syaeh", "seo", "seog", "seogg", "seogs", "seon", "seonj", "seonh", "seod", "seol", "seolg", "seolm", "seolb", "seols", "seolt", "seolp", "seolh", "seom", "seob", "seobs", "seos", "seoss", "seong", "seoj", "seoc", "seok", "seot", "seop", "seoh", "se", "seg", "segg", "segs", "sen", "senj", "senh", "sed", "sel", "selg", "selm", "selb", "sels", "selt", "selp", "selh", "sem", "seb", "sebs", "ses", "sess", "seng", "sej", "sec", "sek", "set", "sep", "seh", "syeo", "syeog", "syeogg", "syeogs", "syeon", "syeonj", "syeonh", "syeod", "syeol", "syeolg", "syeolm", "syeolb", "syeols", "syeolt", "syeolp", "syeolh", "syeom", "syeob", "syeobs", "syeos", "syeoss", "syeong", "syeoj", "syeoc", "syeok", "syeot", "syeop", "syeoh", "sye", "syeg", "syegg", "syegs", "syen", "syenj", "syenh", "syed", "syel", "syelg", "syelm", "syelb", "syels", "syelt", "syelp", "syelh", "syem", "syeb", "syebs", "syes", "syess", "syeng", "syej", "syec", "syek", "syet", "syep", "syeh", "so", "sog", "sogg", "sogs", "son", "sonj", "sonh", "sod", "sol", "solg", "solm", "solb", "sols", "solt", "solp", "solh", "som", "sob", "sobs", "sos", "soss", "song", "soj", "soc", "sok", "sot", "sop", "soh", "swa", "swag", "swagg", "swags", "swan", "swanj", "swanh", "swad", "swal", "swalg", "swalm", "swalb", "swals", "swalt", "swalp", "swalh", "swam", "swab", "swabs", "swas", "swass", "swang", "swaj", "swac", "swak", "swat", "swap", "swah", "swae", "swaeg", "swaegg", "swaegs", "swaen", "swaenj", "swaenh", "swaed", "swael", "swaelg", "swaelm", "swaelb", "swaels", "swaelt", "swaelp", "swaelh", "swaem", "swaeb", "swaebs", "swaes", "swaess", "swaeng", "swaej", "swaec", "swaek", "swaet", "swaep", "swaeh", "soe", "soeg", "soegg", "soegs", "soen", "soenj", "soenh", "soed", "soel", "soelg", "soelm", "soelb", "soels", "soelt", "soelp", "soelh", "soem", "soeb", "soebs", "soes", "soess", "soeng", "soej", "soec", "soek", "soet", "soep", "soeh", "syo", "syog", "syogg", "syogs"], ["syon", "syonj", "syonh", "syod", "syol", "syolg", "syolm", "syolb", "syols", "syolt", "syolp", "syolh", "syom", "syob", "syobs", "syos", "syoss", "syong", "syoj", "syoc", "syok", "syot", "syop", "syoh", "su", "sug", "sugg", "sugs", "sun", "sunj", "sunh", "sud", "sul", "sulg", "sulm", "sulb", "suls", "sult", "sulp", "sulh", "sum", "sub", "subs", "sus", "suss", "sung", "suj", "suc", "suk", "sut", "sup", "suh", "sweo", "sweog", "sweogg", "sweogs", "sweon", "sweonj", "sweonh", "sweod", "sweol", "sweolg", "sweolm", "sweolb", "sweols", "sweolt", "sweolp", "sweolh", "sweom", "sweob", "sweobs", "sweos", "sweoss", "sweong", "sweoj", "sweoc", "sweok", "sweot", "sweop", "sweoh", "swe", "sweg", "swegg", "swegs", "swen", "swenj", "swenh", "swed", "swel", "swelg", "swelm", "swelb", "swels", "swelt", "swelp", "swelh", "swem", "sweb", "swebs", "swes", "swess", "sweng", "swej", "swec", "swek", "swet", "swep", "sweh", "swi", "swig", "swigg", "swigs", "swin", "swinj", "swinh", "swid", "swil", "swilg", "swilm", "swilb", "swils", "swilt", "swilp", "swilh", "swim", "swib", "swibs", "swis", "swiss", "swing", "swij", "swic", "swik", "swit", "swip", "swih", "syu", "syug", "syugg", "syugs", "syun", "syunj", "syunh", "syud", "syul", "syulg", "syulm", "syulb", "syuls", "syult", "syulp", "syulh", "syum", "syub", "syubs", "syus", "syuss", "syung", "syuj", "syuc", "syuk", "syut", "syup", "syuh", "seu", "seug", "seugg", "seugs", "seun", "seunj", "seunh", "seud", "seul", "seulg", "seulm", "seulb", "seuls", "seult", "seulp", "seulh", "seum", "seub", "seubs", "seus", "seuss", "seung", "seuj", "seuc", "seuk", "seut", "seup", "seuh", "syi", "syig", "syigg", "syigs", "syin", "syinj", "syinh", "syid", "syil", "syilg", "syilm", "syilb", "syils", "syilt", "syilp", "syilh", "syim", "syib", "syibs", "syis", "syiss", "sying", "syij", "syic", "syik", "syit", "syip", "syih", "si", "sig", "sigg", "sigs", "sin", "sinj", "sinh", "sid", "sil", "silg", "silm", "silb", "sils", "silt", "silp", "silh", "sim", "sib", "sibs", "sis", "siss", "sing", "sij", "sic", "sik", "sit", "sip", "sih", "ssa", "ssag", "ssagg", "ssags", "ssan", "ssanj", "ssanh", "ssad"], ["ssal", "ssalg", "ssalm", "ssalb", "ssals", "ssalt", "ssalp", "ssalh", "ssam", "ssab", "ssabs", "ssas", "ssass", "ssang", "ssaj", "ssac", "ssak", "ssat", "ssap", "ssah", "ssae", "ssaeg", "ssaegg", "ssaegs", "ssaen", "ssaenj", "ssaenh", "ssaed", "ssael", "ssaelg", "ssaelm", "ssaelb", "ssaels", "ssaelt", "ssaelp", "ssaelh", "ssaem", "ssaeb", "ssaebs", "ssaes", "ssaess", "ssaeng", "ssaej", "ssaec", "ssaek", "ssaet", "ssaep", "ssaeh", "ssya", "ssyag", "ssyagg", "ssyags", "ssyan", "ssyanj", "ssyanh", "ssyad", "ssyal", "ssyalg", "ssyalm", "ssyalb", "ssyals", "ssyalt", "ssyalp", "ssyalh", "ssyam", "ssyab", "ssyabs", "ssyas", "ssyass", "ssyang", "ssyaj", "ssyac", "ssyak", "ssyat", "ssyap", "ssyah", "ssyae", "ssyaeg", "ssyaegg", "ssyaegs", "ssyaen", "ssyaenj", "ssyaenh", "ssyaed", "ssyael", "ssyaelg", "ssyaelm", "ssyaelb", "ssyaels", "ssyaelt", "ssyaelp", "ssyaelh", "ssyaem", "ssyaeb", "ssyaebs", "ssyaes", "ssyaess", "ssyaeng", "ssyaej", "ssyaec", "ssyaek", "ssyaet", "ssyaep", "ssyaeh", "sseo", "sseog", "sseogg", "sseogs", "sseon", "sseonj", "sseonh", "sseod", "sseol", "sseolg", "sseolm", "sseolb", "sseols", "sseolt", "sseolp", "sseolh", "sseom", "sseob", "sseobs", "sseos", "sseoss", "sseong", "sseoj", "sseoc", "sseok", "sseot", "sseop", "sseoh", "sse", "sseg", "ssegg", "ssegs", "ssen", "ssenj", "ssenh", "ssed", "ssel", "sselg", "sselm", "sselb", "ssels", "sselt", "sselp", "sselh", "ssem", "sseb", "ssebs", "sses", "ssess", "sseng", "ssej", "ssec", "ssek", "sset", "ssep", "sseh", "ssyeo", "ssyeog", "ssyeogg", "ssyeogs", "ssyeon", "ssyeonj", "ssyeonh", "ssyeod", "ssyeol", "ssyeolg", "ssyeolm", "ssyeolb", "ssyeols", "ssyeolt", "ssyeolp", "ssyeolh", "ssyeom", "ssyeob", "ssyeobs", "ssyeos", "ssyeoss", "ssyeong", "ssyeoj", "ssyeoc", "ssyeok", "ssyeot", "ssyeop", "ssyeoh", "ssye", "ssyeg", "ssyegg", "ssyegs", "ssyen", "ssyenj", "ssyenh", "ssyed", "ssyel", "ssyelg", "ssyelm", "ssyelb", "ssyels", "ssyelt", "ssyelp", "ssyelh", "ssyem", "ssyeb", "ssyebs", "ssyes", "ssyess", "ssyeng", "ssyej", "ssyec", "ssyek", "ssyet", "ssyep", "ssyeh", "sso", "ssog", "ssogg", "ssogs", "sson", "ssonj", "ssonh", "ssod", "ssol", "ssolg", "ssolm", "ssolb", "ssols", "ssolt", "ssolp", "ssolh", "ssom", "ssob", "ssobs", "ssos", "ssoss", "ssong", "ssoj", "ssoc", "ssok", "ssot", "ssop", "ssoh", "sswa", "sswag", "sswagg", "sswags", "sswan", "sswanj", "sswanh", "sswad", "sswal", "sswalg", "sswalm", "sswalb"], ["sswals", "sswalt", "sswalp", "sswalh", "sswam", "sswab", "sswabs", "sswas", "sswass", "sswang", "sswaj", "sswac", "sswak", "sswat", "sswap", "sswah", "sswae", "sswaeg", "sswaegg", "sswaegs", "sswaen", "sswaenj", "sswaenh", "sswaed", "sswael", "sswaelg", "sswaelm", "sswaelb", "sswaels", "sswaelt", "sswaelp", "sswaelh", "sswaem", "sswaeb", "sswaebs", "sswaes", "sswaess", "sswaeng", "sswaej", "sswaec", "sswaek", "sswaet", "sswaep", "sswaeh", "ssoe", "ssoeg", "ssoegg", "ssoegs", "ssoen", "ssoenj", "ssoenh", "ssoed", "ssoel", "ssoelg", "ssoelm", "ssoelb", "ssoels", "ssoelt", "ssoelp", "ssoelh", "ssoem", "ssoeb", "ssoebs", "ssoes", "ssoess", "ssoeng", "ssoej", "ssoec", "ssoek", "ssoet", "ssoep", "ssoeh", "ssyo", "ssyog", "ssyogg", "ssyogs", "ssyon", "ssyonj", "ssyonh", "ssyod", "ssyol", "ssyolg", "ssyolm", "ssyolb", "ssyols", "ssyolt", "ssyolp", "ssyolh", "ssyom", "ssyob", "ssyobs", "ssyos", "ssyoss", "ssyong", "ssyoj", "ssyoc", "ssyok", "ssyot", "ssyop", "ssyoh", "ssu", "ssug", "ssugg", "ssugs", "ssun", "ssunj", "ssunh", "ssud", "ssul", "ssulg", "ssulm", "ssulb", "ssuls", "ssult", "ssulp", "ssulh", "ssum", "ssub", "ssubs", "ssus", "ssuss", "ssung", "ssuj", "ssuc", "ssuk", "ssut", "ssup", "ssuh", "ssweo", "ssweog", "ssweogg", "ssweogs", "ssweon", "ssweonj", "ssweonh", "ssweod", "ssweol", "ssweolg", "ssweolm", "ssweolb", "ssweols", "ssweolt", "ssweolp", "ssweolh", "ssweom", "ssweob", "ssweobs", "ssweos", "ssweoss", "ssweong", "ssweoj", "ssweoc", "ssweok", "ssweot", "ssweop", "ssweoh", "sswe", "ssweg", "sswegg", "sswegs", "sswen", "sswenj", "sswenh", "sswed", "sswel", "sswelg", "sswelm", "sswelb", "sswels", "sswelt", "sswelp", "sswelh", "sswem", "ssweb", "sswebs", "sswes", "sswess", "ssweng", "sswej", "sswec", "sswek", "sswet", "sswep", "ssweh", "sswi", "sswig", "sswigg", "sswigs", "sswin", "sswinj", "sswinh", "sswid", "sswil", "sswilg", "sswilm", "sswilb", "sswils", "sswilt", "sswilp", "sswilh", "sswim", "sswib", "sswibs", "sswis", "sswiss", "sswing", "sswij", "sswic", "sswik", "sswit", "sswip", "sswih", "ssyu", "ssyug", "ssyugg", "ssyugs", "ssyun", "ssyunj", "ssyunh", "ssyud", "ssyul", "ssyulg", "ssyulm", "ssyulb", "ssyuls", "ssyult", "ssyulp", "ssyulh", "ssyum", "ssyub", "ssyubs", "ssyus", "ssyuss", "ssyung", "ssyuj", "ssyuc", "ssyuk", "ssyut", "ssyup", "ssyuh", "sseu", "sseug", "sseugg", "sseugs", "sseun", "sseunj", "sseunh", "sseud", "sseul", "sseulg", "sseulm", "sseulb", "sseuls", "sseult", "sseulp", "sseulh"], ["sseum", "sseub", "sseubs", "sseus", "sseuss", "sseung", "sseuj", "sseuc", "sseuk", "sseut", "sseup", "sseuh", "ssyi", "ssyig", "ssyigg", "ssyigs", "ssyin", "ssyinj", "ssyinh", "ssyid", "ssyil", "ssyilg", "ssyilm", "ssyilb", "ssyils", "ssyilt", "ssyilp", "ssyilh", "ssyim", "ssyib", "ssyibs", "ssyis", "ssyiss", "ssying", "ssyij", "ssyic", "ssyik", "ssyit", "ssyip", "ssyih", "ssi", "ssig", "ssigg", "ssigs", "ssin", "ssinj", "ssinh", "ssid", "ssil", "ssilg", "ssilm", "ssilb", "ssils", "ssilt", "ssilp", "ssilh", "ssim", "ssib", "ssibs", "ssis", "ssiss", "ssing", "ssij", "ssic", "ssik", "ssit", "ssip", "ssih", "a", "ag", "agg", "ags", "an", "anj", "anh", "ad", "al", "alg", "alm", "alb", "als", "alt", "alp", "alh", "am", "ab", "abs", "as", "ass", "ang", "aj", "ac", "ak", "at", "ap", "ah", "ae", "aeg", "aegg", "aegs", "aen", "aenj", "aenh", "aed", "ael", "aelg", "aelm", "aelb", "aels", "aelt", "aelp", "aelh", "aem", "aeb", "aebs", "aes", "aess", "aeng", "aej", "aec", "aek", "aet", "aep", "aeh", "ya", "yag", "yagg", "yags", "yan", "yanj", "yanh", "yad", "yal", "yalg", "yalm", "yalb", "yals", "yalt", "yalp", "yalh", "yam", "yab", "yabs", "yas", "yass", "yang", "yaj", "yac", "yak", "yat", "yap", "yah", "yae", "yaeg", "yaegg", "yaegs", "yaen", "yaenj", "yaenh", "yaed", "yael", "yaelg", "yaelm", "yaelb", "yaels", "yaelt", "yaelp", "yaelh", "yaem", "yaeb", "yaebs", "yaes", "yaess", "yaeng", "yaej", "yaec", "yaek", "yaet", "yaep", "yaeh", "eo", "eog", "eogg", "eogs", "eon", "eonj", "eonh", "eod", "eol", "eolg", "eolm", "eolb", "eols", "eolt", "eolp", "eolh", "eom", "eob", "eobs", "eos", "eoss", "eong", "eoj", "eoc", "eok", "eot", "eop", "eoh", "e", "eg", "egg", "egs", "en", "enj", "enh", "ed", "el", "elg", "elm", "elb", "els", "elt", "elp", "elh", "em", "eb", "ebs", "es", "ess", "eng", "ej", "ec", "ek", "et", "ep", "eh", "yeo", "yeog", "yeogg", "yeogs", "yeon", "yeonj", "yeonh", "yeod", "yeol", "yeolg", "yeolm", "yeolb", "yeols", "yeolt", "yeolp", "yeolh", "yeom", "yeob", "yeobs", "yeos"], ["yeoss", "yeong", "yeoj", "yeoc", "yeok", "yeot", "yeop", "yeoh", "ye", "yeg", "yegg", "yegs", "yen", "yenj", "yenh", "yed", "yel", "yelg", "yelm", "yelb", "yels", "yelt", "yelp", "yelh", "yem", "yeb", "yebs", "yes", "yess", "yeng", "yej", "yec", "yek", "yet", "yep", "yeh", "o", "og", "ogg", "ogs", "on", "onj", "onh", "od", "ol", "olg", "olm", "olb", "ols", "olt", "olp", "olh", "om", "ob", "obs", "os", "oss", "ong", "oj", "oc", "ok", "ot", "op", "oh", "wa", "wag", "wagg", "wags", "wan", "wanj", "wanh", "wad", "wal", "walg", "walm", "walb", "wals", "walt", "walp", "walh", "wam", "wab", "wabs", "was", "wass", "wang", "waj", "wac", "wak", "wat", "wap", "wah", "wae", "waeg", "waegg", "waegs", "waen", "waenj", "waenh", "waed", "wael", "waelg", "waelm", "waelb", "waels", "waelt", "waelp", "waelh", "waem", "waeb", "waebs", "waes", "waess", "waeng", "waej", "waec", "waek", "waet", "waep", "waeh", "oe", "oeg", "oegg", "oegs", "oen", "oenj", "oenh", "oed", "oel", "oelg", "oelm", "oelb", "oels", "oelt", "oelp", "oelh", "oem", "oeb", "oebs", "oes", "oess", "oeng", "oej", "oec", "oek", "oet", "oep", "oeh", "yo", "yog", "yogg", "yogs", "yon", "yonj", "yonh", "yod", "yol", "yolg", "yolm", "yolb", "yols", "yolt", "yolp", "yolh", "yom", "yob", "yobs", "yos", "yoss", "yong", "yoj", "yoc", "yok", "yot", "yop", "yoh", "u", "ug", "ugg", "ugs", "un", "unj", "unh", "ud", "ul", "ulg", "ulm", "ulb", "uls", "ult", "ulp", "ulh", "um", "ub", "ubs", "us", "uss", "ung", "uj", "uc", "uk", "ut", "up", "uh", "weo", "weog", "weogg", "weogs", "weon", "weonj", "weonh", "weod", "weol", "weolg", "weolm", "weolb", "weols", "weolt", "weolp", "weolh", "weom", "weob", "weobs", "weos", "weoss", "weong", "weoj", "weoc", "weok", "weot", "weop", "weoh", "we", "weg", "wegg", "wegs", "wen", "wenj", "wenh", "wed", "wel", "welg", "welm", "welb", "wels", "welt", "welp", "welh", "wem", "web", "webs", "wes", "wess", "weng", "wej", "wec"], ["wek", "wet", "wep", "weh", "wi", "wig", "wigg", "wigs", "win", "winj", "winh", "wid", "wil", "wilg", "wilm", "wilb", "wils", "wilt", "wilp", "wilh", "wim", "wib", "wibs", "wis", "wiss", "wing", "wij", "wic", "wik", "wit", "wip", "wih", "yu", "yug", "yugg", "yugs", "yun", "yunj", "yunh", "yud", "yul", "yulg", "yulm", "yulb", "yuls", "yult", "yulp", "yulh", "yum", "yub", "yubs", "yus", "yuss", "yung", "yuj", "yuc", "yuk", "yut", "yup", "yuh", "eu", "eug", "eugg", "eugs", "eun", "eunj", "eunh", "eud", "eul", "eulg", "eulm", "eulb", "euls", "eult", "eulp", "eulh", "eum", "eub", "eubs", "eus", "euss", "eung", "euj", "euc", "euk", "eut", "eup", "euh", "yi", "yig", "yigg", "yigs", "yin", "yinj", "yinh", "yid", "yil", "yilg", "yilm", "yilb", "yils", "yilt", "yilp", "yilh", "yim", "yib", "yibs", "yis", "yiss", "ying", "yij", "yic", "yik", "yit", "yip", "yih", "i", "ig", "igg", "igs", "in", "inj", "inh", "id", "il", "ilg", "ilm", "ilb", "ils", "ilt", "ilp", "ilh", "im", "ib", "ibs", "is", "iss", "ing", "ij", "ic", "ik", "it", "ip", "ih", "ja", "jag", "jagg", "jags", "jan", "janj", "janh", "jad", "jal", "jalg", "jalm", "jalb", "jals", "jalt", "jalp", "jalh", "jam", "jab", "jabs", "jas", "jass", "jang", "jaj", "jac", "jak", "jat", "jap", "jah", "jae", "jaeg", "jaegg", "jaegs", "jaen", "jaenj", "jaenh", "jaed", "jael", "jaelg", "jaelm", "jaelb", "jaels", "jaelt", "jaelp", "jaelh", "jaem", "jaeb", "jaebs", "jaes", "jaess", "jaeng", "jaej", "jaec", "jaek", "jaet", "jaep", "jaeh", "jya", "jyag", "jyagg", "jyags", "jyan", "jyanj", "jyanh", "jyad", "jyal", "jyalg", "jyalm", "jyalb", "jyals", "jyalt", "jyalp", "jyalh", "jyam", "jyab", "jyabs", "jyas", "jyass", "jyang", "jyaj", "jyac", "jyak", "jyat", "jyap", "jyah", "jyae", "jyaeg", "jyaegg", "jyaegs", "jyaen", "jyaenj", "jyaenh", "jyaed", "jyael", "jyaelg", "jyaelm", "jyaelb", "jyaels", "jyaelt", "jyaelp", "jyaelh", "jyaem", "jyaeb", "jyaebs", "jyaes", "jyaess", "jyaeng", "jyaej", "jyaec", "jyaek", "jyaet", "jyaep", "jyaeh"], ["jeo", "jeog", "jeogg", "jeogs", "jeon", "jeonj", "jeonh", "jeod", "jeol", "jeolg", "jeolm", "jeolb", "jeols", "jeolt", "jeolp", "jeolh", "jeom", "jeob", "jeobs", "jeos", "jeoss", "jeong", "jeoj", "jeoc", "jeok", "jeot", "jeop", "jeoh", "je", "jeg", "jegg", "jegs", "jen", "jenj", "jenh", "jed", "jel", "jelg", "jelm", "jelb", "jels", "jelt", "jelp", "jelh", "jem", "jeb", "jebs", "jes", "jess", "jeng", "jej", "jec", "jek", "jet", "jep", "jeh", "jyeo", "jyeog", "jyeogg", "jyeogs", "jyeon", "jyeonj", "jyeonh", "jyeod", "jyeol", "jyeolg", "jyeolm", "jyeolb", "jyeols", "jyeolt", "jyeolp", "jyeolh", "jyeom", "jyeob", "jyeobs", "jyeos", "jyeoss", "jyeong", "jyeoj", "jyeoc", "jyeok", "jyeot", "jyeop", "jyeoh", "jye", "jyeg", "jyegg", "jyegs", "jyen", "jyenj", "jyenh", "jyed", "jyel", "jyelg", "jyelm", "jyelb", "jyels", "jyelt", "jyelp", "jyelh", "jyem", "jyeb", "jyebs", "jyes", "jyess", "jyeng", "jyej", "jyec", "jyek", "jyet", "jyep", "jyeh", "jo", "jog", "jogg", "jogs", "jon", "jonj", "jonh", "jod", "jol", "jolg", "jolm", "jolb", "jols", "jolt", "jolp", "jolh", "jom", "job", "jobs", "jos", "joss", "jong", "joj", "joc", "jok", "jot", "jop", "joh", "jwa", "jwag", "jwagg", "jwags", "jwan", "jwanj", "jwanh", "jwad", "jwal", "jwalg", "jwalm", "jwalb", "jwals", "jwalt", "jwalp", "jwalh", "jwam", "jwab", "jwabs", "jwas", "jwass", "jwang", "jwaj", "jwac", "jwak", "jwat", "jwap", "jwah", "jwae", "jwaeg", "jwaegg", "jwaegs", "jwaen", "jwaenj", "jwaenh", "jwaed", "jwael", "jwaelg", "jwaelm", "jwaelb", "jwaels", "jwaelt", "jwaelp", "jwaelh", "jwaem", "jwaeb", "jwaebs", "jwaes", "jwaess", "jwaeng", "jwaej", "jwaec", "jwaek", "jwaet", "jwaep", "jwaeh", "joe", "joeg", "joegg", "joegs", "joen", "joenj", "joenh", "joed", "joel", "joelg", "joelm", "joelb", "joels", "joelt", "joelp", "joelh", "joem", "joeb", "joebs", "joes", "joess", "joeng", "joej", "joec", "joek", "joet", "joep", "joeh", "jyo", "jyog", "jyogg", "jyogs", "jyon", "jyonj", "jyonh", "jyod", "jyol", "jyolg", "jyolm", "jyolb", "jyols", "jyolt", "jyolp", "jyolh", "jyom", "jyob", "jyobs", "jyos", "jyoss", "jyong", "jyoj", "jyoc", "jyok", "jyot", "jyop", "jyoh", "ju", "jug", "jugg", "jugs"], ["jun", "junj", "junh", "jud", "jul", "julg", "julm", "julb", "juls", "jult", "julp", "julh", "jum", "jub", "jubs", "jus", "juss", "jung", "juj", "juc", "juk", "jut", "jup", "juh", "jweo", "jweog", "jweogg", "jweogs", "jweon", "jweonj", "jweonh", "jweod", "jweol", "jweolg", "jweolm", "jweolb", "jweols", "jweolt", "jweolp", "jweolh", "jweom", "jweob", "jweobs", "jweos", "jweoss", "jweong", "jweoj", "jweoc", "jweok", "jweot", "jweop", "jweoh", "jwe", "jweg", "jwegg", "jwegs", "jwen", "jwenj", "jwenh", "jwed", "jwel", "jwelg", "jwelm", "jwelb", "jwels", "jwelt", "jwelp", "jwelh", "jwem", "jweb", "jwebs", "jwes", "jwess", "jweng", "jwej", "jwec", "jwek", "jwet", "jwep", "jweh", "jwi", "jwig", "jwigg", "jwigs", "jwin", "jwinj", "jwinh", "jwid", "jwil", "jwilg", "jwilm", "jwilb", "jwils", "jwilt", "jwilp", "jwilh", "jwim", "jwib", "jwibs", "jwis", "jwiss", "jwing", "jwij", "jwic", "jwik", "jwit", "jwip", "jwih", "jyu", "jyug", "jyugg", "jyugs", "jyun", "jyunj", "jyunh", "jyud", "jyul", "jyulg", "jyulm", "jyulb", "jyuls", "jyult", "jyulp", "jyulh", "jyum", "jyub", "jyubs", "jyus", "jyuss", "jyung", "jyuj", "jyuc", "jyuk", "jyut", "jyup", "jyuh", "jeu", "jeug", "jeugg", "jeugs", "jeun", "jeunj", "jeunh", "jeud", "jeul", "jeulg", "jeulm", "jeulb", "jeuls", "jeult", "jeulp", "jeulh", "jeum", "jeub", "jeubs", "jeus", "jeuss", "jeung", "jeuj", "jeuc", "jeuk", "jeut", "jeup", "jeuh", "jyi", "jyig", "jyigg", "jyigs", "jyin", "jyinj", "jyinh", "jyid", "jyil", "jyilg", "jyilm", "jyilb", "jyils", "jyilt", "jyilp", "jyilh", "jyim", "jyib", "jyibs", "jyis", "jyiss", "jying", "jyij", "jyic", "jyik", "jyit", "jyip", "jyih", "ji", "jig", "jigg", "jigs", "jin", "jinj", "jinh", "jid", "jil", "jilg", "jilm", "jilb", "jils", "jilt", "jilp", "jilh", "jim", "jib", "jibs", "jis", "jiss", "jing", "jij", "jic", "jik", "jit", "jip", "jih", "jja", "jjag", "jjagg", "jjags", "jjan", "jjanj", "jjanh", "jjad", "jjal", "jjalg", "jjalm", "jjalb", "jjals", "jjalt", "jjalp", "jjalh", "jjam", "jjab", "jjabs", "jjas", "jjass", "jjang", "jjaj", "jjac", "jjak", "jjat", "jjap", "jjah", "jjae", "jjaeg", "jjaegg", "jjaegs", "jjaen", "jjaenj", "jjaenh", "jjaed"], ["jjael", "jjaelg", "jjaelm", "jjaelb", "jjaels", "jjaelt", "jjaelp", "jjaelh", "jjaem", "jjaeb", "jjaebs", "jjaes", "jjaess", "jjaeng", "jjaej", "jjaec", "jjaek", "jjaet", "jjaep", "jjaeh", "jjya", "jjyag", "jjyagg", "jjyags", "jjyan", "jjyanj", "jjyanh", "jjyad", "jjyal", "jjyalg", "jjyalm", "jjyalb", "jjyals", "jjyalt", "jjyalp", "jjyalh", "jjyam", "jjyab", "jjyabs", "jjyas", "jjyass", "jjyang", "jjyaj", "jjyac", "jjyak", "jjyat", "jjyap", "jjyah", "jjyae", "jjyaeg", "jjyaegg", "jjyaegs", "jjyaen", "jjyaenj", "jjyaenh", "jjyaed", "jjyael", "jjyaelg", "jjyaelm", "jjyaelb", "jjyaels", "jjyaelt", "jjyaelp", "jjyaelh", "jjyaem", "jjyaeb", "jjyaebs", "jjyaes", "jjyaess", "jjyaeng", "jjyaej", "jjyaec", "jjyaek", "jjyaet", "jjyaep", "jjyaeh", "jjeo", "jjeog", "jjeogg", "jjeogs", "jjeon", "jjeonj", "jjeonh", "jjeod", "jjeol", "jjeolg", "jjeolm", "jjeolb", "jjeols", "jjeolt", "jjeolp", "jjeolh", "jjeom", "jjeob", "jjeobs", "jjeos", "jjeoss", "jjeong", "jjeoj", "jjeoc", "jjeok", "jjeot", "jjeop", "jjeoh", "jje", "jjeg", "jjegg", "jjegs", "jjen", "jjenj", "jjenh", "jjed", "jjel", "jjelg", "jjelm", "jjelb", "jjels", "jjelt", "jjelp", "jjelh", "jjem", "jjeb", "jjebs", "jjes", "jjess", "jjeng", "jjej", "jjec", "jjek", "jjet", "jjep", "jjeh", "jjyeo", "jjyeog", "jjyeogg", "jjyeogs", "jjyeon", "jjyeonj", "jjyeonh", "jjyeod", "jjyeol", "jjyeolg", "jjyeolm", "jjyeolb", "jjyeols", "jjyeolt", "jjyeolp", "jjyeolh", "jjyeom", "jjyeob", "jjyeobs", "jjyeos", "jjyeoss", "jjyeong", "jjyeoj", "jjyeoc", "jjyeok", "jjyeot", "jjyeop", "jjyeoh", "jjye", "jjyeg", "jjyegg", "jjyegs", "jjyen", "jjyenj", "jjyenh", "jjyed", "jjyel", "jjyelg", "jjyelm", "jjyelb", "jjyels", "jjyelt", "jjyelp", "jjyelh", "jjyem", "jjyeb", "jjyebs", "jjyes", "jjyess", "jjyeng", "jjyej", "jjyec", "jjyek", "jjyet", "jjyep", "jjyeh", "jjo", "jjog", "jjogg", "jjogs", "jjon", "jjonj", "jjonh", "jjod", "jjol", "jjolg", "jjolm", "jjolb", "jjols", "jjolt", "jjolp", "jjolh", "jjom", "jjob", "jjobs", "jjos", "jjoss", "jjong", "jjoj", "jjoc", "jjok", "jjot", "jjop", "jjoh", "jjwa", "jjwag", "jjwagg", "jjwags", "jjwan", "jjwanj", "jjwanh", "jjwad", "jjwal", "jjwalg", "jjwalm", "jjwalb", "jjwals", "jjwalt", "jjwalp", "jjwalh", "jjwam", "jjwab", "jjwabs", "jjwas", "jjwass", "jjwang", "jjwaj", "jjwac", "jjwak", "jjwat", "jjwap", "jjwah", "jjwae", "jjwaeg", "jjwaegg", "jjwaegs", "jjwaen", "jjwaenj", "jjwaenh", "jjwaed", "jjwael", "jjwaelg", "jjwaelm", "jjwaelb"], ["jjwaels", "jjwaelt", "jjwaelp", "jjwaelh", "jjwaem", "jjwaeb", "jjwaebs", "jjwaes", "jjwaess", "jjwaeng", "jjwaej", "jjwaec", "jjwaek", "jjwaet", "jjwaep", "jjwaeh", "jjoe", "jjoeg", "jjoegg", "jjoegs", "jjoen", "jjoenj", "jjoenh", "jjoed", "jjoel", "jjoelg", "jjoelm", "jjoelb", "jjoels", "jjoelt", "jjoelp", "jjoelh", "jjoem", "jjoeb", "jjoebs", "jjoes", "jjoess", "jjoeng", "jjoej", "jjoec", "jjoek", "jjoet", "jjoep", "jjoeh", "jjyo", "jjyog", "jjyogg", "jjyogs", "jjyon", "jjyonj", "jjyonh", "jjyod", "jjyol", "jjyolg", "jjyolm", "jjyolb", "jjyols", "jjyolt", "jjyolp", "jjyolh", "jjyom", "jjyob", "jjyobs", "jjyos", "jjyoss", "jjyong", "jjyoj", "jjyoc", "jjyok", "jjyot", "jjyop", "jjyoh", "jju", "jjug", "jjugg", "jjugs", "jjun", "jjunj", "jjunh", "jjud", "jjul", "jjulg", "jjulm", "jjulb", "jjuls", "jjult", "jjulp", "jjulh", "jjum", "jjub", "jjubs", "jjus", "jjuss", "jjung", "jjuj", "jjuc", "jjuk", "jjut", "jjup", "jjuh", "jjweo", "jjweog", "jjweogg", "jjweogs", "jjweon", "jjweonj", "jjweonh", "jjweod", "jjweol", "jjweolg", "jjweolm", "jjweolb", "jjweols", "jjweolt", "jjweolp", "jjweolh", "jjweom", "jjweob", "jjweobs", "jjweos", "jjweoss", "jjweong", "jjweoj", "jjweoc", "jjweok", "jjweot", "jjweop", "jjweoh", "jjwe", "jjweg", "jjwegg", "jjwegs", "jjwen", "jjwenj", "jjwenh", "jjwed", "jjwel", "jjwelg", "jjwelm", "jjwelb", "jjwels", "jjwelt", "jjwelp", "jjwelh", "jjwem", "jjweb", "jjwebs", "jjwes", "jjwess", "jjweng", "jjwej", "jjwec", "jjwek", "jjwet", "jjwep", "jjweh", "jjwi", "jjwig", "jjwigg", "jjwigs", "jjwin", "jjwinj", "jjwinh", "jjwid", "jjwil", "jjwilg", "jjwilm", "jjwilb", "jjwils", "jjwilt", "jjwilp", "jjwilh", "jjwim", "jjwib", "jjwibs", "jjwis", "jjwiss", "jjwing", "jjwij", "jjwic", "jjwik", "jjwit", "jjwip", "jjwih", "jjyu", "jjyug", "jjyugg", "jjyugs", "jjyun", "jjyunj", "jjyunh", "jjyud", "jjyul", "jjyulg", "jjyulm", "jjyulb", "jjyuls", "jjyult", "jjyulp", "jjyulh", "jjyum", "jjyub", "jjyubs", "jjyus", "jjyuss", "jjyung", "jjyuj", "jjyuc", "jjyuk", "jjyut", "jjyup", "jjyuh", "jjeu", "jjeug", "jjeugg", "jjeugs", "jjeun", "jjeunj", "jjeunh", "jjeud", "jjeul", "jjeulg", "jjeulm", "jjeulb", "jjeuls", "jjeult", "jjeulp", "jjeulh", "jjeum", "jjeub", "jjeubs", "jjeus", "jjeuss", "jjeung", "jjeuj", "jjeuc", "jjeuk", "jjeut", "jjeup", "jjeuh", "jjyi", "jjyig", "jjyigg", "jjyigs", "jjyin", "jjyinj", "jjyinh", "jjyid", "jjyil", "jjyilg", "jjyilm", "jjyilb", "jjyils", "jjyilt", "jjyilp", "jjyilh"], ["jjyim", "jjyib", "jjyibs", "jjyis", "jjyiss", "jjying", "jjyij", "jjyic", "jjyik", "jjyit", "jjyip", "jjyih", "jji", "jjig", "jjigg", "jjigs", "jjin", "jjinj", "jjinh", "jjid", "jjil", "jjilg", "jjilm", "jjilb", "jjils", "jjilt", "jjilp", "jjilh", "jjim", "jjib", "jjibs", "jjis", "jjiss", "jjing", "jjij", "jjic", "jjik", "jjit", "jjip", "jjih", "ca", "cag", "cagg", "cags", "can", "canj", "canh", "cad", "cal", "calg", "calm", "calb", "cals", "calt", "calp", "calh", "cam", "cab", "cabs", "cas", "cass", "cang", "caj", "cac", "cak", "cat", "cap", "cah", "cae", "caeg", "caegg", "caegs", "caen", "caenj", "caenh", "caed", "cael", "caelg", "caelm", "caelb", "caels", "caelt", "caelp", "caelh", "caem", "caeb", "caebs", "caes", "caess", "caeng", "caej", "caec", "caek", "caet", "caep", "caeh", "cya", "cyag", "cyagg", "cyags", "cyan", "cyanj", "cyanh", "cyad", "cyal", "cyalg", "cyalm", "cyalb", "cyals", "cyalt", "cyalp", "cyalh", "cyam", "cyab", "cyabs", "cyas", "cyass", "cyang", "cyaj", "cyac", "cyak", "cyat", "cyap", "cyah", "cyae", "cyaeg", "cyaegg", "cyaegs", "cyaen", "cyaenj", "cyaenh", "cyaed", "cyael", "cyaelg", "cyaelm", "cyaelb", "cyaels", "cyaelt", "cyaelp", "cyaelh", "cyaem", "cyaeb", "cyaebs", "cyaes", "cyaess", "cyaeng", "cyaej", "cyaec", "cyaek", "cyaet", "cyaep", "cyaeh", "ceo", "ceog", "ceogg", "ceogs", "ceon", "ceonj", "ceonh", "ceod", "ceol", "ceolg", "ceolm", "ceolb", "ceols", "ceolt", "ceolp", "ceolh", "ceom", "ceob", "ceobs", "ceos", "ceoss", "ceong", "ceoj", "ceoc", "ceok", "ceot", "ceop", "ceoh", "ce", "ceg", "cegg", "cegs", "cen", "cenj", "cenh", "ced", "cel", "celg", "celm", "celb", "cels", "celt", "celp", "celh", "cem", "ceb", "cebs", "ces", "cess", "ceng", "cej", "cec", "cek", "cet", "cep", "ceh", "cyeo", "cyeog", "cyeogg", "cyeogs", "cyeon", "cyeonj", "cyeonh", "cyeod", "cyeol", "cyeolg", "cyeolm", "cyeolb", "cyeols", "cyeolt", "cyeolp", "cyeolh", "cyeom", "cyeob", "cyeobs", "cyeos", "cyeoss", "cyeong", "cyeoj", "cyeoc", "cyeok", "cyeot", "cyeop", "cyeoh", "cye", "cyeg", "cyegg", "cyegs", "cyen", "cyenj", "cyenh", "cyed", "cyel", "cyelg", "cyelm", "cyelb", "cyels", "cyelt", "cyelp", "cyelh", "cyem", "cyeb", "cyebs", "cyes"], ["cyess", "cyeng", "cyej", "cyec", "cyek", "cyet", "cyep", "cyeh", "co", "cog", "cogg", "cogs", "con", "conj", "conh", "cod", "col", "colg", "colm", "colb", "cols", "colt", "colp", "colh", "com", "cob", "cobs", "cos", "coss", "cong", "coj", "coc", "cok", "cot", "cop", "coh", "cwa", "cwag", "cwagg", "cwags", "cwan", "cwanj", "cwanh", "cwad", "cwal", "cwalg", "cwalm", "cwalb", "cwals", "cwalt", "cwalp", "cwalh", "cwam", "cwab", "cwabs", "cwas", "cwass", "cwang", "cwaj", "cwac", "cwak", "cwat", "cwap", "cwah", "cwae", "cwaeg", "cwaegg", "cwaegs", "cwaen", "cwaenj", "cwaenh", "cwaed", "cwael", "cwaelg", "cwaelm", "cwaelb", "cwaels", "cwaelt", "cwaelp", "cwaelh", "cwaem", "cwaeb", "cwaebs", "cwaes", "cwaess", "cwaeng", "cwaej", "cwaec", "cwaek", "cwaet", "cwaep", "cwaeh", "coe", "coeg", "coegg", "coegs", "coen", "coenj", "coenh", "coed", "coel", "coelg", "coelm", "coelb", "coels", "coelt", "coelp", "coelh", "coem", "coeb", "coebs", "coes", "coess", "coeng", "coej", "coec", "coek", "coet", "coep", "coeh", "cyo", "cyog", "cyogg", "cyogs", "cyon", "cyonj", "cyonh", "cyod", "cyol", "cyolg", "cyolm", "cyolb", "cyols", "cyolt", "cyolp", "cyolh", "cyom", "cyob", "cyobs", "cyos", "cyoss", "cyong", "cyoj", "cyoc", "cyok", "cyot", "cyop", "cyoh", "cu", "cug", "cugg", "cugs", "cun", "cunj", "cunh", "cud", "cul", "culg", "culm", "culb", "culs", "cult", "culp", "culh", "cum", "cub", "cubs", "cus", "cuss", "cung", "cuj", "cuc", "cuk", "cut", "cup", "cuh", "cweo", "cweog", "cweogg", "cweogs", "cweon", "cweonj", "cweonh", "cweod", "cweol", "cweolg", "cweolm", "cweolb", "cweols", "cweolt", "cweolp", "cweolh", "cweom", "cweob", "cweobs", "cweos", "cweoss", "cweong", "cweoj", "cweoc", "cweok", "cweot", "cweop", "cweoh", "cwe", "cweg", "cwegg", "cwegs", "cwen", "cwenj", "cwenh", "cwed", "cwel", "cwelg", "cwelm", "cwelb", "cwels", "cwelt", "cwelp", "cwelh", "cwem", "cweb", "cwebs", "cwes", "cwess", "cweng", "cwej", "cwec", "cwek", "cwet", "cwep", "cweh", "cwi", "cwig", "cwigg", "cwigs", "cwin", "cwinj", "cwinh", "cwid", "cwil", "cwilg", "cwilm", "cwilb", "cwils", "cwilt", "cwilp", "cwilh", "cwim", "cwib", "cwibs", "cwis", "cwiss", "cwing", "cwij", "cwic"], ["cwik", "cwit", "cwip", "cwih", "cyu", "cyug", "cyugg", "cyugs", "cyun", "cyunj", "cyunh", "cyud", "cyul", "cyulg", "cyulm", "cyulb", "cyuls", "cyult", "cyulp", "cyulh", "cyum", "cyub", "cyubs", "cyus", "cyuss", "cyung", "cyuj", "cyuc", "cyuk", "cyut", "cyup", "cyuh", "ceu", "ceug", "ceugg", "ceugs", "ceun", "ceunj", "ceunh", "ceud", "ceul", "ceulg", "ceulm", "ceulb", "ceuls", "ceult", "ceulp", "ceulh", "ceum", "ceub", "ceubs", "ceus", "ceuss", "ceung", "ceuj", "ceuc", "ceuk", "ceut", "ceup", "ceuh", "cyi", "cyig", "cyigg", "cyigs", "cyin", "cyinj", "cyinh", "cyid", "cyil", "cyilg", "cyilm", "cyilb", "cyils", "cyilt", "cyilp", "cyilh", "cyim", "cyib", "cyibs", "cyis", "cyiss", "cying", "cyij", "cyic", "cyik", "cyit", "cyip", "cyih", "ci", "cig", "cigg", "cigs", "cin", "cinj", "cinh", "cid", "cil", "cilg", "cilm", "cilb", "cils", "cilt", "cilp", "cilh", "cim", "cib", "cibs", "cis", "ciss", "cing", "cij", "cic", "cik", "cit", "cip", "cih", "ka", "kag", "kagg", "kags", "kan", "kanj", "kanh", "kad", "kal", "kalg", "kalm", "kalb", "kals", "kalt", "kalp", "kalh", "kam", "kab", "kabs", "kas", "kass", "kang", "kaj", "kac", "kak", "kat", "kap", "kah", "kae", "kaeg", "kaegg", "kaegs", "kaen", "kaenj", "kaenh", "kaed", "kael", "kaelg", "kaelm", "kaelb", "kaels", "kaelt", "kaelp", "kaelh", "kaem", "kaeb", "kaebs", "kaes", "kaess", "kaeng", "kaej", "kaec", "kaek", "kaet", "kaep", "kaeh", "kya", "kyag", "kyagg", "kyags", "kyan", "kyanj", "kyanh", "kyad", "kyal", "kyalg", "kyalm", "kyalb", "kyals", "kyalt", "kyalp", "kyalh", "kyam", "kyab", "kyabs", "kyas", "kyass", "kyang", "kyaj", "kyac", "kyak", "kyat", "kyap", "kyah", "kyae", "kyaeg", "kyaegg", "kyaegs", "kyaen", "kyaenj", "kyaenh", "kyaed", "kyael", "kyaelg", "kyaelm", "kyaelb", "kyaels", "kyaelt", "kyaelp", "kyaelh", "kyaem", "kyaeb", "kyaebs", "kyaes", "kyaess", "kyaeng", "kyaej", "kyaec", "kyaek", "kyaet", "kyaep", "kyaeh", "keo", "keog", "keogg", "keogs", "keon", "keonj", "keonh", "keod", "keol", "keolg", "keolm", "keolb", "keols", "keolt", "keolp", "keolh", "keom", "keob", "keobs", "keos", "keoss", "keong", "keoj", "keoc", "keok", "keot", "keop", "keoh"], ["ke", "keg", "kegg", "kegs", "ken", "kenj", "kenh", "ked", "kel", "kelg", "kelm", "kelb", "kels", "kelt", "kelp", "kelh", "kem", "keb", "kebs", "kes", "kess", "keng", "kej", "kec", "kek", "ket", "kep", "keh", "kyeo", "kyeog", "kyeogg", "kyeogs", "kyeon", "kyeonj", "kyeonh", "kyeod", "kyeol", "kyeolg", "kyeolm", "kyeolb", "kyeols", "kyeolt", "kyeolp", "kyeolh", "kyeom", "kyeob", "kyeobs", "kyeos", "kyeoss", "kyeong", "kyeoj", "kyeoc", "kyeok", "kyeot", "kyeop", "kyeoh", "kye", "kyeg", "kyegg", "kyegs", "kyen", "kyenj", "kyenh", "kyed", "kyel", "kyelg", "kyelm", "kyelb", "kyels", "kyelt", "kyelp", "kyelh", "kyem", "kyeb", "kyebs", "kyes", "kyess", "kyeng", "kyej", "kyec", "kyek", "kyet", "kyep", "kyeh", "ko", "kog", "kogg", "kogs", "kon", "konj", "konh", "kod", "kol", "kolg", "kolm", "kolb", "kols", "kolt", "kolp", "kolh", "kom", "kob", "kobs", "kos", "koss", "kong", "koj", "koc", "kok", "kot", "kop", "koh", "kwa", "kwag", "kwagg", "kwags", "kwan", "kwanj", "kwanh", "kwad", "kwal", "kwalg", "kwalm", "kwalb", "kwals", "kwalt", "kwalp", "kwalh", "kwam", "kwab", "kwabs", "kwas", "kwass", "kwang", "kwaj", "kwac", "kwak", "kwat", "kwap", "kwah", "kwae", "kwaeg", "kwaegg", "kwaegs", "kwaen", "kwaenj", "kwaenh", "kwaed", "kwael", "kwaelg", "kwaelm", "kwaelb", "kwaels", "kwaelt", "kwaelp", "kwaelh", "kwaem", "kwaeb", "kwaebs", "kwaes", "kwaess", "kwaeng", "kwaej", "kwaec", "kwaek", "kwaet", "kwaep", "kwaeh", "koe", "koeg", "koegg", "koegs", "koen", "koenj", "koenh", "koed", "koel", "koelg", "koelm", "koelb", "koels", "koelt", "koelp", "koelh", "koem", "koeb", "koebs", "koes", "koess", "koeng", "koej", "koec", "koek", "koet", "koep", "koeh", "kyo", "kyog", "kyogg", "kyogs", "kyon", "kyonj", "kyonh", "kyod", "kyol", "kyolg", "kyolm", "kyolb", "kyols", "kyolt", "kyolp", "kyolh", "kyom", "kyob", "kyobs", "kyos", "kyoss", "kyong", "kyoj", "kyoc", "kyok", "kyot", "kyop", "kyoh", "ku", "kug", "kugg", "kugs", "kun", "kunj", "kunh", "kud", "kul", "kulg", "kulm", "kulb", "kuls", "kult", "kulp", "kulh", "kum", "kub", "kubs", "kus", "kuss", "kung", "kuj", "kuc", "kuk", "kut", "kup", "kuh", "kweo", "kweog", "kweogg", "kweogs"], ["kweon", "kweonj", "kweonh", "kweod", "kweol", "kweolg", "kweolm", "kweolb", "kweols", "kweolt", "kweolp", "kweolh", "kweom", "kweob", "kweobs", "kweos", "kweoss", "kweong", "kweoj", "kweoc", "kweok", "kweot", "kweop", "kweoh", "kwe", "kweg", "kwegg", "kwegs", "kwen", "kwenj", "kwenh", "kwed", "kwel", "kwelg", "kwelm", "kwelb", "kwels", "kwelt", "kwelp", "kwelh", "kwem", "kweb", "kwebs", "kwes", "kwess", "kweng", "kwej", "kwec", "kwek", "kwet", "kwep", "kweh", "kwi", "kwig", "kwigg", "kwigs", "kwin", "kwinj", "kwinh", "kwid", "kwil", "kwilg", "kwilm", "kwilb", "kwils", "kwilt", "kwilp", "kwilh", "kwim", "kwib", "kwibs", "kwis", "kwiss", "kwing", "kwij", "kwic", "kwik", "kwit", "kwip", "kwih", "kyu", "kyug", "kyugg", "kyugs", "kyun", "kyunj", "kyunh", "kyud", "kyul", "kyulg", "kyulm", "kyulb", "kyuls", "kyult", "kyulp", "kyulh", "kyum", "kyub", "kyubs", "kyus", "kyuss", "kyung", "kyuj", "kyuc", "kyuk", "kyut", "kyup", "kyuh", "keu", "keug", "keugg", "keugs", "keun", "keunj", "keunh", "keud", "keul", "keulg", "keulm", "keulb", "keuls", "keult", "keulp", "keulh", "keum", "keub", "keubs", "keus", "keuss", "keung", "keuj", "keuc", "keuk", "keut", "keup", "keuh", "kyi", "kyig", "kyigg", "kyigs", "kyin", "kyinj", "kyinh", "kyid", "kyil", "kyilg", "kyilm", "kyilb", "kyils", "kyilt", "kyilp", "kyilh", "kyim", "kyib", "kyibs", "kyis", "kyiss", "kying", "kyij", "kyic", "kyik", "kyit", "kyip", "kyih", "ki", "kig", "kigg", "kigs", "kin", "kinj", "kinh", "kid", "kil", "kilg", "kilm", "kilb", "kils", "kilt", "kilp", "kilh", "kim", "kib", "kibs", "kis", "kiss", "king", "kij", "kic", "kik", "kit", "kip", "kih", "ta", "tag", "tagg", "tags", "tan", "tanj", "tanh", "tad", "tal", "talg", "talm", "talb", "tals", "talt", "talp", "talh", "tam", "tab", "tabs", "tas", "tass", "tang", "taj", "tac", "tak", "tat", "tap", "tah", "tae", "taeg", "taegg", "taegs", "taen", "taenj", "taenh", "taed", "tael", "taelg", "taelm", "taelb", "taels", "taelt", "taelp", "taelh", "taem", "taeb", "taebs", "taes", "taess", "taeng", "taej", "taec", "taek", "taet", "taep", "taeh", "tya", "tyag", "tyagg", "tyags", "tyan", "tyanj", "tyanh", "tyad"], ["tyal", "tyalg", "tyalm", "tyalb", "tyals", "tyalt", "tyalp", "tyalh", "tyam", "tyab", "tyabs", "tyas", "tyass", "tyang", "tyaj", "tyac", "tyak", "tyat", "tyap", "tyah", "tyae", "tyaeg", "tyaegg", "tyaegs", "tyaen", "tyaenj", "tyaenh", "tyaed", "tyael", "tyaelg", "tyaelm", "tyaelb", "tyaels", "tyaelt", "tyaelp", "tyaelh", "tyaem", "tyaeb", "tyaebs", "tyaes", "tyaess", "tyaeng", "tyaej", "tyaec", "tyaek", "tyaet", "tyaep", "tyaeh", "teo", "teog", "teogg", "teogs", "teon", "teonj", "teonh", "teod", "teol", "teolg", "teolm", "teolb", "teols", "teolt", "teolp", "teolh", "teom", "teob", "teobs", "teos", "teoss", "teong", "teoj", "teoc", "teok", "teot", "teop", "teoh", "te", "teg", "tegg", "tegs", "ten", "tenj", "tenh", "ted", "tel", "telg", "telm", "telb", "tels", "telt", "telp", "telh", "tem", "teb", "tebs", "tes", "tess", "teng", "tej", "tec", "tek", "tet", "tep", "teh", "tyeo", "tyeog", "tyeogg", "tyeogs", "tyeon", "tyeonj", "tyeonh", "tyeod", "tyeol", "tyeolg", "tyeolm", "tyeolb", "tyeols", "tyeolt", "tyeolp", "tyeolh", "tyeom", "tyeob", "tyeobs", "tyeos", "tyeoss", "tyeong", "tyeoj", "tyeoc", "tyeok", "tyeot", "tyeop", "tyeoh", "tye", "tyeg", "tyegg", "tyegs", "tyen", "tyenj", "tyenh", "tyed", "tyel", "tyelg", "tyelm", "tyelb", "tyels", "tyelt", "tyelp", "tyelh", "tyem", "tyeb", "tyebs", "tyes", "tyess", "tyeng", "tyej", "tyec", "tyek", "tyet", "tyep", "tyeh", "to", "tog", "togg", "togs", "ton", "tonj", "tonh", "tod", "tol", "tolg", "tolm", "tolb", "tols", "tolt", "tolp", "tolh", "tom", "tob", "tobs", "tos", "toss", "tong", "toj", "toc", "tok", "tot", "top", "toh", "twa", "twag", "twagg", "twags", "twan", "twanj", "twanh", "twad", "twal", "twalg", "twalm", "twalb", "twals", "twalt", "twalp", "twalh", "twam", "twab", "twabs", "twas", "twass", "twang", "twaj", "twac", "twak", "twat", "twap", "twah", "twae", "twaeg", "twaegg", "twaegs", "twaen", "twaenj", "twaenh", "twaed", "twael", "twaelg", "twaelm", "twaelb", "twaels", "twaelt", "twaelp", "twaelh", "twaem", "twaeb", "twaebs", "twaes", "twaess", "twaeng", "twaej", "twaec", "twaek", "twaet", "twaep", "twaeh", "toe", "toeg", "toegg", "toegs", "toen", "toenj", "toenh", "toed", "toel", "toelg", "toelm", "toelb"], ["toels", "toelt", "toelp", "toelh", "toem", "toeb", "toebs", "toes", "toess", "toeng", "toej", "toec", "toek", "toet", "toep", "toeh", "tyo", "tyog", "tyogg", "tyogs", "tyon", "tyonj", "tyonh", "tyod", "tyol", "tyolg", "tyolm", "tyolb", "tyols", "tyolt", "tyolp", "tyolh", "tyom", "tyob", "tyobs", "tyos", "tyoss", "tyong", "tyoj", "tyoc", "tyok", "tyot", "tyop", "tyoh", "tu", "tug", "tugg", "tugs", "tun", "tunj", "tunh", "tud", "tul", "tulg", "tulm", "tulb", "tuls", "tult", "tulp", "tulh", "tum", "tub", "tubs", "tus", "tuss", "tung", "tuj", "tuc", "tuk", "tut", "tup", "tuh", "tweo", "tweog", "tweogg", "tweogs", "tweon", "tweonj", "tweonh", "tweod", "tweol", "tweolg", "tweolm", "tweolb", "tweols", "tweolt", "tweolp", "tweolh", "tweom", "tweob", "tweobs", "tweos", "tweoss", "tweong", "tweoj", "tweoc", "tweok", "tweot", "tweop", "tweoh", "twe", "tweg", "twegg", "twegs", "twen", "twenj", "twenh", "twed", "twel", "twelg", "twelm", "twelb", "twels", "twelt", "twelp", "twelh", "twem", "tweb", "twebs", "twes", "twess", "tweng", "twej", "twec", "twek", "twet", "twep", "tweh", "twi", "twig", "twigg", "twigs", "twin", "twinj", "twinh", "twid", "twil", "twilg", "twilm", "twilb", "twils", "twilt", "twilp", "twilh", "twim", "twib", "twibs", "twis", "twiss", "twing", "twij", "twic", "twik", "twit", "twip", "twih", "tyu", "tyug", "tyugg", "tyugs", "tyun", "tyunj", "tyunh", "tyud", "tyul", "tyulg", "tyulm", "tyulb", "tyuls", "tyult", "tyulp", "tyulh", "tyum", "tyub", "tyubs", "tyus", "tyuss", "tyung", "tyuj", "tyuc", "tyuk", "tyut", "tyup", "tyuh", "teu", "teug", "teugg", "teugs", "teun", "teunj", "teunh", "teud", "teul", "teulg", "teulm", "teulb", "teuls", "teult", "teulp", "teulh", "teum", "teub", "teubs", "teus", "teuss", "teung", "teuj", "teuc", "teuk", "teut", "teup", "teuh", "tyi", "tyig", "tyigg", "tyigs", "tyin", "tyinj", "tyinh", "tyid", "tyil", "tyilg", "tyilm", "tyilb", "tyils", "tyilt", "tyilp", "tyilh", "tyim", "tyib", "tyibs", "tyis", "tyiss", "tying", "tyij", "tyic", "tyik", "tyit", "tyip", "tyih", "ti", "tig", "tigg", "tigs", "tin", "tinj", "tinh", "tid", "til", "tilg", "tilm", "tilb", "tils", "tilt", "tilp", "tilh"], ["tim", "tib", "tibs", "tis", "tiss", "ting", "tij", "tic", "tik", "tit", "tip", "tih", "pa", "pag", "pagg", "pags", "pan", "panj", "panh", "pad", "pal", "palg", "palm", "palb", "pals", "palt", "palp", "palh", "pam", "pab", "pabs", "pas", "pass", "pang", "paj", "pac", "pak", "pat", "pap", "pah", "pae", "paeg", "paegg", "paegs", "paen", "paenj", "paenh", "paed", "pael", "paelg", "paelm", "paelb", "paels", "paelt", "paelp", "paelh", "paem", "paeb", "paebs", "paes", "paess", "paeng", "paej", "paec", "paek", "paet", "paep", "paeh", "pya", "pyag", "pyagg", "pyags", "pyan", "pyanj", "pyanh", "pyad", "pyal", "pyalg", "pyalm", "pyalb", "pyals", "pyalt", "pyalp", "pyalh", "pyam", "pyab", "pyabs", "pyas", "pyass", "pyang", "pyaj", "pyac", "pyak", "pyat", "pyap", "pyah", "pyae", "pyaeg", "pyaegg", "pyaegs", "pyaen", "pyaenj", "pyaenh", "pyaed", "pyael", "pyaelg", "pyaelm", "pyaelb", "pyaels", "pyaelt", "pyaelp", "pyaelh", "pyaem", "pyaeb", "pyaebs", "pyaes", "pyaess", "pyaeng", "pyaej", "pyaec", "pyaek", "pyaet", "pyaep", "pyaeh", "peo", "peog", "peogg", "peogs", "peon", "peonj", "peonh", "peod", "peol", "peolg", "peolm", "peolb", "peols", "peolt", "peolp", "peolh", "peom", "peob", "peobs", "peos", "peoss", "peong", "peoj", "peoc", "peok", "peot", "peop", "peoh", "pe", "peg", "pegg", "pegs", "pen", "penj", "penh", "ped", "pel", "pelg", "pelm", "pelb", "pels", "pelt", "pelp", "pelh", "pem", "peb", "pebs", "pes", "pess", "peng", "pej", "pec", "pek", "pet", "pep", "peh", "pyeo", "pyeog", "pyeogg", "pyeogs", "pyeon", "pyeonj", "pyeonh", "pyeod", "pyeol", "pyeolg", "pyeolm", "pyeolb", "pyeols", "pyeolt", "pyeolp", "pyeolh", "pyeom", "pyeob", "pyeobs", "pyeos", "pyeoss", "pyeong", "pyeoj", "pyeoc", "pyeok", "pyeot", "pyeop", "pyeoh", "pye", "pyeg", "pyegg", "pyegs", "pyen", "pyenj", "pyenh", "pyed", "pyel", "pyelg", "pyelm", "pyelb", "pyels", "pyelt", "pyelp", "pyelh", "pyem", "pyeb", "pyebs", "pyes", "pyess", "pyeng", "pyej", "pyec", "pyek", "pyet", "pyep", "pyeh", "po", "pog", "pogg", "pogs", "pon", "ponj", "ponh", "pod", "pol", "polg", "polm", "polb", "pols", "polt", "polp", "polh", "pom", "pob", "pobs", "pos"], ["poss", "pong", "poj", "poc", "pok", "pot", "pop", "poh", "pwa", "pwag", "pwagg", "pwags", "pwan", "pwanj", "pwanh", "pwad", "pwal", "pwalg", "pwalm", "pwalb", "pwals", "pwalt", "pwalp", "pwalh", "pwam", "pwab", "pwabs", "pwas", "pwass", "pwang", "pwaj", "pwac", "pwak", "pwat", "pwap", "pwah", "pwae", "pwaeg", "pwaegg", "pwaegs", "pwaen", "pwaenj", "pwaenh", "pwaed", "pwael", "pwaelg", "pwaelm", "pwaelb", "pwaels", "pwaelt", "pwaelp", "pwaelh", "pwaem", "pwaeb", "pwaebs", "pwaes", "pwaess", "pwaeng", "pwaej", "pwaec", "pwaek", "pwaet", "pwaep", "pwaeh", "poe", "poeg", "poegg", "poegs", "poen", "poenj", "poenh", "poed", "poel", "poelg", "poelm", "poelb", "poels", "poelt", "poelp", "poelh", "poem", "poeb", "poebs", "poes", "poess", "poeng", "poej", "poec", "poek", "poet", "poep", "poeh", "pyo", "pyog", "pyogg", "pyogs", "pyon", "pyonj", "pyonh", "pyod", "pyol", "pyolg", "pyolm", "pyolb", "pyols", "pyolt", "pyolp", "pyolh", "pyom", "pyob", "pyobs", "pyos", "pyoss", "pyong", "pyoj", "pyoc", "pyok", "pyot", "pyop", "pyoh", "pu", "pug", "pugg", "pugs", "pun", "punj", "punh", "pud", "pul", "pulg", "pulm", "pulb", "puls", "pult", "pulp", "pulh", "pum", "pub", "pubs", "pus", "puss", "pung", "puj", "puc", "puk", "put", "pup", "puh", "pweo", "pweog", "pweogg", "pweogs", "pweon", "pweonj", "pweonh", "pweod", "pweol", "pweolg", "pweolm", "pweolb", "pweols", "pweolt", "pweolp", "pweolh", "pweom", "pweob", "pweobs", "pweos", "pweoss", "pweong", "pweoj", "pweoc", "pweok", "pweot", "pweop", "pweoh", "pwe", "pweg", "pwegg", "pwegs", "pwen", "pwenj", "pwenh", "pwed", "pwel", "pwelg", "pwelm", "pwelb", "pwels", "pwelt", "pwelp", "pwelh", "pwem", "pweb", "pwebs", "pwes", "pwess", "pweng", "pwej", "pwec", "pwek", "pwet", "pwep", "pweh", "pwi", "pwig", "pwigg", "pwigs", "pwin", "pwinj", "pwinh", "pwid", "pwil", "pwilg", "pwilm", "pwilb", "pwils", "pwilt", "pwilp", "pwilh", "pwim", "pwib", "pwibs", "pwis", "pwiss", "pwing", "pwij", "pwic", "pwik", "pwit", "pwip", "pwih", "pyu", "pyug", "pyugg", "pyugs", "pyun", "pyunj", "pyunh", "pyud", "pyul", "pyulg", "pyulm", "pyulb", "pyuls", "pyult", "pyulp", "pyulh", "pyum", "pyub", "pyubs", "pyus", "pyuss", "pyung", "pyuj", "pyuc"], ["pyuk", "pyut", "pyup", "pyuh", "peu", "peug", "peugg", "peugs", "peun", "peunj", "peunh", "peud", "peul", "peulg", "peulm", "peulb", "peuls", "peult", "peulp", "peulh", "peum", "peub", "peubs", "peus", "peuss", "peung", "peuj", "peuc", "peuk", "peut", "peup", "peuh", "pyi", "pyig", "pyigg", "pyigs", "pyin", "pyinj", "pyinh", "pyid", "pyil", "pyilg", "pyilm", "pyilb", "pyils", "pyilt", "pyilp", "pyilh", "pyim", "pyib", "pyibs", "pyis", "pyiss", "pying", "pyij", "pyic", "pyik", "pyit", "pyip", "pyih", "pi", "pig", "pigg", "pigs", "pin", "pinj", "pinh", "pid", "pil", "pilg", "pilm", "pilb", "pils", "pilt", "pilp", "pilh", "pim", "pib", "pibs", "pis", "piss", "ping", "pij", "pic", "pik", "pit", "pip", "pih", "ha", "hag", "hagg", "hags", "han", "hanj", "hanh", "had", "hal", "halg", "halm", "halb", "hals", "halt", "halp", "halh", "ham", "hab", "habs", "has", "hass", "hang", "haj", "hac", "hak", "hat", "hap", "hah", "hae", "haeg", "haegg", "haegs", "haen", "haenj", "haenh", "haed", "hael", "haelg", "haelm", "haelb", "haels", "haelt", "haelp", "haelh", "haem", "haeb", "haebs", "haes", "haess", "haeng", "haej", "haec", "haek", "haet", "haep", "haeh", "hya", "hyag", "hyagg", "hyags", "hyan", "hyanj", "hyanh", "hyad", "hyal", "hyalg", "hyalm", "hyalb", "hyals", "hyalt", "hyalp", "hyalh", "hyam", "hyab", "hyabs", "hyas", "hyass", "hyang", "hyaj", "hyac", "hyak", "hyat", "hyap", "hyah", "hyae", "hyaeg", "hyaegg", "hyaegs", "hyaen", "hyaenj", "hyaenh", "hyaed", "hyael", "hyaelg", "hyaelm", "hyaelb", "hyaels", "hyaelt", "hyaelp", "hyaelh", "hyaem", "hyaeb", "hyaebs", "hyaes", "hyaess", "hyaeng", "hyaej", "hyaec", "hyaek", "hyaet", "hyaep", "hyaeh", "heo", "heog", "heogg", "heogs", "heon", "heonj", "heonh", "heod", "heol", "heolg", "heolm", "heolb", "heols", "heolt", "heolp", "heolh", "heom", "heob", "heobs", "heos", "heoss", "heong", "heoj", "heoc", "heok", "heot", "heop", "heoh", "he", "heg", "hegg", "hegs", "hen", "henj", "henh", "hed", "hel", "helg", "helm", "helb", "hels", "helt", "help", "helh", "hem", "heb", "hebs", "hes", "hess", "heng", "hej", "hec", "hek", "het", "hep", "heh"], ["hyeo", "hyeog", "hyeogg", "hyeogs", "hyeon", "hyeonj", "hyeonh", "hyeod", "hyeol", "hyeolg", "hyeolm", "hyeolb", "hyeols", "hyeolt", "hyeolp", "hyeolh", "hyeom", "hyeob", "hyeobs", "hyeos", "hyeoss", "hyeong", "hyeoj", "hyeoc", "hyeok", "hyeot", "hyeop", "hyeoh", "hye", "hyeg", "hyegg", "hyegs", "hyen", "hyenj", "hyenh", "hyed", "hyel", "hyelg", "hyelm", "hyelb", "hyels", "hyelt", "hyelp", "hyelh", "hyem", "hyeb", "hyebs", "hyes", "hyess", "hyeng", "hyej", "hyec", "hyek", "hyet", "hyep", "hyeh", "ho", "hog", "hogg", "hogs", "hon", "honj", "honh", "hod", "hol", "holg", "holm", "holb", "hols", "holt", "holp", "holh", "hom", "hob", "hobs", "hos", "hoss", "hong", "hoj", "hoc", "hok", "hot", "hop", "hoh", "hwa", "hwag", "hwagg", "hwags", "hwan", "hwanj", "hwanh", "hwad", "hwal", "hwalg", "hwalm", "hwalb", "hwals", "hwalt", "hwalp", "hwalh", "hwam", "hwab", "hwabs", "hwas", "hwass", "hwang", "hwaj", "hwac", "hwak", "hwat", "hwap", "hwah", "hwae", "hwaeg", "hwaegg", "hwaegs", "hwaen", "hwaenj", "hwaenh", "hwaed", "hwael", "hwaelg", "hwaelm", "hwaelb", "hwaels", "hwaelt", "hwaelp", "hwaelh", "hwaem", "hwaeb", "hwaebs", "hwaes", "hwaess", "hwaeng", "hwaej", "hwaec", "hwaek", "hwaet", "hwaep", "hwaeh", "hoe", "hoeg", "hoegg", "hoegs", "hoen", "hoenj", "hoenh", "hoed", "hoel", "hoelg", "hoelm", "hoelb", "hoels", "hoelt", "hoelp", "hoelh", "hoem", "hoeb", "hoebs", "hoes", "hoess", "hoeng", "hoej", "hoec", "hoek", "hoet", "hoep", "hoeh", "hyo", "hyog", "hyogg", "hyogs", "hyon", "hyonj", "hyonh", "hyod", "hyol", "hyolg", "hyolm", "hyolb", "hyols", "hyolt", "hyolp", "hyolh", "hyom", "hyob", "hyobs", "hyos", "hyoss", "hyong", "hyoj", "hyoc", "hyok", "hyot", "hyop", "hyoh", "hu", "hug", "hugg", "hugs", "hun", "hunj", "hunh", "hud", "hul", "hulg", "hulm", "hulb", "huls", "hult", "hulp", "hulh", "hum", "hub", "hubs", "hus", "huss", "hung", "huj", "huc", "huk", "hut", "hup", "huh", "hweo", "hweog", "hweogg", "hweogs", "hweon", "hweonj", "hweonh", "hweod", "hweol", "hweolg", "hweolm", "hweolb", "hweols", "hweolt", "hweolp", "hweolh", "hweom", "hweob", "hweobs", "hweos", "hweoss", "hweong", "hweoj", "hweoc", "hweok", "hweot", "hweop", "hweoh", "hwe", "hweg", "hwegg", "hwegs"], ["hwen", "hwenj", "hwenh", "hwed", "hwel", "hwelg", "hwelm", "hwelb", "hwels", "hwelt", "hwelp", "hwelh", "hwem", "hweb", "hwebs", "hwes", "hwess", "hweng", "hwej", "hwec", "hwek", "hwet", "hwep", "hweh", "hwi", "hwig", "hwigg", "hwigs", "hwin", "hwinj", "hwinh", "hwid", "hwil", "hwilg", "hwilm", "hwilb", "hwils", "hwilt", "hwilp", "hwilh", "hwim", "hwib", "hwibs", "hwis", "hwiss", "hwing", "hwij", "hwic", "hwik", "hwit", "hwip", "hwih", "hyu", "hyug", "hyugg", "hyugs", "hyun", "hyunj", "hyunh", "hyud", "hyul", "hyulg", "hyulm", "hyulb", "hyuls", "hyult", "hyulp", "hyulh", "hyum", "hyub", "hyubs", "hyus", "hyuss", "hyung", "hyuj", "hyuc", "hyuk", "hyut", "hyup", "hyuh", "heu", "heug", "heugg", "heugs", "heun", "heunj", "heunh", "heud", "heul", "heulg", "heulm", "heulb", "heuls", "heult", "heulp", "heulh", "heum", "heub", "heubs", "heus", "heuss", "heung", "heuj", "heuc", "heuk", "heut", "heup", "heuh", "hyi", "hyig", "hyigg", "hyigs", "hyin", "hyinj", "hyinh", "hyid", "hyil", "hyilg", "hyilm", "hyilb", "hyils", "hyilt", "hyilp", "hyilh", "hyim", "hyib", "hyibs", "hyis", "hyiss", "hying", "hyij", "hyic", "hyik", "hyit", "hyip", "hyih", "hi", "hig", "higg", "higs", "hin", "hinj", "hinh", "hid", "hil", "hilg", "hilm", "hilb", "hils", "hilt", "hilp", "hilh", "him", "hib", "hibs", "his", "hiss", "hing", "hij", "hic", "hik", "hit", "hip", "hih"], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], ["Kay", "Kayng", "Ke", "Ko", "Kol", "Koc", "Kwi", "Kwi", "Kyun", "Kul", "Kum", "Na", "Na", "Na", "La", "Na", "Na", "Na", "Na", "Na", "Nak", "Nak", "Nak", "Nak", "Nak", "Nak", "Nak", "Nan", "Nan", "Nan", "Nan", "Nan", "Nan", "Nam", "Nam", "Nam", "Nam", "Nap", "Nap", "Nap", "Nang", "Nang", "Nang", "Nang", "Nang", "Nay", "Nayng", "No", "No", "No", "No", "No", "No", "No", "No", "No", "No", "No", "No", "Nok", "Nok", "Nok", "Nok", "Nok", "Nok", "Non", "Nong", "Nong", "Nong", "Nong", "Noy", "Noy", "Noy", "Noy", "Nwu", "Nwu", "Nwu", "Nwu", "Nwu", "Nwu", "Nwu", "Nwu", "Nuk", "Nuk", "Num", "Nung", "Nung", "Nung", "Nung", "Nung", "Twu", "La", "Lak", "Lak", "Lan", "Lyeng", "Lo", "Lyul", "Li", "Pey", "Pen", "Pyen", "Pwu", "Pwul", "Pi", "Sak", "Sak", "Sam", "Sayk", "Sayng", "Sep", "Sey", "Sway", "Sin", "Sim", "Sip", "Ya", "Yak", "Yak", "Yang", "Yang", "Yang", "Yang", "Yang", "Yang", "Yang", "Yang", "Ye", "Ye", "Ye", "Ye", "Ye", "Ye", "Ye", "Ye", "Ye", "Ye", "Ye", "Yek", "Yek", "Yek", "Yek", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yen", "Yel", "Yel", "Yel", "Yel", "Yel", "Yel", "Yem", "Yem", "Yem", "Yem", "Yem", "Yep", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yeng", "Yey", "Yey", "Yey", "Yey", "O", "Yo", "Yo", "Yo", "Yo", "Yo", "Yo", "Yo", "Yo", "Yo", "Yo", "Yong", "Wun", "Wen", "Yu", "Yu", "Yu", "Yu", "Yu", "Yu", "Yu", "Yu", "Yu", "Yu", "Yuk", "Yuk", "Yuk", "Yun", "Yun", "Yun", "Yun", "Yul", "Yul", "Yul", "Yul", "Yung", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "Ik", "Ik", "In", "In", "In", "In", "In", "In", "In", "Im", "Im", "Im", "Ip", "Ip", "Ip", "Cang", "Cek", "Ci", "Cip", "Cha", "Chek"], ["Chey", "Thak", "Thak", "Thang", "Thayk", "Thong", "Pho", "Phok", "Hang", "Hang", "Hyen", "Hwak", "Wu", "Huo", , , "Zhong", , "Qing", , , "Xi", "Zhu", "Yi", "Li", "Shen", "Xiang", "Fu", "Jing", "Jing", "Yu", , "Hagi", , "Zhu", , , "Yi", "Du", , , , "Fan", "Si", "Guan"], ["ff", "fi", "fl", "ffi", "ffl", "st", "st", , , , , , , , , , , , , "mn", "me", "mi", "vn", "mkh", , , , , , "yi", , "ay", "`", , "d", "h", "k", "l", "m", "m", "t", "+", "sh", "s", "sh", "s", "a", "a", , "b", "g", "d", "h", "v", "z", , "t", "y", "k", "k", "l", , "l", , "n", "n", , "p", "p", , "ts", "ts", "r", "sh", "t", "vo", "b", "k", "p", "l"], [], [], [, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , "~", , , , , , , , , , , , , "..", "--", "-", "_", "_", "(", ") ", "{", "} ", "[", "] ", "[(", ")] ", "<<", ">> ", "<", "> ", "[", "] ", "{", "}", , , , , , , , , , , , ",", ",", ".", , ";", ":", "?", "!", "-", "(", ")", "{", "}", "{", "}", "#", "&", "*", "+", "-", "<", ">", "=", , "\\", "$", "%", "@"], [, "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", , , ".", "[", "]", ",", "*", "wo", "a", "i", "u", "e", "o", "ya", "yu", "yo", "tu", "+", "a", "i", "u", "e", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "n", ":", ";", , "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", , "j", "jj", "c", "k", "t", "p", "h", , , , "a", "ae", "ya", "yae", "eo", "e", , , "yeo", "ye", "o", "wa", "wae", "oe", , , "yo", "u", "weo", "we", "wi", "yu", , , "eu", "yi", "i", , , , "/C", "PS", "!", "-", "|", "Y=", "W=", , "|", "-", "|", "-", "|", "#", "O", , , , , , , , , , , "{", "|", "}"]];
const ip = {};
for (let n = 0; n < hh.length; n++) for (let e = 0; e < hh[n].length; e++) {
  const t = hh[n][e];
  if (typeof t == "string" && t.length) {
    const i = String.fromCharCode((n << 8) + e);
    ip[i] = t;
  }
}
function Sm(n) {
  return (n || "").replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function Sv(n) {
  return /[\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DBF\u4E00-\u9FFC\uF900-\uFA6D\uFA70-\uFAD9]|\uD81B[\uDFF0\uDFF1]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]/.test(n);
}
function eP(n) {
  return /[\s!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/.test(n);
}
function Vn(n) {
  switch (!0) {
    case n instanceof Array:
      const e = [];
      for (let i = 0; i < n.length; i++) e[i] = Vn(n[i]);
      return e;
    case n instanceof Date:
      return new Date(n.valueOf());
    case n instanceof RegExp:
      return new RegExp(n.source, n.flags);
    case n instanceof Object:
      const t = {};
      for (const i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = Vn(n[i]));
      return t;
    default:
      return n;
  }
}
function kh(n, e) {
  if (e.length === 0) return !1;
  const t = Math.floor(e.length / 2);
  switch (function(i, a) {
    switch (!0) {
      case i < a[0]:
        return -1;
      case i > a[1]:
        return 1;
    }
    return 0;
  }(n, e[t])) {
    case -1:
      return kh(n, e.slice(0, t));
    case 1:
      return kh(n, e.slice(t + 1));
  }
  return !0;
}
function uS(n, e, t, i = []) {
  const a = i.length ? RegExp(i.map(Sm).join("|"), "g") : null, o = RegExp(e.source, e.flags.replace("g", "") + "g");
  let r = "", s = 0;
  for (; ; ) {
    const l = o.exec(n);
    let h = "", d = 0;
    if (!l) {
      r += n.substring(s, n.length);
      break;
    }
    for (; ; ) {
      const f = a ? a.exec(l[0]) : null;
      if (!f) {
        h += l[0].length > d ? t : "";
        break;
      }
      h += f.index > d ? t : "", h += f[0], d = a.lastIndex;
    }
    r += n.substring(s, l.index) + h, s = o.lastIndex;
  }
  return r;
}
hh = void 0;
const ap = { ignore: [], replace: [], replaceAfter: [], trim: !1, unknown: "", fixChineseSpacing: !0 };
let lS = class {
  constructor(e = Vn(ap), t = ip) {
    this.confOptions = e, this.map = t;
  }
  get options() {
    return Vn(Object.assign(Object.assign({}, ap), this.confOptions));
  }
  config(e, t = !1) {
    return t && (this.confOptions = {}), e && typeof e == "object" && (this.confOptions = Vn(e)), this.confOptions;
  }
  codeMapReplace(e, t = [], i) {
    let a = 0, o = "";
    const r = i.fixChineseSpacing && Sv(e);
    let s = !1;
    for (let l = 0; l < e.length; l++) {
      const h = /[\uD800-\uDBFF]/.test(e[l]) && /[\uDC00-\uDFFF]/.test(e[l + 1]) ? e[l] + e[l + 1] : e[l];
      let d, f = !1;
      switch (!0) {
        case kh(a, t):
        case (h.length === 2 && kh(a + 1, t)):
          d = h, t.find((p) => p[1] >= a && p[0] === a) || (f = !0);
          break;
        default:
          d = this.map[h] || i.unknown || "";
      }
      r && (!s || f || eP(d) || (d = " " + d), s = !!d && Sv(h)), o += d, a += h.length, l += h.length - 1;
    }
    return o;
  }
  formatReplaceOption(e) {
    if (e instanceof Array) return Vn(e);
    const t = [];
    for (const i in e) Object.prototype.hasOwnProperty.call(e, i) && t.push([i, e[i]]);
    return t;
  }
  replaceString(e, t, i = []) {
    const a = Vn(t);
    let o = e;
    for (let r = 0; r < a.length; r++) {
      const s = a[r];
      switch (!0) {
        case s[0] instanceof RegExp:
          s[0] = RegExp(s[0].source, s[0].flags.replace("g", "") + "g");
          break;
        case (typeof s[0] == "string" && s[0].length > 0):
          s[0] = RegExp(Sm(s[0]), "g");
          break;
        default:
          s[0] = /[^\s\S]/;
      }
      o = uS(o, s[0], s[1], i);
    }
    return o;
  }
  setData(e, t = !1) {
    if (t && (this.map = Vn(ip)), e && typeof e == "object" && Object.keys(e).length) {
      this.map = Vn(this.map);
      for (const i in e) Object.prototype.hasOwnProperty.call(e, i) && i.length < 3 && i <= "ô¿¿" && (this.map[i] = e[i]);
    }
    return this.map;
  }
  transliterate(e, t) {
    t = typeof t == "object" ? t : {};
    const i = Vn(Object.assign(Object.assign({}, this.options), t));
    let a = typeof e == "string" ? e : String(e);
    const o = this.formatReplaceOption(i.replace);
    o.length && (a = this.replaceString(a, o, i.ignore));
    const r = i.ignore && i.ignore.length > 0 ? function(l, h) {
      let d = [];
      for (let y = 0; y < h.length; y++) {
        const m = h[y];
        let w = -1;
        for (; (w = l.indexOf(m, w + 1)) > -1; ) d.push([w, w + m.length - 1]);
      }
      const f = d.sort((y, m) => y[0] - m[0] || y[1] - m[1]);
      let p;
      return d = [], f.forEach((y) => !p || y[0] > p[1] + 1 ? d.push(p = y) : y[1] > p[1] && (p[1] = y[1])), d;
    }(a, i.ignore) : [];
    a = this.codeMapReplace(a, r, i), i.trim && (a = a.trim());
    const s = this.formatReplaceOption(i.replaceAfter);
    return s.length && (a = this.replaceString(a, s)), a;
  }
};
const tP = Object.assign(Object.assign({}, Vn(ap)), { allowedChars: "a-zA-Z0-9-_.~", lowercase: !0, separator: "-", uppercase: !1, fixChineseSpacing: !0 }), vs = new lS(), kv = vs.transliterate.bind(vs);
kv.config = vs.config.bind(vs), kv.setData = vs.setData.bind(vs);
const Cs = new class extends lS {
  get options() {
    return Vn(Object.assign(Object.assign({}, tP), this.confOptions));
  }
  config(n, e = !1) {
    return e && (this.confOptions = {}), n && typeof n == "object" && (this.confOptions = Vn(n)), this.confOptions;
  }
  slugify(n, e) {
    e = typeof e == "object" ? e : {};
    const t = Vn(Object.assign(Object.assign({}, this.options), e)), i = t.separator ? Sm(t.separator) : "";
    let a = this.transliterate(n, t);
    return a = uS(a, RegExp(`[^${t.allowedChars}]+`, "g"), t.separator, t.ignore), i && (a = a.replace(RegExp(`^${i}+|${i}$`, "g"), "")), t.lowercase && (a = a.toLowerCase()), t.uppercase && (a = a.toUpperCase()), a;
  }
}(), op = Cs.slugify.bind(Cs);
op.config = Cs.config.bind(Cs), op.setData = Cs.setData.bind(Cs);
function nP(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var cS = nP, iP = typeof Qa == "object" && Qa && Qa.Object === Object && Qa, aP = iP, oP = aP, rP = typeof self == "object" && self && self.Object === Object && self, sP = oP || rP || Function("return this")(), hS = sP, uP = hS, lP = function() {
  return uP.Date.now();
}, cP = lP, hP = /\s/;
function dP(n) {
  for (var e = n.length; e-- && hP.test(n.charAt(e)); )
    ;
  return e;
}
var gP = dP, fP = gP, pP = /^\s+/;
function mP(n) {
  return n && n.slice(0, fP(n) + 1).replace(pP, "");
}
var yP = mP, bP = hS, wP = bP.Symbol, dS = wP, _v = dS, gS = Object.prototype, vP = gS.hasOwnProperty, CP = gS.toString, ju = _v ? _v.toStringTag : void 0;
function SP(n) {
  var e = vP.call(n, ju), t = n[ju];
  try {
    n[ju] = void 0;
    var i = !0;
  } catch {
  }
  var a = CP.call(n);
  return i && (e ? n[ju] = t : delete n[ju]), a;
}
var kP = SP, _P = Object.prototype, jP = _P.toString;
function TP(n) {
  return jP.call(n);
}
var LP = TP, jv = dS, xP = kP, EP = LP, DP = "[object Null]", MP = "[object Undefined]", Tv = jv ? jv.toStringTag : void 0;
function NP(n) {
  return n == null ? n === void 0 ? MP : DP : Tv && Tv in Object(n) ? xP(n) : EP(n);
}
var OP = NP;
function AP(n) {
  return n != null && typeof n == "object";
}
var YP = AP, PP = OP, RP = YP, FP = "[object Symbol]";
function IP(n) {
  return typeof n == "symbol" || RP(n) && PP(n) == FP;
}
var JP = IP, ZP = yP, Lv = cS, BP = JP, xv = NaN, HP = /^[-+]0x[0-9a-f]+$/i, XP = /^0b[01]+$/i, GP = /^0o[0-7]+$/i, WP = parseInt;
function QP(n) {
  if (typeof n == "number")
    return n;
  if (BP(n))
    return xv;
  if (Lv(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Lv(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = ZP(n);
  var t = XP.test(n);
  return t || GP.test(n) ? WP(n.slice(2), t ? 2 : 8) : HP.test(n) ? xv : +n;
}
var KP = QP, zP = cS, of = cP, Ev = KP, $P = "Expected a function", VP = Math.max, UP = Math.min;
function qP(n, e, t) {
  var i, a, o, r, s, l, h = 0, d = !1, f = !1, p = !0;
  if (typeof n != "function")
    throw new TypeError($P);
  e = Ev(e) || 0, zP(t) && (d = !!t.leading, f = "maxWait" in t, o = f ? VP(Ev(t.maxWait) || 0, e) : o, p = "trailing" in t ? !!t.trailing : p);
  function y(x) {
    var M = i, P = a;
    return i = a = void 0, h = x, r = n.apply(P, M), r;
  }
  function m(x) {
    return h = x, s = setTimeout(_, e), d ? y(x) : r;
  }
  function w(x) {
    var M = x - l, P = x - h, Y = e - M;
    return f ? UP(Y, o - P) : Y;
  }
  function v(x) {
    var M = x - l, P = x - h;
    return l === void 0 || M >= e || M < 0 || f && P >= o;
  }
  function _() {
    var x = of();
    if (v(x))
      return L(x);
    s = setTimeout(_, w(x));
  }
  function L(x) {
    return s = void 0, p && i ? y(x) : (i = a = void 0, r);
  }
  function T() {
    s !== void 0 && clearTimeout(s), h = 0, i = l = a = s = void 0;
  }
  function S() {
    return s === void 0 ? r : L(of());
  }
  function A() {
    var x = of(), M = v(x);
    if (i = arguments, a = this, l = x, M) {
      if (s === void 0)
        return m(l);
      if (f)
        return clearTimeout(s), s = setTimeout(_, e), y(l);
    }
    return s === void 0 && (s = setTimeout(_, e)), r;
  }
  return A.cancel = T, A.flush = S, A;
}
var e2 = qP;
const qs = /* @__PURE__ */ iS(e2), t2 = (n) => {
  if (n[n.length - 1] === "/") {
    const e = n.split("");
    return e.splice(e.length - 1, 1), e.join("");
  }
  return n;
}, n2 = qs((n) => {
  window.open(n);
}, 200), rf = Ie.debug("MapObjectUrl");
class i2 {
  constructor(e, t) {
    this.mapId = e, this.factories = t;
  }
  open(e, t) {
    if (e != null && e.linked) {
      const i = e.outlink;
      e.targetBlank ? n2(i) : (rf("open new map", i), this.factories.mapNameFromUrl.create(
        this.factories.source.create(i)
      ).name(
        this.factories.guest.create((o) => {
          rf("open map name", i, o), t.give(o);
        })
      ));
    }
    return this;
  }
  url(e, t) {
    return e.value(
      this.factories.guestInTheMiddle.create(t, (i) => {
        this.mapId.id(
          this.factories.guest.create((a) => {
            const o = a[0] === "_" ? a.replaceAll("_", "/") : "/current", r = i.name ? i.name : i.additionalName ? i.additionalName : "";
            this.factories.textNoHtml.create(this.factories.source.create(r)).noHtml(
              this.factories.guest.create((s) => {
                let l = i.outlink ? i.outlink : `${o}/${op(s)}`;
                rf("link is", l), l = t2(l), t.give(l);
              })
            );
          })
        );
      })
    ), t;
  }
}
const a2 = Ie.debug("ObjectPositionBounds");
class o2 {
  constructor(e, t) {
    this.stageSize = e, this.factories = t;
  }
  position(e, t, i) {
    return this.stageSize.value(
      this.factories.guestInTheMiddle.create(i, (a) => {
        let { x: o, y: r } = t;
        o < 30 && (o = 30), r < 30 && (r = 30);
        const s = a.width - e.width;
        o > s && (o = s);
        const l = a.height - e.height;
        r > l && (r = l), a2("position", o, r), i.give({ x: o, y: r });
      })
    ), i;
  }
}
const Rc = 15;
class r2 {
  constructor(e, t) {
    this.baseRestriction = e, this.factories = t;
  }
  position(e, t, i) {
    return this.baseRestriction.position(
      e,
      t,
      this.factories.guestInTheMiddle.create(i, (a) => {
        i.give({
          x: Math.round(a.x / Rc) * Rc,
          y: Math.round(a.y / Rc) * Rc
        });
      })
    ), i;
  }
}
const Dv = {
  x: "width",
  y: "height"
}, sf = {
  x: 0,
  y: 1
}, s2 = {
  positive: 1,
  negative: -1
}, Mv = Ie.debug("ObjectsOutsideScreen");
class u2 {
  constructor(e, t, i, a) {
    this.map = e, this.stageSize = t, this.layer = i, this.factories = a;
  }
  count(e, t) {
    const i = e.direction === "positive", a = this.factories.chain.create();
    return this.map.objects(this.factories.guestCast.create(t, a.receiveKey("objects"))), this.layer.layer(this.factories.guestCast.create(t, a.receiveKey("layer"))), this.layer.position(this.factories.guestCast.create(t, a.receiveKey("position"))), a.result(
      this.factories.guestInTheMiddle.create(
        t,
        ({ objects: o, layer: r, position: s }) => {
          var f;
          const l = s2[e.direction], d = o.sort(
            (p, y) => p.position[sf[e.axis]] * l - y.position[sf[e.axis]] * l
          ).filter((p) => {
            const y = p.position[sf[e.axis]] + (i ? 0 : p[Dv[e.axis]]), m = s[e.axis] * -1 + (i ? r[Dv[e.axis]]() : 0);
            return Mv(
              "mb nearest points",
              e.direction,
              "objectP=",
              y,
              "screenP=",
              m
            ), i ? y > m : y < m;
          });
          Mv("nearest", d), t.give({
            count: d.length,
            nearestObjectId: ((f = d.at(i ? -1 : 0)) == null ? void 0 : f.id) ?? ""
          });
        }
      )
    ), t;
  }
}
class l2 {
  constructor(e, t, i) {
    this.mapFile = e, this.map = t, this.factories = i;
  }
  give(e) {
    return this.mapFile.currentMap(
      this.factories.guest.create((t) => {
        this.map.give({
          ...t,
          settings: e
        });
      })
    ), this;
  }
}
class c2 {
  constructor(e) {
    xe(this, "idCache");
    this.idCache = e.sourceEmpty.create();
  }
  typeId(e) {
    return this.idCache.value(e), e;
  }
  give(e) {
    return this.idCache.give(e), this;
  }
}
class h2 {
  constructor(e) {
    this.mapType = e;
  }
  byName() {
    const e = String((/* @__PURE__ */ new Date()).getTime());
    this.mapType.give({
      name: e,
      type: {
        id: e,
        name: "ÐÐ¾Ð²Ñ‹Ð¹ Ñ‚Ð¸Ð¿",
        svg: '<div style="background: lightyellow;border: 1px solid #ccc;">type</div>',
        width: 100,
        height: 40
      }
    });
  }
}
class d2 {
  constructor(e, t, i, a) {
    this.map = e, this.mapFile = t, this.checks = i, this.factories = a;
  }
  give(e) {
    const t = this.factories.chain.create(this);
    return this.checks.forEach((i, a) => {
      i.breakOnFail(
        {
          name: e.id,
          type: e
        },
        t.receiveKey(String(a))
      );
    }), t.result(
      this.factories.guest.create(() => {
        this.mapFile.currentMap(
          this.factories.guest.create((i) => {
            delete i.types[e.id], this.map.give(i);
          })
        );
      })
    ), this;
  }
}
class g2 {
  constructor(e, t, i, a) {
    this.map = e, this.mapFile = t, this.checks = i, this.factories = a;
  }
  give(e) {
    const t = this.factories.chain.create(this);
    return this.checks.forEach((i, a) => {
      i.breakOnFail(e, t.receiveKey(String(a)));
    }), t.result(
      this.factories.guest.create(() => {
        this.mapFile.currentMap(
          this.factories.guest.create((i) => {
            delete i.types[e.name], this.map.give({
              ...i,
              types: {
                ...i.types,
                [e.type.name]: e.type
              }
            });
          })
        );
      })
    ), this;
  }
}
const f2 = Ie.debug("MapTypeUsed");
class p2 {
  constructor(e, t) {
    this.mapFile = e, this.factories = t;
  }
  check(e, t) {
    return this.mapFile.currentMap(
      this.factories.guest.create((i) => {
        const a = Object.values(i.objects).some(
          (o) => o.type === e.name
        );
        f2("is type used", a), t.give(!a || "Ð¢Ð¸Ð¿ ÐºÐ°Ñ€Ñ‚Ñ‹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½");
      })
    ), this;
  }
}
class m2 {
  constructor(e, t) {
    this.mapTypeUsedCheck = e, this.factories = t;
  }
  check(e, t) {
    return this.mapTypeUsedCheck.check(
      e,
      this.factories.guest.create((i) => {
        i !== !0 && e.name !== e.type.name ? t.give("ÐÐµÐ»ÑŒÐ·Ñ Ð¸Ð·Ð¼ÐµÐ½ÑÑ‚ÑŒ Ð¸Ð¼Ñ Ñ‚Ð¸Ð¿Ð°, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½!") : t.give(!0);
      })
    ), this;
  }
}
const Nv = Ie.debug("ParentTypes");
class y2 {
  constructor(e, t, i) {
    this.parentNames = e, this.mapFile = t, this.factories = i;
  }
  types(e) {
    Nv("parent types requested");
    const t = this.factories.chain.create();
    return this.parentNames.names(this.factories.guestCast.create(e, t.receiveKey("parentNames"))), this.mapFile.mapFile(this.factories.guestCast.create(e, t.receiveKey("mapFile"))), t.result(
      this.factories.guestInTheMiddle.create(e, ({ parentNames: i, mapFile: a }) => {
        const o = i.slice(0, -1);
        Nv("parent names", o);
        const r = {};
        o.map((l) => a[l]).forEach((l) => {
          Object.values(l.types).forEach((h) => {
            r[h.name] = h;
          });
        }), e.give(Object.values(r));
      })
    ), e;
  }
}
const Ov = Ie.debug("ObjectsMatchedToQuery");
class b2 {
  constructor(e, t) {
    this.map = e, this.factories = t;
  }
  objects(e, t) {
    return e.value(
      this.factories.guestInTheMiddle.create(
        t,
        qs((a) => {
          a = a.toLowerCase(), this.map.objects(
            this.factories.guest.create((o) => {
              if (!a) {
                Ov("reset results"), t.give([]);
                return;
              }
              const r = o.filter(
                (s) => {
                  var l;
                  return s.name.toLowerCase().includes(a) || ((l = s.additionalName) == null ? void 0 : l.toLowerCase().includes(a)) || Object.values(s.additionalFields ?? {}).join(" ").toLowerCase().includes(a);
                }
              );
              Ov("objects in searching", r, a), t.give(r);
            })
          );
        }, 500)
      )
    ), t;
  }
}
const w2 = {
  height: 3e3,
  width: 3e3
};
class v2 {
  value(e) {
    return e.give(w2), e;
  }
}
const Av = Ie.debug("StageMoveRestriction");
class C2 {
  constructor(e, t, i) {
    this.canvasDep = e, this.stageSize = t, this.factories = i;
  }
  position(e, t) {
    return this.canvasDep.canvas(
      this.factories.guest.create((i) => {
        this.stageSize.value(
          this.factories.guest.create((a) => {
            Av("income position", e);
            const o = a.width - i.clientWidth, r = a.height - i.clientHeight, s = e.x * -1, l = e.y * -1;
            if (r < 0 || o < 0)
              return { x: 0, y: 0 };
            Av("boundings", r, o, l, s), t.give({
              x: e.x > 0 ? 0 : s > o ? o * -1 : e.x,
              y: e.y > 0 ? 0 : l > r ? r * -1 : e.y
            });
          })
        );
      })
    ), t;
  }
}
const Tu = Ie.debug("app:MapObjectsVisible");
class S2 {
  constructor(e, t, i, a) {
    xe(this, "visibleObjectsCache", new V1());
    Tu("constructor initialized");
    const o = a.chain.create();
    t.size(a.patron.create(o.receiveKey("size"))), e.position(a.patron.create(o.receiveKey("position"))), i.currentMap(a.patron.create(o.receiveKey("map"))), o.result(
      a.patron.create(
        a.guest.create(({ position: r, size: s, map: l }) => {
          const h = Object.values(l.objects);
          Tu("objects come to result", h);
          const d = h.filter((f) => {
            const p = l.types[f.type] ?? {}, y = {
              width: f.width || p.width,
              height: f.height || p.height
            };
            return this.isInBounding(r, s, f.position, y);
          });
          Tu("visible objects calculated", d), this.visibleObjectsCache.give(d);
        })
      )
    );
  }
  objects(e) {
    return this.visibleObjectsCache.value(e), this;
  }
  isInBounding(e, t, i, a) {
    const o = e.x, r = e.x - t.width, s = e.y, l = e.y - t.height, [h, d] = i;
    return Tu("bounding vars", o, r, s, l), Tu("object position", i), o > -h - a.width && -h > r && s > -d - a.height && -d > l;
  }
}
const k2 = (n, e) => {
  const t = n.matchAll(e);
  return Array.from(t).map((i) => i[1]);
}, _2 = (n, e) => n.reduce((t, i) => (t[i] = e[i] || i, t), {});
class j2 {
  constructor(e, t, i, a) {
    this.mapFile = t, this.mapObject = i, this.factories = a, e.objectId(this);
  }
  give(e) {
    return this.mapFile.currentMap(
      this.factories.guest.create((t) => {
        const i = t.objects[e];
        if (!i)
          return;
        const a = t.types[i.type], o = /\$\{([a-zA-Z1-9]+)\}/g, s = k2(a.svg, o).filter((l) => l !== "width" && l !== "height");
        i.additionalFields = _2(s, i.additionalFields ?? {}), this.mapObject.give(i);
      })
    ), this;
  }
  introduction() {
    return "patron";
  }
}
class T2 {
  constructor() {
    xe(this, "filledPoints", /* @__PURE__ */ new Map());
  }
  clear() {
    this.filledPoints.clear();
  }
  breakPoints(e, t, i) {
    const a = this.arrowPointPosition(
      e.shapeGeometry,
      e.shapePosition,
      e.lookToGeometry,
      e.lookToPosition
    ), o = this.arrowPointPosition(
      t.shapeGeometry,
      t.shapePosition,
      t.lookToGeometry,
      t.lookToPosition
    );
    return i.give([
      +a.point.x + a.shift.x,
      +a.point.y + a.shift.y,
      +a.breakPoint.x + a.shift.x,
      +a.breakPoint.y + a.shift.y,
      +o.breakPoint.x + o.shift.x,
      +o.breakPoint.y + o.shift.y,
      +o.point.x + o.shift.x,
      +o.point.y + o.shift.y
    ]), this;
  }
  arrowPointPosition(e, t, i, a) {
    const o = {
      x: +a.x + Math.round(i.width / 2),
      y: +a.y + Math.round(i.height / 2)
    }, r = {
      x: +t.x + Math.round(e.width / 2),
      y: +t.y + Math.round(e.height / 2)
    }, s = r.x - o.x, l = r.y - o.y, h = Math.abs(l) > Math.abs(s);
    let d = +t.x, f = +t.y;
    const p = h && l >= 0, y = !h && s >= 0, m = h && l < 0, w = !h && s < 0, v = { x: 0, y: 0 };
    let _ = 0, L = 0;
    p ? (d += Math.round(e.width / 2), v.x = d, v.y = (t.y + a.y + i.height) / 2, _ = a.x > t.x ? 1 : -1) : w ? (f += Math.round(e.height / 2), d += +e.width, v.x = (t.x + e.width + a.x) / 2, v.y = f, L = a.y > t.y ? 1 : -1) : m ? (d += Math.round(e.width / 2), f += +e.height, v.x = d, v.y = (t.y + e.height + a.y) / 2, _ = a.x > t.x ? 1 : -1) : y && (f += Math.round(e.height / 2), v.x = (t.x + a.x + i.width) / 2, v.y = f, L = a.y > t.y ? 1 : -1);
    const T = [d, f].join("-"), S = this.filledPoints.get(T) || 0;
    return this.filledPoints.set(T, S + 1), {
      point: { x: d, y: f },
      breakPoint: v,
      shift: {
        x: _ * S * 10,
        y: L * S * 10
      }
    };
  }
}
var L2 = Math.PI / 180;
function x2() {
  return typeof window < "u" && ({}.toString.call(window) === "[object Window]" || {}.toString.call(window) === "[object global]");
}
const uf = typeof global < "u" ? global : typeof window < "u" ? window : typeof WorkerGlobalScope < "u" ? self : {}, Te = {
  _global: uf,
  version: "8.4.3",
  isBrowser: x2(),
  isUnminified: /param/.test((function(n) {
  }).toString()),
  dblClickWindow: 400,
  getAngle(n) {
    return Te.angleDeg ? n * L2 : n;
  },
  enableTrace: !1,
  pointerEventsEnabled: !0,
  autoDrawEnabled: !0,
  hitOnDragEnabled: !1,
  capturePointerEventsEnabled: !1,
  _mouseListenClick: !1,
  _touchListenClick: !1,
  _pointerListenClick: !1,
  _mouseInDblClickWindow: !1,
  _touchInDblClickWindow: !1,
  _pointerInDblClickWindow: !1,
  _mouseDblClickPointerId: null,
  _touchDblClickPointerId: null,
  _pointerDblClickPointerId: null,
  pixelRatio: typeof window < "u" && window.devicePixelRatio || 1,
  dragDistance: 3,
  angleDeg: !0,
  showWarnings: !0,
  dragButtons: [0, 1],
  isDragging() {
    return Te.DD.isDragging;
  },
  isDragReady() {
    return !!Te.DD.node;
  },
  releaseCanvasOnDestroy: !0,
  document: uf.document,
  _injectGlobal(n) {
    uf.Konva = n;
  }
}, eu = (n) => {
  Te[n.prototype.getClassName()] = n;
};
Te._injectGlobal(Te);
let Ru = class fS {
  constructor(e = [1, 0, 0, 1, 0, 0]) {
    this.dirty = !1, this.m = e && e.slice() || [1, 0, 0, 1, 0, 0];
  }
  reset() {
    this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0;
  }
  copy() {
    return new fS(this.m);
  }
  copyInto(e) {
    e.m[0] = this.m[0], e.m[1] = this.m[1], e.m[2] = this.m[2], e.m[3] = this.m[3], e.m[4] = this.m[4], e.m[5] = this.m[5];
  }
  point(e) {
    var t = this.m;
    return {
      x: t[0] * e.x + t[2] * e.y + t[4],
      y: t[1] * e.x + t[3] * e.y + t[5]
    };
  }
  translate(e, t) {
    return this.m[4] += this.m[0] * e + this.m[2] * t, this.m[5] += this.m[1] * e + this.m[3] * t, this;
  }
  scale(e, t) {
    return this.m[0] *= e, this.m[1] *= e, this.m[2] *= t, this.m[3] *= t, this;
  }
  rotate(e) {
    var t = Math.cos(e), i = Math.sin(e), a = this.m[0] * t + this.m[2] * i, o = this.m[1] * t + this.m[3] * i, r = this.m[0] * -i + this.m[2] * t, s = this.m[1] * -i + this.m[3] * t;
    return this.m[0] = a, this.m[1] = o, this.m[2] = r, this.m[3] = s, this;
  }
  getTranslation() {
    return {
      x: this.m[4],
      y: this.m[5]
    };
  }
  skew(e, t) {
    var i = this.m[0] + this.m[2] * t, a = this.m[1] + this.m[3] * t, o = this.m[2] + this.m[0] * e, r = this.m[3] + this.m[1] * e;
    return this.m[0] = i, this.m[1] = a, this.m[2] = o, this.m[3] = r, this;
  }
  multiply(e) {
    var t = this.m[0] * e.m[0] + this.m[2] * e.m[1], i = this.m[1] * e.m[0] + this.m[3] * e.m[1], a = this.m[0] * e.m[2] + this.m[2] * e.m[3], o = this.m[1] * e.m[2] + this.m[3] * e.m[3], r = this.m[0] * e.m[4] + this.m[2] * e.m[5] + this.m[4], s = this.m[1] * e.m[4] + this.m[3] * e.m[5] + this.m[5];
    return this.m[0] = t, this.m[1] = i, this.m[2] = a, this.m[3] = o, this.m[4] = r, this.m[5] = s, this;
  }
  invert() {
    var e = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), t = this.m[3] * e, i = -this.m[1] * e, a = -this.m[2] * e, o = this.m[0] * e, r = e * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), s = e * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
    return this.m[0] = t, this.m[1] = i, this.m[2] = a, this.m[3] = o, this.m[4] = r, this.m[5] = s, this;
  }
  getMatrix() {
    return this.m;
  }
  decompose() {
    var e = this.m[0], t = this.m[1], i = this.m[2], a = this.m[3], o = this.m[4], r = this.m[5], s = e * a - t * i;
    let l = {
      x: o,
      y: r,
      rotation: 0,
      scaleX: 0,
      scaleY: 0,
      skewX: 0,
      skewY: 0
    };
    if (e != 0 || t != 0) {
      var h = Math.sqrt(e * e + t * t);
      l.rotation = t > 0 ? Math.acos(e / h) : -Math.acos(e / h), l.scaleX = h, l.scaleY = s / h, l.skewX = (e * i + t * a) / s, l.skewY = 0;
    } else if (i != 0 || a != 0) {
      var d = Math.sqrt(i * i + a * a);
      l.rotation = Math.PI / 2 - (a > 0 ? Math.acos(-i / d) : -Math.acos(i / d)), l.scaleX = s / d, l.scaleY = d, l.skewX = 0, l.skewY = (e * i + t * a) / s;
    }
    return l.rotation = Q._getRotation(l.rotation), l;
  }
};
var E2 = "[object Array]", D2 = "[object Number]", M2 = "[object String]", N2 = "[object Boolean]", O2 = Math.PI / 180, A2 = 180 / Math.PI, lf = "#", Y2 = "", P2 = "0", R2 = "Konva warning: ", Yv = "Konva error: ", F2 = "rgb(", cf = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 132, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 255, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 203],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [119, 128, 144],
  slategrey: [119, 128, 144],
  snow: [255, 255, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  transparent: [255, 255, 255, 0],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 5]
}, I2 = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, Fc = [];
const J2 = typeof requestAnimationFrame < "u" && requestAnimationFrame || function(n) {
  setTimeout(n, 60);
}, Q = {
  _isElement(n) {
    return !!(n && n.nodeType == 1);
  },
  _isFunction(n) {
    return !!(n && n.constructor && n.call && n.apply);
  },
  _isPlainObject(n) {
    return !!n && n.constructor === Object;
  },
  _isArray(n) {
    return Object.prototype.toString.call(n) === E2;
  },
  _isNumber(n) {
    return Object.prototype.toString.call(n) === D2 && !isNaN(n) && isFinite(n);
  },
  _isString(n) {
    return Object.prototype.toString.call(n) === M2;
  },
  _isBoolean(n) {
    return Object.prototype.toString.call(n) === N2;
  },
  isObject(n) {
    return n instanceof Object;
  },
  isValidSelector(n) {
    if (typeof n != "string")
      return !1;
    var e = n[0];
    return e === "#" || e === "." || e === e.toUpperCase();
  },
  _sign(n) {
    return n === 0 || n > 0 ? 1 : -1;
  },
  requestAnimFrame(n) {
    Fc.push(n), Fc.length === 1 && J2(function() {
      const e = Fc;
      Fc = [], e.forEach(function(t) {
        t();
      });
    });
  },
  createCanvasElement() {
    var n = document.createElement("canvas");
    try {
      n.style = n.style || {};
    } catch {
    }
    return n;
  },
  createImageElement() {
    return document.createElement("img");
  },
  _isInDocument(n) {
    for (; n = n.parentNode; )
      if (n == document)
        return !0;
    return !1;
  },
  _urlToImage(n, e) {
    var t = Q.createImageElement();
    t.onload = function() {
      e(t);
    }, t.src = n;
  },
  _rgbToHex(n, e, t) {
    return ((1 << 24) + (n << 16) + (e << 8) + t).toString(16).slice(1);
  },
  _hexToRgb(n) {
    n = n.replace(lf, Y2);
    var e = parseInt(n, 16);
    return {
      r: e >> 16 & 255,
      g: e >> 8 & 255,
      b: e & 255
    };
  },
  getRandomColor() {
    for (var n = (Math.random() * 16777215 << 0).toString(16); n.length < 6; )
      n = P2 + n;
    return lf + n;
  },
  getRGB(n) {
    var e;
    return n in cf ? (e = cf[n], {
      r: e[0],
      g: e[1],
      b: e[2]
    }) : n[0] === lf ? this._hexToRgb(n.substring(1)) : n.substr(0, 4) === F2 ? (e = I2.exec(n.replace(/ /g, "")), {
      r: parseInt(e[1], 10),
      g: parseInt(e[2], 10),
      b: parseInt(e[3], 10)
    }) : {
      r: 0,
      g: 0,
      b: 0
    };
  },
  colorToRGBA(n) {
    return n = n || "black", Q._namedColorToRBA(n) || Q._hex3ColorToRGBA(n) || Q._hex4ColorToRGBA(n) || Q._hex6ColorToRGBA(n) || Q._hex8ColorToRGBA(n) || Q._rgbColorToRGBA(n) || Q._rgbaColorToRGBA(n) || Q._hslColorToRGBA(n);
  },
  _namedColorToRBA(n) {
    var e = cf[n.toLowerCase()];
    return e ? {
      r: e[0],
      g: e[1],
      b: e[2],
      a: 1
    } : null;
  },
  _rgbColorToRGBA(n) {
    if (n.indexOf("rgb(") === 0) {
      n = n.match(/rgb\(([^)]+)\)/)[1];
      var e = n.split(/ *, */).map(Number);
      return {
        r: e[0],
        g: e[1],
        b: e[2],
        a: 1
      };
    }
  },
  _rgbaColorToRGBA(n) {
    if (n.indexOf("rgba(") === 0) {
      n = n.match(/rgba\(([^)]+)\)/)[1];
      var e = n.split(/ *, */).map((t, i) => t.slice(-1) === "%" ? i === 3 ? parseInt(t) / 100 : parseInt(t) / 100 * 255 : Number(t));
      return {
        r: e[0],
        g: e[1],
        b: e[2],
        a: e[3]
      };
    }
  },
  _hex8ColorToRGBA(n) {
    if (n[0] === "#" && n.length === 9)
      return {
        r: parseInt(n.slice(1, 3), 16),
        g: parseInt(n.slice(3, 5), 16),
        b: parseInt(n.slice(5, 7), 16),
        a: parseInt(n.slice(7, 9), 16) / 255
      };
  },
  _hex6ColorToRGBA(n) {
    if (n[0] === "#" && n.length === 7)
      return {
        r: parseInt(n.slice(1, 3), 16),
        g: parseInt(n.slice(3, 5), 16),
        b: parseInt(n.slice(5, 7), 16),
        a: 1
      };
  },
  _hex4ColorToRGBA(n) {
    if (n[0] === "#" && n.length === 5)
      return {
        r: parseInt(n[1] + n[1], 16),
        g: parseInt(n[2] + n[2], 16),
        b: parseInt(n[3] + n[3], 16),
        a: parseInt(n[4] + n[4], 16) / 255
      };
  },
  _hex3ColorToRGBA(n) {
    if (n[0] === "#" && n.length === 4)
      return {
        r: parseInt(n[1] + n[1], 16),
        g: parseInt(n[2] + n[2], 16),
        b: parseInt(n[3] + n[3], 16),
        a: 1
      };
  },
  _hslColorToRGBA(n) {
    if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(n)) {
      const [e, ...t] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(n), i = Number(t[0]) / 360, a = Number(t[1]) / 100, o = Number(t[2]) / 100;
      let r, s, l;
      if (a === 0)
        return l = o * 255, {
          r: Math.round(l),
          g: Math.round(l),
          b: Math.round(l),
          a: 1
        };
      o < 0.5 ? r = o * (1 + a) : r = o + a - o * a;
      const h = 2 * o - r, d = [0, 0, 0];
      for (let f = 0; f < 3; f++)
        s = i + 1 / 3 * -(f - 1), s < 0 && s++, s > 1 && s--, 6 * s < 1 ? l = h + (r - h) * 6 * s : 2 * s < 1 ? l = r : 3 * s < 2 ? l = h + (r - h) * (2 / 3 - s) * 6 : l = h, d[f] = l * 255;
      return {
        r: Math.round(d[0]),
        g: Math.round(d[1]),
        b: Math.round(d[2]),
        a: 1
      };
    }
  },
  haveIntersection(n, e) {
    return !(e.x > n.x + n.width || e.x + e.width < n.x || e.y > n.y + n.height || e.y + e.height < n.y);
  },
  cloneObject(n) {
    var e = {};
    for (var t in n)
      this._isPlainObject(n[t]) ? e[t] = this.cloneObject(n[t]) : this._isArray(n[t]) ? e[t] = this.cloneArray(n[t]) : e[t] = n[t];
    return e;
  },
  cloneArray(n) {
    return n.slice(0);
  },
  degToRad(n) {
    return n * O2;
  },
  radToDeg(n) {
    return n * A2;
  },
  _degToRad(n) {
    return Q.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), Q.degToRad(n);
  },
  _radToDeg(n) {
    return Q.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), Q.radToDeg(n);
  },
  _getRotation(n) {
    return Te.angleDeg ? Q.radToDeg(n) : n;
  },
  _capitalize(n) {
    return n.charAt(0).toUpperCase() + n.slice(1);
  },
  throw(n) {
    throw new Error(Yv + n);
  },
  error(n) {
    console.error(Yv + n);
  },
  warn(n) {
    Te.showWarnings && console.warn(R2 + n);
  },
  each(n, e) {
    for (var t in n)
      e(t, n[t]);
  },
  _inRange(n, e, t) {
    return e <= n && n < t;
  },
  _getProjectionToSegment(n, e, t, i, a, o) {
    var r, s, l, h = (n - t) * (n - t) + (e - i) * (e - i);
    if (h == 0)
      r = n, s = e, l = (a - t) * (a - t) + (o - i) * (o - i);
    else {
      var d = ((a - n) * (t - n) + (o - e) * (i - e)) / h;
      d < 0 ? (r = n, s = e, l = (n - a) * (n - a) + (e - o) * (e - o)) : d > 1 ? (r = t, s = i, l = (t - a) * (t - a) + (i - o) * (i - o)) : (r = n + d * (t - n), s = e + d * (i - e), l = (r - a) * (r - a) + (s - o) * (s - o));
    }
    return [r, s, l];
  },
  _getProjectionToLine(n, e, t) {
    var i = Q.cloneObject(n), a = Number.MAX_VALUE;
    return e.forEach(function(o, r) {
      if (!(!t && r === e.length - 1)) {
        var s = e[(r + 1) % e.length], l = Q._getProjectionToSegment(o.x, o.y, s.x, s.y, n.x, n.y), h = l[0], d = l[1], f = l[2];
        f < a && (i.x = h, i.y = d, a = f);
      }
    }), i;
  },
  _prepareArrayForTween(n, e, t) {
    var i, a = [], o = [];
    if (n.length > e.length) {
      var r = e;
      e = n, n = r;
    }
    for (i = 0; i < n.length; i += 2)
      a.push({
        x: n[i],
        y: n[i + 1]
      });
    for (i = 0; i < e.length; i += 2)
      o.push({
        x: e[i],
        y: e[i + 1]
      });
    var s = [];
    return o.forEach(function(l) {
      var h = Q._getProjectionToLine(l, a, t);
      s.push(h.x), s.push(h.y);
    }), s;
  },
  _prepareToStringify(n) {
    var e;
    n.visitedByCircularReferenceRemoval = !0;
    for (var t in n)
      if (n.hasOwnProperty(t) && n[t] && typeof n[t] == "object") {
        if (e = Object.getOwnPropertyDescriptor(n, t), n[t].visitedByCircularReferenceRemoval || Q._isElement(n[t]))
          if (e.configurable)
            delete n[t];
          else
            return null;
        else if (Q._prepareToStringify(n[t]) === null)
          if (e.configurable)
            delete n[t];
          else
            return null;
      }
    return delete n.visitedByCircularReferenceRemoval, n;
  },
  _assign(n, e) {
    for (var t in e)
      n[t] = e[t];
    return n;
  },
  _getFirstPointerId(n) {
    return n.touches ? n.changedTouches[0].identifier : n.pointerId || 999;
  },
  releaseCanvas(...n) {
    Te.releaseCanvasOnDestroy && n.forEach((e) => {
      e.width = 0, e.height = 0;
    });
  },
  drawRoundedRectPath(n, e, t, i) {
    let a = 0, o = 0, r = 0, s = 0;
    typeof i == "number" ? a = o = r = s = Math.min(i, e / 2, t / 2) : (a = Math.min(i[0] || 0, e / 2, t / 2), o = Math.min(i[1] || 0, e / 2, t / 2), s = Math.min(i[2] || 0, e / 2, t / 2), r = Math.min(i[3] || 0, e / 2, t / 2)), n.moveTo(a, 0), n.lineTo(e - o, 0), n.arc(e - o, o, o, Math.PI * 3 / 2, 0, !1), n.lineTo(e, t - s), n.arc(e - s, t - s, s, 0, Math.PI / 2, !1), n.lineTo(r, t), n.arc(r, t - r, r, Math.PI / 2, Math.PI, !1), n.lineTo(0, a), n.arc(a, a, a, Math.PI, Math.PI * 3 / 2, !1);
  }
};
function Wo(n) {
  return Q._isString(n) ? '"' + n + '"' : Object.prototype.toString.call(n) === "[object Number]" || Q._isBoolean(n) ? n : Object.prototype.toString.call(n);
}
function nt() {
  if (Te.isUnminified)
    return function(n, e) {
      return Q._isNumber(n) || Q.warn(Wo(n) + ' is a not valid value for "' + e + '" attribute. The value should be a number.'), n;
    };
}
function Z2(n) {
  if (Te.isUnminified)
    return function(e, t) {
      let i = Q._isNumber(e), a = Q._isArray(e) && e.length == n;
      return !i && !a && Q.warn(Wo(e) + ' is a not valid value for "' + t + '" attribute. The value should be a number or Array<number>(' + n + ")"), e;
    };
}
function B2() {
  if (Te.isUnminified)
    return function(n, e) {
      var t = Q._isNumber(n), i = n === "auto";
      return t || i || Q.warn(Wo(n) + ' is a not valid value for "' + e + '" attribute. The value should be a number or "auto".'), n;
    };
}
function Yl() {
  if (Te.isUnminified)
    return function(n, e) {
      return Q._isString(n) || Q.warn(Wo(n) + ' is a not valid value for "' + e + '" attribute. The value should be a string.'), n;
    };
}
function pS() {
  if (Te.isUnminified)
    return function(n, e) {
      const t = Q._isString(n), i = Object.prototype.toString.call(n) === "[object CanvasGradient]" || n && n.addColorStop;
      return t || i || Q.warn(Wo(n) + ' is a not valid value for "' + e + '" attribute. The value should be a string or a native gradient.'), n;
    };
}
function H2() {
  if (Te.isUnminified)
    return function(n, e) {
      const t = Int8Array ? Object.getPrototypeOf(Int8Array) : null;
      return t && n instanceof t || (Q._isArray(n) ? n.forEach(function(i) {
        Q._isNumber(i) || Q.warn('"' + e + '" attribute has non numeric element ' + i + ". Make sure that all elements are numbers.");
      }) : Q.warn(Wo(n) + ' is a not valid value for "' + e + '" attribute. The value should be a array of numbers.')), n;
    };
}
function Br() {
  if (Te.isUnminified)
    return function(n, e) {
      var t = n === !0 || n === !1;
      return t || Q.warn(Wo(n) + ' is a not valid value for "' + e + '" attribute. The value should be a boolean.'), n;
    };
}
function X2(n) {
  if (Te.isUnminified)
    return function(e, t) {
      return e == null || Q.isObject(e) || Q.warn(Wo(e) + ' is a not valid value for "' + t + '" attribute. The value should be an object with properties ' + n), e;
    };
}
var Lu = "get", xu = "set";
const ee = {
  addGetterSetter(n, e, t, i, a) {
    ee.addGetter(n, e, t), ee.addSetter(n, e, i, a), ee.addOverloadedGetterSetter(n, e);
  },
  addGetter(n, e, t) {
    var i = Lu + Q._capitalize(e);
    n.prototype[i] = n.prototype[i] || function() {
      var a = this.attrs[e];
      return a === void 0 ? t : a;
    };
  },
  addSetter(n, e, t, i) {
    var a = xu + Q._capitalize(e);
    n.prototype[a] || ee.overWriteSetter(n, e, t, i);
  },
  overWriteSetter(n, e, t, i) {
    var a = xu + Q._capitalize(e);
    n.prototype[a] = function(o) {
      return t && o !== void 0 && o !== null && (o = t.call(this, o, e)), this._setAttr(e, o), i && i.call(this), this;
    };
  },
  addComponentsGetterSetter(n, e, t, i, a) {
    var o = t.length, r = Q._capitalize, s = Lu + r(e), l = xu + r(e), h, d;
    n.prototype[s] = function() {
      var p = {};
      for (h = 0; h < o; h++)
        d = t[h], p[d] = this.getAttr(e + r(d));
      return p;
    };
    var f = X2(t);
    n.prototype[l] = function(p) {
      var y = this.attrs[e], m;
      i && (p = i.call(this, p)), f && f.call(this, p, e);
      for (m in p)
        p.hasOwnProperty(m) && this._setAttr(e + r(m), p[m]);
      return p || t.forEach((w) => {
        this._setAttr(e + r(w), void 0);
      }), this._fireChangeEvent(e, y, p), a && a.call(this), this;
    }, ee.addOverloadedGetterSetter(n, e);
  },
  addOverloadedGetterSetter(n, e) {
    var t = Q._capitalize(e), i = xu + t, a = Lu + t;
    n.prototype[e] = function() {
      return arguments.length ? (this[i](arguments[0]), this) : this[a]();
    };
  },
  addDeprecatedGetterSetter(n, e, t, i) {
    Q.error("Adding deprecated " + e);
    var a = Lu + Q._capitalize(e), o = e + " property is deprecated and will be removed soon. Look at Konva change log for more information.";
    n.prototype[a] = function() {
      Q.error(o);
      var r = this.attrs[e];
      return r === void 0 ? t : r;
    }, ee.addSetter(n, e, i, function() {
      Q.error(o);
    }), ee.addOverloadedGetterSetter(n, e);
  },
  backCompat(n, e) {
    Q.each(e, function(t, i) {
      var a = n.prototype[i], o = Lu + Q._capitalize(t), r = xu + Q._capitalize(t);
      function s() {
        a.apply(this, arguments), Q.error('"' + t + '" method is deprecated and will be removed soon. Use ""' + i + '" instead.');
      }
      n.prototype[t] = s, n.prototype[o] = s, n.prototype[r] = s;
    });
  },
  afterSetFilter() {
    this._filterUpToDate = !1;
  }
};
function G2(n) {
  var e = [], t = n.length, i = Q, a, o;
  for (a = 0; a < t; a++)
    o = n[a], i._isNumber(o) ? o = Math.round(o * 1e3) / 1e3 : i._isString(o) || (o = o + ""), e.push(o);
  return e;
}
var Pv = ",", W2 = "(", Q2 = ")", K2 = "([", z2 = "])", $2 = ";", V2 = "()", U2 = "=", Rv = [
  "arc",
  "arcTo",
  "beginPath",
  "bezierCurveTo",
  "clearRect",
  "clip",
  "closePath",
  "createLinearGradient",
  "createPattern",
  "createRadialGradient",
  "drawImage",
  "ellipse",
  "fill",
  "fillText",
  "getImageData",
  "createImageData",
  "lineTo",
  "moveTo",
  "putImageData",
  "quadraticCurveTo",
  "rect",
  "restore",
  "rotate",
  "save",
  "scale",
  "setLineDash",
  "setTransform",
  "stroke",
  "strokeText",
  "transform",
  "translate"
], q2 = [
  "fillStyle",
  "strokeStyle",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "lineCap",
  "lineDashOffset",
  "lineJoin",
  "lineWidth",
  "miterLimit",
  "font",
  "textAlign",
  "textBaseline",
  "globalAlpha",
  "globalCompositeOperation",
  "imageSmoothingEnabled"
];
const eR = 100;
class km {
  constructor(e) {
    this.canvas = e, Te.enableTrace && (this.traceArr = [], this._enableTrace());
  }
  fillShape(e) {
    e.fillEnabled() && this._fill(e);
  }
  _fill(e) {
  }
  strokeShape(e) {
    e.hasStroke() && this._stroke(e);
  }
  _stroke(e) {
  }
  fillStrokeShape(e) {
    e.attrs.fillAfterStrokeEnabled ? (this.strokeShape(e), this.fillShape(e)) : (this.fillShape(e), this.strokeShape(e));
  }
  getTrace(e, t) {
    var i = this.traceArr, a = i.length, o = "", r, s, l, h;
    for (r = 0; r < a; r++)
      s = i[r], l = s.method, l ? (h = s.args, o += l, e ? o += V2 : Q._isArray(h[0]) ? o += K2 + h.join(Pv) + z2 : (t && (h = h.map((d) => typeof d == "number" ? Math.floor(d) : d)), o += W2 + h.join(Pv) + Q2)) : (o += s.property, e || (o += U2 + s.val)), o += $2;
    return o;
  }
  clearTrace() {
    this.traceArr = [];
  }
  _trace(e) {
    var t = this.traceArr, i;
    t.push(e), i = t.length, i >= eR && t.shift();
  }
  reset() {
    var e = this.getCanvas().getPixelRatio();
    this.setTransform(1 * e, 0, 0, 1 * e, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  clear(e) {
    var t = this.getCanvas();
    e ? this.clearRect(e.x || 0, e.y || 0, e.width || 0, e.height || 0) : this.clearRect(0, 0, t.getWidth() / t.pixelRatio, t.getHeight() / t.pixelRatio);
  }
  _applyLineCap(e) {
    const t = e.attrs.lineCap;
    t && this.setAttr("lineCap", t);
  }
  _applyOpacity(e) {
    var t = e.getAbsoluteOpacity();
    t !== 1 && this.setAttr("globalAlpha", t);
  }
  _applyLineJoin(e) {
    const t = e.attrs.lineJoin;
    t && this.setAttr("lineJoin", t);
  }
  setAttr(e, t) {
    this._context[e] = t;
  }
  arc(e, t, i, a, o, r) {
    this._context.arc(e, t, i, a, o, r);
  }
  arcTo(e, t, i, a, o) {
    this._context.arcTo(e, t, i, a, o);
  }
  beginPath() {
    this._context.beginPath();
  }
  bezierCurveTo(e, t, i, a, o, r) {
    this._context.bezierCurveTo(e, t, i, a, o, r);
  }
  clearRect(e, t, i, a) {
    this._context.clearRect(e, t, i, a);
  }
  clip() {
    this._context.clip();
  }
  closePath() {
    this._context.closePath();
  }
  createImageData(e, t) {
    var i = arguments;
    if (i.length === 2)
      return this._context.createImageData(e, t);
    if (i.length === 1)
      return this._context.createImageData(e);
  }
  createLinearGradient(e, t, i, a) {
    return this._context.createLinearGradient(e, t, i, a);
  }
  createPattern(e, t) {
    return this._context.createPattern(e, t);
  }
  createRadialGradient(e, t, i, a, o, r) {
    return this._context.createRadialGradient(e, t, i, a, o, r);
  }
  drawImage(e, t, i, a, o, r, s, l, h) {
    var d = arguments, f = this._context;
    d.length === 3 ? f.drawImage(e, t, i) : d.length === 5 ? f.drawImage(e, t, i, a, o) : d.length === 9 && f.drawImage(e, t, i, a, o, r, s, l, h);
  }
  ellipse(e, t, i, a, o, r, s, l) {
    this._context.ellipse(e, t, i, a, o, r, s, l);
  }
  isPointInPath(e, t, i, a) {
    return i ? this._context.isPointInPath(i, e, t, a) : this._context.isPointInPath(e, t, a);
  }
  fill(e) {
    e ? this._context.fill(e) : this._context.fill();
  }
  fillRect(e, t, i, a) {
    this._context.fillRect(e, t, i, a);
  }
  strokeRect(e, t, i, a) {
    this._context.strokeRect(e, t, i, a);
  }
  fillText(e, t, i, a) {
    a ? this._context.fillText(e, t, i, a) : this._context.fillText(e, t, i);
  }
  measureText(e) {
    return this._context.measureText(e);
  }
  getImageData(e, t, i, a) {
    return this._context.getImageData(e, t, i, a);
  }
  lineTo(e, t) {
    this._context.lineTo(e, t);
  }
  moveTo(e, t) {
    this._context.moveTo(e, t);
  }
  rect(e, t, i, a) {
    this._context.rect(e, t, i, a);
  }
  putImageData(e, t, i) {
    this._context.putImageData(e, t, i);
  }
  quadraticCurveTo(e, t, i, a) {
    this._context.quadraticCurveTo(e, t, i, a);
  }
  restore() {
    this._context.restore();
  }
  rotate(e) {
    this._context.rotate(e);
  }
  save() {
    this._context.save();
  }
  scale(e, t) {
    this._context.scale(e, t);
  }
  setLineDash(e) {
    this._context.setLineDash ? this._context.setLineDash(e) : "mozDash" in this._context ? this._context.mozDash = e : "webkitLineDash" in this._context && (this._context.webkitLineDash = e);
  }
  getLineDash() {
    return this._context.getLineDash();
  }
  setTransform(e, t, i, a, o, r) {
    this._context.setTransform(e, t, i, a, o, r);
  }
  stroke(e) {
    e ? this._context.stroke(e) : this._context.stroke();
  }
  strokeText(e, t, i, a) {
    this._context.strokeText(e, t, i, a);
  }
  transform(e, t, i, a, o, r) {
    this._context.transform(e, t, i, a, o, r);
  }
  translate(e, t) {
    this._context.translate(e, t);
  }
  _enableTrace() {
    var e = this, t = Rv.length, i = this.setAttr, a, o, r = function(s) {
      var l = e[s], h;
      e[s] = function() {
        return o = G2(Array.prototype.slice.call(arguments, 0)), h = l.apply(e, arguments), e._trace({
          method: s,
          args: o
        }), h;
      };
    };
    for (a = 0; a < t; a++)
      r(Rv[a]);
    e.setAttr = function() {
      i.apply(e, arguments);
      var s = arguments[0], l = arguments[1];
      (s === "shadowOffsetX" || s === "shadowOffsetY" || s === "shadowBlur") && (l = l / this.canvas.getPixelRatio()), e._trace({
        property: s,
        val: l
      });
    };
  }
  _applyGlobalCompositeOperation(e) {
    const t = e.attrs.globalCompositeOperation;
    var i = !t || t === "source-over";
    i || this.setAttr("globalCompositeOperation", t);
  }
}
q2.forEach(function(n) {
  Object.defineProperty(km.prototype, n, {
    get() {
      return this._context[n];
    },
    set(e) {
      this._context[n] = e;
    }
  });
});
class tR extends km {
  constructor(e) {
    super(e), this._context = e._canvas.getContext("2d");
  }
  _fillColor(e) {
    var t = e.fill();
    this.setAttr("fillStyle", t), e._fillFunc(this);
  }
  _fillPattern(e) {
    this.setAttr("fillStyle", e._getFillPattern()), e._fillFunc(this);
  }
  _fillLinearGradient(e) {
    var t = e._getLinearGradient();
    t && (this.setAttr("fillStyle", t), e._fillFunc(this));
  }
  _fillRadialGradient(e) {
    const t = e._getRadialGradient();
    t && (this.setAttr("fillStyle", t), e._fillFunc(this));
  }
  _fill(e) {
    const t = e.fill(), i = e.getFillPriority();
    if (t && i === "color") {
      this._fillColor(e);
      return;
    }
    const a = e.getFillPatternImage();
    if (a && i === "pattern") {
      this._fillPattern(e);
      return;
    }
    const o = e.getFillLinearGradientColorStops();
    if (o && i === "linear-gradient") {
      this._fillLinearGradient(e);
      return;
    }
    const r = e.getFillRadialGradientColorStops();
    if (r && i === "radial-gradient") {
      this._fillRadialGradient(e);
      return;
    }
    t ? this._fillColor(e) : a ? this._fillPattern(e) : o ? this._fillLinearGradient(e) : r && this._fillRadialGradient(e);
  }
  _strokeLinearGradient(e) {
    const t = e.getStrokeLinearGradientStartPoint(), i = e.getStrokeLinearGradientEndPoint(), a = e.getStrokeLinearGradientColorStops(), o = this.createLinearGradient(t.x, t.y, i.x, i.y);
    if (a) {
      for (var r = 0; r < a.length; r += 2)
        o.addColorStop(a[r], a[r + 1]);
      this.setAttr("strokeStyle", o);
    }
  }
  _stroke(e) {
    var t = e.dash(), i = e.getStrokeScaleEnabled();
    if (e.hasStroke()) {
      if (!i) {
        this.save();
        var a = this.getCanvas().getPixelRatio();
        this.setTransform(a, 0, 0, a, 0, 0);
      }
      this._applyLineCap(e), t && e.dashEnabled() && (this.setLineDash(t), this.setAttr("lineDashOffset", e.dashOffset())), this.setAttr("lineWidth", e.strokeWidth()), e.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)");
      var o = e.getStrokeLinearGradientColorStops();
      o ? this._strokeLinearGradient(e) : this.setAttr("strokeStyle", e.stroke()), e._strokeFunc(this), i || this.restore();
    }
  }
  _applyShadow(e) {
    var t, i, a, o = (t = e.getShadowRGBA()) !== null && t !== void 0 ? t : "black", r = (i = e.getShadowBlur()) !== null && i !== void 0 ? i : 5, s = (a = e.getShadowOffset()) !== null && a !== void 0 ? a : {
      x: 0,
      y: 0
    }, l = e.getAbsoluteScale(), h = this.canvas.getPixelRatio(), d = l.x * h, f = l.y * h;
    this.setAttr("shadowColor", o), this.setAttr("shadowBlur", r * Math.min(Math.abs(d), Math.abs(f))), this.setAttr("shadowOffsetX", s.x * d), this.setAttr("shadowOffsetY", s.y * f);
  }
}
class nR extends km {
  constructor(e) {
    super(e), this._context = e._canvas.getContext("2d", {
      willReadFrequently: !0
    });
  }
  _fill(e) {
    this.save(), this.setAttr("fillStyle", e.colorKey), e._fillFuncHit(this), this.restore();
  }
  strokeShape(e) {
    e.hasHitStroke() && this._stroke(e);
  }
  _stroke(e) {
    if (e.hasHitStroke()) {
      const o = e.getStrokeScaleEnabled();
      if (!o) {
        this.save();
        var t = this.getCanvas().getPixelRatio();
        this.setTransform(t, 0, 0, t, 0, 0);
      }
      this._applyLineCap(e);
      var i = e.hitStrokeWidth(), a = i === "auto" ? e.strokeWidth() : i;
      this.setAttr("lineWidth", a), this.setAttr("strokeStyle", e.colorKey), e._strokeFuncHit(this), o || this.restore();
    }
  }
}
var Ic;
function iR() {
  if (Ic)
    return Ic;
  var n = Q.createCanvasElement(), e = n.getContext("2d");
  return Ic = function() {
    var t = Te._global.devicePixelRatio || 1, i = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1;
    return t / i;
  }(), Q.releaseCanvas(n), Ic;
}
class _m {
  constructor(e) {
    this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;
    var t = e || {}, i = t.pixelRatio || Te.pixelRatio || iR();
    this.pixelRatio = i, this._canvas = Q.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0";
  }
  getContext() {
    return this.context;
  }
  getPixelRatio() {
    return this.pixelRatio;
  }
  setPixelRatio(e) {
    var t = this.pixelRatio;
    this.pixelRatio = e, this.setSize(this.getWidth() / t, this.getHeight() / t);
  }
  setWidth(e) {
    this.width = this._canvas.width = e * this.pixelRatio, this._canvas.style.width = e + "px";
    var t = this.pixelRatio, i = this.getContext()._context;
    i.scale(t, t);
  }
  setHeight(e) {
    this.height = this._canvas.height = e * this.pixelRatio, this._canvas.style.height = e + "px";
    var t = this.pixelRatio, i = this.getContext()._context;
    i.scale(t, t);
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setSize(e, t) {
    this.setWidth(e || 0), this.setHeight(t || 0);
  }
  toDataURL(e, t) {
    try {
      return this._canvas.toDataURL(e, t);
    } catch {
      try {
        return this._canvas.toDataURL();
      } catch (a) {
        return Q.error("Unable to get data URL. " + a.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "";
      }
    }
  }
}
ee.addGetterSetter(_m, "pixelRatio", void 0, nt());
class Ku extends _m {
  constructor(e = { width: 0, height: 0 }) {
    super(e), this.context = new tR(this), this.setSize(e.width, e.height);
  }
}
class mS extends _m {
  constructor(e = { width: 0, height: 0 }) {
    super(e), this.hitCanvas = !0, this.context = new nR(this), this.setSize(e.width, e.height);
  }
}
const rt = {
  get isDragging() {
    var n = !1;
    return rt._dragElements.forEach((e) => {
      e.dragStatus === "dragging" && (n = !0);
    }), n;
  },
  justDragged: !1,
  get node() {
    var n;
    return rt._dragElements.forEach((e) => {
      n = e.node;
    }), n;
  },
  _dragElements: /* @__PURE__ */ new Map(),
  _drag(n) {
    const e = [];
    rt._dragElements.forEach((t, i) => {
      const { node: a } = t, o = a.getStage();
      o.setPointersPositions(n), t.pointerId === void 0 && (t.pointerId = Q._getFirstPointerId(n));
      const r = o._changedPointerPositions.find((h) => h.id === t.pointerId);
      if (r) {
        if (t.dragStatus !== "dragging") {
          var s = a.dragDistance(), l = Math.max(Math.abs(r.x - t.startPointerPos.x), Math.abs(r.y - t.startPointerPos.y));
          if (l < s || (a.startDrag({ evt: n }), !a.isDragging()))
            return;
        }
        a._setDragPosition(n, t), e.push(a);
      }
    }), e.forEach((t) => {
      t.fire("dragmove", {
        type: "dragmove",
        target: t,
        evt: n
      }, !0);
    });
  },
  _endDragBefore(n) {
    const e = [];
    rt._dragElements.forEach((t) => {
      const { node: i } = t, a = i.getStage();
      if (n && a.setPointersPositions(n), !a._changedPointerPositions.find((s) => s.id === t.pointerId))
        return;
      (t.dragStatus === "dragging" || t.dragStatus === "stopped") && (rt.justDragged = !0, Te._mouseListenClick = !1, Te._touchListenClick = !1, Te._pointerListenClick = !1, t.dragStatus = "stopped");
      const r = t.node.getLayer() || t.node instanceof Te.Stage && t.node;
      r && e.indexOf(r) === -1 && e.push(r);
    }), e.forEach((t) => {
      t.draw();
    });
  },
  _endDragAfter(n) {
    rt._dragElements.forEach((e, t) => {
      e.dragStatus === "stopped" && e.node.fire("dragend", {
        type: "dragend",
        target: e.node,
        evt: n
      }, !0), e.dragStatus !== "dragging" && rt._dragElements.delete(t);
    });
  }
};
Te.isBrowser && (window.addEventListener("mouseup", rt._endDragBefore, !0), window.addEventListener("touchend", rt._endDragBefore, !0), window.addEventListener("mousemove", rt._drag), window.addEventListener("touchmove", rt._drag), window.addEventListener("mouseup", rt._endDragAfter, !1), window.addEventListener("touchend", rt._endDragAfter, !1));
var dh = "absoluteOpacity", Jc = "allEventListeners", Ha = "absoluteTransform", Fv = "absoluteScale", lr = "canvas", aR = "Change", oR = "children", rR = "konva", rp = "listening", Iv = "mouseenter", Jv = "mouseleave", Zv = "set", Bv = "Shape", gh = " ", Hv = "stage", So = "transform", sR = "Stage", sp = "visible", uR = [
  "xChange.konva",
  "yChange.konva",
  "scaleXChange.konva",
  "scaleYChange.konva",
  "skewXChange.konva",
  "skewYChange.konva",
  "rotationChange.konva",
  "offsetXChange.konva",
  "offsetYChange.konva",
  "transformsEnabledChange.konva"
].join(gh);
let lR = 1, Le = class up {
  constructor(e) {
    this._id = lR++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = /* @__PURE__ */ new Map(), this._attachedDepsListeners = /* @__PURE__ */ new Map(), this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(e), this._shouldFireChangeEvents = !0;
  }
  hasChildren() {
    return !1;
  }
  _clearCache(e) {
    (e === So || e === Ha) && this._cache.get(e) ? this._cache.get(e).dirty = !0 : e ? this._cache.delete(e) : this._cache.clear();
  }
  _getCache(e, t) {
    var i = this._cache.get(e), a = e === So || e === Ha, o = i === void 0 || a && i.dirty === !0;
    return o && (i = t.call(this), this._cache.set(e, i)), i;
  }
  _calculate(e, t, i) {
    if (!this._attachedDepsListeners.get(e)) {
      const a = t.map((o) => o + "Change.konva").join(gh);
      this.on(a, () => {
        this._clearCache(e);
      }), this._attachedDepsListeners.set(e, !0);
    }
    return this._getCache(e, i);
  }
  _getCanvasCache() {
    return this._cache.get(lr);
  }
  _clearSelfAndDescendantCache(e) {
    this._clearCache(e), e === Ha && this.fire("absoluteTransformChange");
  }
  clearCache() {
    if (this._cache.has(lr)) {
      const { scene: e, filter: t, hit: i } = this._cache.get(lr);
      Q.releaseCanvas(e, t, i), this._cache.delete(lr);
    }
    return this._clearSelfAndDescendantCache(), this._requestDraw(), this;
  }
  cache(e) {
    var t = e || {}, i = {};
    (t.x === void 0 || t.y === void 0 || t.width === void 0 || t.height === void 0) && (i = this.getClientRect({
      skipTransform: !0,
      relativeTo: this.getParent()
    }));
    var a = Math.ceil(t.width || i.width), o = Math.ceil(t.height || i.height), r = t.pixelRatio, s = t.x === void 0 ? Math.floor(i.x) : t.x, l = t.y === void 0 ? Math.floor(i.y) : t.y, h = t.offset || 0, d = t.drawBorder || !1, f = t.hitCanvasPixelRatio || 1;
    if (!a || !o) {
      Q.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
      return;
    }
    a += h * 2 + 1, o += h * 2 + 1, s -= h, l -= h;
    var p = new Ku({
      pixelRatio: r,
      width: a,
      height: o
    }), y = new Ku({
      pixelRatio: r,
      width: 0,
      height: 0
    }), m = new mS({
      pixelRatio: f,
      width: a,
      height: o
    }), w = p.getContext(), v = m.getContext();
    return m.isCache = !0, p.isCache = !0, this._cache.delete(lr), this._filterUpToDate = !1, t.imageSmoothingEnabled === !1 && (p.getContext()._context.imageSmoothingEnabled = !1, y.getContext()._context.imageSmoothingEnabled = !1), w.save(), v.save(), w.translate(-s, -l), v.translate(-s, -l), this._isUnderCache = !0, this._clearSelfAndDescendantCache(dh), this._clearSelfAndDescendantCache(Fv), this.drawScene(p, this), this.drawHit(m, this), this._isUnderCache = !1, w.restore(), v.restore(), d && (w.save(), w.beginPath(), w.rect(0, 0, a, o), w.closePath(), w.setAttr("strokeStyle", "red"), w.setAttr("lineWidth", 5), w.stroke(), w.restore()), this._cache.set(lr, {
      scene: p,
      filter: y,
      hit: m,
      x: s,
      y: l
    }), this._requestDraw(), this;
  }
  isCached() {
    return this._cache.has(lr);
  }
  getClientRect(e) {
    throw new Error('abstract "getClientRect" method call');
  }
  _transformedRect(e, t) {
    var i = [
      { x: e.x, y: e.y },
      { x: e.x + e.width, y: e.y },
      { x: e.x + e.width, y: e.y + e.height },
      { x: e.x, y: e.y + e.height }
    ], a, o, r, s, l = this.getAbsoluteTransform(t);
    return i.forEach(function(h) {
      var d = l.point(h);
      a === void 0 && (a = r = d.x, o = s = d.y), a = Math.min(a, d.x), o = Math.min(o, d.y), r = Math.max(r, d.x), s = Math.max(s, d.y);
    }), {
      x: a,
      y: o,
      width: r - a,
      height: s - o
    };
  }
  _drawCachedSceneCanvas(e) {
    e.save(), e._applyOpacity(this), e._applyGlobalCompositeOperation(this);
    const t = this._getCanvasCache();
    e.translate(t.x, t.y);
    var i = this._getCachedSceneCanvas(), a = i.pixelRatio;
    e.drawImage(i._canvas, 0, 0, i.width / a, i.height / a), e.restore();
  }
  _drawCachedHitCanvas(e) {
    var t = this._getCanvasCache(), i = t.hit;
    e.save(), e.translate(t.x, t.y), e.drawImage(i._canvas, 0, 0, i.width / i.pixelRatio, i.height / i.pixelRatio), e.restore();
  }
  _getCachedSceneCanvas() {
    var e = this.filters(), t = this._getCanvasCache(), i = t.scene, a = t.filter, o = a.getContext(), r, s, l, h;
    if (e) {
      if (!this._filterUpToDate) {
        var d = i.pixelRatio;
        a.setSize(i.width / i.pixelRatio, i.height / i.pixelRatio);
        try {
          for (r = e.length, o.clear(), o.drawImage(i._canvas, 0, 0, i.getWidth() / d, i.getHeight() / d), s = o.getImageData(0, 0, a.getWidth(), a.getHeight()), l = 0; l < r; l++) {
            if (h = e[l], typeof h != "function") {
              Q.error("Filter should be type of function, but got " + typeof h + " instead. Please check correct filters");
              continue;
            }
            h.call(this, s), o.putImageData(s, 0, 0);
          }
        } catch (f) {
          Q.error("Unable to apply filter. " + f.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
        }
        this._filterUpToDate = !0;
      }
      return a;
    }
    return i;
  }
  on(e, t) {
    if (this._cache && this._cache.delete(Jc), arguments.length === 3)
      return this._delegate.apply(this, arguments);
    var i = e.split(gh), a = i.length, o, r, s, l, h;
    for (o = 0; o < a; o++)
      r = i[o], s = r.split("."), l = s[0], h = s[1] || "", this.eventListeners[l] || (this.eventListeners[l] = []), this.eventListeners[l].push({
        name: h,
        handler: t
      });
    return this;
  }
  off(e, t) {
    var i = (e || "").split(gh), a = i.length, o, r, s, l, h, d;
    if (this._cache && this._cache.delete(Jc), !e)
      for (r in this.eventListeners)
        this._off(r);
    for (o = 0; o < a; o++)
      if (s = i[o], l = s.split("."), h = l[0], d = l[1], h)
        this.eventListeners[h] && this._off(h, d, t);
      else
        for (r in this.eventListeners)
          this._off(r, d, t);
    return this;
  }
  dispatchEvent(e) {
    var t = {
      target: this,
      type: e.type,
      evt: e
    };
    return this.fire(e.type, t), this;
  }
  addEventListener(e, t) {
    return this.on(e, function(i) {
      t.call(this, i.evt);
    }), this;
  }
  removeEventListener(e) {
    return this.off(e), this;
  }
  _delegate(e, t, i) {
    var a = this;
    this.on(e, function(o) {
      for (var r = o.target.findAncestors(t, !0, a), s = 0; s < r.length; s++)
        o = Q.cloneObject(o), o.currentTarget = r[s], i.call(r[s], o);
    });
  }
  remove() {
    return this.isDragging() && this.stopDrag(), rt._dragElements.delete(this._id), this._remove(), this;
  }
  _clearCaches() {
    this._clearSelfAndDescendantCache(Ha), this._clearSelfAndDescendantCache(dh), this._clearSelfAndDescendantCache(Fv), this._clearSelfAndDescendantCache(Hv), this._clearSelfAndDescendantCache(sp), this._clearSelfAndDescendantCache(rp);
  }
  _remove() {
    this._clearCaches();
    var e = this.getParent();
    e && e.children && (e.children.splice(this.index, 1), e._setChildrenIndices(), this.parent = null);
  }
  destroy() {
    return this.remove(), this.clearCache(), this;
  }
  getAttr(e) {
    var t = "get" + Q._capitalize(e);
    return Q._isFunction(this[t]) ? this[t]() : this.attrs[e];
  }
  getAncestors() {
    for (var e = this.getParent(), t = []; e; )
      t.push(e), e = e.getParent();
    return t;
  }
  getAttrs() {
    return this.attrs || {};
  }
  setAttrs(e) {
    return this._batchTransformChanges(() => {
      var t, i;
      if (!e)
        return this;
      for (t in e)
        t !== oR && (i = Zv + Q._capitalize(t), Q._isFunction(this[i]) ? this[i](e[t]) : this._setAttr(t, e[t]));
    }), this;
  }
  isListening() {
    return this._getCache(rp, this._isListening);
  }
  _isListening(e) {
    if (!this.listening())
      return !1;
    const i = this.getParent();
    return i && i !== e && this !== e ? i._isListening(e) : !0;
  }
  isVisible() {
    return this._getCache(sp, this._isVisible);
  }
  _isVisible(e) {
    if (!this.visible())
      return !1;
    const i = this.getParent();
    return i && i !== e && this !== e ? i._isVisible(e) : !0;
  }
  shouldDrawHit(e, t = !1) {
    if (e)
      return this._isVisible(e) && this._isListening(e);
    var i = this.getLayer(), a = !1;
    rt._dragElements.forEach((r) => {
      r.dragStatus === "dragging" && (r.node.nodeType === "Stage" || r.node.getLayer() === i) && (a = !0);
    });
    var o = !t && !Te.hitOnDragEnabled && a;
    return this.isListening() && this.isVisible() && !o;
  }
  show() {
    return this.visible(!0), this;
  }
  hide() {
    return this.visible(!1), this;
  }
  getZIndex() {
    return this.index || 0;
  }
  getAbsoluteZIndex() {
    var e = this.getDepth(), t = this, i = 0, a, o, r, s;
    function l(h) {
      for (a = [], o = h.length, r = 0; r < o; r++)
        s = h[r], i++, s.nodeType !== Bv && (a = a.concat(s.getChildren().slice())), s._id === t._id && (r = o);
      a.length > 0 && a[0].getDepth() <= e && l(a);
    }
    return t.nodeType !== sR && l(t.getStage().getChildren()), i;
  }
  getDepth() {
    for (var e = 0, t = this.parent; t; )
      e++, t = t.parent;
    return e;
  }
  _batchTransformChanges(e) {
    this._batchingTransformChange = !0, e(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(So), this._clearSelfAndDescendantCache(Ha)), this._needClearTransformCache = !1;
  }
  setPosition(e) {
    return this._batchTransformChanges(() => {
      this.x(e.x), this.y(e.y);
    }), this;
  }
  getPosition() {
    return {
      x: this.x(),
      y: this.y()
    };
  }
  getRelativePointerPosition() {
    if (!this.getStage())
      return null;
    var e = this.getStage().getPointerPosition();
    if (!e)
      return null;
    var t = this.getAbsoluteTransform().copy();
    return t.invert(), t.point(e);
  }
  getAbsolutePosition(e) {
    let t = !1, i = this.parent;
    for (; i; ) {
      if (i.isCached()) {
        t = !0;
        break;
      }
      i = i.parent;
    }
    t && !e && (e = !0);
    var a = this.getAbsoluteTransform(e).getMatrix(), o = new Ru(), r = this.offset();
    return o.m = a.slice(), o.translate(r.x, r.y), o.getTranslation();
  }
  setAbsolutePosition(e) {
    var t = this._clearTransform();
    this.attrs.x = t.x, this.attrs.y = t.y, delete t.x, delete t.y, this._clearCache(So);
    var i = this._getAbsoluteTransform().copy();
    return i.invert(), i.translate(e.x, e.y), e = {
      x: this.attrs.x + i.getTranslation().x,
      y: this.attrs.y + i.getTranslation().y
    }, this._setTransform(t), this.setPosition({ x: e.x, y: e.y }), this._clearCache(So), this._clearSelfAndDescendantCache(Ha), this;
  }
  _setTransform(e) {
    var t;
    for (t in e)
      this.attrs[t] = e[t];
  }
  _clearTransform() {
    var e = {
      x: this.x(),
      y: this.y(),
      rotation: this.rotation(),
      scaleX: this.scaleX(),
      scaleY: this.scaleY(),
      offsetX: this.offsetX(),
      offsetY: this.offsetY(),
      skewX: this.skewX(),
      skewY: this.skewY()
    };
    return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, e;
  }
  move(e) {
    var t = e.x, i = e.y, a = this.x(), o = this.y();
    return t !== void 0 && (a += t), i !== void 0 && (o += i), this.setPosition({ x: a, y: o }), this;
  }
  _eachAncestorReverse(e, t) {
    var i = [], a = this.getParent(), o, r;
    if (!(t && t._id === this._id)) {
      for (i.unshift(this); a && (!t || a._id !== t._id); )
        i.unshift(a), a = a.parent;
      for (o = i.length, r = 0; r < o; r++)
        e(i[r]);
    }
  }
  rotate(e) {
    return this.rotation(this.rotation() + e), this;
  }
  moveToTop() {
    if (!this.parent)
      return Q.warn("Node has no parent. moveToTop function is ignored."), !1;
    var e = this.index, t = this.parent.getChildren().length;
    return e < t - 1 ? (this.parent.children.splice(e, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) : !1;
  }
  moveUp() {
    if (!this.parent)
      return Q.warn("Node has no parent. moveUp function is ignored."), !1;
    var e = this.index, t = this.parent.getChildren().length;
    return e < t - 1 ? (this.parent.children.splice(e, 1), this.parent.children.splice(e + 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
  }
  moveDown() {
    if (!this.parent)
      return Q.warn("Node has no parent. moveDown function is ignored."), !1;
    var e = this.index;
    return e > 0 ? (this.parent.children.splice(e, 1), this.parent.children.splice(e - 1, 0, this), this.parent._setChildrenIndices(), !0) : !1;
  }
  moveToBottom() {
    if (!this.parent)
      return Q.warn("Node has no parent. moveToBottom function is ignored."), !1;
    var e = this.index;
    return e > 0 ? (this.parent.children.splice(e, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) : !1;
  }
  setZIndex(e) {
    if (!this.parent)
      return Q.warn("Node has no parent. zIndex parameter is ignored."), this;
    (e < 0 || e >= this.parent.children.length) && Q.warn("Unexpected value " + e + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
    var t = this.index;
    return this.parent.children.splice(t, 1), this.parent.children.splice(e, 0, this), this.parent._setChildrenIndices(), this;
  }
  getAbsoluteOpacity() {
    return this._getCache(dh, this._getAbsoluteOpacity);
  }
  _getAbsoluteOpacity() {
    var e = this.opacity(), t = this.getParent();
    return t && !t._isUnderCache && (e *= t.getAbsoluteOpacity()), e;
  }
  moveTo(e) {
    return this.getParent() !== e && (this._remove(), e.add(this)), this;
  }
  toObject() {
    var e = {}, t = this.getAttrs(), i, a, o, r, s;
    e.attrs = {};
    for (i in t)
      a = t[i], s = Q.isObject(a) && !Q._isPlainObject(a) && !Q._isArray(a), !s && (o = typeof this[i] == "function" && this[i], delete t[i], r = o ? o.call(this) : null, t[i] = a, r !== a && (e.attrs[i] = a));
    return e.className = this.getClassName(), Q._prepareToStringify(e);
  }
  toJSON() {
    return JSON.stringify(this.toObject());
  }
  getParent() {
    return this.parent;
  }
  findAncestors(e, t, i) {
    var a = [];
    t && this._isMatch(e) && a.push(this);
    for (var o = this.parent; o; ) {
      if (o === i)
        return a;
      o._isMatch(e) && a.push(o), o = o.parent;
    }
    return a;
  }
  isAncestorOf(e) {
    return !1;
  }
  findAncestor(e, t, i) {
    return this.findAncestors(e, t, i)[0];
  }
  _isMatch(e) {
    if (!e)
      return !1;
    if (typeof e == "function")
      return e(this);
    var t = e.replace(/ /g, "").split(","), i = t.length, a, o;
    for (a = 0; a < i; a++)
      if (o = t[a], Q.isValidSelector(o) || (Q.warn('Selector "' + o + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), Q.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), Q.warn("Konva is awesome, right?")), o.charAt(0) === "#") {
        if (this.id() === o.slice(1))
          return !0;
      } else if (o.charAt(0) === ".") {
        if (this.hasName(o.slice(1)))
          return !0;
      } else if (this.className === o || this.nodeType === o)
        return !0;
    return !1;
  }
  getLayer() {
    var e = this.getParent();
    return e ? e.getLayer() : null;
  }
  getStage() {
    return this._getCache(Hv, this._getStage);
  }
  _getStage() {
    var e = this.getParent();
    if (e)
      return e.getStage();
  }
  fire(e, t = {}, i) {
    return t.target = t.target || this, i ? this._fireAndBubble(e, t) : this._fire(e, t), this;
  }
  getAbsoluteTransform(e) {
    return e ? this._getAbsoluteTransform(e) : this._getCache(Ha, this._getAbsoluteTransform);
  }
  _getAbsoluteTransform(e) {
    var t;
    if (e)
      return t = new Ru(), this._eachAncestorReverse(function(a) {
        var o = a.transformsEnabled();
        o === "all" ? t.multiply(a.getTransform()) : o === "position" && t.translate(a.x() - a.offsetX(), a.y() - a.offsetY());
      }, e), t;
    t = this._cache.get(Ha) || new Ru(), this.parent ? this.parent.getAbsoluteTransform().copyInto(t) : t.reset();
    var i = this.transformsEnabled();
    if (i === "all")
      t.multiply(this.getTransform());
    else if (i === "position") {
      const a = this.attrs.x || 0, o = this.attrs.y || 0, r = this.attrs.offsetX || 0, s = this.attrs.offsetY || 0;
      t.translate(a - r, o - s);
    }
    return t.dirty = !1, t;
  }
  getAbsoluteScale(e) {
    for (var t = this; t; )
      t._isUnderCache && (e = t), t = t.getParent();
    const a = this.getAbsoluteTransform(e).decompose();
    return {
      x: a.scaleX,
      y: a.scaleY
    };
  }
  getAbsoluteRotation() {
    return this.getAbsoluteTransform().decompose().rotation;
  }
  getTransform() {
    return this._getCache(So, this._getTransform);
  }
  _getTransform() {
    var e, t, i = this._cache.get(So) || new Ru();
    i.reset();
    var a = this.x(), o = this.y(), r = Te.getAngle(this.rotation()), s = (e = this.attrs.scaleX) !== null && e !== void 0 ? e : 1, l = (t = this.attrs.scaleY) !== null && t !== void 0 ? t : 1, h = this.attrs.skewX || 0, d = this.attrs.skewY || 0, f = this.attrs.offsetX || 0, p = this.attrs.offsetY || 0;
    return (a !== 0 || o !== 0) && i.translate(a, o), r !== 0 && i.rotate(r), (h !== 0 || d !== 0) && i.skew(h, d), (s !== 1 || l !== 1) && i.scale(s, l), (f !== 0 || p !== 0) && i.translate(-1 * f, -1 * p), i.dirty = !1, i;
  }
  clone(e) {
    var t = Q.cloneObject(this.attrs), i, a, o, r, s;
    for (i in e)
      t[i] = e[i];
    var l = new this.constructor(t);
    for (i in this.eventListeners)
      for (a = this.eventListeners[i], o = a.length, r = 0; r < o; r++)
        s = a[r], s.name.indexOf(rR) < 0 && (l.eventListeners[i] || (l.eventListeners[i] = []), l.eventListeners[i].push(s));
    return l;
  }
  _toKonvaCanvas(e) {
    e = e || {};
    var t = this.getClientRect(), i = this.getStage(), a = e.x !== void 0 ? e.x : Math.floor(t.x), o = e.y !== void 0 ? e.y : Math.floor(t.y), r = e.pixelRatio || 1, s = new Ku({
      width: e.width || Math.ceil(t.width) || (i ? i.width() : 0),
      height: e.height || Math.ceil(t.height) || (i ? i.height() : 0),
      pixelRatio: r
    }), l = s.getContext();
    return e.imageSmoothingEnabled === !1 && (l._context.imageSmoothingEnabled = !1), l.save(), (a || o) && l.translate(-1 * a, -1 * o), this.drawScene(s), l.restore(), s;
  }
  toCanvas(e) {
    return this._toKonvaCanvas(e)._canvas;
  }
  toDataURL(e) {
    e = e || {};
    var t = e.mimeType || null, i = e.quality || null, a = this._toKonvaCanvas(e).toDataURL(t, i);
    return e.callback && e.callback(a), a;
  }
  toImage(e) {
    return new Promise((t, i) => {
      try {
        const a = e == null ? void 0 : e.callback;
        a && delete e.callback, Q._urlToImage(this.toDataURL(e), function(o) {
          t(o), a == null || a(o);
        });
      } catch (a) {
        i(a);
      }
    });
  }
  toBlob(e) {
    return new Promise((t, i) => {
      try {
        const a = e == null ? void 0 : e.callback;
        a && delete e.callback, this.toCanvas(e).toBlob((o) => {
          t(o), a == null || a(o);
        });
      } catch (a) {
        i(a);
      }
    });
  }
  setSize(e) {
    return this.width(e.width), this.height(e.height), this;
  }
  getSize() {
    return {
      width: this.width(),
      height: this.height()
    };
  }
  getClassName() {
    return this.className || this.nodeType;
  }
  getType() {
    return this.nodeType;
  }
  getDragDistance() {
    return this.attrs.dragDistance !== void 0 ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : Te.dragDistance;
  }
  _off(e, t, i) {
    var a = this.eventListeners[e], o, r, s;
    for (o = 0; o < a.length; o++)
      if (r = a[o].name, s = a[o].handler, (r !== "konva" || t === "konva") && (!t || r === t) && (!i || i === s)) {
        if (a.splice(o, 1), a.length === 0) {
          delete this.eventListeners[e];
          break;
        }
        o--;
      }
  }
  _fireChangeEvent(e, t, i) {
    this._fire(e + aR, {
      oldVal: t,
      newVal: i
    });
  }
  addName(e) {
    if (!this.hasName(e)) {
      var t = this.name(), i = t ? t + " " + e : e;
      this.name(i);
    }
    return this;
  }
  hasName(e) {
    if (!e)
      return !1;
    const t = this.name();
    if (!t)
      return !1;
    var i = (t || "").split(/\s/g);
    return i.indexOf(e) !== -1;
  }
  removeName(e) {
    var t = (this.name() || "").split(/\s/g), i = t.indexOf(e);
    return i !== -1 && (t.splice(i, 1), this.name(t.join(" "))), this;
  }
  setAttr(e, t) {
    var i = this[Zv + Q._capitalize(e)];
    return Q._isFunction(i) ? i.call(this, t) : this._setAttr(e, t), this;
  }
  _requestDraw() {
    if (Te.autoDrawEnabled) {
      const e = this.getLayer() || this.getStage();
      e == null || e.batchDraw();
    }
  }
  _setAttr(e, t) {
    var i = this.attrs[e];
    i === t && !Q.isObject(t) || (t == null ? delete this.attrs[e] : this.attrs[e] = t, this._shouldFireChangeEvents && this._fireChangeEvent(e, i, t), this._requestDraw());
  }
  _setComponentAttr(e, t, i) {
    var a;
    i !== void 0 && (a = this.attrs[e], a || (this.attrs[e] = this.getAttr(e)), this.attrs[e][t] = i, this._fireChangeEvent(e, a, i));
  }
  _fireAndBubble(e, t, i) {
    t && this.nodeType === Bv && (t.target = this);
    var a = (e === Iv || e === Jv) && (i && (this === i || this.isAncestorOf && this.isAncestorOf(i)) || this.nodeType === "Stage" && !i);
    if (!a) {
      this._fire(e, t);
      var o = (e === Iv || e === Jv) && i && i.isAncestorOf && i.isAncestorOf(this) && !i.isAncestorOf(this.parent);
      (t && !t.cancelBubble || !t) && this.parent && this.parent.isListening() && !o && (i && i.parent ? this._fireAndBubble.call(this.parent, e, t, i) : this._fireAndBubble.call(this.parent, e, t));
    }
  }
  _getProtoListeners(e) {
    let t = this._cache.get(Jc);
    if (!t) {
      t = {};
      let a = Object.getPrototypeOf(this);
      for (; a; ) {
        if (!a.eventListeners) {
          a = Object.getPrototypeOf(a);
          continue;
        }
        for (var i in a.eventListeners) {
          const o = a.eventListeners[i], r = t[i] || [];
          t[i] = o.concat(r);
        }
        a = Object.getPrototypeOf(a);
      }
      this._cache.set(Jc, t);
    }
    return t[e];
  }
  _fire(e, t) {
    t = t || {}, t.currentTarget = this, t.type = e;
    const i = this._getProtoListeners(e);
    if (i)
      for (var a = 0; a < i.length; a++)
        i[a].handler.call(this, t);
    const o = this.eventListeners[e];
    if (o)
      for (var a = 0; a < o.length; a++)
        o[a].handler.call(this, t);
  }
  draw() {
    return this.drawScene(), this.drawHit(), this;
  }
  _createDragElement(e) {
    var t = e ? e.pointerId : void 0, i = this.getStage(), a = this.getAbsolutePosition(), o = i._getPointerById(t) || i._changedPointerPositions[0] || a;
    rt._dragElements.set(this._id, {
      node: this,
      startPointerPos: o,
      offset: {
        x: o.x - a.x,
        y: o.y - a.y
      },
      dragStatus: "ready",
      pointerId: t
    });
  }
  startDrag(e, t = !0) {
    rt._dragElements.has(this._id) || this._createDragElement(e);
    const i = rt._dragElements.get(this._id);
    i.dragStatus = "dragging", this.fire("dragstart", {
      type: "dragstart",
      target: this,
      evt: e && e.evt
    }, t);
  }
  _setDragPosition(e, t) {
    const i = this.getStage()._getPointerById(t.pointerId);
    if (i) {
      var a = {
        x: i.x - t.offset.x,
        y: i.y - t.offset.y
      }, o = this.dragBoundFunc();
      if (o !== void 0) {
        const r = o.call(this, a, e);
        r ? a = r : Q.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
      }
      (!this._lastPos || this._lastPos.x !== a.x || this._lastPos.y !== a.y) && (this.setAbsolutePosition(a), this._requestDraw()), this._lastPos = a;
    }
  }
  stopDrag(e) {
    const t = rt._dragElements.get(this._id);
    t && (t.dragStatus = "stopped"), rt._endDragBefore(e), rt._endDragAfter(e);
  }
  setDraggable(e) {
    this._setAttr("draggable", e), this._dragChange();
  }
  isDragging() {
    const e = rt._dragElements.get(this._id);
    return e ? e.dragStatus === "dragging" : !1;
  }
  _listenDrag() {
    this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function(e) {
      var t = e.evt.button !== void 0, i = !t || Te.dragButtons.indexOf(e.evt.button) >= 0;
      if (i && !this.isDragging()) {
        var a = !1;
        rt._dragElements.forEach((o) => {
          this.isAncestorOf(o.node) && (a = !0);
        }), a || this._createDragElement(e);
      }
    });
  }
  _dragChange() {
    if (this.attrs.draggable)
      this._listenDrag();
    else {
      this._dragCleanup();
      var e = this.getStage();
      if (!e)
        return;
      const t = rt._dragElements.get(this._id), i = t && t.dragStatus === "dragging", a = t && t.dragStatus === "ready";
      i ? this.stopDrag() : a && rt._dragElements.delete(this._id);
    }
  }
  _dragCleanup() {
    this.off("mousedown.konva"), this.off("touchstart.konva");
  }
  isClientRectOnScreen(e = { x: 0, y: 0 }) {
    const t = this.getStage();
    if (!t)
      return !1;
    const i = {
      x: -e.x,
      y: -e.y,
      width: t.width() + 2 * e.x,
      height: t.height() + 2 * e.y
    };
    return Q.haveIntersection(i, this.getClientRect());
  }
  static create(e, t) {
    return Q._isString(e) && (e = JSON.parse(e)), this._createNode(e, t);
  }
  static _createNode(e, t) {
    var i = up.prototype.getClassName.call(e), a = e.children, o, r, s;
    t && (e.attrs.container = t), Te[i] || (Q.warn('Can not find a node with class name "' + i + '". Fallback to "Shape".'), i = "Shape");
    const l = Te[i];
    if (o = new l(e.attrs), a)
      for (r = a.length, s = 0; s < r; s++)
        o.add(up._createNode(a[s]));
    return o;
  }
};
Le.prototype.nodeType = "Node";
Le.prototype._attrsAffectingSize = [];
Le.prototype.eventListeners = {};
Le.prototype.on.call(Le.prototype, uR, function() {
  if (this._batchingTransformChange) {
    this._needClearTransformCache = !0;
    return;
  }
  this._clearCache(So), this._clearSelfAndDescendantCache(Ha);
});
Le.prototype.on.call(Le.prototype, "visibleChange.konva", function() {
  this._clearSelfAndDescendantCache(sp);
});
Le.prototype.on.call(Le.prototype, "listeningChange.konva", function() {
  this._clearSelfAndDescendantCache(rp);
});
Le.prototype.on.call(Le.prototype, "opacityChange.konva", function() {
  this._clearSelfAndDescendantCache(dh);
});
const Ct = ee.addGetterSetter;
Ct(Le, "zIndex");
Ct(Le, "absolutePosition");
Ct(Le, "position");
Ct(Le, "x", 0, nt());
Ct(Le, "y", 0, nt());
Ct(Le, "globalCompositeOperation", "source-over", Yl());
Ct(Le, "opacity", 1, nt());
Ct(Le, "name", "", Yl());
Ct(Le, "id", "", Yl());
Ct(Le, "rotation", 0, nt());
ee.addComponentsGetterSetter(Le, "scale", ["x", "y"]);
Ct(Le, "scaleX", 1, nt());
Ct(Le, "scaleY", 1, nt());
ee.addComponentsGetterSetter(Le, "skew", ["x", "y"]);
Ct(Le, "skewX", 0, nt());
Ct(Le, "skewY", 0, nt());
ee.addComponentsGetterSetter(Le, "offset", ["x", "y"]);
Ct(Le, "offsetX", 0, nt());
Ct(Le, "offsetY", 0, nt());
Ct(Le, "dragDistance", null, nt());
Ct(Le, "width", 0, nt());
Ct(Le, "height", 0, nt());
Ct(Le, "listening", !0, Br());
Ct(Le, "preventDefault", !0, Br());
Ct(Le, "filters", null, function(n) {
  return this._filterUpToDate = !1, n;
});
Ct(Le, "visible", !0, Br());
Ct(Le, "transformsEnabled", "all", Yl());
Ct(Le, "size");
Ct(Le, "dragBoundFunc");
Ct(Le, "draggable", !1, Br());
ee.backCompat(Le, {
  rotateDeg: "rotate",
  setRotationDeg: "setRotation",
  getRotationDeg: "getRotation"
});
const hl = /* @__PURE__ */ new Map(), yS = Te._global.PointerEvent !== void 0;
function hf(n) {
  return hl.get(n);
}
function jm(n) {
  return {
    evt: n,
    pointerId: n.pointerId
  };
}
function bS(n, e) {
  return hl.get(n) === e;
}
function wS(n, e) {
  zu(n), e.getStage() && (hl.set(n, e), yS && e._fire("gotpointercapture", jm(new PointerEvent("gotpointercapture"))));
}
function zu(n, e) {
  const t = hl.get(n);
  if (!t)
    return;
  const i = t.getStage();
  i && i.content, hl.delete(n), yS && t._fire("lostpointercapture", jm(new PointerEvent("lostpointercapture")));
}
var vS = "hasShadow", CS = "shadowRGBA", SS = "patternImage", kS = "linearGradient", _S = "radialGradient";
let Zc;
function df() {
  return Zc || (Zc = Q.createCanvasElement().getContext("2d"), Zc);
}
const gf = {};
function cR(n) {
  n.fill();
}
function hR(n) {
  n.stroke();
}
function dR(n) {
  n.fill();
}
function gR(n) {
  n.stroke();
}
function fR() {
  this._clearCache(vS);
}
function pR() {
  this._clearCache(CS);
}
function mR() {
  this._clearCache(SS);
}
function yR() {
  this._clearCache(kS);
}
function bR() {
  this._clearCache(_S);
}
class ne extends Le {
  constructor(e) {
    super(e);
    let t;
    for (; t = Q.getRandomColor(), !(t && !(t in gf)); )
      ;
    this.colorKey = t, gf[t] = this;
  }
  getContext() {
    return Q.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext();
  }
  getCanvas() {
    return Q.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas();
  }
  getSceneFunc() {
    return this.attrs.sceneFunc || this._sceneFunc;
  }
  getHitFunc() {
    return this.attrs.hitFunc || this._hitFunc;
  }
  hasShadow() {
    return this._getCache(vS, this._hasShadow);
  }
  _hasShadow() {
    return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
  }
  _getFillPattern() {
    return this._getCache(SS, this.__getFillPattern);
  }
  __getFillPattern() {
    if (this.fillPatternImage()) {
      var e = df();
      const t = e.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
      if (t && t.setTransform) {
        const i = new Ru();
        i.translate(this.fillPatternX(), this.fillPatternY()), i.rotate(Te.getAngle(this.fillPatternRotation())), i.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), i.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());
        const a = i.getMatrix(), o = typeof DOMMatrix > "u" ? {
          a: a[0],
          b: a[1],
          c: a[2],
          d: a[3],
          e: a[4],
          f: a[5]
        } : new DOMMatrix(a);
        t.setTransform(o);
      }
      return t;
    }
  }
  _getLinearGradient() {
    return this._getCache(kS, this.__getLinearGradient);
  }
  __getLinearGradient() {
    var e = this.fillLinearGradientColorStops();
    if (e) {
      for (var t = df(), i = this.fillLinearGradientStartPoint(), a = this.fillLinearGradientEndPoint(), o = t.createLinearGradient(i.x, i.y, a.x, a.y), r = 0; r < e.length; r += 2)
        o.addColorStop(e[r], e[r + 1]);
      return o;
    }
  }
  _getRadialGradient() {
    return this._getCache(_S, this.__getRadialGradient);
  }
  __getRadialGradient() {
    var e = this.fillRadialGradientColorStops();
    if (e) {
      for (var t = df(), i = this.fillRadialGradientStartPoint(), a = this.fillRadialGradientEndPoint(), o = t.createRadialGradient(i.x, i.y, this.fillRadialGradientStartRadius(), a.x, a.y, this.fillRadialGradientEndRadius()), r = 0; r < e.length; r += 2)
        o.addColorStop(e[r], e[r + 1]);
      return o;
    }
  }
  getShadowRGBA() {
    return this._getCache(CS, this._getShadowRGBA);
  }
  _getShadowRGBA() {
    if (this.hasShadow()) {
      var e = Q.colorToRGBA(this.shadowColor());
      if (e)
        return "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a * (this.shadowOpacity() || 1) + ")";
    }
  }
  hasFill() {
    return this._calculate("hasFill", [
      "fillEnabled",
      "fill",
      "fillPatternImage",
      "fillLinearGradientColorStops",
      "fillRadialGradientColorStops"
    ], () => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()));
  }
  hasStroke() {
    return this._calculate("hasStroke", [
      "strokeEnabled",
      "strokeWidth",
      "stroke",
      "strokeLinearGradientColorStops"
    ], () => this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops()));
  }
  hasHitStroke() {
    const e = this.hitStrokeWidth();
    return e === "auto" ? this.hasStroke() : this.strokeEnabled() && !!e;
  }
  intersects(e) {
    var t = this.getStage(), i = t.bufferHitCanvas, a;
    return i.getContext().clear(), this.drawHit(i, null, !0), a = i.context.getImageData(Math.round(e.x), Math.round(e.y), 1, 1).data, a[3] > 0;
  }
  destroy() {
    return Le.prototype.destroy.call(this), delete gf[this.colorKey], delete this.colorKey, this;
  }
  _useBufferCanvas(e) {
    var t;
    if (!this.getStage() || !((t = this.attrs.perfectDrawEnabled) !== null && t !== void 0 ? t : !0))
      return !1;
    const a = e || this.hasFill(), o = this.hasStroke(), r = this.getAbsoluteOpacity() !== 1;
    if (a && o && r)
      return !0;
    const s = this.hasShadow(), l = this.shadowForStrokeEnabled();
    return !!(a && o && s && l);
  }
  setStrokeHitEnabled(e) {
    Q.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), e ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0);
  }
  getStrokeHitEnabled() {
    return this.hitStrokeWidth() !== 0;
  }
  getSelfRect() {
    var e = this.size();
    return {
      x: this._centroid ? -e.width / 2 : 0,
      y: this._centroid ? -e.height / 2 : 0,
      width: e.width,
      height: e.height
    };
  }
  getClientRect(e = {}) {
    const t = e.skipTransform, i = e.relativeTo, a = this.getSelfRect(), r = !e.skipStroke && this.hasStroke() && this.strokeWidth() || 0, s = a.width + r, l = a.height + r, h = !e.skipShadow && this.hasShadow(), d = h ? this.shadowOffsetX() : 0, f = h ? this.shadowOffsetY() : 0, p = s + Math.abs(d), y = l + Math.abs(f), m = h && this.shadowBlur() || 0, w = p + m * 2, v = y + m * 2, _ = {
      width: w,
      height: v,
      x: -(r / 2 + m) + Math.min(d, 0) + a.x,
      y: -(r / 2 + m) + Math.min(f, 0) + a.y
    };
    return t ? _ : this._transformedRect(_, i);
  }
  drawScene(e, t) {
    var i = this.getLayer(), a = e || i.getCanvas(), o = a.getContext(), r = this._getCanvasCache(), s = this.getSceneFunc(), l = this.hasShadow(), h, d, f, p = a.isCache, y = t === this;
    if (!this.isVisible() && !y)
      return this;
    if (r) {
      o.save();
      var m = this.getAbsoluteTransform(t).getMatrix();
      return o.transform(m[0], m[1], m[2], m[3], m[4], m[5]), this._drawCachedSceneCanvas(o), o.restore(), this;
    }
    if (!s)
      return this;
    if (o.save(), this._useBufferCanvas() && !p) {
      h = this.getStage(), d = h.bufferCanvas, f = d.getContext(), f.clear(), f.save(), f._applyLineJoin(this);
      var w = this.getAbsoluteTransform(t).getMatrix();
      f.transform(w[0], w[1], w[2], w[3], w[4], w[5]), s.call(this, f, this), f.restore();
      var v = d.pixelRatio;
      l && o._applyShadow(this), o._applyOpacity(this), o._applyGlobalCompositeOperation(this), o.drawImage(d._canvas, 0, 0, d.width / v, d.height / v);
    } else {
      if (o._applyLineJoin(this), !y) {
        var w = this.getAbsoluteTransform(t).getMatrix();
        o.transform(w[0], w[1], w[2], w[3], w[4], w[5]), o._applyOpacity(this), o._applyGlobalCompositeOperation(this);
      }
      l && o._applyShadow(this), s.call(this, o, this);
    }
    return o.restore(), this;
  }
  drawHit(e, t, i = !1) {
    if (!this.shouldDrawHit(t, i))
      return this;
    var a = this.getLayer(), o = e || a.hitCanvas, r = o && o.getContext(), s = this.hitFunc() || this.sceneFunc(), l = this._getCanvasCache(), h = l && l.hit;
    if (this.colorKey || Q.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), h) {
      r.save();
      var d = this.getAbsoluteTransform(t).getMatrix();
      return r.transform(d[0], d[1], d[2], d[3], d[4], d[5]), this._drawCachedHitCanvas(r), r.restore(), this;
    }
    if (!s)
      return this;
    if (r.save(), r._applyLineJoin(this), !(this === t)) {
      var p = this.getAbsoluteTransform(t).getMatrix();
      r.transform(p[0], p[1], p[2], p[3], p[4], p[5]);
    }
    return s.call(this, r, this), r.restore(), this;
  }
  drawHitFromCache(e = 0) {
    var t = this._getCanvasCache(), i = this._getCachedSceneCanvas(), a = t.hit, o = a.getContext(), r = a.getWidth(), s = a.getHeight(), l, h, d, f, p, y;
    o.clear(), o.drawImage(i._canvas, 0, 0, r, s);
    try {
      for (l = o.getImageData(0, 0, r, s), h = l.data, d = h.length, f = Q._hexToRgb(this.colorKey), p = 0; p < d; p += 4)
        y = h[p + 3], y > e ? (h[p] = f.r, h[p + 1] = f.g, h[p + 2] = f.b, h[p + 3] = 255) : h[p + 3] = 0;
      o.putImageData(l, 0, 0);
    } catch (m) {
      Q.error("Unable to draw hit graph from cached scene canvas. " + m.message);
    }
    return this;
  }
  hasPointerCapture(e) {
    return bS(e, this);
  }
  setPointerCapture(e) {
    wS(e, this);
  }
  releaseCapture(e) {
    zu(e);
  }
}
ne.prototype._fillFunc = cR;
ne.prototype._strokeFunc = hR;
ne.prototype._fillFuncHit = dR;
ne.prototype._strokeFuncHit = gR;
ne.prototype._centroid = !1;
ne.prototype.nodeType = "Shape";
eu(ne);
ne.prototype.eventListeners = {};
ne.prototype.on.call(ne.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", fR);
ne.prototype.on.call(ne.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", pR);
ne.prototype.on.call(ne.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", mR);
ne.prototype.on.call(ne.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", yR);
ne.prototype.on.call(ne.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", bR);
ee.addGetterSetter(ne, "stroke", void 0, pS());
ee.addGetterSetter(ne, "strokeWidth", 2, nt());
ee.addGetterSetter(ne, "fillAfterStrokeEnabled", !1);
ee.addGetterSetter(ne, "hitStrokeWidth", "auto", B2());
ee.addGetterSetter(ne, "strokeHitEnabled", !0, Br());
ee.addGetterSetter(ne, "perfectDrawEnabled", !0, Br());
ee.addGetterSetter(ne, "shadowForStrokeEnabled", !0, Br());
ee.addGetterSetter(ne, "lineJoin");
ee.addGetterSetter(ne, "lineCap");
ee.addGetterSetter(ne, "sceneFunc");
ee.addGetterSetter(ne, "hitFunc");
ee.addGetterSetter(ne, "dash");
ee.addGetterSetter(ne, "dashOffset", 0, nt());
ee.addGetterSetter(ne, "shadowColor", void 0, Yl());
ee.addGetterSetter(ne, "shadowBlur", 0, nt());
ee.addGetterSetter(ne, "shadowOpacity", 1, nt());
ee.addComponentsGetterSetter(ne, "shadowOffset", ["x", "y"]);
ee.addGetterSetter(ne, "shadowOffsetX", 0, nt());
ee.addGetterSetter(ne, "shadowOffsetY", 0, nt());
ee.addGetterSetter(ne, "fillPatternImage");
ee.addGetterSetter(ne, "fill", void 0, pS());
ee.addGetterSetter(ne, "fillPatternX", 0, nt());
ee.addGetterSetter(ne, "fillPatternY", 0, nt());
ee.addGetterSetter(ne, "fillLinearGradientColorStops");
ee.addGetterSetter(ne, "strokeLinearGradientColorStops");
ee.addGetterSetter(ne, "fillRadialGradientStartRadius", 0);
ee.addGetterSetter(ne, "fillRadialGradientEndRadius", 0);
ee.addGetterSetter(ne, "fillRadialGradientColorStops");
ee.addGetterSetter(ne, "fillPatternRepeat", "repeat");
ee.addGetterSetter(ne, "fillEnabled", !0);
ee.addGetterSetter(ne, "strokeEnabled", !0);
ee.addGetterSetter(ne, "shadowEnabled", !0);
ee.addGetterSetter(ne, "dashEnabled", !0);
ee.addGetterSetter(ne, "strokeScaleEnabled", !0);
ee.addGetterSetter(ne, "fillPriority", "color");
ee.addComponentsGetterSetter(ne, "fillPatternOffset", ["x", "y"]);
ee.addGetterSetter(ne, "fillPatternOffsetX", 0, nt());
ee.addGetterSetter(ne, "fillPatternOffsetY", 0, nt());
ee.addComponentsGetterSetter(ne, "fillPatternScale", ["x", "y"]);
ee.addGetterSetter(ne, "fillPatternScaleX", 1, nt());
ee.addGetterSetter(ne, "fillPatternScaleY", 1, nt());
ee.addComponentsGetterSetter(ne, "fillLinearGradientStartPoint", [
  "x",
  "y"
]);
ee.addComponentsGetterSetter(ne, "strokeLinearGradientStartPoint", [
  "x",
  "y"
]);
ee.addGetterSetter(ne, "fillLinearGradientStartPointX", 0);
ee.addGetterSetter(ne, "strokeLinearGradientStartPointX", 0);
ee.addGetterSetter(ne, "fillLinearGradientStartPointY", 0);
ee.addGetterSetter(ne, "strokeLinearGradientStartPointY", 0);
ee.addComponentsGetterSetter(ne, "fillLinearGradientEndPoint", [
  "x",
  "y"
]);
ee.addComponentsGetterSetter(ne, "strokeLinearGradientEndPoint", [
  "x",
  "y"
]);
ee.addGetterSetter(ne, "fillLinearGradientEndPointX", 0);
ee.addGetterSetter(ne, "strokeLinearGradientEndPointX", 0);
ee.addGetterSetter(ne, "fillLinearGradientEndPointY", 0);
ee.addGetterSetter(ne, "strokeLinearGradientEndPointY", 0);
ee.addComponentsGetterSetter(ne, "fillRadialGradientStartPoint", [
  "x",
  "y"
]);
ee.addGetterSetter(ne, "fillRadialGradientStartPointX", 0);
ee.addGetterSetter(ne, "fillRadialGradientStartPointY", 0);
ee.addComponentsGetterSetter(ne, "fillRadialGradientEndPoint", [
  "x",
  "y"
]);
ee.addGetterSetter(ne, "fillRadialGradientEndPointX", 0);
ee.addGetterSetter(ne, "fillRadialGradientEndPointY", 0);
ee.addGetterSetter(ne, "fillPatternRotation", 0);
ee.backCompat(ne, {
  dashArray: "dash",
  getDashArray: "getDash",
  setDashArray: "getDash",
  drawFunc: "sceneFunc",
  getDrawFunc: "getSceneFunc",
  setDrawFunc: "setSceneFunc",
  drawHitFunc: "hitFunc",
  getDrawHitFunc: "getHitFunc",
  setDrawHitFunc: "setHitFunc"
});
function lp(n, e, t, i, a, o, r) {
  var s = Math.sqrt(Math.pow(t - n, 2) + Math.pow(i - e, 2)), l = Math.sqrt(Math.pow(a - t, 2) + Math.pow(o - i, 2)), h = r * s / (s + l), d = r * l / (s + l), f = t - h * (a - n), p = i - h * (o - e), y = t + d * (a - n), m = i + d * (o - e);
  return [f, p, y, m];
}
function Xv(n, e) {
  var t = n.length, i = [], a, o;
  for (a = 2; a < t - 2; a += 2)
    o = lp(n[a - 2], n[a - 1], n[a], n[a + 1], n[a + 2], n[a + 3], e), !isNaN(o[0]) && (i.push(o[0]), i.push(o[1]), i.push(n[a]), i.push(n[a + 1]), i.push(o[2]), i.push(o[3]));
  return i;
}
class Qo extends ne {
  constructor(e) {
    super(e), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function() {
      this._clearCache("tensionPoints");
    });
  }
  _sceneFunc(e) {
    var t = this.points(), i = t.length, a = this.tension(), o = this.closed(), r = this.bezier(), s, l, h;
    if (i) {
      if (e.beginPath(), e.moveTo(t[0], t[1]), a !== 0 && i > 4) {
        for (s = this.getTensionPoints(), l = s.length, h = o ? 0 : 4, o || e.quadraticCurveTo(s[0], s[1], s[2], s[3]); h < l - 2; )
          e.bezierCurveTo(s[h++], s[h++], s[h++], s[h++], s[h++], s[h++]);
        o || e.quadraticCurveTo(s[l - 2], s[l - 1], t[i - 2], t[i - 1]);
      } else if (r)
        for (h = 2; h < i; )
          e.bezierCurveTo(t[h++], t[h++], t[h++], t[h++], t[h++], t[h++]);
      else
        for (h = 2; h < i; h += 2)
          e.lineTo(t[h], t[h + 1]);
      o ? (e.closePath(), e.fillStrokeShape(this)) : e.strokeShape(this);
    }
  }
  getTensionPoints() {
    return this._getCache("tensionPoints", this._getTensionPoints);
  }
  _getTensionPoints() {
    return this.closed() ? this._getTensionPointsClosed() : Xv(this.points(), this.tension());
  }
  _getTensionPointsClosed() {
    var e = this.points(), t = e.length, i = this.tension(), a = lp(e[t - 2], e[t - 1], e[0], e[1], e[2], e[3], i), o = lp(e[t - 4], e[t - 3], e[t - 2], e[t - 1], e[0], e[1], i), r = Xv(e, i), s = [a[2], a[3]].concat(r).concat([
      o[0],
      o[1],
      e[t - 2],
      e[t - 1],
      o[2],
      o[3],
      a[0],
      a[1],
      e[0],
      e[1]
    ]);
    return s;
  }
  getWidth() {
    return this.getSelfRect().width;
  }
  getHeight() {
    return this.getSelfRect().height;
  }
  getSelfRect() {
    var e = this.points();
    if (e.length < 4)
      return {
        x: e[0] || 0,
        y: e[1] || 0,
        width: 0,
        height: 0
      };
    this.tension() !== 0 ? e = [
      e[0],
      e[1],
      ...this._getTensionPoints(),
      e[e.length - 2],
      e[e.length - 1]
    ] : e = this.points();
    for (var t = e[0], i = e[0], a = e[1], o = e[1], r, s, l = 0; l < e.length / 2; l++)
      r = e[l * 2], s = e[l * 2 + 1], t = Math.min(t, r), i = Math.max(i, r), a = Math.min(a, s), o = Math.max(o, s);
    return {
      x: t,
      y: a,
      width: i - t,
      height: o - a
    };
  }
}
Qo.prototype.className = "Line";
Qo.prototype._attrsAffectingSize = ["points", "bezier", "tension"];
eu(Qo);
ee.addGetterSetter(Qo, "closed", !1);
ee.addGetterSetter(Qo, "bezier", !1);
ee.addGetterSetter(Qo, "tension", 0, nt());
ee.addGetterSetter(Qo, "points", [], H2());
class yn extends ne {
  constructor(e) {
    super(e), this.dataArray = [], this.pathLength = 0, this.dataArray = yn.parsePathData(this.data()), this.pathLength = 0;
    for (var t = 0; t < this.dataArray.length; ++t)
      this.pathLength += this.dataArray[t].pathLength;
    this.on("dataChange.konva", function() {
      this.dataArray = yn.parsePathData(this.data()), this.pathLength = 0;
      for (var i = 0; i < this.dataArray.length; ++i)
        this.pathLength += this.dataArray[i].pathLength;
    });
  }
  _sceneFunc(e) {
    var t = this.dataArray;
    e.beginPath();
    for (var i = !1, a = 0; a < t.length; a++) {
      var o = t[a].command, r = t[a].points;
      switch (o) {
        case "L":
          e.lineTo(r[0], r[1]);
          break;
        case "M":
          e.moveTo(r[0], r[1]);
          break;
        case "C":
          e.bezierCurveTo(r[0], r[1], r[2], r[3], r[4], r[5]);
          break;
        case "Q":
          e.quadraticCurveTo(r[0], r[1], r[2], r[3]);
          break;
        case "A":
          var s = r[0], l = r[1], h = r[2], d = r[3], f = r[4], p = r[5], y = r[6], m = r[7], w = h > d ? h : d, v = h > d ? 1 : h / d, _ = h > d ? d / h : 1;
          e.translate(s, l), e.rotate(y), e.scale(v, _), e.arc(0, 0, w, f, f + p, 1 - m), e.scale(1 / v, 1 / _), e.rotate(-y), e.translate(-s, -l);
          break;
        case "z":
          i = !0, e.closePath();
          break;
      }
    }
    !i && !this.hasFill() ? e.strokeShape(this) : e.fillStrokeShape(this);
  }
  getSelfRect() {
    var e = [];
    this.dataArray.forEach(function(h) {
      if (h.command === "A") {
        var d = h.points[4], f = h.points[5], p = h.points[4] + f, y = Math.PI / 180;
        if (Math.abs(d - p) < y && (y = Math.abs(d - p)), f < 0)
          for (let m = d - y; m > p; m -= y) {
            const w = yn.getPointOnEllipticalArc(h.points[0], h.points[1], h.points[2], h.points[3], m, 0);
            e.push(w.x, w.y);
          }
        else
          for (let m = d + y; m < p; m += y) {
            const w = yn.getPointOnEllipticalArc(h.points[0], h.points[1], h.points[2], h.points[3], m, 0);
            e.push(w.x, w.y);
          }
      } else if (h.command === "C")
        for (let m = 0; m <= 1; m += 0.01) {
          const w = yn.getPointOnCubicBezier(m, h.start.x, h.start.y, h.points[0], h.points[1], h.points[2], h.points[3], h.points[4], h.points[5]);
          e.push(w.x, w.y);
        }
      else
        e = e.concat(h.points);
    });
    for (var t = e[0], i = e[0], a = e[1], o = e[1], r, s, l = 0; l < e.length / 2; l++)
      r = e[l * 2], s = e[l * 2 + 1], isNaN(r) || (t = Math.min(t, r), i = Math.max(i, r)), isNaN(s) || (a = Math.min(a, s), o = Math.max(o, s));
    return {
      x: t,
      y: a,
      width: i - t,
      height: o - a
    };
  }
  getLength() {
    return this.pathLength;
  }
  getPointAtLength(e) {
    var t, i = 0, a = this.dataArray.length;
    if (!a)
      return null;
    for (; i < a && e > this.dataArray[i].pathLength; )
      e -= this.dataArray[i].pathLength, ++i;
    if (i === a)
      return t = this.dataArray[i - 1].points.slice(-2), {
        x: t[0],
        y: t[1]
      };
    if (e < 0.01)
      return t = this.dataArray[i].points.slice(0, 2), {
        x: t[0],
        y: t[1]
      };
    var o = this.dataArray[i], r = o.points;
    switch (o.command) {
      case "L":
        return yn.getPointOnLine(e, o.start.x, o.start.y, r[0], r[1]);
      case "C":
        return yn.getPointOnCubicBezier(e / o.pathLength, o.start.x, o.start.y, r[0], r[1], r[2], r[3], r[4], r[5]);
      case "Q":
        return yn.getPointOnQuadraticBezier(e / o.pathLength, o.start.x, o.start.y, r[0], r[1], r[2], r[3]);
      case "A":
        var s = r[0], l = r[1], h = r[2], d = r[3], f = r[4], p = r[5], y = r[6];
        return f += p * e / o.pathLength, yn.getPointOnEllipticalArc(s, l, h, d, f, y);
    }
    return null;
  }
  static getLineLength(e, t, i, a) {
    return Math.sqrt((i - e) * (i - e) + (a - t) * (a - t));
  }
  static getPointOnLine(e, t, i, a, o, r, s) {
    r === void 0 && (r = t), s === void 0 && (s = i);
    var l = (o - i) / (a - t + 1e-8), h = Math.sqrt(e * e / (1 + l * l));
    a < t && (h *= -1);
    var d = l * h, f;
    if (a === t)
      f = {
        x: r,
        y: s + d
      };
    else if ((s - i) / (r - t + 1e-8) === l)
      f = {
        x: r + h,
        y: s + d
      };
    else {
      var p, y, m = this.getLineLength(t, i, a, o), w = (r - t) * (a - t) + (s - i) * (o - i);
      w = w / (m * m), p = t + w * (a - t), y = i + w * (o - i);
      var v = this.getLineLength(r, s, p, y), _ = Math.sqrt(e * e - v * v);
      h = Math.sqrt(_ * _ / (1 + l * l)), a < t && (h *= -1), d = l * h, f = {
        x: p + h,
        y: y + d
      };
    }
    return f;
  }
  static getPointOnCubicBezier(e, t, i, a, o, r, s, l, h) {
    function d(v) {
      return v * v * v;
    }
    function f(v) {
      return 3 * v * v * (1 - v);
    }
    function p(v) {
      return 3 * v * (1 - v) * (1 - v);
    }
    function y(v) {
      return (1 - v) * (1 - v) * (1 - v);
    }
    var m = l * d(e) + r * f(e) + a * p(e) + t * y(e), w = h * d(e) + s * f(e) + o * p(e) + i * y(e);
    return {
      x: m,
      y: w
    };
  }
  static getPointOnQuadraticBezier(e, t, i, a, o, r, s) {
    function l(y) {
      return y * y;
    }
    function h(y) {
      return 2 * y * (1 - y);
    }
    function d(y) {
      return (1 - y) * (1 - y);
    }
    var f = r * l(e) + a * h(e) + t * d(e), p = s * l(e) + o * h(e) + i * d(e);
    return {
      x: f,
      y: p
    };
  }
  static getPointOnEllipticalArc(e, t, i, a, o, r) {
    var s = Math.cos(r), l = Math.sin(r), h = {
      x: i * Math.cos(o),
      y: a * Math.sin(o)
    };
    return {
      x: e + (h.x * s - h.y * l),
      y: t + (h.x * l + h.y * s)
    };
  }
  static parsePathData(e) {
    if (!e)
      return [];
    var t = e, i = [
      "m",
      "M",
      "l",
      "L",
      "v",
      "V",
      "h",
      "H",
      "z",
      "Z",
      "c",
      "C",
      "q",
      "Q",
      "t",
      "T",
      "s",
      "S",
      "a",
      "A"
    ];
    t = t.replace(new RegExp(" ", "g"), ",");
    for (var a = 0; a < i.length; a++)
      t = t.replace(new RegExp(i[a], "g"), "|" + i[a]);
    var o = t.split("|"), r = [], s = [], l = 0, h = 0, d = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi, f;
    for (a = 1; a < o.length; a++) {
      var p = o[a], y = p.charAt(0);
      for (p = p.slice(1), s.length = 0; f = d.exec(p); )
        s.push(f[0]);
      for (var m = [], w = 0, v = s.length; w < v; w++) {
        if (s[w] === "00") {
          m.push(0, 0);
          continue;
        }
        var _ = parseFloat(s[w]);
        isNaN(_) ? m.push(0) : m.push(_);
      }
      for (; m.length > 0 && !isNaN(m[0]); ) {
        var L = null, T = [], S = l, A = h, x, M, P, Y, te, ge, re, me, ut, ht;
        switch (y) {
          case "l":
            l += m.shift(), h += m.shift(), L = "L", T.push(l, h);
            break;
          case "L":
            l = m.shift(), h = m.shift(), T.push(l, h);
            break;
          case "m":
            var ze = m.shift(), Ge = m.shift();
            if (l += ze, h += Ge, L = "M", r.length > 2 && r[r.length - 1].command === "z") {
              for (var Ae = r.length - 2; Ae >= 0; Ae--)
                if (r[Ae].command === "M") {
                  l = r[Ae].points[0] + ze, h = r[Ae].points[1] + Ge;
                  break;
                }
            }
            T.push(l, h), y = "l";
            break;
          case "M":
            l = m.shift(), h = m.shift(), L = "M", T.push(l, h), y = "L";
            break;
          case "h":
            l += m.shift(), L = "L", T.push(l, h);
            break;
          case "H":
            l = m.shift(), L = "L", T.push(l, h);
            break;
          case "v":
            h += m.shift(), L = "L", T.push(l, h);
            break;
          case "V":
            h = m.shift(), L = "L", T.push(l, h);
            break;
          case "C":
            T.push(m.shift(), m.shift(), m.shift(), m.shift()), l = m.shift(), h = m.shift(), T.push(l, h);
            break;
          case "c":
            T.push(l + m.shift(), h + m.shift(), l + m.shift(), h + m.shift()), l += m.shift(), h += m.shift(), L = "C", T.push(l, h);
            break;
          case "S":
            M = l, P = h, x = r[r.length - 1], x.command === "C" && (M = l + (l - x.points[2]), P = h + (h - x.points[3])), T.push(M, P, m.shift(), m.shift()), l = m.shift(), h = m.shift(), L = "C", T.push(l, h);
            break;
          case "s":
            M = l, P = h, x = r[r.length - 1], x.command === "C" && (M = l + (l - x.points[2]), P = h + (h - x.points[3])), T.push(M, P, l + m.shift(), h + m.shift()), l += m.shift(), h += m.shift(), L = "C", T.push(l, h);
            break;
          case "Q":
            T.push(m.shift(), m.shift()), l = m.shift(), h = m.shift(), T.push(l, h);
            break;
          case "q":
            T.push(l + m.shift(), h + m.shift()), l += m.shift(), h += m.shift(), L = "Q", T.push(l, h);
            break;
          case "T":
            M = l, P = h, x = r[r.length - 1], x.command === "Q" && (M = l + (l - x.points[0]), P = h + (h - x.points[1])), l = m.shift(), h = m.shift(), L = "Q", T.push(M, P, l, h);
            break;
          case "t":
            M = l, P = h, x = r[r.length - 1], x.command === "Q" && (M = l + (l - x.points[0]), P = h + (h - x.points[1])), l += m.shift(), h += m.shift(), L = "Q", T.push(M, P, l, h);
            break;
          case "A":
            Y = m.shift(), te = m.shift(), ge = m.shift(), re = m.shift(), me = m.shift(), ut = l, ht = h, l = m.shift(), h = m.shift(), L = "A", T = this.convertEndpointToCenterParameterization(ut, ht, l, h, re, me, Y, te, ge);
            break;
          case "a":
            Y = m.shift(), te = m.shift(), ge = m.shift(), re = m.shift(), me = m.shift(), ut = l, ht = h, l += m.shift(), h += m.shift(), L = "A", T = this.convertEndpointToCenterParameterization(ut, ht, l, h, re, me, Y, te, ge);
            break;
        }
        r.push({
          command: L || y,
          points: T,
          start: {
            x: S,
            y: A
          },
          pathLength: this.calcLength(S, A, L || y, T)
        });
      }
      (y === "z" || y === "Z") && r.push({
        command: "z",
        points: [],
        start: void 0,
        pathLength: 0
      });
    }
    return r;
  }
  static calcLength(e, t, i, a) {
    var o, r, s, l, h = yn;
    switch (i) {
      case "L":
        return h.getLineLength(e, t, a[0], a[1]);
      case "C":
        for (o = 0, r = h.getPointOnCubicBezier(0, e, t, a[0], a[1], a[2], a[3], a[4], a[5]), l = 0.01; l <= 1; l += 0.01)
          s = h.getPointOnCubicBezier(l, e, t, a[0], a[1], a[2], a[3], a[4], a[5]), o += h.getLineLength(r.x, r.y, s.x, s.y), r = s;
        return o;
      case "Q":
        for (o = 0, r = h.getPointOnQuadraticBezier(0, e, t, a[0], a[1], a[2], a[3]), l = 0.01; l <= 1; l += 0.01)
          s = h.getPointOnQuadraticBezier(l, e, t, a[0], a[1], a[2], a[3]), o += h.getLineLength(r.x, r.y, s.x, s.y), r = s;
        return o;
      case "A":
        o = 0;
        var d = a[4], f = a[5], p = a[4] + f, y = Math.PI / 180;
        if (Math.abs(d - p) < y && (y = Math.abs(d - p)), r = h.getPointOnEllipticalArc(a[0], a[1], a[2], a[3], d, 0), f < 0)
          for (l = d - y; l > p; l -= y)
            s = h.getPointOnEllipticalArc(a[0], a[1], a[2], a[3], l, 0), o += h.getLineLength(r.x, r.y, s.x, s.y), r = s;
        else
          for (l = d + y; l < p; l += y)
            s = h.getPointOnEllipticalArc(a[0], a[1], a[2], a[3], l, 0), o += h.getLineLength(r.x, r.y, s.x, s.y), r = s;
        return s = h.getPointOnEllipticalArc(a[0], a[1], a[2], a[3], p, 0), o += h.getLineLength(r.x, r.y, s.x, s.y), o;
    }
    return 0;
  }
  static convertEndpointToCenterParameterization(e, t, i, a, o, r, s, l, h) {
    var d = h * (Math.PI / 180), f = Math.cos(d) * (e - i) / 2 + Math.sin(d) * (t - a) / 2, p = -1 * Math.sin(d) * (e - i) / 2 + Math.cos(d) * (t - a) / 2, y = f * f / (s * s) + p * p / (l * l);
    y > 1 && (s *= Math.sqrt(y), l *= Math.sqrt(y));
    var m = Math.sqrt((s * s * (l * l) - s * s * (p * p) - l * l * (f * f)) / (s * s * (p * p) + l * l * (f * f)));
    o === r && (m *= -1), isNaN(m) && (m = 0);
    var w = m * s * p / l, v = m * -l * f / s, _ = (e + i) / 2 + Math.cos(d) * w - Math.sin(d) * v, L = (t + a) / 2 + Math.sin(d) * w + Math.cos(d) * v, T = function(te) {
      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);
    }, S = function(te, ge) {
      return (te[0] * ge[0] + te[1] * ge[1]) / (T(te) * T(ge));
    }, A = function(te, ge) {
      return (te[0] * ge[1] < te[1] * ge[0] ? -1 : 1) * Math.acos(S(te, ge));
    }, x = A([1, 0], [(f - w) / s, (p - v) / l]), M = [(f - w) / s, (p - v) / l], P = [(-1 * f - w) / s, (-1 * p - v) / l], Y = A(M, P);
    return S(M, P) <= -1 && (Y = Math.PI), S(M, P) >= 1 && (Y = 0), r === 0 && Y > 0 && (Y = Y - 2 * Math.PI), r === 1 && Y < 0 && (Y = Y + 2 * Math.PI), [_, L, s, l, x, Y, d, r];
  }
}
yn.prototype.className = "Path";
yn.prototype._attrsAffectingSize = ["data"];
eu(yn);
ee.addGetterSetter(yn, "data");
class Ko extends Qo {
  _sceneFunc(e) {
    super._sceneFunc(e);
    var t = Math.PI * 2, i = this.points(), a = i, o = this.tension() !== 0 && i.length > 4;
    o && (a = this.getTensionPoints());
    var r = this.pointerLength(), s = i.length, l, h;
    if (o) {
      const p = [
        a[a.length - 4],
        a[a.length - 3],
        a[a.length - 2],
        a[a.length - 1],
        i[s - 2],
        i[s - 1]
      ], y = yn.calcLength(a[a.length - 4], a[a.length - 3], "C", p), m = yn.getPointOnQuadraticBezier(Math.min(1, 1 - r / y), p[0], p[1], p[2], p[3], p[4], p[5]);
      l = i[s - 2] - m.x, h = i[s - 1] - m.y;
    } else
      l = i[s - 2] - i[s - 4], h = i[s - 1] - i[s - 3];
    var d = (Math.atan2(h, l) + t) % t, f = this.pointerWidth();
    this.pointerAtEnding() && (e.save(), e.beginPath(), e.translate(i[s - 2], i[s - 1]), e.rotate(d), e.moveTo(0, 0), e.lineTo(-r, f / 2), e.lineTo(-r, -f / 2), e.closePath(), e.restore(), this.__fillStroke(e)), this.pointerAtBeginning() && (e.save(), e.beginPath(), e.translate(i[0], i[1]), o ? (l = (a[0] + a[2]) / 2 - i[0], h = (a[1] + a[3]) / 2 - i[1]) : (l = i[2] - i[0], h = i[3] - i[1]), e.rotate((Math.atan2(-h, -l) + t) % t), e.moveTo(0, 0), e.lineTo(-r, f / 2), e.lineTo(-r, -f / 2), e.closePath(), e.restore(), this.__fillStroke(e));
  }
  __fillStroke(e) {
    var t = this.dashEnabled();
    t && (this.attrs.dashEnabled = !1, e.setLineDash([])), e.fillStrokeShape(this), t && (this.attrs.dashEnabled = !0);
  }
  getSelfRect() {
    const e = super.getSelfRect(), t = this.pointerWidth() / 2;
    return {
      x: e.x - t,
      y: e.y - t,
      width: e.width + t * 2,
      height: e.height + t * 2
    };
  }
}
Ko.prototype.className = "Arrow";
eu(Ko);
ee.addGetterSetter(Ko, "pointerLength", 10, nt());
ee.addGetterSetter(Ko, "pointerWidth", 10, nt());
ee.addGetterSetter(Ko, "pointerAtBeginning", !1);
ee.addGetterSetter(Ko, "pointerAtEnding", !0);
var _h = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
_h.exports;
(function(n, e) {
  (function() {
    var t, i = "4.17.21", a = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", r = "Expected a function", s = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", h = 500, d = "__lodash_placeholder__", f = 1, p = 2, y = 4, m = 1, w = 2, v = 1, _ = 2, L = 4, T = 8, S = 16, A = 32, x = 64, M = 128, P = 256, Y = 512, te = 30, ge = "...", re = 800, me = 16, ut = 1, ht = 2, ze = 3, Ge = 1 / 0, Ae = 9007199254740991, It = 17976931348623157e292, xt = NaN, ft = 4294967295, gt = ft - 1, Kt = ft >>> 1, Jt = [
      ["ary", M],
      ["bind", v],
      ["bindKey", _],
      ["curry", T],
      ["curryRight", S],
      ["flip", Y],
      ["partial", A],
      ["partialRight", x],
      ["rearg", P]
    ], pt = "[object Arguments]", Ee = "[object Array]", xn = "[object AsyncFunction]", Xt = "[object Boolean]", en = "[object Date]", hn = "[object DOMException]", dn = "[object Error]", En = "[object Function]", Zn = "[object GeneratorFunction]", $ = "[object Map]", Oe = "[object Number]", ai = "[object Null]", Mt = "[object Object]", oi = "[object Promise]", oa = "[object Proxy]", D = "[object RegExp]", N = "[object Set]", X = "[object String]", le = "[object Symbol]", it = "[object Undefined]", Je = "[object WeakMap]", We = "[object WeakSet]", Z = "[object ArrayBuffer]", z = "[object DataView]", Be = "[object Float32Array]", mt = "[object Float64Array]", Bn = "[object Int8Array]", ra = "[object Int16Array]", ki = "[object Int32Array]", B = "[object Uint8Array]", he = "[object Uint8ClampedArray]", ve = "[object Uint16Array]", et = "[object Uint32Array]", $e = /\b__p \+= '';/g, gn = /\b(__p \+=) '' \+/g, Hn = /(__e\(.*?\)|\b__t\)) \+\n'';/g, xa = /&(?:amp|lt|gt|quot|#39);/g, su = /[&<>"']/g, Ea = RegExp(xa.source), uu = RegExp(su.source), Wr = /<%-([\s\S]+?)%>/g, lo = /<%([\s\S]+?)%>/g, Gl = /<%=([\s\S]+?)%>/g, lu = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Qr = /^\w*$/, IT = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Bd = /[\\^$.*+?()[\]{}|]/g, JT = RegExp(Bd.source), Hd = /^\s+/, ZT = /\s/, BT = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, HT = /\{\n\/\* \[wrapped with (.+)\] \*/, XT = /,? & /, GT = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, WT = /[()=,{}\[\]\/\s]/, QT = /\\(\\)?/g, KT = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Yy = /\w*$/, zT = /^[-+]0x[0-9a-f]+$/i, $T = /^0b[01]+$/i, VT = /^\[object .+?Constructor\]$/, UT = /^0o[0-7]+$/i, qT = /^(?:0|[1-9]\d*)$/, eL = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Wl = /($^)/, tL = /['\n\r\u2028\u2029\\]/g, Ql = "\\ud800-\\udfff", nL = "\\u0300-\\u036f", iL = "\\ufe20-\\ufe2f", aL = "\\u20d0-\\u20ff", Py = nL + iL + aL, Ry = "\\u2700-\\u27bf", Fy = "a-z\\xdf-\\xf6\\xf8-\\xff", oL = "\\xac\\xb1\\xd7\\xf7", rL = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", sL = "\\u2000-\\u206f", uL = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Iy = "A-Z\\xc0-\\xd6\\xd8-\\xde", Jy = "\\ufe0e\\ufe0f", Zy = oL + rL + sL + uL, Xd = "['â€™]", lL = "[" + Ql + "]", By = "[" + Zy + "]", Kl = "[" + Py + "]", Hy = "\\d+", cL = "[" + Ry + "]", Xy = "[" + Fy + "]", Gy = "[^" + Ql + Zy + Hy + Ry + Fy + Iy + "]", Gd = "\\ud83c[\\udffb-\\udfff]", hL = "(?:" + Kl + "|" + Gd + ")", Wy = "[^" + Ql + "]", Wd = "(?:\\ud83c[\\udde6-\\uddff]){2}", Qd = "[\\ud800-\\udbff][\\udc00-\\udfff]", Kr = "[" + Iy + "]", Qy = "\\u200d", Ky = "(?:" + Xy + "|" + Gy + ")", dL = "(?:" + Kr + "|" + Gy + ")", zy = "(?:" + Xd + "(?:d|ll|m|re|s|t|ve))?", $y = "(?:" + Xd + "(?:D|LL|M|RE|S|T|VE))?", Vy = hL + "?", Uy = "[" + Jy + "]?", gL = "(?:" + Qy + "(?:" + [Wy, Wd, Qd].join("|") + ")" + Uy + Vy + ")*", fL = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", pL = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", qy = Uy + Vy + gL, mL = "(?:" + [cL, Wd, Qd].join("|") + ")" + qy, yL = "(?:" + [Wy + Kl + "?", Kl, Wd, Qd, lL].join("|") + ")", bL = RegExp(Xd, "g"), wL = RegExp(Kl, "g"), Kd = RegExp(Gd + "(?=" + Gd + ")|" + yL + qy, "g"), vL = RegExp([
      Kr + "?" + Xy + "+" + zy + "(?=" + [By, Kr, "$"].join("|") + ")",
      dL + "+" + $y + "(?=" + [By, Kr + Ky, "$"].join("|") + ")",
      Kr + "?" + Ky + "+" + zy,
      Kr + "+" + $y,
      pL,
      fL,
      Hy,
      mL
    ].join("|"), "g"), CL = RegExp("[" + Qy + Ql + Py + Jy + "]"), SL = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, kL = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], _L = -1, _t = {};
    _t[Be] = _t[mt] = _t[Bn] = _t[ra] = _t[ki] = _t[B] = _t[he] = _t[ve] = _t[et] = !0, _t[pt] = _t[Ee] = _t[Z] = _t[Xt] = _t[z] = _t[en] = _t[dn] = _t[En] = _t[$] = _t[Oe] = _t[Mt] = _t[D] = _t[N] = _t[X] = _t[Je] = !1;
    var St = {};
    St[pt] = St[Ee] = St[Z] = St[z] = St[Xt] = St[en] = St[Be] = St[mt] = St[Bn] = St[ra] = St[ki] = St[$] = St[Oe] = St[Mt] = St[D] = St[N] = St[X] = St[le] = St[B] = St[he] = St[ve] = St[et] = !0, St[dn] = St[En] = St[Je] = !1;
    var jL = {
      // Latin-1 Supplement block.
      Ã€: "A",
      Ã: "A",
      Ã‚: "A",
      Ãƒ: "A",
      Ã„: "A",
      Ã…: "A",
      Ã : "a",
      Ã¡: "a",
      Ã¢: "a",
      Ã£: "a",
      Ã¤: "a",
      Ã¥: "a",
      Ã‡: "C",
      Ã§: "c",
      Ã: "D",
      Ã°: "d",
      Ãˆ: "E",
      Ã‰: "E",
      ÃŠ: "E",
      Ã‹: "E",
      Ã¨: "e",
      Ã©: "e",
      Ãª: "e",
      Ã«: "e",
      ÃŒ: "I",
      Ã: "I",
      ÃŽ: "I",
      Ã: "I",
      Ã¬: "i",
      Ã­: "i",
      Ã®: "i",
      Ã¯: "i",
      Ã‘: "N",
      Ã±: "n",
      Ã’: "O",
      Ã“: "O",
      Ã”: "O",
      Ã•: "O",
      Ã–: "O",
      Ã˜: "O",
      Ã²: "o",
      Ã³: "o",
      Ã´: "o",
      Ãµ: "o",
      Ã¶: "o",
      Ã¸: "o",
      Ã™: "U",
      Ãš: "U",
      Ã›: "U",
      Ãœ: "U",
      Ã¹: "u",
      Ãº: "u",
      Ã»: "u",
      Ã¼: "u",
      Ã: "Y",
      Ã½: "y",
      Ã¿: "y",
      Ã†: "Ae",
      Ã¦: "ae",
      Ãž: "Th",
      Ã¾: "th",
      ÃŸ: "ss",
      // Latin Extended-A block.
      Ä€: "A",
      Ä‚: "A",
      Ä„: "A",
      Ä: "a",
      Äƒ: "a",
      Ä…: "a",
      Ä†: "C",
      Äˆ: "C",
      ÄŠ: "C",
      ÄŒ: "C",
      Ä‡: "c",
      Ä‰: "c",
      Ä‹: "c",
      Ä: "c",
      ÄŽ: "D",
      Ä: "D",
      Ä: "d",
      Ä‘: "d",
      Ä’: "E",
      Ä”: "E",
      Ä–: "E",
      Ä˜: "E",
      Äš: "E",
      Ä“: "e",
      Ä•: "e",
      Ä—: "e",
      Ä™: "e",
      Ä›: "e",
      Äœ: "G",
      Äž: "G",
      Ä : "G",
      Ä¢: "G",
      Ä: "g",
      ÄŸ: "g",
      Ä¡: "g",
      Ä£: "g",
      Ä¤: "H",
      Ä¦: "H",
      Ä¥: "h",
      Ä§: "h",
      Ä¨: "I",
      Äª: "I",
      Ä¬: "I",
      Ä®: "I",
      Ä°: "I",
      Ä©: "i",
      Ä«: "i",
      Ä­: "i",
      Ä¯: "i",
      Ä±: "i",
      Ä´: "J",
      Äµ: "j",
      Ä¶: "K",
      Ä·: "k",
      Ä¸: "k",
      Ä¹: "L",
      Ä»: "L",
      Ä½: "L",
      Ä¿: "L",
      Å: "L",
      Äº: "l",
      Ä¼: "l",
      Ä¾: "l",
      Å€: "l",
      Å‚: "l",
      Åƒ: "N",
      Å…: "N",
      Å‡: "N",
      ÅŠ: "N",
      Å„: "n",
      Å†: "n",
      Åˆ: "n",
      Å‹: "n",
      ÅŒ: "O",
      ÅŽ: "O",
      Å: "O",
      Å: "o",
      Å: "o",
      Å‘: "o",
      Å”: "R",
      Å–: "R",
      Å˜: "R",
      Å•: "r",
      Å—: "r",
      Å™: "r",
      Åš: "S",
      Åœ: "S",
      Åž: "S",
      Å : "S",
      Å›: "s",
      Å: "s",
      ÅŸ: "s",
      Å¡: "s",
      Å¢: "T",
      Å¤: "T",
      Å¦: "T",
      Å£: "t",
      Å¥: "t",
      Å§: "t",
      Å¨: "U",
      Åª: "U",
      Å¬: "U",
      Å®: "U",
      Å°: "U",
      Å²: "U",
      Å©: "u",
      Å«: "u",
      Å­: "u",
      Å¯: "u",
      Å±: "u",
      Å³: "u",
      Å´: "W",
      Åµ: "w",
      Å¶: "Y",
      Å·: "y",
      Å¸: "Y",
      Å¹: "Z",
      Å»: "Z",
      Å½: "Z",
      Åº: "z",
      Å¼: "z",
      Å¾: "z",
      Ä²: "IJ",
      Ä³: "ij",
      Å’: "Oe",
      Å“: "oe",
      Å‰: "'n",
      Å¿: "s"
    }, TL = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, LL = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, xL = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, EL = parseFloat, DL = parseInt, eb = typeof Qa == "object" && Qa && Qa.Object === Object && Qa, ML = typeof self == "object" && self && self.Object === Object && self, fn = eb || ML || Function("return this")(), zd = e && !e.nodeType && e, er = zd && !0 && n && !n.nodeType && n, tb = er && er.exports === zd, $d = tb && eb.process, _i = function() {
      try {
        var R = er && er.require && er.require("util").types;
        return R || $d && $d.binding && $d.binding("util");
      } catch {
      }
    }(), nb = _i && _i.isArrayBuffer, ib = _i && _i.isDate, ab = _i && _i.isMap, ob = _i && _i.isRegExp, rb = _i && _i.isSet, sb = _i && _i.isTypedArray;
    function ri(R, H, J) {
      switch (J.length) {
        case 0:
          return R.call(H);
        case 1:
          return R.call(H, J[0]);
        case 2:
          return R.call(H, J[0], J[1]);
        case 3:
          return R.call(H, J[0], J[1], J[2]);
      }
      return R.apply(H, J);
    }
    function NL(R, H, J, ce) {
      for (var De = -1, ot = R == null ? 0 : R.length; ++De < ot; ) {
        var zt = R[De];
        H(ce, zt, J(zt), R);
      }
      return ce;
    }
    function ji(R, H) {
      for (var J = -1, ce = R == null ? 0 : R.length; ++J < ce && H(R[J], J, R) !== !1; )
        ;
      return R;
    }
    function OL(R, H) {
      for (var J = R == null ? 0 : R.length; J-- && H(R[J], J, R) !== !1; )
        ;
      return R;
    }
    function ub(R, H) {
      for (var J = -1, ce = R == null ? 0 : R.length; ++J < ce; )
        if (!H(R[J], J, R))
          return !1;
      return !0;
    }
    function co(R, H) {
      for (var J = -1, ce = R == null ? 0 : R.length, De = 0, ot = []; ++J < ce; ) {
        var zt = R[J];
        H(zt, J, R) && (ot[De++] = zt);
      }
      return ot;
    }
    function zl(R, H) {
      var J = R == null ? 0 : R.length;
      return !!J && zr(R, H, 0) > -1;
    }
    function Vd(R, H, J) {
      for (var ce = -1, De = R == null ? 0 : R.length; ++ce < De; )
        if (J(H, R[ce]))
          return !0;
      return !1;
    }
    function Et(R, H) {
      for (var J = -1, ce = R == null ? 0 : R.length, De = Array(ce); ++J < ce; )
        De[J] = H(R[J], J, R);
      return De;
    }
    function ho(R, H) {
      for (var J = -1, ce = H.length, De = R.length; ++J < ce; )
        R[De + J] = H[J];
      return R;
    }
    function Ud(R, H, J, ce) {
      var De = -1, ot = R == null ? 0 : R.length;
      for (ce && ot && (J = R[++De]); ++De < ot; )
        J = H(J, R[De], De, R);
      return J;
    }
    function AL(R, H, J, ce) {
      var De = R == null ? 0 : R.length;
      for (ce && De && (J = R[--De]); De--; )
        J = H(J, R[De], De, R);
      return J;
    }
    function qd(R, H) {
      for (var J = -1, ce = R == null ? 0 : R.length; ++J < ce; )
        if (H(R[J], J, R))
          return !0;
      return !1;
    }
    var YL = eg("length");
    function PL(R) {
      return R.split("");
    }
    function RL(R) {
      return R.match(GT) || [];
    }
    function lb(R, H, J) {
      var ce;
      return J(R, function(De, ot, zt) {
        if (H(De, ot, zt))
          return ce = ot, !1;
      }), ce;
    }
    function $l(R, H, J, ce) {
      for (var De = R.length, ot = J + (ce ? 1 : -1); ce ? ot-- : ++ot < De; )
        if (H(R[ot], ot, R))
          return ot;
      return -1;
    }
    function zr(R, H, J) {
      return H === H ? zL(R, H, J) : $l(R, cb, J);
    }
    function FL(R, H, J, ce) {
      for (var De = J - 1, ot = R.length; ++De < ot; )
        if (ce(R[De], H))
          return De;
      return -1;
    }
    function cb(R) {
      return R !== R;
    }
    function hb(R, H) {
      var J = R == null ? 0 : R.length;
      return J ? ng(R, H) / J : xt;
    }
    function eg(R) {
      return function(H) {
        return H == null ? t : H[R];
      };
    }
    function tg(R) {
      return function(H) {
        return R == null ? t : R[H];
      };
    }
    function db(R, H, J, ce, De) {
      return De(R, function(ot, zt, yt) {
        J = ce ? (ce = !1, ot) : H(J, ot, zt, yt);
      }), J;
    }
    function IL(R, H) {
      var J = R.length;
      for (R.sort(H); J--; )
        R[J] = R[J].value;
      return R;
    }
    function ng(R, H) {
      for (var J, ce = -1, De = R.length; ++ce < De; ) {
        var ot = H(R[ce]);
        ot !== t && (J = J === t ? ot : J + ot);
      }
      return J;
    }
    function ig(R, H) {
      for (var J = -1, ce = Array(R); ++J < R; )
        ce[J] = H(J);
      return ce;
    }
    function JL(R, H) {
      return Et(H, function(J) {
        return [J, R[J]];
      });
    }
    function gb(R) {
      return R && R.slice(0, yb(R) + 1).replace(Hd, "");
    }
    function si(R) {
      return function(H) {
        return R(H);
      };
    }
    function ag(R, H) {
      return Et(H, function(J) {
        return R[J];
      });
    }
    function cu(R, H) {
      return R.has(H);
    }
    function fb(R, H) {
      for (var J = -1, ce = R.length; ++J < ce && zr(H, R[J], 0) > -1; )
        ;
      return J;
    }
    function pb(R, H) {
      for (var J = R.length; J-- && zr(H, R[J], 0) > -1; )
        ;
      return J;
    }
    function ZL(R, H) {
      for (var J = R.length, ce = 0; J--; )
        R[J] === H && ++ce;
      return ce;
    }
    var BL = tg(jL), HL = tg(TL);
    function XL(R) {
      return "\\" + xL[R];
    }
    function GL(R, H) {
      return R == null ? t : R[H];
    }
    function $r(R) {
      return CL.test(R);
    }
    function WL(R) {
      return SL.test(R);
    }
    function QL(R) {
      for (var H, J = []; !(H = R.next()).done; )
        J.push(H.value);
      return J;
    }
    function og(R) {
      var H = -1, J = Array(R.size);
      return R.forEach(function(ce, De) {
        J[++H] = [De, ce];
      }), J;
    }
    function mb(R, H) {
      return function(J) {
        return R(H(J));
      };
    }
    function go(R, H) {
      for (var J = -1, ce = R.length, De = 0, ot = []; ++J < ce; ) {
        var zt = R[J];
        (zt === H || zt === d) && (R[J] = d, ot[De++] = J);
      }
      return ot;
    }
    function Vl(R) {
      var H = -1, J = Array(R.size);
      return R.forEach(function(ce) {
        J[++H] = ce;
      }), J;
    }
    function KL(R) {
      var H = -1, J = Array(R.size);
      return R.forEach(function(ce) {
        J[++H] = [ce, ce];
      }), J;
    }
    function zL(R, H, J) {
      for (var ce = J - 1, De = R.length; ++ce < De; )
        if (R[ce] === H)
          return ce;
      return -1;
    }
    function $L(R, H, J) {
      for (var ce = J + 1; ce--; )
        if (R[ce] === H)
          return ce;
      return ce;
    }
    function Vr(R) {
      return $r(R) ? UL(R) : YL(R);
    }
    function Gi(R) {
      return $r(R) ? qL(R) : PL(R);
    }
    function yb(R) {
      for (var H = R.length; H-- && ZT.test(R.charAt(H)); )
        ;
      return H;
    }
    var VL = tg(LL);
    function UL(R) {
      for (var H = Kd.lastIndex = 0; Kd.test(R); )
        ++H;
      return H;
    }
    function qL(R) {
      return R.match(Kd) || [];
    }
    function ex(R) {
      return R.match(vL) || [];
    }
    var tx = function R(H) {
      H = H == null ? fn : Ur.defaults(fn.Object(), H, Ur.pick(fn, kL));
      var J = H.Array, ce = H.Date, De = H.Error, ot = H.Function, zt = H.Math, yt = H.Object, rg = H.RegExp, nx = H.String, Ti = H.TypeError, Ul = J.prototype, ix = ot.prototype, qr = yt.prototype, ql = H["__core-js_shared__"], ec = ix.toString, dt = qr.hasOwnProperty, ax = 0, bb = function() {
        var u = /[^.]+$/.exec(ql && ql.keys && ql.keys.IE_PROTO || "");
        return u ? "Symbol(src)_1." + u : "";
      }(), tc = qr.toString, ox = ec.call(yt), rx = fn._, sx = rg(
        "^" + ec.call(dt).replace(Bd, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), nc = tb ? H.Buffer : t, fo = H.Symbol, ic = H.Uint8Array, wb = nc ? nc.allocUnsafe : t, ac = mb(yt.getPrototypeOf, yt), vb = yt.create, Cb = qr.propertyIsEnumerable, oc = Ul.splice, Sb = fo ? fo.isConcatSpreadable : t, hu = fo ? fo.iterator : t, tr = fo ? fo.toStringTag : t, rc = function() {
        try {
          var u = rr(yt, "defineProperty");
          return u({}, "", {}), u;
        } catch {
        }
      }(), ux = H.clearTimeout !== fn.clearTimeout && H.clearTimeout, lx = ce && ce.now !== fn.Date.now && ce.now, cx = H.setTimeout !== fn.setTimeout && H.setTimeout, sc = zt.ceil, uc = zt.floor, sg = yt.getOwnPropertySymbols, hx = nc ? nc.isBuffer : t, kb = H.isFinite, dx = Ul.join, gx = mb(yt.keys, yt), $t = zt.max, Cn = zt.min, fx = ce.now, px = H.parseInt, _b = zt.random, mx = Ul.reverse, ug = rr(H, "DataView"), du = rr(H, "Map"), lg = rr(H, "Promise"), es = rr(H, "Set"), gu = rr(H, "WeakMap"), fu = rr(yt, "create"), lc = gu && new gu(), ts = {}, yx = sr(ug), bx = sr(du), wx = sr(lg), vx = sr(es), Cx = sr(gu), cc = fo ? fo.prototype : t, pu = cc ? cc.valueOf : t, jb = cc ? cc.toString : t;
      function k(u) {
        if (Pt(u) && !Ne(u) && !(u instanceof Qe)) {
          if (u instanceof Li)
            return u;
          if (dt.call(u, "__wrapped__"))
            return Tw(u);
        }
        return new Li(u);
      }
      var ns = /* @__PURE__ */ function() {
        function u() {
        }
        return function(c) {
          if (!Nt(c))
            return {};
          if (vb)
            return vb(c);
          u.prototype = c;
          var g = new u();
          return u.prototype = t, g;
        };
      }();
      function hc() {
      }
      function Li(u, c) {
        this.__wrapped__ = u, this.__actions__ = [], this.__chain__ = !!c, this.__index__ = 0, this.__values__ = t;
      }
      k.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Wr,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: lo,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Gl,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: k
        }
      }, k.prototype = hc.prototype, k.prototype.constructor = k, Li.prototype = ns(hc.prototype), Li.prototype.constructor = Li;
      function Qe(u) {
        this.__wrapped__ = u, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = ft, this.__views__ = [];
      }
      function Sx() {
        var u = new Qe(this.__wrapped__);
        return u.__actions__ = Xn(this.__actions__), u.__dir__ = this.__dir__, u.__filtered__ = this.__filtered__, u.__iteratees__ = Xn(this.__iteratees__), u.__takeCount__ = this.__takeCount__, u.__views__ = Xn(this.__views__), u;
      }
      function kx() {
        if (this.__filtered__) {
          var u = new Qe(this);
          u.__dir__ = -1, u.__filtered__ = !0;
        } else
          u = this.clone(), u.__dir__ *= -1;
        return u;
      }
      function _x() {
        var u = this.__wrapped__.value(), c = this.__dir__, g = Ne(u), b = c < 0, C = g ? u.length : 0, j = PE(0, C, this.__views__), E = j.start, O = j.end, F = O - E, G = b ? O : E - 1, W = this.__iteratees__, K = W.length, oe = 0, ye = Cn(F, this.__takeCount__);
        if (!g || !b && C == F && ye == F)
          return zb(u, this.__actions__);
        var ke = [];
        e:
          for (; F-- && oe < ye; ) {
            G += c;
            for (var Re = -1, _e = u[G]; ++Re < K; ) {
              var He = W[Re], Ve = He.iteratee, ci = He.type, Nn = Ve(_e);
              if (ci == ht)
                _e = Nn;
              else if (!Nn) {
                if (ci == ut)
                  continue e;
                break e;
              }
            }
            ke[oe++] = _e;
          }
        return ke;
      }
      Qe.prototype = ns(hc.prototype), Qe.prototype.constructor = Qe;
      function nr(u) {
        var c = -1, g = u == null ? 0 : u.length;
        for (this.clear(); ++c < g; ) {
          var b = u[c];
          this.set(b[0], b[1]);
        }
      }
      function jx() {
        this.__data__ = fu ? fu(null) : {}, this.size = 0;
      }
      function Tx(u) {
        var c = this.has(u) && delete this.__data__[u];
        return this.size -= c ? 1 : 0, c;
      }
      function Lx(u) {
        var c = this.__data__;
        if (fu) {
          var g = c[u];
          return g === l ? t : g;
        }
        return dt.call(c, u) ? c[u] : t;
      }
      function xx(u) {
        var c = this.__data__;
        return fu ? c[u] !== t : dt.call(c, u);
      }
      function Ex(u, c) {
        var g = this.__data__;
        return this.size += this.has(u) ? 0 : 1, g[u] = fu && c === t ? l : c, this;
      }
      nr.prototype.clear = jx, nr.prototype.delete = Tx, nr.prototype.get = Lx, nr.prototype.has = xx, nr.prototype.set = Ex;
      function Da(u) {
        var c = -1, g = u == null ? 0 : u.length;
        for (this.clear(); ++c < g; ) {
          var b = u[c];
          this.set(b[0], b[1]);
        }
      }
      function Dx() {
        this.__data__ = [], this.size = 0;
      }
      function Mx(u) {
        var c = this.__data__, g = dc(c, u);
        if (g < 0)
          return !1;
        var b = c.length - 1;
        return g == b ? c.pop() : oc.call(c, g, 1), --this.size, !0;
      }
      function Nx(u) {
        var c = this.__data__, g = dc(c, u);
        return g < 0 ? t : c[g][1];
      }
      function Ox(u) {
        return dc(this.__data__, u) > -1;
      }
      function Ax(u, c) {
        var g = this.__data__, b = dc(g, u);
        return b < 0 ? (++this.size, g.push([u, c])) : g[b][1] = c, this;
      }
      Da.prototype.clear = Dx, Da.prototype.delete = Mx, Da.prototype.get = Nx, Da.prototype.has = Ox, Da.prototype.set = Ax;
      function Ma(u) {
        var c = -1, g = u == null ? 0 : u.length;
        for (this.clear(); ++c < g; ) {
          var b = u[c];
          this.set(b[0], b[1]);
        }
      }
      function Yx() {
        this.size = 0, this.__data__ = {
          hash: new nr(),
          map: new (du || Da)(),
          string: new nr()
        };
      }
      function Px(u) {
        var c = _c(this, u).delete(u);
        return this.size -= c ? 1 : 0, c;
      }
      function Rx(u) {
        return _c(this, u).get(u);
      }
      function Fx(u) {
        return _c(this, u).has(u);
      }
      function Ix(u, c) {
        var g = _c(this, u), b = g.size;
        return g.set(u, c), this.size += g.size == b ? 0 : 1, this;
      }
      Ma.prototype.clear = Yx, Ma.prototype.delete = Px, Ma.prototype.get = Rx, Ma.prototype.has = Fx, Ma.prototype.set = Ix;
      function ir(u) {
        var c = -1, g = u == null ? 0 : u.length;
        for (this.__data__ = new Ma(); ++c < g; )
          this.add(u[c]);
      }
      function Jx(u) {
        return this.__data__.set(u, l), this;
      }
      function Zx(u) {
        return this.__data__.has(u);
      }
      ir.prototype.add = ir.prototype.push = Jx, ir.prototype.has = Zx;
      function Wi(u) {
        var c = this.__data__ = new Da(u);
        this.size = c.size;
      }
      function Bx() {
        this.__data__ = new Da(), this.size = 0;
      }
      function Hx(u) {
        var c = this.__data__, g = c.delete(u);
        return this.size = c.size, g;
      }
      function Xx(u) {
        return this.__data__.get(u);
      }
      function Gx(u) {
        return this.__data__.has(u);
      }
      function Wx(u, c) {
        var g = this.__data__;
        if (g instanceof Da) {
          var b = g.__data__;
          if (!du || b.length < a - 1)
            return b.push([u, c]), this.size = ++g.size, this;
          g = this.__data__ = new Ma(b);
        }
        return g.set(u, c), this.size = g.size, this;
      }
      Wi.prototype.clear = Bx, Wi.prototype.delete = Hx, Wi.prototype.get = Xx, Wi.prototype.has = Gx, Wi.prototype.set = Wx;
      function Tb(u, c) {
        var g = Ne(u), b = !g && ur(u), C = !g && !b && wo(u), j = !g && !b && !C && ss(u), E = g || b || C || j, O = E ? ig(u.length, nx) : [], F = O.length;
        for (var G in u)
          (c || dt.call(u, G)) && !(E && // Safari 9 has enumerable `arguments.length` in strict mode.
          (G == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          C && (G == "offset" || G == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          j && (G == "buffer" || G == "byteLength" || G == "byteOffset") || // Skip index properties.
          Ya(G, F))) && O.push(G);
        return O;
      }
      function Lb(u) {
        var c = u.length;
        return c ? u[vg(0, c - 1)] : t;
      }
      function Qx(u, c) {
        return jc(Xn(u), ar(c, 0, u.length));
      }
      function Kx(u) {
        return jc(Xn(u));
      }
      function cg(u, c, g) {
        (g !== t && !Qi(u[c], g) || g === t && !(c in u)) && Na(u, c, g);
      }
      function mu(u, c, g) {
        var b = u[c];
        (!(dt.call(u, c) && Qi(b, g)) || g === t && !(c in u)) && Na(u, c, g);
      }
      function dc(u, c) {
        for (var g = u.length; g--; )
          if (Qi(u[g][0], c))
            return g;
        return -1;
      }
      function zx(u, c, g, b) {
        return po(u, function(C, j, E) {
          c(b, C, g(C), E);
        }), b;
      }
      function xb(u, c) {
        return u && ua(c, tn(c), u);
      }
      function $x(u, c) {
        return u && ua(c, Wn(c), u);
      }
      function Na(u, c, g) {
        c == "__proto__" && rc ? rc(u, c, {
          configurable: !0,
          enumerable: !0,
          value: g,
          writable: !0
        }) : u[c] = g;
      }
      function hg(u, c) {
        for (var g = -1, b = c.length, C = J(b), j = u == null; ++g < b; )
          C[g] = j ? t : Gg(u, c[g]);
        return C;
      }
      function ar(u, c, g) {
        return u === u && (g !== t && (u = u <= g ? u : g), c !== t && (u = u >= c ? u : c)), u;
      }
      function xi(u, c, g, b, C, j) {
        var E, O = c & f, F = c & p, G = c & y;
        if (g && (E = C ? g(u, b, C, j) : g(u)), E !== t)
          return E;
        if (!Nt(u))
          return u;
        var W = Ne(u);
        if (W) {
          if (E = FE(u), !O)
            return Xn(u, E);
        } else {
          var K = Sn(u), oe = K == En || K == Zn;
          if (wo(u))
            return Ub(u, O);
          if (K == Mt || K == pt || oe && !C) {
            if (E = F || oe ? {} : yw(u), !O)
              return F ? LE(u, $x(E, u)) : TE(u, xb(E, u));
          } else {
            if (!St[K])
              return C ? u : {};
            E = IE(u, K, O);
          }
        }
        j || (j = new Wi());
        var ye = j.get(u);
        if (ye)
          return ye;
        j.set(u, E), Ww(u) ? u.forEach(function(_e) {
          E.add(xi(_e, c, g, _e, u, j));
        }) : Xw(u) && u.forEach(function(_e, He) {
          E.set(He, xi(_e, c, g, He, u, j));
        });
        var ke = G ? F ? Mg : Dg : F ? Wn : tn, Re = W ? t : ke(u);
        return ji(Re || u, function(_e, He) {
          Re && (He = _e, _e = u[He]), mu(E, He, xi(_e, c, g, He, u, j));
        }), E;
      }
      function Vx(u) {
        var c = tn(u);
        return function(g) {
          return Eb(g, u, c);
        };
      }
      function Eb(u, c, g) {
        var b = g.length;
        if (u == null)
          return !b;
        for (u = yt(u); b--; ) {
          var C = g[b], j = c[C], E = u[C];
          if (E === t && !(C in u) || !j(E))
            return !1;
        }
        return !0;
      }
      function Db(u, c, g) {
        if (typeof u != "function")
          throw new Ti(r);
        return ku(function() {
          u.apply(t, g);
        }, c);
      }
      function yu(u, c, g, b) {
        var C = -1, j = zl, E = !0, O = u.length, F = [], G = c.length;
        if (!O)
          return F;
        g && (c = Et(c, si(g))), b ? (j = Vd, E = !1) : c.length >= a && (j = cu, E = !1, c = new ir(c));
        e:
          for (; ++C < O; ) {
            var W = u[C], K = g == null ? W : g(W);
            if (W = b || W !== 0 ? W : 0, E && K === K) {
              for (var oe = G; oe--; )
                if (c[oe] === K)
                  continue e;
              F.push(W);
            } else j(c, K, b) || F.push(W);
          }
        return F;
      }
      var po = iw(sa), Mb = iw(gg, !0);
      function Ux(u, c) {
        var g = !0;
        return po(u, function(b, C, j) {
          return g = !!c(b, C, j), g;
        }), g;
      }
      function gc(u, c, g) {
        for (var b = -1, C = u.length; ++b < C; ) {
          var j = u[b], E = c(j);
          if (E != null && (O === t ? E === E && !li(E) : g(E, O)))
            var O = E, F = j;
        }
        return F;
      }
      function qx(u, c, g, b) {
        var C = u.length;
        for (g = Ye(g), g < 0 && (g = -g > C ? 0 : C + g), b = b === t || b > C ? C : Ye(b), b < 0 && (b += C), b = g > b ? 0 : Kw(b); g < b; )
          u[g++] = c;
        return u;
      }
      function Nb(u, c) {
        var g = [];
        return po(u, function(b, C, j) {
          c(b, C, j) && g.push(b);
        }), g;
      }
      function pn(u, c, g, b, C) {
        var j = -1, E = u.length;
        for (g || (g = ZE), C || (C = []); ++j < E; ) {
          var O = u[j];
          c > 0 && g(O) ? c > 1 ? pn(O, c - 1, g, b, C) : ho(C, O) : b || (C[C.length] = O);
        }
        return C;
      }
      var dg = aw(), Ob = aw(!0);
      function sa(u, c) {
        return u && dg(u, c, tn);
      }
      function gg(u, c) {
        return u && Ob(u, c, tn);
      }
      function fc(u, c) {
        return co(c, function(g) {
          return Pa(u[g]);
        });
      }
      function or(u, c) {
        c = yo(c, u);
        for (var g = 0, b = c.length; u != null && g < b; )
          u = u[la(c[g++])];
        return g && g == b ? u : t;
      }
      function Ab(u, c, g) {
        var b = c(u);
        return Ne(u) ? b : ho(b, g(u));
      }
      function Dn(u) {
        return u == null ? u === t ? it : ai : tr && tr in yt(u) ? YE(u) : KE(u);
      }
      function fg(u, c) {
        return u > c;
      }
      function eE(u, c) {
        return u != null && dt.call(u, c);
      }
      function tE(u, c) {
        return u != null && c in yt(u);
      }
      function nE(u, c, g) {
        return u >= Cn(c, g) && u < $t(c, g);
      }
      function pg(u, c, g) {
        for (var b = g ? Vd : zl, C = u[0].length, j = u.length, E = j, O = J(j), F = 1 / 0, G = []; E--; ) {
          var W = u[E];
          E && c && (W = Et(W, si(c))), F = Cn(W.length, F), O[E] = !g && (c || C >= 120 && W.length >= 120) ? new ir(E && W) : t;
        }
        W = u[0];
        var K = -1, oe = O[0];
        e:
          for (; ++K < C && G.length < F; ) {
            var ye = W[K], ke = c ? c(ye) : ye;
            if (ye = g || ye !== 0 ? ye : 0, !(oe ? cu(oe, ke) : b(G, ke, g))) {
              for (E = j; --E; ) {
                var Re = O[E];
                if (!(Re ? cu(Re, ke) : b(u[E], ke, g)))
                  continue e;
              }
              oe && oe.push(ke), G.push(ye);
            }
          }
        return G;
      }
      function iE(u, c, g, b) {
        return sa(u, function(C, j, E) {
          c(b, g(C), j, E);
        }), b;
      }
      function bu(u, c, g) {
        c = yo(c, u), u = Cw(u, c);
        var b = u == null ? u : u[la(Di(c))];
        return b == null ? t : ri(b, u, g);
      }
      function Yb(u) {
        return Pt(u) && Dn(u) == pt;
      }
      function aE(u) {
        return Pt(u) && Dn(u) == Z;
      }
      function oE(u) {
        return Pt(u) && Dn(u) == en;
      }
      function wu(u, c, g, b, C) {
        return u === c ? !0 : u == null || c == null || !Pt(u) && !Pt(c) ? u !== u && c !== c : rE(u, c, g, b, wu, C);
      }
      function rE(u, c, g, b, C, j) {
        var E = Ne(u), O = Ne(c), F = E ? Ee : Sn(u), G = O ? Ee : Sn(c);
        F = F == pt ? Mt : F, G = G == pt ? Mt : G;
        var W = F == Mt, K = G == Mt, oe = F == G;
        if (oe && wo(u)) {
          if (!wo(c))
            return !1;
          E = !0, W = !1;
        }
        if (oe && !W)
          return j || (j = new Wi()), E || ss(u) ? fw(u, c, g, b, C, j) : OE(u, c, F, g, b, C, j);
        if (!(g & m)) {
          var ye = W && dt.call(u, "__wrapped__"), ke = K && dt.call(c, "__wrapped__");
          if (ye || ke) {
            var Re = ye ? u.value() : u, _e = ke ? c.value() : c;
            return j || (j = new Wi()), C(Re, _e, g, b, j);
          }
        }
        return oe ? (j || (j = new Wi()), AE(u, c, g, b, C, j)) : !1;
      }
      function sE(u) {
        return Pt(u) && Sn(u) == $;
      }
      function mg(u, c, g, b) {
        var C = g.length, j = C, E = !b;
        if (u == null)
          return !j;
        for (u = yt(u); C--; ) {
          var O = g[C];
          if (E && O[2] ? O[1] !== u[O[0]] : !(O[0] in u))
            return !1;
        }
        for (; ++C < j; ) {
          O = g[C];
          var F = O[0], G = u[F], W = O[1];
          if (E && O[2]) {
            if (G === t && !(F in u))
              return !1;
          } else {
            var K = new Wi();
            if (b)
              var oe = b(G, W, F, u, c, K);
            if (!(oe === t ? wu(W, G, m | w, b, K) : oe))
              return !1;
          }
        }
        return !0;
      }
      function Pb(u) {
        if (!Nt(u) || HE(u))
          return !1;
        var c = Pa(u) ? sx : VT;
        return c.test(sr(u));
      }
      function uE(u) {
        return Pt(u) && Dn(u) == D;
      }
      function lE(u) {
        return Pt(u) && Sn(u) == N;
      }
      function cE(u) {
        return Pt(u) && Mc(u.length) && !!_t[Dn(u)];
      }
      function Rb(u) {
        return typeof u == "function" ? u : u == null ? Qn : typeof u == "object" ? Ne(u) ? Jb(u[0], u[1]) : Ib(u) : ov(u);
      }
      function yg(u) {
        if (!Su(u))
          return gx(u);
        var c = [];
        for (var g in yt(u))
          dt.call(u, g) && g != "constructor" && c.push(g);
        return c;
      }
      function hE(u) {
        if (!Nt(u))
          return QE(u);
        var c = Su(u), g = [];
        for (var b in u)
          b == "constructor" && (c || !dt.call(u, b)) || g.push(b);
        return g;
      }
      function bg(u, c) {
        return u < c;
      }
      function Fb(u, c) {
        var g = -1, b = Gn(u) ? J(u.length) : [];
        return po(u, function(C, j, E) {
          b[++g] = c(C, j, E);
        }), b;
      }
      function Ib(u) {
        var c = Og(u);
        return c.length == 1 && c[0][2] ? ww(c[0][0], c[0][1]) : function(g) {
          return g === u || mg(g, u, c);
        };
      }
      function Jb(u, c) {
        return Yg(u) && bw(c) ? ww(la(u), c) : function(g) {
          var b = Gg(g, u);
          return b === t && b === c ? Wg(g, u) : wu(c, b, m | w);
        };
      }
      function pc(u, c, g, b, C) {
        u !== c && dg(c, function(j, E) {
          if (C || (C = new Wi()), Nt(j))
            dE(u, c, E, g, pc, b, C);
          else {
            var O = b ? b(Rg(u, E), j, E + "", u, c, C) : t;
            O === t && (O = j), cg(u, E, O);
          }
        }, Wn);
      }
      function dE(u, c, g, b, C, j, E) {
        var O = Rg(u, g), F = Rg(c, g), G = E.get(F);
        if (G) {
          cg(u, g, G);
          return;
        }
        var W = j ? j(O, F, g + "", u, c, E) : t, K = W === t;
        if (K) {
          var oe = Ne(F), ye = !oe && wo(F), ke = !oe && !ye && ss(F);
          W = F, oe || ye || ke ? Ne(O) ? W = O : Zt(O) ? W = Xn(O) : ye ? (K = !1, W = Ub(F, !0)) : ke ? (K = !1, W = qb(F, !0)) : W = [] : _u(F) || ur(F) ? (W = O, ur(O) ? W = zw(O) : (!Nt(O) || Pa(O)) && (W = yw(F))) : K = !1;
        }
        K && (E.set(F, W), C(W, F, b, j, E), E.delete(F)), cg(u, g, W);
      }
      function Zb(u, c) {
        var g = u.length;
        if (g)
          return c += c < 0 ? g : 0, Ya(c, g) ? u[c] : t;
      }
      function Bb(u, c, g) {
        c.length ? c = Et(c, function(j) {
          return Ne(j) ? function(E) {
            return or(E, j.length === 1 ? j[0] : j);
          } : j;
        }) : c = [Qn];
        var b = -1;
        c = Et(c, si(Se()));
        var C = Fb(u, function(j, E, O) {
          var F = Et(c, function(G) {
            return G(j);
          });
          return { criteria: F, index: ++b, value: j };
        });
        return IL(C, function(j, E) {
          return jE(j, E, g);
        });
      }
      function gE(u, c) {
        return Hb(u, c, function(g, b) {
          return Wg(u, b);
        });
      }
      function Hb(u, c, g) {
        for (var b = -1, C = c.length, j = {}; ++b < C; ) {
          var E = c[b], O = or(u, E);
          g(O, E) && vu(j, yo(E, u), O);
        }
        return j;
      }
      function fE(u) {
        return function(c) {
          return or(c, u);
        };
      }
      function wg(u, c, g, b) {
        var C = b ? FL : zr, j = -1, E = c.length, O = u;
        for (u === c && (c = Xn(c)), g && (O = Et(u, si(g))); ++j < E; )
          for (var F = 0, G = c[j], W = g ? g(G) : G; (F = C(O, W, F, b)) > -1; )
            O !== u && oc.call(O, F, 1), oc.call(u, F, 1);
        return u;
      }
      function Xb(u, c) {
        for (var g = u ? c.length : 0, b = g - 1; g--; ) {
          var C = c[g];
          if (g == b || C !== j) {
            var j = C;
            Ya(C) ? oc.call(u, C, 1) : kg(u, C);
          }
        }
        return u;
      }
      function vg(u, c) {
        return u + uc(_b() * (c - u + 1));
      }
      function pE(u, c, g, b) {
        for (var C = -1, j = $t(sc((c - u) / (g || 1)), 0), E = J(j); j--; )
          E[b ? j : ++C] = u, u += g;
        return E;
      }
      function Cg(u, c) {
        var g = "";
        if (!u || c < 1 || c > Ae)
          return g;
        do
          c % 2 && (g += u), c = uc(c / 2), c && (u += u);
        while (c);
        return g;
      }
      function Fe(u, c) {
        return Fg(vw(u, c, Qn), u + "");
      }
      function mE(u) {
        return Lb(us(u));
      }
      function yE(u, c) {
        var g = us(u);
        return jc(g, ar(c, 0, g.length));
      }
      function vu(u, c, g, b) {
        if (!Nt(u))
          return u;
        c = yo(c, u);
        for (var C = -1, j = c.length, E = j - 1, O = u; O != null && ++C < j; ) {
          var F = la(c[C]), G = g;
          if (F === "__proto__" || F === "constructor" || F === "prototype")
            return u;
          if (C != E) {
            var W = O[F];
            G = b ? b(W, F, O) : t, G === t && (G = Nt(W) ? W : Ya(c[C + 1]) ? [] : {});
          }
          mu(O, F, G), O = O[F];
        }
        return u;
      }
      var Gb = lc ? function(u, c) {
        return lc.set(u, c), u;
      } : Qn, bE = rc ? function(u, c) {
        return rc(u, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Kg(c),
          writable: !0
        });
      } : Qn;
      function wE(u) {
        return jc(us(u));
      }
      function Ei(u, c, g) {
        var b = -1, C = u.length;
        c < 0 && (c = -c > C ? 0 : C + c), g = g > C ? C : g, g < 0 && (g += C), C = c > g ? 0 : g - c >>> 0, c >>>= 0;
        for (var j = J(C); ++b < C; )
          j[b] = u[b + c];
        return j;
      }
      function vE(u, c) {
        var g;
        return po(u, function(b, C, j) {
          return g = c(b, C, j), !g;
        }), !!g;
      }
      function mc(u, c, g) {
        var b = 0, C = u == null ? b : u.length;
        if (typeof c == "number" && c === c && C <= Kt) {
          for (; b < C; ) {
            var j = b + C >>> 1, E = u[j];
            E !== null && !li(E) && (g ? E <= c : E < c) ? b = j + 1 : C = j;
          }
          return C;
        }
        return Sg(u, c, Qn, g);
      }
      function Sg(u, c, g, b) {
        var C = 0, j = u == null ? 0 : u.length;
        if (j === 0)
          return 0;
        c = g(c);
        for (var E = c !== c, O = c === null, F = li(c), G = c === t; C < j; ) {
          var W = uc((C + j) / 2), K = g(u[W]), oe = K !== t, ye = K === null, ke = K === K, Re = li(K);
          if (E)
            var _e = b || ke;
          else G ? _e = ke && (b || oe) : O ? _e = ke && oe && (b || !ye) : F ? _e = ke && oe && !ye && (b || !Re) : ye || Re ? _e = !1 : _e = b ? K <= c : K < c;
          _e ? C = W + 1 : j = W;
        }
        return Cn(j, gt);
      }
      function Wb(u, c) {
        for (var g = -1, b = u.length, C = 0, j = []; ++g < b; ) {
          var E = u[g], O = c ? c(E) : E;
          if (!g || !Qi(O, F)) {
            var F = O;
            j[C++] = E === 0 ? 0 : E;
          }
        }
        return j;
      }
      function Qb(u) {
        return typeof u == "number" ? u : li(u) ? xt : +u;
      }
      function ui(u) {
        if (typeof u == "string")
          return u;
        if (Ne(u))
          return Et(u, ui) + "";
        if (li(u))
          return jb ? jb.call(u) : "";
        var c = u + "";
        return c == "0" && 1 / u == -Ge ? "-0" : c;
      }
      function mo(u, c, g) {
        var b = -1, C = zl, j = u.length, E = !0, O = [], F = O;
        if (g)
          E = !1, C = Vd;
        else if (j >= a) {
          var G = c ? null : ME(u);
          if (G)
            return Vl(G);
          E = !1, C = cu, F = new ir();
        } else
          F = c ? [] : O;
        e:
          for (; ++b < j; ) {
            var W = u[b], K = c ? c(W) : W;
            if (W = g || W !== 0 ? W : 0, E && K === K) {
              for (var oe = F.length; oe--; )
                if (F[oe] === K)
                  continue e;
              c && F.push(K), O.push(W);
            } else C(F, K, g) || (F !== O && F.push(K), O.push(W));
          }
        return O;
      }
      function kg(u, c) {
        return c = yo(c, u), u = Cw(u, c), u == null || delete u[la(Di(c))];
      }
      function Kb(u, c, g, b) {
        return vu(u, c, g(or(u, c)), b);
      }
      function yc(u, c, g, b) {
        for (var C = u.length, j = b ? C : -1; (b ? j-- : ++j < C) && c(u[j], j, u); )
          ;
        return g ? Ei(u, b ? 0 : j, b ? j + 1 : C) : Ei(u, b ? j + 1 : 0, b ? C : j);
      }
      function zb(u, c) {
        var g = u;
        return g instanceof Qe && (g = g.value()), Ud(c, function(b, C) {
          return C.func.apply(C.thisArg, ho([b], C.args));
        }, g);
      }
      function _g(u, c, g) {
        var b = u.length;
        if (b < 2)
          return b ? mo(u[0]) : [];
        for (var C = -1, j = J(b); ++C < b; )
          for (var E = u[C], O = -1; ++O < b; )
            O != C && (j[C] = yu(j[C] || E, u[O], c, g));
        return mo(pn(j, 1), c, g);
      }
      function $b(u, c, g) {
        for (var b = -1, C = u.length, j = c.length, E = {}; ++b < C; ) {
          var O = b < j ? c[b] : t;
          g(E, u[b], O);
        }
        return E;
      }
      function jg(u) {
        return Zt(u) ? u : [];
      }
      function Tg(u) {
        return typeof u == "function" ? u : Qn;
      }
      function yo(u, c) {
        return Ne(u) ? u : Yg(u, c) ? [u] : jw(lt(u));
      }
      var CE = Fe;
      function bo(u, c, g) {
        var b = u.length;
        return g = g === t ? b : g, !c && g >= b ? u : Ei(u, c, g);
      }
      var Vb = ux || function(u) {
        return fn.clearTimeout(u);
      };
      function Ub(u, c) {
        if (c)
          return u.slice();
        var g = u.length, b = wb ? wb(g) : new u.constructor(g);
        return u.copy(b), b;
      }
      function Lg(u) {
        var c = new u.constructor(u.byteLength);
        return new ic(c).set(new ic(u)), c;
      }
      function SE(u, c) {
        var g = c ? Lg(u.buffer) : u.buffer;
        return new u.constructor(g, u.byteOffset, u.byteLength);
      }
      function kE(u) {
        var c = new u.constructor(u.source, Yy.exec(u));
        return c.lastIndex = u.lastIndex, c;
      }
      function _E(u) {
        return pu ? yt(pu.call(u)) : {};
      }
      function qb(u, c) {
        var g = c ? Lg(u.buffer) : u.buffer;
        return new u.constructor(g, u.byteOffset, u.length);
      }
      function ew(u, c) {
        if (u !== c) {
          var g = u !== t, b = u === null, C = u === u, j = li(u), E = c !== t, O = c === null, F = c === c, G = li(c);
          if (!O && !G && !j && u > c || j && E && F && !O && !G || b && E && F || !g && F || !C)
            return 1;
          if (!b && !j && !G && u < c || G && g && C && !b && !j || O && g && C || !E && C || !F)
            return -1;
        }
        return 0;
      }
      function jE(u, c, g) {
        for (var b = -1, C = u.criteria, j = c.criteria, E = C.length, O = g.length; ++b < E; ) {
          var F = ew(C[b], j[b]);
          if (F) {
            if (b >= O)
              return F;
            var G = g[b];
            return F * (G == "desc" ? -1 : 1);
          }
        }
        return u.index - c.index;
      }
      function tw(u, c, g, b) {
        for (var C = -1, j = u.length, E = g.length, O = -1, F = c.length, G = $t(j - E, 0), W = J(F + G), K = !b; ++O < F; )
          W[O] = c[O];
        for (; ++C < E; )
          (K || C < j) && (W[g[C]] = u[C]);
        for (; G--; )
          W[O++] = u[C++];
        return W;
      }
      function nw(u, c, g, b) {
        for (var C = -1, j = u.length, E = -1, O = g.length, F = -1, G = c.length, W = $t(j - O, 0), K = J(W + G), oe = !b; ++C < W; )
          K[C] = u[C];
        for (var ye = C; ++F < G; )
          K[ye + F] = c[F];
        for (; ++E < O; )
          (oe || C < j) && (K[ye + g[E]] = u[C++]);
        return K;
      }
      function Xn(u, c) {
        var g = -1, b = u.length;
        for (c || (c = J(b)); ++g < b; )
          c[g] = u[g];
        return c;
      }
      function ua(u, c, g, b) {
        var C = !g;
        g || (g = {});
        for (var j = -1, E = c.length; ++j < E; ) {
          var O = c[j], F = b ? b(g[O], u[O], O, g, u) : t;
          F === t && (F = u[O]), C ? Na(g, O, F) : mu(g, O, F);
        }
        return g;
      }
      function TE(u, c) {
        return ua(u, Ag(u), c);
      }
      function LE(u, c) {
        return ua(u, pw(u), c);
      }
      function bc(u, c) {
        return function(g, b) {
          var C = Ne(g) ? NL : zx, j = c ? c() : {};
          return C(g, u, Se(b, 2), j);
        };
      }
      function is(u) {
        return Fe(function(c, g) {
          var b = -1, C = g.length, j = C > 1 ? g[C - 1] : t, E = C > 2 ? g[2] : t;
          for (j = u.length > 3 && typeof j == "function" ? (C--, j) : t, E && Mn(g[0], g[1], E) && (j = C < 3 ? t : j, C = 1), c = yt(c); ++b < C; ) {
            var O = g[b];
            O && u(c, O, b, j);
          }
          return c;
        });
      }
      function iw(u, c) {
        return function(g, b) {
          if (g == null)
            return g;
          if (!Gn(g))
            return u(g, b);
          for (var C = g.length, j = c ? C : -1, E = yt(g); (c ? j-- : ++j < C) && b(E[j], j, E) !== !1; )
            ;
          return g;
        };
      }
      function aw(u) {
        return function(c, g, b) {
          for (var C = -1, j = yt(c), E = b(c), O = E.length; O--; ) {
            var F = E[u ? O : ++C];
            if (g(j[F], F, j) === !1)
              break;
          }
          return c;
        };
      }
      function xE(u, c, g) {
        var b = c & v, C = Cu(u);
        function j() {
          var E = this && this !== fn && this instanceof j ? C : u;
          return E.apply(b ? g : this, arguments);
        }
        return j;
      }
      function ow(u) {
        return function(c) {
          c = lt(c);
          var g = $r(c) ? Gi(c) : t, b = g ? g[0] : c.charAt(0), C = g ? bo(g, 1).join("") : c.slice(1);
          return b[u]() + C;
        };
      }
      function as(u) {
        return function(c) {
          return Ud(iv(nv(c).replace(bL, "")), u, "");
        };
      }
      function Cu(u) {
        return function() {
          var c = arguments;
          switch (c.length) {
            case 0:
              return new u();
            case 1:
              return new u(c[0]);
            case 2:
              return new u(c[0], c[1]);
            case 3:
              return new u(c[0], c[1], c[2]);
            case 4:
              return new u(c[0], c[1], c[2], c[3]);
            case 5:
              return new u(c[0], c[1], c[2], c[3], c[4]);
            case 6:
              return new u(c[0], c[1], c[2], c[3], c[4], c[5]);
            case 7:
              return new u(c[0], c[1], c[2], c[3], c[4], c[5], c[6]);
          }
          var g = ns(u.prototype), b = u.apply(g, c);
          return Nt(b) ? b : g;
        };
      }
      function EE(u, c, g) {
        var b = Cu(u);
        function C() {
          for (var j = arguments.length, E = J(j), O = j, F = rs(C); O--; )
            E[O] = arguments[O];
          var G = j < 3 && E[0] !== F && E[j - 1] !== F ? [] : go(E, F);
          if (j -= G.length, j < g)
            return cw(
              u,
              c,
              wc,
              C.placeholder,
              t,
              E,
              G,
              t,
              t,
              g - j
            );
          var W = this && this !== fn && this instanceof C ? b : u;
          return ri(W, this, E);
        }
        return C;
      }
      function rw(u) {
        return function(c, g, b) {
          var C = yt(c);
          if (!Gn(c)) {
            var j = Se(g, 3);
            c = tn(c), g = function(O) {
              return j(C[O], O, C);
            };
          }
          var E = u(c, g, b);
          return E > -1 ? C[j ? c[E] : E] : t;
        };
      }
      function sw(u) {
        return Aa(function(c) {
          var g = c.length, b = g, C = Li.prototype.thru;
          for (u && c.reverse(); b--; ) {
            var j = c[b];
            if (typeof j != "function")
              throw new Ti(r);
            if (C && !E && kc(j) == "wrapper")
              var E = new Li([], !0);
          }
          for (b = E ? b : g; ++b < g; ) {
            j = c[b];
            var O = kc(j), F = O == "wrapper" ? Ng(j) : t;
            F && Pg(F[0]) && F[1] == (M | T | A | P) && !F[4].length && F[9] == 1 ? E = E[kc(F[0])].apply(E, F[3]) : E = j.length == 1 && Pg(j) ? E[O]() : E.thru(j);
          }
          return function() {
            var G = arguments, W = G[0];
            if (E && G.length == 1 && Ne(W))
              return E.plant(W).value();
            for (var K = 0, oe = g ? c[K].apply(this, G) : W; ++K < g; )
              oe = c[K].call(this, oe);
            return oe;
          };
        });
      }
      function wc(u, c, g, b, C, j, E, O, F, G) {
        var W = c & M, K = c & v, oe = c & _, ye = c & (T | S), ke = c & Y, Re = oe ? t : Cu(u);
        function _e() {
          for (var He = arguments.length, Ve = J(He), ci = He; ci--; )
            Ve[ci] = arguments[ci];
          if (ye)
            var Nn = rs(_e), hi = ZL(Ve, Nn);
          if (b && (Ve = tw(Ve, b, C, ye)), j && (Ve = nw(Ve, j, E, ye)), He -= hi, ye && He < G) {
            var Bt = go(Ve, Nn);
            return cw(
              u,
              c,
              wc,
              _e.placeholder,
              g,
              Ve,
              Bt,
              O,
              F,
              G - He
            );
          }
          var Ki = K ? g : this, Fa = oe ? Ki[u] : u;
          return He = Ve.length, O ? Ve = zE(Ve, O) : ke && He > 1 && Ve.reverse(), W && F < He && (Ve.length = F), this && this !== fn && this instanceof _e && (Fa = Re || Cu(Fa)), Fa.apply(Ki, Ve);
        }
        return _e;
      }
      function uw(u, c) {
        return function(g, b) {
          return iE(g, u, c(b), {});
        };
      }
      function vc(u, c) {
        return function(g, b) {
          var C;
          if (g === t && b === t)
            return c;
          if (g !== t && (C = g), b !== t) {
            if (C === t)
              return b;
            typeof g == "string" || typeof b == "string" ? (g = ui(g), b = ui(b)) : (g = Qb(g), b = Qb(b)), C = u(g, b);
          }
          return C;
        };
      }
      function xg(u) {
        return Aa(function(c) {
          return c = Et(c, si(Se())), Fe(function(g) {
            var b = this;
            return u(c, function(C) {
              return ri(C, b, g);
            });
          });
        });
      }
      function Cc(u, c) {
        c = c === t ? " " : ui(c);
        var g = c.length;
        if (g < 2)
          return g ? Cg(c, u) : c;
        var b = Cg(c, sc(u / Vr(c)));
        return $r(c) ? bo(Gi(b), 0, u).join("") : b.slice(0, u);
      }
      function DE(u, c, g, b) {
        var C = c & v, j = Cu(u);
        function E() {
          for (var O = -1, F = arguments.length, G = -1, W = b.length, K = J(W + F), oe = this && this !== fn && this instanceof E ? j : u; ++G < W; )
            K[G] = b[G];
          for (; F--; )
            K[G++] = arguments[++O];
          return ri(oe, C ? g : this, K);
        }
        return E;
      }
      function lw(u) {
        return function(c, g, b) {
          return b && typeof b != "number" && Mn(c, g, b) && (g = b = t), c = Ra(c), g === t ? (g = c, c = 0) : g = Ra(g), b = b === t ? c < g ? 1 : -1 : Ra(b), pE(c, g, b, u);
        };
      }
      function Sc(u) {
        return function(c, g) {
          return typeof c == "string" && typeof g == "string" || (c = Mi(c), g = Mi(g)), u(c, g);
        };
      }
      function cw(u, c, g, b, C, j, E, O, F, G) {
        var W = c & T, K = W ? E : t, oe = W ? t : E, ye = W ? j : t, ke = W ? t : j;
        c |= W ? A : x, c &= ~(W ? x : A), c & L || (c &= ~(v | _));
        var Re = [
          u,
          c,
          C,
          ye,
          K,
          ke,
          oe,
          O,
          F,
          G
        ], _e = g.apply(t, Re);
        return Pg(u) && Sw(_e, Re), _e.placeholder = b, kw(_e, u, c);
      }
      function Eg(u) {
        var c = zt[u];
        return function(g, b) {
          if (g = Mi(g), b = b == null ? 0 : Cn(Ye(b), 292), b && kb(g)) {
            var C = (lt(g) + "e").split("e"), j = c(C[0] + "e" + (+C[1] + b));
            return C = (lt(j) + "e").split("e"), +(C[0] + "e" + (+C[1] - b));
          }
          return c(g);
        };
      }
      var ME = es && 1 / Vl(new es([, -0]))[1] == Ge ? function(u) {
        return new es(u);
      } : Vg;
      function hw(u) {
        return function(c) {
          var g = Sn(c);
          return g == $ ? og(c) : g == N ? KL(c) : JL(c, u(c));
        };
      }
      function Oa(u, c, g, b, C, j, E, O) {
        var F = c & _;
        if (!F && typeof u != "function")
          throw new Ti(r);
        var G = b ? b.length : 0;
        if (G || (c &= ~(A | x), b = C = t), E = E === t ? E : $t(Ye(E), 0), O = O === t ? O : Ye(O), G -= C ? C.length : 0, c & x) {
          var W = b, K = C;
          b = C = t;
        }
        var oe = F ? t : Ng(u), ye = [
          u,
          c,
          g,
          b,
          C,
          W,
          K,
          j,
          E,
          O
        ];
        if (oe && WE(ye, oe), u = ye[0], c = ye[1], g = ye[2], b = ye[3], C = ye[4], O = ye[9] = ye[9] === t ? F ? 0 : u.length : $t(ye[9] - G, 0), !O && c & (T | S) && (c &= ~(T | S)), !c || c == v)
          var ke = xE(u, c, g);
        else c == T || c == S ? ke = EE(u, c, O) : (c == A || c == (v | A)) && !C.length ? ke = DE(u, c, g, b) : ke = wc.apply(t, ye);
        var Re = oe ? Gb : Sw;
        return kw(Re(ke, ye), u, c);
      }
      function dw(u, c, g, b) {
        return u === t || Qi(u, qr[g]) && !dt.call(b, g) ? c : u;
      }
      function gw(u, c, g, b, C, j) {
        return Nt(u) && Nt(c) && (j.set(c, u), pc(u, c, t, gw, j), j.delete(c)), u;
      }
      function NE(u) {
        return _u(u) ? t : u;
      }
      function fw(u, c, g, b, C, j) {
        var E = g & m, O = u.length, F = c.length;
        if (O != F && !(E && F > O))
          return !1;
        var G = j.get(u), W = j.get(c);
        if (G && W)
          return G == c && W == u;
        var K = -1, oe = !0, ye = g & w ? new ir() : t;
        for (j.set(u, c), j.set(c, u); ++K < O; ) {
          var ke = u[K], Re = c[K];
          if (b)
            var _e = E ? b(Re, ke, K, c, u, j) : b(ke, Re, K, u, c, j);
          if (_e !== t) {
            if (_e)
              continue;
            oe = !1;
            break;
          }
          if (ye) {
            if (!qd(c, function(He, Ve) {
              if (!cu(ye, Ve) && (ke === He || C(ke, He, g, b, j)))
                return ye.push(Ve);
            })) {
              oe = !1;
              break;
            }
          } else if (!(ke === Re || C(ke, Re, g, b, j))) {
            oe = !1;
            break;
          }
        }
        return j.delete(u), j.delete(c), oe;
      }
      function OE(u, c, g, b, C, j, E) {
        switch (g) {
          case z:
            if (u.byteLength != c.byteLength || u.byteOffset != c.byteOffset)
              return !1;
            u = u.buffer, c = c.buffer;
          case Z:
            return !(u.byteLength != c.byteLength || !j(new ic(u), new ic(c)));
          case Xt:
          case en:
          case Oe:
            return Qi(+u, +c);
          case dn:
            return u.name == c.name && u.message == c.message;
          case D:
          case X:
            return u == c + "";
          case $:
            var O = og;
          case N:
            var F = b & m;
            if (O || (O = Vl), u.size != c.size && !F)
              return !1;
            var G = E.get(u);
            if (G)
              return G == c;
            b |= w, E.set(u, c);
            var W = fw(O(u), O(c), b, C, j, E);
            return E.delete(u), W;
          case le:
            if (pu)
              return pu.call(u) == pu.call(c);
        }
        return !1;
      }
      function AE(u, c, g, b, C, j) {
        var E = g & m, O = Dg(u), F = O.length, G = Dg(c), W = G.length;
        if (F != W && !E)
          return !1;
        for (var K = F; K--; ) {
          var oe = O[K];
          if (!(E ? oe in c : dt.call(c, oe)))
            return !1;
        }
        var ye = j.get(u), ke = j.get(c);
        if (ye && ke)
          return ye == c && ke == u;
        var Re = !0;
        j.set(u, c), j.set(c, u);
        for (var _e = E; ++K < F; ) {
          oe = O[K];
          var He = u[oe], Ve = c[oe];
          if (b)
            var ci = E ? b(Ve, He, oe, c, u, j) : b(He, Ve, oe, u, c, j);
          if (!(ci === t ? He === Ve || C(He, Ve, g, b, j) : ci)) {
            Re = !1;
            break;
          }
          _e || (_e = oe == "constructor");
        }
        if (Re && !_e) {
          var Nn = u.constructor, hi = c.constructor;
          Nn != hi && "constructor" in u && "constructor" in c && !(typeof Nn == "function" && Nn instanceof Nn && typeof hi == "function" && hi instanceof hi) && (Re = !1);
        }
        return j.delete(u), j.delete(c), Re;
      }
      function Aa(u) {
        return Fg(vw(u, t, Ew), u + "");
      }
      function Dg(u) {
        return Ab(u, tn, Ag);
      }
      function Mg(u) {
        return Ab(u, Wn, pw);
      }
      var Ng = lc ? function(u) {
        return lc.get(u);
      } : Vg;
      function kc(u) {
        for (var c = u.name + "", g = ts[c], b = dt.call(ts, c) ? g.length : 0; b--; ) {
          var C = g[b], j = C.func;
          if (j == null || j == u)
            return C.name;
        }
        return c;
      }
      function rs(u) {
        var c = dt.call(k, "placeholder") ? k : u;
        return c.placeholder;
      }
      function Se() {
        var u = k.iteratee || zg;
        return u = u === zg ? Rb : u, arguments.length ? u(arguments[0], arguments[1]) : u;
      }
      function _c(u, c) {
        var g = u.__data__;
        return BE(c) ? g[typeof c == "string" ? "string" : "hash"] : g.map;
      }
      function Og(u) {
        for (var c = tn(u), g = c.length; g--; ) {
          var b = c[g], C = u[b];
          c[g] = [b, C, bw(C)];
        }
        return c;
      }
      function rr(u, c) {
        var g = GL(u, c);
        return Pb(g) ? g : t;
      }
      function YE(u) {
        var c = dt.call(u, tr), g = u[tr];
        try {
          u[tr] = t;
          var b = !0;
        } catch {
        }
        var C = tc.call(u);
        return b && (c ? u[tr] = g : delete u[tr]), C;
      }
      var Ag = sg ? function(u) {
        return u == null ? [] : (u = yt(u), co(sg(u), function(c) {
          return Cb.call(u, c);
        }));
      } : Ug, pw = sg ? function(u) {
        for (var c = []; u; )
          ho(c, Ag(u)), u = ac(u);
        return c;
      } : Ug, Sn = Dn;
      (ug && Sn(new ug(new ArrayBuffer(1))) != z || du && Sn(new du()) != $ || lg && Sn(lg.resolve()) != oi || es && Sn(new es()) != N || gu && Sn(new gu()) != Je) && (Sn = function(u) {
        var c = Dn(u), g = c == Mt ? u.constructor : t, b = g ? sr(g) : "";
        if (b)
          switch (b) {
            case yx:
              return z;
            case bx:
              return $;
            case wx:
              return oi;
            case vx:
              return N;
            case Cx:
              return Je;
          }
        return c;
      });
      function PE(u, c, g) {
        for (var b = -1, C = g.length; ++b < C; ) {
          var j = g[b], E = j.size;
          switch (j.type) {
            case "drop":
              u += E;
              break;
            case "dropRight":
              c -= E;
              break;
            case "take":
              c = Cn(c, u + E);
              break;
            case "takeRight":
              u = $t(u, c - E);
              break;
          }
        }
        return { start: u, end: c };
      }
      function RE(u) {
        var c = u.match(HT);
        return c ? c[1].split(XT) : [];
      }
      function mw(u, c, g) {
        c = yo(c, u);
        for (var b = -1, C = c.length, j = !1; ++b < C; ) {
          var E = la(c[b]);
          if (!(j = u != null && g(u, E)))
            break;
          u = u[E];
        }
        return j || ++b != C ? j : (C = u == null ? 0 : u.length, !!C && Mc(C) && Ya(E, C) && (Ne(u) || ur(u)));
      }
      function FE(u) {
        var c = u.length, g = new u.constructor(c);
        return c && typeof u[0] == "string" && dt.call(u, "index") && (g.index = u.index, g.input = u.input), g;
      }
      function yw(u) {
        return typeof u.constructor == "function" && !Su(u) ? ns(ac(u)) : {};
      }
      function IE(u, c, g) {
        var b = u.constructor;
        switch (c) {
          case Z:
            return Lg(u);
          case Xt:
          case en:
            return new b(+u);
          case z:
            return SE(u, g);
          case Be:
          case mt:
          case Bn:
          case ra:
          case ki:
          case B:
          case he:
          case ve:
          case et:
            return qb(u, g);
          case $:
            return new b();
          case Oe:
          case X:
            return new b(u);
          case D:
            return kE(u);
          case N:
            return new b();
          case le:
            return _E(u);
        }
      }
      function JE(u, c) {
        var g = c.length;
        if (!g)
          return u;
        var b = g - 1;
        return c[b] = (g > 1 ? "& " : "") + c[b], c = c.join(g > 2 ? ", " : " "), u.replace(BT, `{
/* [wrapped with ` + c + `] */
`);
      }
      function ZE(u) {
        return Ne(u) || ur(u) || !!(Sb && u && u[Sb]);
      }
      function Ya(u, c) {
        var g = typeof u;
        return c = c ?? Ae, !!c && (g == "number" || g != "symbol" && qT.test(u)) && u > -1 && u % 1 == 0 && u < c;
      }
      function Mn(u, c, g) {
        if (!Nt(g))
          return !1;
        var b = typeof c;
        return (b == "number" ? Gn(g) && Ya(c, g.length) : b == "string" && c in g) ? Qi(g[c], u) : !1;
      }
      function Yg(u, c) {
        if (Ne(u))
          return !1;
        var g = typeof u;
        return g == "number" || g == "symbol" || g == "boolean" || u == null || li(u) ? !0 : Qr.test(u) || !lu.test(u) || c != null && u in yt(c);
      }
      function BE(u) {
        var c = typeof u;
        return c == "string" || c == "number" || c == "symbol" || c == "boolean" ? u !== "__proto__" : u === null;
      }
      function Pg(u) {
        var c = kc(u), g = k[c];
        if (typeof g != "function" || !(c in Qe.prototype))
          return !1;
        if (u === g)
          return !0;
        var b = Ng(g);
        return !!b && u === b[0];
      }
      function HE(u) {
        return !!bb && bb in u;
      }
      var XE = ql ? Pa : qg;
      function Su(u) {
        var c = u && u.constructor, g = typeof c == "function" && c.prototype || qr;
        return u === g;
      }
      function bw(u) {
        return u === u && !Nt(u);
      }
      function ww(u, c) {
        return function(g) {
          return g == null ? !1 : g[u] === c && (c !== t || u in yt(g));
        };
      }
      function GE(u) {
        var c = Ec(u, function(b) {
          return g.size === h && g.clear(), b;
        }), g = c.cache;
        return c;
      }
      function WE(u, c) {
        var g = u[1], b = c[1], C = g | b, j = C < (v | _ | M), E = b == M && g == T || b == M && g == P && u[7].length <= c[8] || b == (M | P) && c[7].length <= c[8] && g == T;
        if (!(j || E))
          return u;
        b & v && (u[2] = c[2], C |= g & v ? 0 : L);
        var O = c[3];
        if (O) {
          var F = u[3];
          u[3] = F ? tw(F, O, c[4]) : O, u[4] = F ? go(u[3], d) : c[4];
        }
        return O = c[5], O && (F = u[5], u[5] = F ? nw(F, O, c[6]) : O, u[6] = F ? go(u[5], d) : c[6]), O = c[7], O && (u[7] = O), b & M && (u[8] = u[8] == null ? c[8] : Cn(u[8], c[8])), u[9] == null && (u[9] = c[9]), u[0] = c[0], u[1] = C, u;
      }
      function QE(u) {
        var c = [];
        if (u != null)
          for (var g in yt(u))
            c.push(g);
        return c;
      }
      function KE(u) {
        return tc.call(u);
      }
      function vw(u, c, g) {
        return c = $t(c === t ? u.length - 1 : c, 0), function() {
          for (var b = arguments, C = -1, j = $t(b.length - c, 0), E = J(j); ++C < j; )
            E[C] = b[c + C];
          C = -1;
          for (var O = J(c + 1); ++C < c; )
            O[C] = b[C];
          return O[c] = g(E), ri(u, this, O);
        };
      }
      function Cw(u, c) {
        return c.length < 2 ? u : or(u, Ei(c, 0, -1));
      }
      function zE(u, c) {
        for (var g = u.length, b = Cn(c.length, g), C = Xn(u); b--; ) {
          var j = c[b];
          u[b] = Ya(j, g) ? C[j] : t;
        }
        return u;
      }
      function Rg(u, c) {
        if (!(c === "constructor" && typeof u[c] == "function") && c != "__proto__")
          return u[c];
      }
      var Sw = _w(Gb), ku = cx || function(u, c) {
        return fn.setTimeout(u, c);
      }, Fg = _w(bE);
      function kw(u, c, g) {
        var b = c + "";
        return Fg(u, JE(b, $E(RE(b), g)));
      }
      function _w(u) {
        var c = 0, g = 0;
        return function() {
          var b = fx(), C = me - (b - g);
          if (g = b, C > 0) {
            if (++c >= re)
              return arguments[0];
          } else
            c = 0;
          return u.apply(t, arguments);
        };
      }
      function jc(u, c) {
        var g = -1, b = u.length, C = b - 1;
        for (c = c === t ? b : c; ++g < c; ) {
          var j = vg(g, C), E = u[j];
          u[j] = u[g], u[g] = E;
        }
        return u.length = c, u;
      }
      var jw = GE(function(u) {
        var c = [];
        return u.charCodeAt(0) === 46 && c.push(""), u.replace(IT, function(g, b, C, j) {
          c.push(C ? j.replace(QT, "$1") : b || g);
        }), c;
      });
      function la(u) {
        if (typeof u == "string" || li(u))
          return u;
        var c = u + "";
        return c == "0" && 1 / u == -Ge ? "-0" : c;
      }
      function sr(u) {
        if (u != null) {
          try {
            return ec.call(u);
          } catch {
          }
          try {
            return u + "";
          } catch {
          }
        }
        return "";
      }
      function $E(u, c) {
        return ji(Jt, function(g) {
          var b = "_." + g[0];
          c & g[1] && !zl(u, b) && u.push(b);
        }), u.sort();
      }
      function Tw(u) {
        if (u instanceof Qe)
          return u.clone();
        var c = new Li(u.__wrapped__, u.__chain__);
        return c.__actions__ = Xn(u.__actions__), c.__index__ = u.__index__, c.__values__ = u.__values__, c;
      }
      function VE(u, c, g) {
        (g ? Mn(u, c, g) : c === t) ? c = 1 : c = $t(Ye(c), 0);
        var b = u == null ? 0 : u.length;
        if (!b || c < 1)
          return [];
        for (var C = 0, j = 0, E = J(sc(b / c)); C < b; )
          E[j++] = Ei(u, C, C += c);
        return E;
      }
      function UE(u) {
        for (var c = -1, g = u == null ? 0 : u.length, b = 0, C = []; ++c < g; ) {
          var j = u[c];
          j && (C[b++] = j);
        }
        return C;
      }
      function qE() {
        var u = arguments.length;
        if (!u)
          return [];
        for (var c = J(u - 1), g = arguments[0], b = u; b--; )
          c[b - 1] = arguments[b];
        return ho(Ne(g) ? Xn(g) : [g], pn(c, 1));
      }
      var eD = Fe(function(u, c) {
        return Zt(u) ? yu(u, pn(c, 1, Zt, !0)) : [];
      }), tD = Fe(function(u, c) {
        var g = Di(c);
        return Zt(g) && (g = t), Zt(u) ? yu(u, pn(c, 1, Zt, !0), Se(g, 2)) : [];
      }), nD = Fe(function(u, c) {
        var g = Di(c);
        return Zt(g) && (g = t), Zt(u) ? yu(u, pn(c, 1, Zt, !0), t, g) : [];
      });
      function iD(u, c, g) {
        var b = u == null ? 0 : u.length;
        return b ? (c = g || c === t ? 1 : Ye(c), Ei(u, c < 0 ? 0 : c, b)) : [];
      }
      function aD(u, c, g) {
        var b = u == null ? 0 : u.length;
        return b ? (c = g || c === t ? 1 : Ye(c), c = b - c, Ei(u, 0, c < 0 ? 0 : c)) : [];
      }
      function oD(u, c) {
        return u && u.length ? yc(u, Se(c, 3), !0, !0) : [];
      }
      function rD(u, c) {
        return u && u.length ? yc(u, Se(c, 3), !0) : [];
      }
      function sD(u, c, g, b) {
        var C = u == null ? 0 : u.length;
        return C ? (g && typeof g != "number" && Mn(u, c, g) && (g = 0, b = C), qx(u, c, g, b)) : [];
      }
      function Lw(u, c, g) {
        var b = u == null ? 0 : u.length;
        if (!b)
          return -1;
        var C = g == null ? 0 : Ye(g);
        return C < 0 && (C = $t(b + C, 0)), $l(u, Se(c, 3), C);
      }
      function xw(u, c, g) {
        var b = u == null ? 0 : u.length;
        if (!b)
          return -1;
        var C = b - 1;
        return g !== t && (C = Ye(g), C = g < 0 ? $t(b + C, 0) : Cn(C, b - 1)), $l(u, Se(c, 3), C, !0);
      }
      function Ew(u) {
        var c = u == null ? 0 : u.length;
        return c ? pn(u, 1) : [];
      }
      function uD(u) {
        var c = u == null ? 0 : u.length;
        return c ? pn(u, Ge) : [];
      }
      function lD(u, c) {
        var g = u == null ? 0 : u.length;
        return g ? (c = c === t ? 1 : Ye(c), pn(u, c)) : [];
      }
      function cD(u) {
        for (var c = -1, g = u == null ? 0 : u.length, b = {}; ++c < g; ) {
          var C = u[c];
          b[C[0]] = C[1];
        }
        return b;
      }
      function Dw(u) {
        return u && u.length ? u[0] : t;
      }
      function hD(u, c, g) {
        var b = u == null ? 0 : u.length;
        if (!b)
          return -1;
        var C = g == null ? 0 : Ye(g);
        return C < 0 && (C = $t(b + C, 0)), zr(u, c, C);
      }
      function dD(u) {
        var c = u == null ? 0 : u.length;
        return c ? Ei(u, 0, -1) : [];
      }
      var gD = Fe(function(u) {
        var c = Et(u, jg);
        return c.length && c[0] === u[0] ? pg(c) : [];
      }), fD = Fe(function(u) {
        var c = Di(u), g = Et(u, jg);
        return c === Di(g) ? c = t : g.pop(), g.length && g[0] === u[0] ? pg(g, Se(c, 2)) : [];
      }), pD = Fe(function(u) {
        var c = Di(u), g = Et(u, jg);
        return c = typeof c == "function" ? c : t, c && g.pop(), g.length && g[0] === u[0] ? pg(g, t, c) : [];
      });
      function mD(u, c) {
        return u == null ? "" : dx.call(u, c);
      }
      function Di(u) {
        var c = u == null ? 0 : u.length;
        return c ? u[c - 1] : t;
      }
      function yD(u, c, g) {
        var b = u == null ? 0 : u.length;
        if (!b)
          return -1;
        var C = b;
        return g !== t && (C = Ye(g), C = C < 0 ? $t(b + C, 0) : Cn(C, b - 1)), c === c ? $L(u, c, C) : $l(u, cb, C, !0);
      }
      function bD(u, c) {
        return u && u.length ? Zb(u, Ye(c)) : t;
      }
      var wD = Fe(Mw);
      function Mw(u, c) {
        return u && u.length && c && c.length ? wg(u, c) : u;
      }
      function vD(u, c, g) {
        return u && u.length && c && c.length ? wg(u, c, Se(g, 2)) : u;
      }
      function CD(u, c, g) {
        return u && u.length && c && c.length ? wg(u, c, t, g) : u;
      }
      var SD = Aa(function(u, c) {
        var g = u == null ? 0 : u.length, b = hg(u, c);
        return Xb(u, Et(c, function(C) {
          return Ya(C, g) ? +C : C;
        }).sort(ew)), b;
      });
      function kD(u, c) {
        var g = [];
        if (!(u && u.length))
          return g;
        var b = -1, C = [], j = u.length;
        for (c = Se(c, 3); ++b < j; ) {
          var E = u[b];
          c(E, b, u) && (g.push(E), C.push(b));
        }
        return Xb(u, C), g;
      }
      function Ig(u) {
        return u == null ? u : mx.call(u);
      }
      function _D(u, c, g) {
        var b = u == null ? 0 : u.length;
        return b ? (g && typeof g != "number" && Mn(u, c, g) ? (c = 0, g = b) : (c = c == null ? 0 : Ye(c), g = g === t ? b : Ye(g)), Ei(u, c, g)) : [];
      }
      function jD(u, c) {
        return mc(u, c);
      }
      function TD(u, c, g) {
        return Sg(u, c, Se(g, 2));
      }
      function LD(u, c) {
        var g = u == null ? 0 : u.length;
        if (g) {
          var b = mc(u, c);
          if (b < g && Qi(u[b], c))
            return b;
        }
        return -1;
      }
      function xD(u, c) {
        return mc(u, c, !0);
      }
      function ED(u, c, g) {
        return Sg(u, c, Se(g, 2), !0);
      }
      function DD(u, c) {
        var g = u == null ? 0 : u.length;
        if (g) {
          var b = mc(u, c, !0) - 1;
          if (Qi(u[b], c))
            return b;
        }
        return -1;
      }
      function MD(u) {
        return u && u.length ? Wb(u) : [];
      }
      function ND(u, c) {
        return u && u.length ? Wb(u, Se(c, 2)) : [];
      }
      function OD(u) {
        var c = u == null ? 0 : u.length;
        return c ? Ei(u, 1, c) : [];
      }
      function AD(u, c, g) {
        return u && u.length ? (c = g || c === t ? 1 : Ye(c), Ei(u, 0, c < 0 ? 0 : c)) : [];
      }
      function YD(u, c, g) {
        var b = u == null ? 0 : u.length;
        return b ? (c = g || c === t ? 1 : Ye(c), c = b - c, Ei(u, c < 0 ? 0 : c, b)) : [];
      }
      function PD(u, c) {
        return u && u.length ? yc(u, Se(c, 3), !1, !0) : [];
      }
      function RD(u, c) {
        return u && u.length ? yc(u, Se(c, 3)) : [];
      }
      var FD = Fe(function(u) {
        return mo(pn(u, 1, Zt, !0));
      }), ID = Fe(function(u) {
        var c = Di(u);
        return Zt(c) && (c = t), mo(pn(u, 1, Zt, !0), Se(c, 2));
      }), JD = Fe(function(u) {
        var c = Di(u);
        return c = typeof c == "function" ? c : t, mo(pn(u, 1, Zt, !0), t, c);
      });
      function ZD(u) {
        return u && u.length ? mo(u) : [];
      }
      function BD(u, c) {
        return u && u.length ? mo(u, Se(c, 2)) : [];
      }
      function HD(u, c) {
        return c = typeof c == "function" ? c : t, u && u.length ? mo(u, t, c) : [];
      }
      function Jg(u) {
        if (!(u && u.length))
          return [];
        var c = 0;
        return u = co(u, function(g) {
          if (Zt(g))
            return c = $t(g.length, c), !0;
        }), ig(c, function(g) {
          return Et(u, eg(g));
        });
      }
      function Nw(u, c) {
        if (!(u && u.length))
          return [];
        var g = Jg(u);
        return c == null ? g : Et(g, function(b) {
          return ri(c, t, b);
        });
      }
      var XD = Fe(function(u, c) {
        return Zt(u) ? yu(u, c) : [];
      }), GD = Fe(function(u) {
        return _g(co(u, Zt));
      }), WD = Fe(function(u) {
        var c = Di(u);
        return Zt(c) && (c = t), _g(co(u, Zt), Se(c, 2));
      }), QD = Fe(function(u) {
        var c = Di(u);
        return c = typeof c == "function" ? c : t, _g(co(u, Zt), t, c);
      }), KD = Fe(Jg);
      function zD(u, c) {
        return $b(u || [], c || [], mu);
      }
      function $D(u, c) {
        return $b(u || [], c || [], vu);
      }
      var VD = Fe(function(u) {
        var c = u.length, g = c > 1 ? u[c - 1] : t;
        return g = typeof g == "function" ? (u.pop(), g) : t, Nw(u, g);
      });
      function Ow(u) {
        var c = k(u);
        return c.__chain__ = !0, c;
      }
      function UD(u, c) {
        return c(u), u;
      }
      function Tc(u, c) {
        return c(u);
      }
      var qD = Aa(function(u) {
        var c = u.length, g = c ? u[0] : 0, b = this.__wrapped__, C = function(j) {
          return hg(j, u);
        };
        return c > 1 || this.__actions__.length || !(b instanceof Qe) || !Ya(g) ? this.thru(C) : (b = b.slice(g, +g + (c ? 1 : 0)), b.__actions__.push({
          func: Tc,
          args: [C],
          thisArg: t
        }), new Li(b, this.__chain__).thru(function(j) {
          return c && !j.length && j.push(t), j;
        }));
      });
      function eM() {
        return Ow(this);
      }
      function tM() {
        return new Li(this.value(), this.__chain__);
      }
      function nM() {
        this.__values__ === t && (this.__values__ = Qw(this.value()));
        var u = this.__index__ >= this.__values__.length, c = u ? t : this.__values__[this.__index__++];
        return { done: u, value: c };
      }
      function iM() {
        return this;
      }
      function aM(u) {
        for (var c, g = this; g instanceof hc; ) {
          var b = Tw(g);
          b.__index__ = 0, b.__values__ = t, c ? C.__wrapped__ = b : c = b;
          var C = b;
          g = g.__wrapped__;
        }
        return C.__wrapped__ = u, c;
      }
      function oM() {
        var u = this.__wrapped__;
        if (u instanceof Qe) {
          var c = u;
          return this.__actions__.length && (c = new Qe(this)), c = c.reverse(), c.__actions__.push({
            func: Tc,
            args: [Ig],
            thisArg: t
          }), new Li(c, this.__chain__);
        }
        return this.thru(Ig);
      }
      function rM() {
        return zb(this.__wrapped__, this.__actions__);
      }
      var sM = bc(function(u, c, g) {
        dt.call(u, g) ? ++u[g] : Na(u, g, 1);
      });
      function uM(u, c, g) {
        var b = Ne(u) ? ub : Ux;
        return g && Mn(u, c, g) && (c = t), b(u, Se(c, 3));
      }
      function lM(u, c) {
        var g = Ne(u) ? co : Nb;
        return g(u, Se(c, 3));
      }
      var cM = rw(Lw), hM = rw(xw);
      function dM(u, c) {
        return pn(Lc(u, c), 1);
      }
      function gM(u, c) {
        return pn(Lc(u, c), Ge);
      }
      function fM(u, c, g) {
        return g = g === t ? 1 : Ye(g), pn(Lc(u, c), g);
      }
      function Aw(u, c) {
        var g = Ne(u) ? ji : po;
        return g(u, Se(c, 3));
      }
      function Yw(u, c) {
        var g = Ne(u) ? OL : Mb;
        return g(u, Se(c, 3));
      }
      var pM = bc(function(u, c, g) {
        dt.call(u, g) ? u[g].push(c) : Na(u, g, [c]);
      });
      function mM(u, c, g, b) {
        u = Gn(u) ? u : us(u), g = g && !b ? Ye(g) : 0;
        var C = u.length;
        return g < 0 && (g = $t(C + g, 0)), Nc(u) ? g <= C && u.indexOf(c, g) > -1 : !!C && zr(u, c, g) > -1;
      }
      var yM = Fe(function(u, c, g) {
        var b = -1, C = typeof c == "function", j = Gn(u) ? J(u.length) : [];
        return po(u, function(E) {
          j[++b] = C ? ri(c, E, g) : bu(E, c, g);
        }), j;
      }), bM = bc(function(u, c, g) {
        Na(u, g, c);
      });
      function Lc(u, c) {
        var g = Ne(u) ? Et : Fb;
        return g(u, Se(c, 3));
      }
      function wM(u, c, g, b) {
        return u == null ? [] : (Ne(c) || (c = c == null ? [] : [c]), g = b ? t : g, Ne(g) || (g = g == null ? [] : [g]), Bb(u, c, g));
      }
      var vM = bc(function(u, c, g) {
        u[g ? 0 : 1].push(c);
      }, function() {
        return [[], []];
      });
      function CM(u, c, g) {
        var b = Ne(u) ? Ud : db, C = arguments.length < 3;
        return b(u, Se(c, 4), g, C, po);
      }
      function SM(u, c, g) {
        var b = Ne(u) ? AL : db, C = arguments.length < 3;
        return b(u, Se(c, 4), g, C, Mb);
      }
      function kM(u, c) {
        var g = Ne(u) ? co : Nb;
        return g(u, Dc(Se(c, 3)));
      }
      function _M(u) {
        var c = Ne(u) ? Lb : mE;
        return c(u);
      }
      function jM(u, c, g) {
        (g ? Mn(u, c, g) : c === t) ? c = 1 : c = Ye(c);
        var b = Ne(u) ? Qx : yE;
        return b(u, c);
      }
      function TM(u) {
        var c = Ne(u) ? Kx : wE;
        return c(u);
      }
      function LM(u) {
        if (u == null)
          return 0;
        if (Gn(u))
          return Nc(u) ? Vr(u) : u.length;
        var c = Sn(u);
        return c == $ || c == N ? u.size : yg(u).length;
      }
      function xM(u, c, g) {
        var b = Ne(u) ? qd : vE;
        return g && Mn(u, c, g) && (c = t), b(u, Se(c, 3));
      }
      var EM = Fe(function(u, c) {
        if (u == null)
          return [];
        var g = c.length;
        return g > 1 && Mn(u, c[0], c[1]) ? c = [] : g > 2 && Mn(c[0], c[1], c[2]) && (c = [c[0]]), Bb(u, pn(c, 1), []);
      }), xc = lx || function() {
        return fn.Date.now();
      };
      function DM(u, c) {
        if (typeof c != "function")
          throw new Ti(r);
        return u = Ye(u), function() {
          if (--u < 1)
            return c.apply(this, arguments);
        };
      }
      function Pw(u, c, g) {
        return c = g ? t : c, c = u && c == null ? u.length : c, Oa(u, M, t, t, t, t, c);
      }
      function Rw(u, c) {
        var g;
        if (typeof c != "function")
          throw new Ti(r);
        return u = Ye(u), function() {
          return --u > 0 && (g = c.apply(this, arguments)), u <= 1 && (c = t), g;
        };
      }
      var Zg = Fe(function(u, c, g) {
        var b = v;
        if (g.length) {
          var C = go(g, rs(Zg));
          b |= A;
        }
        return Oa(u, b, c, g, C);
      }), Fw = Fe(function(u, c, g) {
        var b = v | _;
        if (g.length) {
          var C = go(g, rs(Fw));
          b |= A;
        }
        return Oa(c, b, u, g, C);
      });
      function Iw(u, c, g) {
        c = g ? t : c;
        var b = Oa(u, T, t, t, t, t, t, c);
        return b.placeholder = Iw.placeholder, b;
      }
      function Jw(u, c, g) {
        c = g ? t : c;
        var b = Oa(u, S, t, t, t, t, t, c);
        return b.placeholder = Jw.placeholder, b;
      }
      function Zw(u, c, g) {
        var b, C, j, E, O, F, G = 0, W = !1, K = !1, oe = !0;
        if (typeof u != "function")
          throw new Ti(r);
        c = Mi(c) || 0, Nt(g) && (W = !!g.leading, K = "maxWait" in g, j = K ? $t(Mi(g.maxWait) || 0, c) : j, oe = "trailing" in g ? !!g.trailing : oe);
        function ye(Bt) {
          var Ki = b, Fa = C;
          return b = C = t, G = Bt, E = u.apply(Fa, Ki), E;
        }
        function ke(Bt) {
          return G = Bt, O = ku(He, c), W ? ye(Bt) : E;
        }
        function Re(Bt) {
          var Ki = Bt - F, Fa = Bt - G, rv = c - Ki;
          return K ? Cn(rv, j - Fa) : rv;
        }
        function _e(Bt) {
          var Ki = Bt - F, Fa = Bt - G;
          return F === t || Ki >= c || Ki < 0 || K && Fa >= j;
        }
        function He() {
          var Bt = xc();
          if (_e(Bt))
            return Ve(Bt);
          O = ku(He, Re(Bt));
        }
        function Ve(Bt) {
          return O = t, oe && b ? ye(Bt) : (b = C = t, E);
        }
        function ci() {
          O !== t && Vb(O), G = 0, b = F = C = O = t;
        }
        function Nn() {
          return O === t ? E : Ve(xc());
        }
        function hi() {
          var Bt = xc(), Ki = _e(Bt);
          if (b = arguments, C = this, F = Bt, Ki) {
            if (O === t)
              return ke(F);
            if (K)
              return Vb(O), O = ku(He, c), ye(F);
          }
          return O === t && (O = ku(He, c)), E;
        }
        return hi.cancel = ci, hi.flush = Nn, hi;
      }
      var MM = Fe(function(u, c) {
        return Db(u, 1, c);
      }), NM = Fe(function(u, c, g) {
        return Db(u, Mi(c) || 0, g);
      });
      function OM(u) {
        return Oa(u, Y);
      }
      function Ec(u, c) {
        if (typeof u != "function" || c != null && typeof c != "function")
          throw new Ti(r);
        var g = function() {
          var b = arguments, C = c ? c.apply(this, b) : b[0], j = g.cache;
          if (j.has(C))
            return j.get(C);
          var E = u.apply(this, b);
          return g.cache = j.set(C, E) || j, E;
        };
        return g.cache = new (Ec.Cache || Ma)(), g;
      }
      Ec.Cache = Ma;
      function Dc(u) {
        if (typeof u != "function")
          throw new Ti(r);
        return function() {
          var c = arguments;
          switch (c.length) {
            case 0:
              return !u.call(this);
            case 1:
              return !u.call(this, c[0]);
            case 2:
              return !u.call(this, c[0], c[1]);
            case 3:
              return !u.call(this, c[0], c[1], c[2]);
          }
          return !u.apply(this, c);
        };
      }
      function AM(u) {
        return Rw(2, u);
      }
      var YM = CE(function(u, c) {
        c = c.length == 1 && Ne(c[0]) ? Et(c[0], si(Se())) : Et(pn(c, 1), si(Se()));
        var g = c.length;
        return Fe(function(b) {
          for (var C = -1, j = Cn(b.length, g); ++C < j; )
            b[C] = c[C].call(this, b[C]);
          return ri(u, this, b);
        });
      }), Bg = Fe(function(u, c) {
        var g = go(c, rs(Bg));
        return Oa(u, A, t, c, g);
      }), Bw = Fe(function(u, c) {
        var g = go(c, rs(Bw));
        return Oa(u, x, t, c, g);
      }), PM = Aa(function(u, c) {
        return Oa(u, P, t, t, t, c);
      });
      function RM(u, c) {
        if (typeof u != "function")
          throw new Ti(r);
        return c = c === t ? c : Ye(c), Fe(u, c);
      }
      function FM(u, c) {
        if (typeof u != "function")
          throw new Ti(r);
        return c = c == null ? 0 : $t(Ye(c), 0), Fe(function(g) {
          var b = g[c], C = bo(g, 0, c);
          return b && ho(C, b), ri(u, this, C);
        });
      }
      function IM(u, c, g) {
        var b = !0, C = !0;
        if (typeof u != "function")
          throw new Ti(r);
        return Nt(g) && (b = "leading" in g ? !!g.leading : b, C = "trailing" in g ? !!g.trailing : C), Zw(u, c, {
          leading: b,
          maxWait: c,
          trailing: C
        });
      }
      function JM(u) {
        return Pw(u, 1);
      }
      function ZM(u, c) {
        return Bg(Tg(c), u);
      }
      function BM() {
        if (!arguments.length)
          return [];
        var u = arguments[0];
        return Ne(u) ? u : [u];
      }
      function HM(u) {
        return xi(u, y);
      }
      function XM(u, c) {
        return c = typeof c == "function" ? c : t, xi(u, y, c);
      }
      function GM(u) {
        return xi(u, f | y);
      }
      function WM(u, c) {
        return c = typeof c == "function" ? c : t, xi(u, f | y, c);
      }
      function QM(u, c) {
        return c == null || Eb(u, c, tn(c));
      }
      function Qi(u, c) {
        return u === c || u !== u && c !== c;
      }
      var KM = Sc(fg), zM = Sc(function(u, c) {
        return u >= c;
      }), ur = Yb(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Yb : function(u) {
        return Pt(u) && dt.call(u, "callee") && !Cb.call(u, "callee");
      }, Ne = J.isArray, $M = nb ? si(nb) : aE;
      function Gn(u) {
        return u != null && Mc(u.length) && !Pa(u);
      }
      function Zt(u) {
        return Pt(u) && Gn(u);
      }
      function VM(u) {
        return u === !0 || u === !1 || Pt(u) && Dn(u) == Xt;
      }
      var wo = hx || qg, UM = ib ? si(ib) : oE;
      function qM(u) {
        return Pt(u) && u.nodeType === 1 && !_u(u);
      }
      function eN(u) {
        if (u == null)
          return !0;
        if (Gn(u) && (Ne(u) || typeof u == "string" || typeof u.splice == "function" || wo(u) || ss(u) || ur(u)))
          return !u.length;
        var c = Sn(u);
        if (c == $ || c == N)
          return !u.size;
        if (Su(u))
          return !yg(u).length;
        for (var g in u)
          if (dt.call(u, g))
            return !1;
        return !0;
      }
      function tN(u, c) {
        return wu(u, c);
      }
      function nN(u, c, g) {
        g = typeof g == "function" ? g : t;
        var b = g ? g(u, c) : t;
        return b === t ? wu(u, c, t, g) : !!b;
      }
      function Hg(u) {
        if (!Pt(u))
          return !1;
        var c = Dn(u);
        return c == dn || c == hn || typeof u.message == "string" && typeof u.name == "string" && !_u(u);
      }
      function iN(u) {
        return typeof u == "number" && kb(u);
      }
      function Pa(u) {
        if (!Nt(u))
          return !1;
        var c = Dn(u);
        return c == En || c == Zn || c == xn || c == oa;
      }
      function Hw(u) {
        return typeof u == "number" && u == Ye(u);
      }
      function Mc(u) {
        return typeof u == "number" && u > -1 && u % 1 == 0 && u <= Ae;
      }
      function Nt(u) {
        var c = typeof u;
        return u != null && (c == "object" || c == "function");
      }
      function Pt(u) {
        return u != null && typeof u == "object";
      }
      var Xw = ab ? si(ab) : sE;
      function aN(u, c) {
        return u === c || mg(u, c, Og(c));
      }
      function oN(u, c, g) {
        return g = typeof g == "function" ? g : t, mg(u, c, Og(c), g);
      }
      function rN(u) {
        return Gw(u) && u != +u;
      }
      function sN(u) {
        if (XE(u))
          throw new De(o);
        return Pb(u);
      }
      function uN(u) {
        return u === null;
      }
      function lN(u) {
        return u == null;
      }
      function Gw(u) {
        return typeof u == "number" || Pt(u) && Dn(u) == Oe;
      }
      function _u(u) {
        if (!Pt(u) || Dn(u) != Mt)
          return !1;
        var c = ac(u);
        if (c === null)
          return !0;
        var g = dt.call(c, "constructor") && c.constructor;
        return typeof g == "function" && g instanceof g && ec.call(g) == ox;
      }
      var Xg = ob ? si(ob) : uE;
      function cN(u) {
        return Hw(u) && u >= -Ae && u <= Ae;
      }
      var Ww = rb ? si(rb) : lE;
      function Nc(u) {
        return typeof u == "string" || !Ne(u) && Pt(u) && Dn(u) == X;
      }
      function li(u) {
        return typeof u == "symbol" || Pt(u) && Dn(u) == le;
      }
      var ss = sb ? si(sb) : cE;
      function hN(u) {
        return u === t;
      }
      function dN(u) {
        return Pt(u) && Sn(u) == Je;
      }
      function gN(u) {
        return Pt(u) && Dn(u) == We;
      }
      var fN = Sc(bg), pN = Sc(function(u, c) {
        return u <= c;
      });
      function Qw(u) {
        if (!u)
          return [];
        if (Gn(u))
          return Nc(u) ? Gi(u) : Xn(u);
        if (hu && u[hu])
          return QL(u[hu]());
        var c = Sn(u), g = c == $ ? og : c == N ? Vl : us;
        return g(u);
      }
      function Ra(u) {
        if (!u)
          return u === 0 ? u : 0;
        if (u = Mi(u), u === Ge || u === -Ge) {
          var c = u < 0 ? -1 : 1;
          return c * It;
        }
        return u === u ? u : 0;
      }
      function Ye(u) {
        var c = Ra(u), g = c % 1;
        return c === c ? g ? c - g : c : 0;
      }
      function Kw(u) {
        return u ? ar(Ye(u), 0, ft) : 0;
      }
      function Mi(u) {
        if (typeof u == "number")
          return u;
        if (li(u))
          return xt;
        if (Nt(u)) {
          var c = typeof u.valueOf == "function" ? u.valueOf() : u;
          u = Nt(c) ? c + "" : c;
        }
        if (typeof u != "string")
          return u === 0 ? u : +u;
        u = gb(u);
        var g = $T.test(u);
        return g || UT.test(u) ? DL(u.slice(2), g ? 2 : 8) : zT.test(u) ? xt : +u;
      }
      function zw(u) {
        return ua(u, Wn(u));
      }
      function mN(u) {
        return u ? ar(Ye(u), -Ae, Ae) : u === 0 ? u : 0;
      }
      function lt(u) {
        return u == null ? "" : ui(u);
      }
      var yN = is(function(u, c) {
        if (Su(c) || Gn(c)) {
          ua(c, tn(c), u);
          return;
        }
        for (var g in c)
          dt.call(c, g) && mu(u, g, c[g]);
      }), $w = is(function(u, c) {
        ua(c, Wn(c), u);
      }), Oc = is(function(u, c, g, b) {
        ua(c, Wn(c), u, b);
      }), bN = is(function(u, c, g, b) {
        ua(c, tn(c), u, b);
      }), wN = Aa(hg);
      function vN(u, c) {
        var g = ns(u);
        return c == null ? g : xb(g, c);
      }
      var CN = Fe(function(u, c) {
        u = yt(u);
        var g = -1, b = c.length, C = b > 2 ? c[2] : t;
        for (C && Mn(c[0], c[1], C) && (b = 1); ++g < b; )
          for (var j = c[g], E = Wn(j), O = -1, F = E.length; ++O < F; ) {
            var G = E[O], W = u[G];
            (W === t || Qi(W, qr[G]) && !dt.call(u, G)) && (u[G] = j[G]);
          }
        return u;
      }), SN = Fe(function(u) {
        return u.push(t, gw), ri(Vw, t, u);
      });
      function kN(u, c) {
        return lb(u, Se(c, 3), sa);
      }
      function _N(u, c) {
        return lb(u, Se(c, 3), gg);
      }
      function jN(u, c) {
        return u == null ? u : dg(u, Se(c, 3), Wn);
      }
      function TN(u, c) {
        return u == null ? u : Ob(u, Se(c, 3), Wn);
      }
      function LN(u, c) {
        return u && sa(u, Se(c, 3));
      }
      function xN(u, c) {
        return u && gg(u, Se(c, 3));
      }
      function EN(u) {
        return u == null ? [] : fc(u, tn(u));
      }
      function DN(u) {
        return u == null ? [] : fc(u, Wn(u));
      }
      function Gg(u, c, g) {
        var b = u == null ? t : or(u, c);
        return b === t ? g : b;
      }
      function MN(u, c) {
        return u != null && mw(u, c, eE);
      }
      function Wg(u, c) {
        return u != null && mw(u, c, tE);
      }
      var NN = uw(function(u, c, g) {
        c != null && typeof c.toString != "function" && (c = tc.call(c)), u[c] = g;
      }, Kg(Qn)), ON = uw(function(u, c, g) {
        c != null && typeof c.toString != "function" && (c = tc.call(c)), dt.call(u, c) ? u[c].push(g) : u[c] = [g];
      }, Se), AN = Fe(bu);
      function tn(u) {
        return Gn(u) ? Tb(u) : yg(u);
      }
      function Wn(u) {
        return Gn(u) ? Tb(u, !0) : hE(u);
      }
      function YN(u, c) {
        var g = {};
        return c = Se(c, 3), sa(u, function(b, C, j) {
          Na(g, c(b, C, j), b);
        }), g;
      }
      function PN(u, c) {
        var g = {};
        return c = Se(c, 3), sa(u, function(b, C, j) {
          Na(g, C, c(b, C, j));
        }), g;
      }
      var RN = is(function(u, c, g) {
        pc(u, c, g);
      }), Vw = is(function(u, c, g, b) {
        pc(u, c, g, b);
      }), FN = Aa(function(u, c) {
        var g = {};
        if (u == null)
          return g;
        var b = !1;
        c = Et(c, function(j) {
          return j = yo(j, u), b || (b = j.length > 1), j;
        }), ua(u, Mg(u), g), b && (g = xi(g, f | p | y, NE));
        for (var C = c.length; C--; )
          kg(g, c[C]);
        return g;
      });
      function IN(u, c) {
        return Uw(u, Dc(Se(c)));
      }
      var JN = Aa(function(u, c) {
        return u == null ? {} : gE(u, c);
      });
      function Uw(u, c) {
        if (u == null)
          return {};
        var g = Et(Mg(u), function(b) {
          return [b];
        });
        return c = Se(c), Hb(u, g, function(b, C) {
          return c(b, C[0]);
        });
      }
      function ZN(u, c, g) {
        c = yo(c, u);
        var b = -1, C = c.length;
        for (C || (C = 1, u = t); ++b < C; ) {
          var j = u == null ? t : u[la(c[b])];
          j === t && (b = C, j = g), u = Pa(j) ? j.call(u) : j;
        }
        return u;
      }
      function BN(u, c, g) {
        return u == null ? u : vu(u, c, g);
      }
      function HN(u, c, g, b) {
        return b = typeof b == "function" ? b : t, u == null ? u : vu(u, c, g, b);
      }
      var qw = hw(tn), ev = hw(Wn);
      function XN(u, c, g) {
        var b = Ne(u), C = b || wo(u) || ss(u);
        if (c = Se(c, 4), g == null) {
          var j = u && u.constructor;
          C ? g = b ? new j() : [] : Nt(u) ? g = Pa(j) ? ns(ac(u)) : {} : g = {};
        }
        return (C ? ji : sa)(u, function(E, O, F) {
          return c(g, E, O, F);
        }), g;
      }
      function GN(u, c) {
        return u == null ? !0 : kg(u, c);
      }
      function WN(u, c, g) {
        return u == null ? u : Kb(u, c, Tg(g));
      }
      function QN(u, c, g, b) {
        return b = typeof b == "function" ? b : t, u == null ? u : Kb(u, c, Tg(g), b);
      }
      function us(u) {
        return u == null ? [] : ag(u, tn(u));
      }
      function KN(u) {
        return u == null ? [] : ag(u, Wn(u));
      }
      function zN(u, c, g) {
        return g === t && (g = c, c = t), g !== t && (g = Mi(g), g = g === g ? g : 0), c !== t && (c = Mi(c), c = c === c ? c : 0), ar(Mi(u), c, g);
      }
      function $N(u, c, g) {
        return c = Ra(c), g === t ? (g = c, c = 0) : g = Ra(g), u = Mi(u), nE(u, c, g);
      }
      function VN(u, c, g) {
        if (g && typeof g != "boolean" && Mn(u, c, g) && (c = g = t), g === t && (typeof c == "boolean" ? (g = c, c = t) : typeof u == "boolean" && (g = u, u = t)), u === t && c === t ? (u = 0, c = 1) : (u = Ra(u), c === t ? (c = u, u = 0) : c = Ra(c)), u > c) {
          var b = u;
          u = c, c = b;
        }
        if (g || u % 1 || c % 1) {
          var C = _b();
          return Cn(u + C * (c - u + EL("1e-" + ((C + "").length - 1))), c);
        }
        return vg(u, c);
      }
      var UN = as(function(u, c, g) {
        return c = c.toLowerCase(), u + (g ? tv(c) : c);
      });
      function tv(u) {
        return Qg(lt(u).toLowerCase());
      }
      function nv(u) {
        return u = lt(u), u && u.replace(eL, BL).replace(wL, "");
      }
      function qN(u, c, g) {
        u = lt(u), c = ui(c);
        var b = u.length;
        g = g === t ? b : ar(Ye(g), 0, b);
        var C = g;
        return g -= c.length, g >= 0 && u.slice(g, C) == c;
      }
      function eO(u) {
        return u = lt(u), u && uu.test(u) ? u.replace(su, HL) : u;
      }
      function tO(u) {
        return u = lt(u), u && JT.test(u) ? u.replace(Bd, "\\$&") : u;
      }
      var nO = as(function(u, c, g) {
        return u + (g ? "-" : "") + c.toLowerCase();
      }), iO = as(function(u, c, g) {
        return u + (g ? " " : "") + c.toLowerCase();
      }), aO = ow("toLowerCase");
      function oO(u, c, g) {
        u = lt(u), c = Ye(c);
        var b = c ? Vr(u) : 0;
        if (!c || b >= c)
          return u;
        var C = (c - b) / 2;
        return Cc(uc(C), g) + u + Cc(sc(C), g);
      }
      function rO(u, c, g) {
        u = lt(u), c = Ye(c);
        var b = c ? Vr(u) : 0;
        return c && b < c ? u + Cc(c - b, g) : u;
      }
      function sO(u, c, g) {
        u = lt(u), c = Ye(c);
        var b = c ? Vr(u) : 0;
        return c && b < c ? Cc(c - b, g) + u : u;
      }
      function uO(u, c, g) {
        return g || c == null ? c = 0 : c && (c = +c), px(lt(u).replace(Hd, ""), c || 0);
      }
      function lO(u, c, g) {
        return (g ? Mn(u, c, g) : c === t) ? c = 1 : c = Ye(c), Cg(lt(u), c);
      }
      function cO() {
        var u = arguments, c = lt(u[0]);
        return u.length < 3 ? c : c.replace(u[1], u[2]);
      }
      var hO = as(function(u, c, g) {
        return u + (g ? "_" : "") + c.toLowerCase();
      });
      function dO(u, c, g) {
        return g && typeof g != "number" && Mn(u, c, g) && (c = g = t), g = g === t ? ft : g >>> 0, g ? (u = lt(u), u && (typeof c == "string" || c != null && !Xg(c)) && (c = ui(c), !c && $r(u)) ? bo(Gi(u), 0, g) : u.split(c, g)) : [];
      }
      var gO = as(function(u, c, g) {
        return u + (g ? " " : "") + Qg(c);
      });
      function fO(u, c, g) {
        return u = lt(u), g = g == null ? 0 : ar(Ye(g), 0, u.length), c = ui(c), u.slice(g, g + c.length) == c;
      }
      function pO(u, c, g) {
        var b = k.templateSettings;
        g && Mn(u, c, g) && (c = t), u = lt(u), c = Oc({}, c, b, dw);
        var C = Oc({}, c.imports, b.imports, dw), j = tn(C), E = ag(C, j), O, F, G = 0, W = c.interpolate || Wl, K = "__p += '", oe = rg(
          (c.escape || Wl).source + "|" + W.source + "|" + (W === Gl ? KT : Wl).source + "|" + (c.evaluate || Wl).source + "|$",
          "g"
        ), ye = "//# sourceURL=" + (dt.call(c, "sourceURL") ? (c.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++_L + "]") + `
`;
        u.replace(oe, function(_e, He, Ve, ci, Nn, hi) {
          return Ve || (Ve = ci), K += u.slice(G, hi).replace(tL, XL), He && (O = !0, K += `' +
__e(` + He + `) +
'`), Nn && (F = !0, K += `';
` + Nn + `;
__p += '`), Ve && (K += `' +
((__t = (` + Ve + `)) == null ? '' : __t) +
'`), G = hi + _e.length, _e;
        }), K += `';
`;
        var ke = dt.call(c, "variable") && c.variable;
        if (!ke)
          K = `with (obj) {
` + K + `
}
`;
        else if (WT.test(ke))
          throw new De(s);
        K = (F ? K.replace($e, "") : K).replace(gn, "$1").replace(Hn, "$1;"), K = "function(" + (ke || "obj") + `) {
` + (ke ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (O ? ", __e = _.escape" : "") + (F ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + K + `return __p
}`;
        var Re = av(function() {
          return ot(j, ye + "return " + K).apply(t, E);
        });
        if (Re.source = K, Hg(Re))
          throw Re;
        return Re;
      }
      function mO(u) {
        return lt(u).toLowerCase();
      }
      function yO(u) {
        return lt(u).toUpperCase();
      }
      function bO(u, c, g) {
        if (u = lt(u), u && (g || c === t))
          return gb(u);
        if (!u || !(c = ui(c)))
          return u;
        var b = Gi(u), C = Gi(c), j = fb(b, C), E = pb(b, C) + 1;
        return bo(b, j, E).join("");
      }
      function wO(u, c, g) {
        if (u = lt(u), u && (g || c === t))
          return u.slice(0, yb(u) + 1);
        if (!u || !(c = ui(c)))
          return u;
        var b = Gi(u), C = pb(b, Gi(c)) + 1;
        return bo(b, 0, C).join("");
      }
      function vO(u, c, g) {
        if (u = lt(u), u && (g || c === t))
          return u.replace(Hd, "");
        if (!u || !(c = ui(c)))
          return u;
        var b = Gi(u), C = fb(b, Gi(c));
        return bo(b, C).join("");
      }
      function CO(u, c) {
        var g = te, b = ge;
        if (Nt(c)) {
          var C = "separator" in c ? c.separator : C;
          g = "length" in c ? Ye(c.length) : g, b = "omission" in c ? ui(c.omission) : b;
        }
        u = lt(u);
        var j = u.length;
        if ($r(u)) {
          var E = Gi(u);
          j = E.length;
        }
        if (g >= j)
          return u;
        var O = g - Vr(b);
        if (O < 1)
          return b;
        var F = E ? bo(E, 0, O).join("") : u.slice(0, O);
        if (C === t)
          return F + b;
        if (E && (O += F.length - O), Xg(C)) {
          if (u.slice(O).search(C)) {
            var G, W = F;
            for (C.global || (C = rg(C.source, lt(Yy.exec(C)) + "g")), C.lastIndex = 0; G = C.exec(W); )
              var K = G.index;
            F = F.slice(0, K === t ? O : K);
          }
        } else if (u.indexOf(ui(C), O) != O) {
          var oe = F.lastIndexOf(C);
          oe > -1 && (F = F.slice(0, oe));
        }
        return F + b;
      }
      function SO(u) {
        return u = lt(u), u && Ea.test(u) ? u.replace(xa, VL) : u;
      }
      var kO = as(function(u, c, g) {
        return u + (g ? " " : "") + c.toUpperCase();
      }), Qg = ow("toUpperCase");
      function iv(u, c, g) {
        return u = lt(u), c = g ? t : c, c === t ? WL(u) ? ex(u) : RL(u) : u.match(c) || [];
      }
      var av = Fe(function(u, c) {
        try {
          return ri(u, t, c);
        } catch (g) {
          return Hg(g) ? g : new De(g);
        }
      }), _O = Aa(function(u, c) {
        return ji(c, function(g) {
          g = la(g), Na(u, g, Zg(u[g], u));
        }), u;
      });
      function jO(u) {
        var c = u == null ? 0 : u.length, g = Se();
        return u = c ? Et(u, function(b) {
          if (typeof b[1] != "function")
            throw new Ti(r);
          return [g(b[0]), b[1]];
        }) : [], Fe(function(b) {
          for (var C = -1; ++C < c; ) {
            var j = u[C];
            if (ri(j[0], this, b))
              return ri(j[1], this, b);
          }
        });
      }
      function TO(u) {
        return Vx(xi(u, f));
      }
      function Kg(u) {
        return function() {
          return u;
        };
      }
      function LO(u, c) {
        return u == null || u !== u ? c : u;
      }
      var xO = sw(), EO = sw(!0);
      function Qn(u) {
        return u;
      }
      function zg(u) {
        return Rb(typeof u == "function" ? u : xi(u, f));
      }
      function DO(u) {
        return Ib(xi(u, f));
      }
      function MO(u, c) {
        return Jb(u, xi(c, f));
      }
      var NO = Fe(function(u, c) {
        return function(g) {
          return bu(g, u, c);
        };
      }), OO = Fe(function(u, c) {
        return function(g) {
          return bu(u, g, c);
        };
      });
      function $g(u, c, g) {
        var b = tn(c), C = fc(c, b);
        g == null && !(Nt(c) && (C.length || !b.length)) && (g = c, c = u, u = this, C = fc(c, tn(c)));
        var j = !(Nt(g) && "chain" in g) || !!g.chain, E = Pa(u);
        return ji(C, function(O) {
          var F = c[O];
          u[O] = F, E && (u.prototype[O] = function() {
            var G = this.__chain__;
            if (j || G) {
              var W = u(this.__wrapped__), K = W.__actions__ = Xn(this.__actions__);
              return K.push({ func: F, args: arguments, thisArg: u }), W.__chain__ = G, W;
            }
            return F.apply(u, ho([this.value()], arguments));
          });
        }), u;
      }
      function AO() {
        return fn._ === this && (fn._ = rx), this;
      }
      function Vg() {
      }
      function YO(u) {
        return u = Ye(u), Fe(function(c) {
          return Zb(c, u);
        });
      }
      var PO = xg(Et), RO = xg(ub), FO = xg(qd);
      function ov(u) {
        return Yg(u) ? eg(la(u)) : fE(u);
      }
      function IO(u) {
        return function(c) {
          return u == null ? t : or(u, c);
        };
      }
      var JO = lw(), ZO = lw(!0);
      function Ug() {
        return [];
      }
      function qg() {
        return !1;
      }
      function BO() {
        return {};
      }
      function HO() {
        return "";
      }
      function XO() {
        return !0;
      }
      function GO(u, c) {
        if (u = Ye(u), u < 1 || u > Ae)
          return [];
        var g = ft, b = Cn(u, ft);
        c = Se(c), u -= ft;
        for (var C = ig(b, c); ++g < u; )
          c(g);
        return C;
      }
      function WO(u) {
        return Ne(u) ? Et(u, la) : li(u) ? [u] : Xn(jw(lt(u)));
      }
      function QO(u) {
        var c = ++ax;
        return lt(u) + c;
      }
      var KO = vc(function(u, c) {
        return u + c;
      }, 0), zO = Eg("ceil"), $O = vc(function(u, c) {
        return u / c;
      }, 1), VO = Eg("floor");
      function UO(u) {
        return u && u.length ? gc(u, Qn, fg) : t;
      }
      function qO(u, c) {
        return u && u.length ? gc(u, Se(c, 2), fg) : t;
      }
      function eA(u) {
        return hb(u, Qn);
      }
      function tA(u, c) {
        return hb(u, Se(c, 2));
      }
      function nA(u) {
        return u && u.length ? gc(u, Qn, bg) : t;
      }
      function iA(u, c) {
        return u && u.length ? gc(u, Se(c, 2), bg) : t;
      }
      var aA = vc(function(u, c) {
        return u * c;
      }, 1), oA = Eg("round"), rA = vc(function(u, c) {
        return u - c;
      }, 0);
      function sA(u) {
        return u && u.length ? ng(u, Qn) : 0;
      }
      function uA(u, c) {
        return u && u.length ? ng(u, Se(c, 2)) : 0;
      }
      return k.after = DM, k.ary = Pw, k.assign = yN, k.assignIn = $w, k.assignInWith = Oc, k.assignWith = bN, k.at = wN, k.before = Rw, k.bind = Zg, k.bindAll = _O, k.bindKey = Fw, k.castArray = BM, k.chain = Ow, k.chunk = VE, k.compact = UE, k.concat = qE, k.cond = jO, k.conforms = TO, k.constant = Kg, k.countBy = sM, k.create = vN, k.curry = Iw, k.curryRight = Jw, k.debounce = Zw, k.defaults = CN, k.defaultsDeep = SN, k.defer = MM, k.delay = NM, k.difference = eD, k.differenceBy = tD, k.differenceWith = nD, k.drop = iD, k.dropRight = aD, k.dropRightWhile = oD, k.dropWhile = rD, k.fill = sD, k.filter = lM, k.flatMap = dM, k.flatMapDeep = gM, k.flatMapDepth = fM, k.flatten = Ew, k.flattenDeep = uD, k.flattenDepth = lD, k.flip = OM, k.flow = xO, k.flowRight = EO, k.fromPairs = cD, k.functions = EN, k.functionsIn = DN, k.groupBy = pM, k.initial = dD, k.intersection = gD, k.intersectionBy = fD, k.intersectionWith = pD, k.invert = NN, k.invertBy = ON, k.invokeMap = yM, k.iteratee = zg, k.keyBy = bM, k.keys = tn, k.keysIn = Wn, k.map = Lc, k.mapKeys = YN, k.mapValues = PN, k.matches = DO, k.matchesProperty = MO, k.memoize = Ec, k.merge = RN, k.mergeWith = Vw, k.method = NO, k.methodOf = OO, k.mixin = $g, k.negate = Dc, k.nthArg = YO, k.omit = FN, k.omitBy = IN, k.once = AM, k.orderBy = wM, k.over = PO, k.overArgs = YM, k.overEvery = RO, k.overSome = FO, k.partial = Bg, k.partialRight = Bw, k.partition = vM, k.pick = JN, k.pickBy = Uw, k.property = ov, k.propertyOf = IO, k.pull = wD, k.pullAll = Mw, k.pullAllBy = vD, k.pullAllWith = CD, k.pullAt = SD, k.range = JO, k.rangeRight = ZO, k.rearg = PM, k.reject = kM, k.remove = kD, k.rest = RM, k.reverse = Ig, k.sampleSize = jM, k.set = BN, k.setWith = HN, k.shuffle = TM, k.slice = _D, k.sortBy = EM, k.sortedUniq = MD, k.sortedUniqBy = ND, k.split = dO, k.spread = FM, k.tail = OD, k.take = AD, k.takeRight = YD, k.takeRightWhile = PD, k.takeWhile = RD, k.tap = UD, k.throttle = IM, k.thru = Tc, k.toArray = Qw, k.toPairs = qw, k.toPairsIn = ev, k.toPath = WO, k.toPlainObject = zw, k.transform = XN, k.unary = JM, k.union = FD, k.unionBy = ID, k.unionWith = JD, k.uniq = ZD, k.uniqBy = BD, k.uniqWith = HD, k.unset = GN, k.unzip = Jg, k.unzipWith = Nw, k.update = WN, k.updateWith = QN, k.values = us, k.valuesIn = KN, k.without = XD, k.words = iv, k.wrap = ZM, k.xor = GD, k.xorBy = WD, k.xorWith = QD, k.zip = KD, k.zipObject = zD, k.zipObjectDeep = $D, k.zipWith = VD, k.entries = qw, k.entriesIn = ev, k.extend = $w, k.extendWith = Oc, $g(k, k), k.add = KO, k.attempt = av, k.camelCase = UN, k.capitalize = tv, k.ceil = zO, k.clamp = zN, k.clone = HM, k.cloneDeep = GM, k.cloneDeepWith = WM, k.cloneWith = XM, k.conformsTo = QM, k.deburr = nv, k.defaultTo = LO, k.divide = $O, k.endsWith = qN, k.eq = Qi, k.escape = eO, k.escapeRegExp = tO, k.every = uM, k.find = cM, k.findIndex = Lw, k.findKey = kN, k.findLast = hM, k.findLastIndex = xw, k.findLastKey = _N, k.floor = VO, k.forEach = Aw, k.forEachRight = Yw, k.forIn = jN, k.forInRight = TN, k.forOwn = LN, k.forOwnRight = xN, k.get = Gg, k.gt = KM, k.gte = zM, k.has = MN, k.hasIn = Wg, k.head = Dw, k.identity = Qn, k.includes = mM, k.indexOf = hD, k.inRange = $N, k.invoke = AN, k.isArguments = ur, k.isArray = Ne, k.isArrayBuffer = $M, k.isArrayLike = Gn, k.isArrayLikeObject = Zt, k.isBoolean = VM, k.isBuffer = wo, k.isDate = UM, k.isElement = qM, k.isEmpty = eN, k.isEqual = tN, k.isEqualWith = nN, k.isError = Hg, k.isFinite = iN, k.isFunction = Pa, k.isInteger = Hw, k.isLength = Mc, k.isMap = Xw, k.isMatch = aN, k.isMatchWith = oN, k.isNaN = rN, k.isNative = sN, k.isNil = lN, k.isNull = uN, k.isNumber = Gw, k.isObject = Nt, k.isObjectLike = Pt, k.isPlainObject = _u, k.isRegExp = Xg, k.isSafeInteger = cN, k.isSet = Ww, k.isString = Nc, k.isSymbol = li, k.isTypedArray = ss, k.isUndefined = hN, k.isWeakMap = dN, k.isWeakSet = gN, k.join = mD, k.kebabCase = nO, k.last = Di, k.lastIndexOf = yD, k.lowerCase = iO, k.lowerFirst = aO, k.lt = fN, k.lte = pN, k.max = UO, k.maxBy = qO, k.mean = eA, k.meanBy = tA, k.min = nA, k.minBy = iA, k.stubArray = Ug, k.stubFalse = qg, k.stubObject = BO, k.stubString = HO, k.stubTrue = XO, k.multiply = aA, k.nth = bD, k.noConflict = AO, k.noop = Vg, k.now = xc, k.pad = oO, k.padEnd = rO, k.padStart = sO, k.parseInt = uO, k.random = VN, k.reduce = CM, k.reduceRight = SM, k.repeat = lO, k.replace = cO, k.result = ZN, k.round = oA, k.runInContext = R, k.sample = _M, k.size = LM, k.snakeCase = hO, k.some = xM, k.sortedIndex = jD, k.sortedIndexBy = TD, k.sortedIndexOf = LD, k.sortedLastIndex = xD, k.sortedLastIndexBy = ED, k.sortedLastIndexOf = DD, k.startCase = gO, k.startsWith = fO, k.subtract = rA, k.sum = sA, k.sumBy = uA, k.template = pO, k.times = GO, k.toFinite = Ra, k.toInteger = Ye, k.toLength = Kw, k.toLower = mO, k.toNumber = Mi, k.toSafeInteger = mN, k.toString = lt, k.toUpper = yO, k.trim = bO, k.trimEnd = wO, k.trimStart = vO, k.truncate = CO, k.unescape = SO, k.uniqueId = QO, k.upperCase = kO, k.upperFirst = Qg, k.each = Aw, k.eachRight = Yw, k.first = Dw, $g(k, function() {
        var u = {};
        return sa(k, function(c, g) {
          dt.call(k.prototype, g) || (u[g] = c);
        }), u;
      }(), { chain: !1 }), k.VERSION = i, ji(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(u) {
        k[u].placeholder = k;
      }), ji(["drop", "take"], function(u, c) {
        Qe.prototype[u] = function(g) {
          g = g === t ? 1 : $t(Ye(g), 0);
          var b = this.__filtered__ && !c ? new Qe(this) : this.clone();
          return b.__filtered__ ? b.__takeCount__ = Cn(g, b.__takeCount__) : b.__views__.push({
            size: Cn(g, ft),
            type: u + (b.__dir__ < 0 ? "Right" : "")
          }), b;
        }, Qe.prototype[u + "Right"] = function(g) {
          return this.reverse()[u](g).reverse();
        };
      }), ji(["filter", "map", "takeWhile"], function(u, c) {
        var g = c + 1, b = g == ut || g == ze;
        Qe.prototype[u] = function(C) {
          var j = this.clone();
          return j.__iteratees__.push({
            iteratee: Se(C, 3),
            type: g
          }), j.__filtered__ = j.__filtered__ || b, j;
        };
      }), ji(["head", "last"], function(u, c) {
        var g = "take" + (c ? "Right" : "");
        Qe.prototype[u] = function() {
          return this[g](1).value()[0];
        };
      }), ji(["initial", "tail"], function(u, c) {
        var g = "drop" + (c ? "" : "Right");
        Qe.prototype[u] = function() {
          return this.__filtered__ ? new Qe(this) : this[g](1);
        };
      }), Qe.prototype.compact = function() {
        return this.filter(Qn);
      }, Qe.prototype.find = function(u) {
        return this.filter(u).head();
      }, Qe.prototype.findLast = function(u) {
        return this.reverse().find(u);
      }, Qe.prototype.invokeMap = Fe(function(u, c) {
        return typeof u == "function" ? new Qe(this) : this.map(function(g) {
          return bu(g, u, c);
        });
      }), Qe.prototype.reject = function(u) {
        return this.filter(Dc(Se(u)));
      }, Qe.prototype.slice = function(u, c) {
        u = Ye(u);
        var g = this;
        return g.__filtered__ && (u > 0 || c < 0) ? new Qe(g) : (u < 0 ? g = g.takeRight(-u) : u && (g = g.drop(u)), c !== t && (c = Ye(c), g = c < 0 ? g.dropRight(-c) : g.take(c - u)), g);
      }, Qe.prototype.takeRightWhile = function(u) {
        return this.reverse().takeWhile(u).reverse();
      }, Qe.prototype.toArray = function() {
        return this.take(ft);
      }, sa(Qe.prototype, function(u, c) {
        var g = /^(?:filter|find|map|reject)|While$/.test(c), b = /^(?:head|last)$/.test(c), C = k[b ? "take" + (c == "last" ? "Right" : "") : c], j = b || /^find/.test(c);
        C && (k.prototype[c] = function() {
          var E = this.__wrapped__, O = b ? [1] : arguments, F = E instanceof Qe, G = O[0], W = F || Ne(E), K = function(He) {
            var Ve = C.apply(k, ho([He], O));
            return b && oe ? Ve[0] : Ve;
          };
          W && g && typeof G == "function" && G.length != 1 && (F = W = !1);
          var oe = this.__chain__, ye = !!this.__actions__.length, ke = j && !oe, Re = F && !ye;
          if (!j && W) {
            E = Re ? E : new Qe(this);
            var _e = u.apply(E, O);
            return _e.__actions__.push({ func: Tc, args: [K], thisArg: t }), new Li(_e, oe);
          }
          return ke && Re ? u.apply(this, O) : (_e = this.thru(K), ke ? b ? _e.value()[0] : _e.value() : _e);
        });
      }), ji(["pop", "push", "shift", "sort", "splice", "unshift"], function(u) {
        var c = Ul[u], g = /^(?:push|sort|unshift)$/.test(u) ? "tap" : "thru", b = /^(?:pop|shift)$/.test(u);
        k.prototype[u] = function() {
          var C = arguments;
          if (b && !this.__chain__) {
            var j = this.value();
            return c.apply(Ne(j) ? j : [], C);
          }
          return this[g](function(E) {
            return c.apply(Ne(E) ? E : [], C);
          });
        };
      }), sa(Qe.prototype, function(u, c) {
        var g = k[c];
        if (g) {
          var b = g.name + "";
          dt.call(ts, b) || (ts[b] = []), ts[b].push({ name: c, func: g });
        }
      }), ts[wc(t, _).name] = [{
        name: "wrapper",
        func: t
      }], Qe.prototype.clone = Sx, Qe.prototype.reverse = kx, Qe.prototype.value = _x, k.prototype.at = qD, k.prototype.chain = eM, k.prototype.commit = tM, k.prototype.next = nM, k.prototype.plant = aM, k.prototype.reverse = oM, k.prototype.toJSON = k.prototype.valueOf = k.prototype.value = rM, k.prototype.first = k.prototype.head, hu && (k.prototype[hu] = iM), k;
    }, Ur = tx();
    er ? ((er.exports = Ur)._ = Ur, zd._ = Ur) : fn._ = Ur;
  }).call(Qa);
})(_h, _h.exports);
var wR = _h.exports;
const Bc = Ie.debug("MapObjectsArrows");
class vR {
  constructor(e, t, i, a, o) {
    xe(this, "previouslyRenderedArrows", /* @__PURE__ */ new Map());
    this.konvaLayer = e, this.mapFile = t, this.mapDep = i, this.arrowPath = a, this.factories = o, Bc("draw arrows on canvas");
    const r = this.factories.chain.create();
    this.konvaLayer.layer(this.factories.patron.create(r.receiveKey("layer"))), this.mapFile.currentMap(this.factories.patron.create(r.receiveKey("map"))), this.mapDep.objects(this.factories.patron.create(r.receiveKey("objects"))), r.result(
      this.factories.patron.create(
        this.factories.guest.create(
          wR.throttle(({ layer: s, map: l, objects: h }) => {
            const d = (f, p) => {
              const y = l.types[p.type];
              this.arrowPath.breakPoints(
                {
                  shapeGeometry: {
                    width: f.width,
                    height: f.height
                  },
                  shapePosition: {
                    x: f.position[0],
                    y: f.position[1]
                  },
                  lookToGeometry: {
                    width: p.width,
                    height: p.height
                  },
                  lookToPosition: {
                    x: p.position[0],
                    y: p.position[1]
                  }
                },
                {
                  shapeGeometry: {
                    width: p.width || y.width,
                    height: p.height || y.height
                  },
                  shapePosition: {
                    x: p.position[0],
                    y: p.position[1]
                  },
                  lookToGeometry: {
                    width: f.width,
                    height: f.height
                  },
                  lookToPosition: {
                    x: f.position[0],
                    y: f.position[1]
                  }
                },
                this.factories.guest.create((m) => {
                  const w = m.join("-"), v = [f.id, p.id].join("-");
                  if (Bc("points", m), Bc(f, p), this.previouslyRenderedArrows.has(v)) {
                    const L = this.previouslyRenderedArrows.get(v);
                    L.arrow.show(), L.arrow.points(m);
                    return;
                  }
                  const _ = new Ko({
                    x: 0,
                    y: 0,
                    points: m,
                    pointerLength: 20,
                    pointerWidth: 10,
                    fill: "#ccc",
                    stroke: "#bbb",
                    strokeWidth: 2,
                    zIndex: 2
                  });
                  this.previouslyRenderedArrows.set(v, {
                    arrow: _,
                    arrowKey: w
                  }), s.add(_);
                })
              );
            };
            this.arrowPath.clear(), this.previouslyRenderedArrows.forEach((f) => f.arrow.hide()), h.forEach((f) => {
              f.arrows && (Bc("visible objects", h.length), f.arrows.forEach((p) => {
                const y = h.find((m) => m.id === p.id) || l.objects[p.id];
                y && d(f, y);
              }));
            });
          }, 50)
        )
      )
    );
  }
  introduction() {
    return "patron";
  }
}
const ff = Ie.debug("NewArrow"), Gv = {
  width: 10,
  height: 10
};
class CR {
  constructor(e, t, i, a) {
    xe(this, "cursorGuest");
    xe(this, "arrowCache");
    this.konvaLayer = e, this.cursorPosition = t, this.arrowPath = i, this.factories = a, this.cursorGuest = this.factories.sourceEmpty.create(), this.arrowCache = this.factories.sourceEmpty.create();
  }
  /**
   * Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ Ð½Ð¾Ð²ÑƒÑŽ ÑÑ‚Ñ€ÐµÐ»ÐºÑƒ Ð´Ð»Ñ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°
   */
  forObject(e) {
    ff("start watch cursor"), this.cursorGuest.value(
      this.factories.guest.create((a) => {
        uv(a);
      })
    );
    let t = null;
    const i = this.factories.patron.create(
      this.factories.guest.create((a) => {
        ff("cursor moves"), this.konvaLayer.layer(
          this.factories.guest.create((o) => {
            ff("cursor moves in layer"), this.arrowPath.breakPoints(
              {
                shapeGeometry: {
                  width: e.width,
                  height: e.height
                },
                shapePosition: {
                  x: e.position[0],
                  y: e.position[1]
                },
                lookToGeometry: Gv,
                lookToPosition: a
              },
              {
                lookToGeometry: {
                  width: e.width,
                  height: e.height
                },
                lookToPosition: {
                  x: e.position[0],
                  y: e.position[1]
                },
                shapeGeometry: Gv,
                shapePosition: a
              },
              this.factories.guest.create((r) => {
                if (t) {
                  t.points(r);
                  return;
                }
                t = new Ko({
                  x: 0,
                  y: 0,
                  points: r,
                  pointerLength: 20,
                  pointerWidth: 10,
                  fill: "#ccc",
                  stroke: "#bbb",
                  strokeWidth: 2,
                  zIndex: 2
                }), o.add(t), this.arrowCache.give(t);
              })
            );
          })
        ), this.arrowPath.clear();
      })
    );
    this.cursorPosition.value(i), this.cursorGuest.give(i);
  }
  /**
   * ÐžÑ‚Ð¼ÐµÐ½Ð° ÑÑ‚Ñ€ÐµÐ»ÐºÐ¸
   */
  dispose() {
    this.cursorGuest.value(
      this.factories.guest.create((e) => {
        uv(e);
      })
    ), this.arrowCache.value(
      this.factories.guest.create((e) => {
        e.remove();
      })
    );
  }
}
class Pl extends ne {
  _sceneFunc(e) {
    var t = this.cornerRadius(), i = this.width(), a = this.height();
    e.beginPath(), t ? Q.drawRoundedRectPath(e, i, a, t) : e.rect(0, 0, i, a), e.closePath(), e.fillStrokeShape(this);
  }
}
Pl.prototype.className = "Rect";
eu(Pl);
ee.addGetterSetter(Pl, "cornerRadius", 0, Z2(4));
const Eu = Ie.debug("MapObjectBackground");
class SR {
  constructor(e, t, i, a) {
    xe(this, "mapNameCache");
    this.konvaLayer = e, this.mapFile = t, this.zIndex = i, this.factories = a, this.mapNameCache = a.cache.create(""), this.mapFile.currentMap(a.patron.create(this));
  }
  give(e) {
    return this.konvaLayer.layer(
      this.factories.patronOnce.create((t) => {
        Eu("map received in background", e), this.mapNameCache.value(
          this.factories.guest.create((i) => {
            if (i === e.url)
              return;
            Eu("background cache is not equals", i), this.mapNameCache.give(e.url);
            const a = new Image(), o = document.querySelector(".grid-example");
            Eu("grid example", o), o && xA(o).then((r) => {
              a.src = r.toDataURL(), a.onload = () => {
                Eu("canvas pattern loaded"), Eu("konva layer loaded");
                const s = new Pl({
                  width: 3e3,
                  height: 3e3,
                  x: 0,
                  y: 0,
                  fillPatternImage: a,
                  zIndex: 1
                });
                this.zIndex.give(() => {
                  s.zIndex(0);
                }), t.add(s);
              };
            });
          })
        );
      })
    ), this;
  }
}
const kR = Ie.debug("Breadcrumbs");
class _R {
  constructor(e, t, i) {
    this.parentNames = e, this.mapFile = t, this.factories = i;
  }
  list(e) {
    const t = this.factories.chain.create();
    return this.parentNames.names(this.factories.guestCast.create(e, t.receiveKey("names"))), this.mapFile.mapFile(this.factories.guestCast.create(e, t.receiveKey("mapFile"))), t.result(
      this.factories.guestInTheMiddle.create(e, ({ names: i, mapFile: a }) => {
        kR("map id", i, a), e.give(
          i.map((o) => {
            var r, s;
            return {
              title: ((s = (r = a[o]) == null ? void 0 : r.settings) == null ? void 0 : s.title) || "unknown",
              name: o
            };
          })
        );
      })
    ), e;
  }
}
const Wv = Ie.debug("CursorWithObjects");
class jR {
  constructor(e, t, i) {
    this.objectsVisible = e, this.cursor = t, this.factories = i;
  }
  value(e) {
    const t = this.factories.chain.create();
    return this.cursor.value(this.factories.guestCast.create(e, t.receiveKey("cursor"))), this.objectsVisible.objects(
      this.factories.guestCast.create(e, t.receiveKey("objects"))
    ), t.result(
      this.factories.guestInTheMiddle.create(e, ({ cursor: i, objects: a }) => {
        const o = a.find((r) => {
          const s = r.position[0], l = r.position[0] + r.width || 100, h = r.position[1], d = r.position[1] + r.height || 100;
          return i.x >= s && i.x <= l && i.y >= h && i.y <= d;
        });
        o ? (Wv("crossed with", o), e.give({
          x: o.position[0] + o.width / 2,
          y: o.position[1] + o.height / 2
        })) : (Wv("cursor pos", i), e.give(i));
      })
    ), this;
  }
}
const Qv = Ie.debug("Drawer");
class TR {
  constructor(e, t) {
    xe(this, "drawerNameCache");
    this.keyboard = e, this.factories = t, this.drawerNameCache = t.cache.create(""), this.keyboard.pressed(
      this.factories.patron.create(
        this.factories.guest.create((i) => {
          Qv("new key in drawer", i), i === "Escape" && this.give("");
        })
      )
    );
  }
  isOpenedByName(e, t) {
    return this.drawerNameCache.value(
      this.factories.guestInTheMiddle.create(t, (i) => {
        Qv("new drawer name", i), t.give(i === e);
      })
    ), t;
  }
  openedByName(e) {
    return this.factories.guestAware.create((t) => {
      this.isOpenedByName(e, t);
    });
  }
  give(e) {
    return this.drawerNameCache.give(e), this;
  }
}
class LR {
  value(e) {
    typeof performance > "u" && e.give(0);
    const t = 10;
    let i = performance.now(), a = 0;
    const o = () => requestAnimationFrame(() => {
      if (a += 1, a >= t) {
        const r = performance.now(), s = r - i;
        e.give(Math.round(1e3 / (s / a))), i = r, a = 0;
      }
      o();
    });
    return o(), e;
  }
}
class xR {
  constructor(e, t) {
    this.mapFile = e, this.factories = t;
  }
  menuObjects(e) {
    return this.mapFile.currentMap(
      this.factories.guestInTheMiddle.create(e, (t) => {
        const i = Object.values(t.objects).filter((a) => a.inMenu);
        e.give(i);
      })
    ), e;
  }
}
const Kv = Ie.debug("app:MiniMap"), zv = 130;
class ER {
  constructor(e, t, i, a) {
    xe(this, "theSize");
    xe(this, "thePoints");
    xe(this, "viewportSizeCache");
    this.map = e, this.layer = t, this.stageSize = i, this.factories = a, this.theSize = a.sourceEmpty.create(), this.thePoints = a.sourceEmpty.create(), this.viewportSizeCache = a.sourceEmpty.create();
    const o = a.chain.create();
    e.objects(a.patron.create(o.receiveKey("objects"))), t.layer(a.patron.create(o.receiveKey("layer"))), i.value(a.patron.create(o.receiveKey("size"))), o.result(
      a.patron.create(
        a.guest.create(({ layer: r, size: s, objects: l }) => {
          const h = zv / s.width, d = {
            width: Math.round(r.width() * h),
            height: Math.round(r.height() * h)
          };
          this.viewportSizeCache.give(d);
          const f = {
            width: Math.round(s.width * h),
            height: Math.round(s.height * h)
          };
          this.theSize.give(f);
          const p = l.map((y) => ({
            id: y.id,
            x: Math.round(y.position[0] * h),
            y: Math.round(y.position[1] * h),
            width: Math.round(y.width * h),
            height: Math.round(y.height * h)
          }));
          Kv("minimap points", p), this.thePoints.give(p);
        })
      )
    );
  }
  viewportPosition(e) {
    const t = this.factories.chain.create();
    return this.stageSize.value(this.factories.guestCast.create(e, t.receiveKey("size"))), this.layer.position(this.factories.guestCast.create(e, t.receiveKey("position"))), t.result(
      this.factories.guestInTheMiddle.create(e, ({ size: i, position: a }) => {
        const o = zv / i.width, r = {
          x: a.x * o * -1,
          y: a.y * o * -1
        };
        Kv("scaled position is", r), e.give(r);
      })
    ), e;
  }
  viewportSize(e) {
    return this.viewportSizeCache.value(e), e;
  }
  size(e) {
    return this.theSize.value(e), e;
  }
  points(e) {
    return this.thePoints.value(e), e;
  }
}
const $v = Ie.debug("Modal");
class DR {
  constructor(e, t) {
    xe(this, "modalNameCache");
    this.keyboard = e, this.factories = t, $v("modal created"), this.modalNameCache = t.cache.create(""), this.keyboard.pressed(
      this.factories.patron.create(
        this.factories.guest.create((i) => {
          $v("new key in modal", i), i === "Escape" && this.give("");
        })
      )
    );
  }
  isOpenedByName(e, t) {
    return this.modalNameCache.value(
      this.factories.guestInTheMiddle.create(t, (i) => {
        t.give(i === e);
      })
    ), t;
  }
  openedByName(e) {
    return this.factories.guestAware.create((t) => {
      this.isOpenedByName(e, t);
    });
  }
  give(e) {
    return this.modalNameCache.give(e), this;
  }
}
class MR {
  constructor(e) {
    xe(this, "messageCache");
    xe(this, "notificationLifetimeDelay", 3500);
    xe(this, "lastTimerHead", null);
    this.messageCache = e.sourceEmpty.create();
  }
  message(e) {
    return this.messageCache.value(e), e;
  }
  give(e) {
    return this.messageCache.give(e), this.lastTimerHead && clearTimeout(this.lastTimerHead), this.lastTimerHead = setTimeout(() => {
      this.messageCache.give({
        type: "success",
        text: "hide"
      });
    }, this.notificationLifetimeDelay), this;
  }
}
const Du = Ie.debug("ObjectGeometryFix");
class NR {
  constructor(e, t, i, a) {
    xe(this, "innerReceive");
    this.mapFile = t, this.map = i, this.factories = a, e.objects(a.patron.create(this)), this.innerReceive = qs((o) => {
      this.mapFile.currentMap(
        this.factories.guest.create((r) => {
          Du("objects to fix", o);
          const s = document.querySelectorAll(".objects-container .rendered-object"), l = r.objects;
          let h = !1;
          s.forEach((d) => {
            const f = d.getAttribute("data-object-id");
            if (Du("i see id", f), !f)
              return;
            const p = l[f];
            if (p && (Du("dom object geometry", d.clientWidth, d.clientHeight), Du("saved object geometry", p.width, p.height), (p.width !== d.clientWidth || p.height !== d.clientHeight) && (h = !0, Du("update object geometry"), p.width = d.clientWidth, p.height = d.clientHeight), !p.width || !p.height)) {
              const y = r.types[p.type];
              p.width = y.width, p.height = y.height;
            }
          }), h && this.map.give({
            ...r,
            objects: l
          });
        })
      );
    }, 500);
  }
  give(e) {
    return this.innerReceive(e), this;
  }
}
const Mu = Ie.debug("MapObjectsRectsPatron");
class OR {
  constructor(e, t, i, a, o, r, s, l) {
    xe(this, "previouslyRenderedRects", /* @__PURE__ */ new Map());
    this.konvaLayer = e, this.mapFile = t, this.mapObject = i, this.mapObjectCurrent = o, this.mapObjectForRendering = r, this.objectPosition = s, this.factories = l, a.objects(this);
  }
  give(e) {
    return this.konvaLayer.layer(
      this.factories.patronOnce.create(
        this.factories.guest.create((t) => {
          this.mapFile.currentMap(
            this.factories.guest.create((i) => {
              Mu("rerender object rects"), this.previouslyRenderedRects.forEach((a) => {
                a.hide();
              }), e.forEach((a) => {
                const o = i.types[a.type], r = +a.width || +o.width || 100, s = +a.height || +o.height || 100;
                if (this.previouslyRenderedRects.has(a)) {
                  const h = this.previouslyRenderedRects.get(a);
                  h.width(r), h.height(s), h.x(+a.position[0]), h.y(+a.position[1]), h.show();
                  return;
                }
                Mu("rect object", a, o);
                const l = new Pl({
                  x: +a.position[0],
                  y: +a.position[1],
                  width: r,
                  height: s,
                  name: a.id,
                  draggable: !0,
                  objectId: a.id,
                  zIndex: 3
                });
                this.previouslyRenderedRects.set(a, l), t.add(l), l.on("mouseenter", () => {
                  t.getStage().container().style.cursor = "pointer";
                }), l.on("mouseleave", () => {
                  t.getStage().container().style.cursor = "default";
                }), l.on("dragend", () => {
                  Mu("drag ended"), this.objectPosition.position(
                    a,
                    {
                      x: l.x(),
                      y: l.y()
                    },
                    this.factories.guest.create((h) => {
                      this.mapObject.give({
                        ...a,
                        position: [h.x, h.y]
                      });
                    })
                  );
                }), l.on("dragmove", () => {
                  Mu("dragmove works", l.x(), l.y()), t.getStage().container().style.cursor = "move", this.objectPosition.position(
                    a,
                    {
                      x: l.x(),
                      y: l.y()
                    },
                    this.factories.guest.create((h) => {
                      this.mapObjectForRendering.give({
                        ...a,
                        position: [h.x, h.y]
                      });
                    })
                  );
                }), l.on("click", () => {
                  Mu("object clicked with id", a.id), this.mapObjectCurrent.give(a.id);
                });
              });
            })
          );
        })
      )
    ), this;
  }
  introduction() {
    return "patron";
  }
}
class AR {
  constructor(e, t, i, a) {
    this.canvas = t, this.konvaLayer = i, this.factories = a, e.currentMap(this);
  }
  give() {
    const e = new ResizeObserver((i) => {
      const [a] = i;
      this.canvas.canvas(
        this.factories.guest.create((o) => {
          const r = o.getBoundingClientRect();
          this.konvaLayer.layer(
            this.factories.guest.create((s) => {
              s.getStage().width(a.contentRect.width - r.left), s.getStage().height(a.contentRect.height - r.top), this.canvas.give(o), this.konvaLayer.give(s);
            })
          );
        })
      );
    }), t = document.querySelector("body");
    return t && e.observe(t), this;
  }
}
const YR = Ie.debug("StagePosition");
class PR {
  constructor(e) {
    this.stageMove = e;
  }
  give(e) {
    return YR("received position", e), this.stageMove.move(e), this;
  }
}
class RR {
  constructor(e, t) {
    this.stageMove = e, this.factories = t;
  }
  move(e, t) {
    return e.value(
      this.factories.guest.create((i) => {
        this.stageMove.move(i.objects[t]);
      })
    ), this;
  }
}
const Vv = Ie.debug("Zindex");
class FR {
  constructor(e) {
    xe(this, "fnsCache");
    this.factories = e, this.fnsCache = e.cache.create([]), this.fnsCache.value(
      e.patron.create(
        e.guest.create(
          qs((t) => {
            Vv("zindex fns run"), t.forEach((i) => i());
          }, 50)
        )
      )
    );
  }
  give(e) {
    return Vv("zindex received value"), this.fnsCache.value(
      this.factories.guest.create((t) => {
        this.fnsCache.give(t.concat(e));
      })
    ), this;
  }
}
const Uv = Ie.debug("app:BrowserCanvas");
class IR {
  constructor(e) {
    xe(this, "canvasCache");
    this.factories = e, this.canvasCache = e.sourceEmpty.create();
  }
  canvas(e) {
    return this.canvasCache.value(e), this;
  }
  size(e) {
    return this.canvasCache.value(
      this.factories.guestInTheMiddle.create(e, (t) => {
        const i = t.width || t.clientWidth, a = t.height || t.clientHeight;
        Uv("canvas size", i, a), e.give({
          height: a,
          width: i
        });
      })
    ), this;
  }
  give(e) {
    return Uv("receive new canvas", e), this.canvasCache.give(e), this;
  }
}
const JR = Ie.debug("Cursor");
class ZR {
  constructor(e, t) {
    xe(this, "cursorPool");
    this.cursorPool = t.pool.create(this);
    const i = {
      x: 0,
      y: 0
    };
    window.addEventListener("mousemove", (a) => {
      const o = {
        x: a.offsetX + -i.x,
        y: a.offsetY + -i.y
      };
      JR("move cursor fired", o), this.cursorPool.give(o);
    }), e.position(
      t.patron.create(
        t.guest.create((a) => {
          i.x = a.x, i.y = a.y;
        })
      )
    );
  }
  value(e) {
    return this.cursorPool.add(e), this;
  }
}
const Hc = Ie.debug("ControlCombo");
class BR {
  constructor(e, t) {
    this.keyboard = e, this.factories = t;
  }
  /**
   * Ð¡Ð»ÑƒÑ‡Ð¸Ð»Ð°ÑÑŒ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸Ñ ctrl + keyCode
   */
  happened(e, t) {
    this.keyboard.event(
      this.factories.guestInTheMiddle.create(t, (i) => {
        Hc("combo happened look for key", e, "received", i.code), i.ctrlKey && i.code === e && i.type === "keydown" && (i.preventDefault(), t.give(i));
      })
    );
  }
  /**
   * Ð¡Ð»ÑƒÑ‡Ð¸Ð»Ð°ÑÑŒ ÐºÐ¾Ð¼Ð±Ð¸Ð½Ð°Ñ†Ð¸Ñ ctrl + keyCode Ñ ÑƒÑÐ»Ð¾Ð²Ð¸ÐµÐ¼ comboCondition
   */
  happenedConditional(e, t, i) {
    Hc("combo control happened registration"), this.keyboard.event(
      this.factories.guestInTheMiddle.create(i, (a) => {
        Hc("keyboard event come"), t.value(
          this.factories.guest.create((o) => {
            Hc("combo happened look for key", e, "received", a.code), o && a.ctrlKey && a.code === e && a.type === "keydown" && (a.preventDefault(), i.give(a));
          })
        );
      })
    );
  }
}
const Nu = Ie.debug("Keyboard");
class HR {
  constructor(e) {
    xe(this, "pressedPool");
    xe(this, "combinationsPool");
    Nu("keyboard created"), this.pressedPool = e.pool.create(this), this.combinationsPool = e.pool.create(this), window.addEventListener("keyup", (t) => {
      Nu("keyboard pressed", t.key), this.pressedPool.give(t.key);
    }), $A({
      passive: !1,
      onEventFired: (t) => {
        Nu("magic combination happens 11", t.ctrlKey, t.key), this.combinationsPool.give(t);
      }
    });
  }
  pressed(e) {
    return Nu("keyboard receive pressed subscriber"), this.pressedPool.add(e), this;
  }
  event(e) {
    return Nu("keyboard receive combination subscriber"), this.combinationsPool.add(e), this;
  }
}
class Jo extends Le {
  constructor() {
    super(...arguments), this.children = [];
  }
  getChildren(e) {
    if (!e)
      return this.children || [];
    const t = this.children || [];
    var i = [];
    return t.forEach(function(a) {
      e(a) && i.push(a);
    }), i;
  }
  hasChildren() {
    return this.getChildren().length > 0;
  }
  removeChildren() {
    return this.getChildren().forEach((e) => {
      e.parent = null, e.index = 0, e.remove();
    }), this.children = [], this._requestDraw(), this;
  }
  destroyChildren() {
    return this.getChildren().forEach((e) => {
      e.parent = null, e.index = 0, e.destroy();
    }), this.children = [], this._requestDraw(), this;
  }
  add(...e) {
    if (e.length === 0)
      return this;
    if (e.length > 1) {
      for (var t = 0; t < e.length; t++)
        this.add(e[t]);
      return this;
    }
    const i = e[0];
    return i.getParent() ? (i.moveTo(this), this) : (this._validateAdd(i), i.index = this.getChildren().length, i.parent = this, i._clearCaches(), this.getChildren().push(i), this._fire("add", {
      child: i
    }), this._requestDraw(), this);
  }
  destroy() {
    return this.hasChildren() && this.destroyChildren(), super.destroy(), this;
  }
  find(e) {
    return this._generalFind(e, !1);
  }
  findOne(e) {
    var t = this._generalFind(e, !0);
    return t.length > 0 ? t[0] : void 0;
  }
  _generalFind(e, t) {
    var i = [];
    return this._descendants((a) => {
      const o = a._isMatch(e);
      return o && i.push(a), !!(o && t);
    }), i;
  }
  _descendants(e) {
    let t = !1;
    const i = this.getChildren();
    for (const a of i) {
      if (t = e(a), t)
        return !0;
      if (a.hasChildren() && (t = a._descendants(e), t))
        return !0;
    }
    return !1;
  }
  toObject() {
    var e = Le.prototype.toObject.call(this);
    return e.children = [], this.getChildren().forEach((t) => {
      e.children.push(t.toObject());
    }), e;
  }
  isAncestorOf(e) {
    for (var t = e.getParent(); t; ) {
      if (t._id === this._id)
        return !0;
      t = t.getParent();
    }
    return !1;
  }
  clone(e) {
    var t = Le.prototype.clone.call(this, e);
    return this.getChildren().forEach(function(i) {
      t.add(i.clone());
    }), t;
  }
  getAllIntersections(e) {
    var t = [];
    return this.find("Shape").forEach(function(i) {
      i.isVisible() && i.intersects(e) && t.push(i);
    }), t;
  }
  _clearSelfAndDescendantCache(e) {
    var t;
    super._clearSelfAndDescendantCache(e), !this.isCached() && ((t = this.children) === null || t === void 0 || t.forEach(function(i) {
      i._clearSelfAndDescendantCache(e);
    }));
  }
  _setChildrenIndices() {
    var e;
    (e = this.children) === null || e === void 0 || e.forEach(function(t, i) {
      t.index = i;
    }), this._requestDraw();
  }
  drawScene(e, t) {
    var i = this.getLayer(), a = e || i && i.getCanvas(), o = a && a.getContext(), r = this._getCanvasCache(), s = r && r.scene, l = a && a.isCache;
    if (!this.isVisible() && !l)
      return this;
    if (s) {
      o.save();
      var h = this.getAbsoluteTransform(t).getMatrix();
      o.transform(h[0], h[1], h[2], h[3], h[4], h[5]), this._drawCachedSceneCanvas(o), o.restore();
    } else
      this._drawChildren("drawScene", a, t);
    return this;
  }
  drawHit(e, t) {
    if (!this.shouldDrawHit(t))
      return this;
    var i = this.getLayer(), a = e || i && i.hitCanvas, o = a && a.getContext(), r = this._getCanvasCache(), s = r && r.hit;
    if (s) {
      o.save();
      var l = this.getAbsoluteTransform(t).getMatrix();
      o.transform(l[0], l[1], l[2], l[3], l[4], l[5]), this._drawCachedHitCanvas(o), o.restore();
    } else
      this._drawChildren("drawHit", a, t);
    return this;
  }
  _drawChildren(e, t, i) {
    var a, o = t && t.getContext(), r = this.clipWidth(), s = this.clipHeight(), l = this.clipFunc(), h = r && s || l;
    const d = i === this;
    if (h) {
      o.save();
      var f = this.getAbsoluteTransform(i), p = f.getMatrix();
      if (o.transform(p[0], p[1], p[2], p[3], p[4], p[5]), o.beginPath(), l)
        l.call(this, o, this);
      else {
        var y = this.clipX(), m = this.clipY();
        o.rect(y, m, r, s);
      }
      o.clip(), p = f.copy().invert().getMatrix(), o.transform(p[0], p[1], p[2], p[3], p[4], p[5]);
    }
    var w = !d && this.globalCompositeOperation() !== "source-over" && e === "drawScene";
    w && (o.save(), o._applyGlobalCompositeOperation(this)), (a = this.children) === null || a === void 0 || a.forEach(function(v) {
      v[e](t, i);
    }), w && o.restore(), h && o.restore();
  }
  getClientRect(e) {
    var t;
    e = e || {};
    var i = e.skipTransform, a = e.relativeTo, o, r, s, l, h = {
      x: 1 / 0,
      y: 1 / 0,
      width: 0,
      height: 0
    }, d = this;
    (t = this.children) === null || t === void 0 || t.forEach(function(w) {
      if (w.visible()) {
        var v = w.getClientRect({
          relativeTo: d,
          skipShadow: e.skipShadow,
          skipStroke: e.skipStroke
        });
        v.width === 0 && v.height === 0 || (o === void 0 ? (o = v.x, r = v.y, s = v.x + v.width, l = v.y + v.height) : (o = Math.min(o, v.x), r = Math.min(r, v.y), s = Math.max(s, v.x + v.width), l = Math.max(l, v.y + v.height)));
      }
    });
    for (var f = this.find("Shape"), p = !1, y = 0; y < f.length; y++) {
      var m = f[y];
      if (m._isVisible(this)) {
        p = !0;
        break;
      }
    }
    return p && o !== void 0 ? h = {
      x: o,
      y: r,
      width: s - o,
      height: l - r
    } : h = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, i ? h : this._transformedRect(h, a);
  }
}
ee.addComponentsGetterSetter(Jo, "clip", [
  "x",
  "y",
  "width",
  "height"
]);
ee.addGetterSetter(Jo, "clipX", void 0, nt());
ee.addGetterSetter(Jo, "clipY", void 0, nt());
ee.addGetterSetter(Jo, "clipWidth", void 0, nt());
ee.addGetterSetter(Jo, "clipHeight", void 0, nt());
ee.addGetterSetter(Jo, "clipFunc");
var XR = "Stage", GR = "string", qv = "px", WR = "mouseout", jS = "mouseleave", TS = "mouseover", LS = "mouseenter", xS = "mousemove", ES = "mousedown", DS = "mouseup", Fu = "pointermove", Iu = "pointerdown", Ss = "pointerup", Ju = "pointercancel", QR = "lostpointercapture", Xc = "pointerout", Gc = "pointerleave", Wc = "pointerover", Qc = "pointerenter", cp = "contextmenu", MS = "touchstart", NS = "touchend", OS = "touchmove", AS = "touchcancel", hp = "wheel", KR = 5, zR = [
  [LS, "_pointerenter"],
  [ES, "_pointerdown"],
  [xS, "_pointermove"],
  [DS, "_pointerup"],
  [jS, "_pointerleave"],
  [MS, "_pointerdown"],
  [OS, "_pointermove"],
  [NS, "_pointerup"],
  [AS, "_pointercancel"],
  [TS, "_pointerover"],
  [hp, "_wheel"],
  [cp, "_contextmenu"],
  [Iu, "_pointerdown"],
  [Fu, "_pointermove"],
  [Ss, "_pointerup"],
  [Ju, "_pointercancel"],
  [QR, "_lostpointercapture"]
];
const pf = {
  mouse: {
    [Xc]: WR,
    [Gc]: jS,
    [Wc]: TS,
    [Qc]: LS,
    [Fu]: xS,
    [Iu]: ES,
    [Ss]: DS,
    [Ju]: "mousecancel",
    pointerclick: "click",
    pointerdblclick: "dblclick"
  },
  touch: {
    [Xc]: "touchout",
    [Gc]: "touchleave",
    [Wc]: "touchover",
    [Qc]: "touchenter",
    [Fu]: OS,
    [Iu]: MS,
    [Ss]: NS,
    [Ju]: AS,
    pointerclick: "tap",
    pointerdblclick: "dbltap"
  },
  pointer: {
    [Xc]: Xc,
    [Gc]: Gc,
    [Wc]: Wc,
    [Qc]: Qc,
    [Fu]: Fu,
    [Iu]: Iu,
    [Ss]: Ss,
    [Ju]: Ju,
    pointerclick: "pointerclick",
    pointerdblclick: "pointerdblclick"
  }
}, Zu = (n) => n.indexOf("pointer") >= 0 ? "pointer" : n.indexOf("touch") >= 0 ? "touch" : "mouse", ls = (n) => {
  const e = Zu(n);
  if (e === "pointer")
    return Te.pointerEventsEnabled && pf.pointer;
  if (e === "touch")
    return pf.touch;
  if (e === "mouse")
    return pf.mouse;
};
function e0(n = {}) {
  return (n.clipFunc || n.clipWidth || n.clipHeight) && Q.warn("Stage does not support clipping. Please use clip for Layers or Groups."), n;
}
const $R = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);";
class dl extends Jo {
  constructor(e) {
    super(e0(e)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", () => {
      e0(this.attrs);
    }), this._checkVisibility();
  }
  _validateAdd(e) {
    const t = e.getType() === "Layer", i = e.getType() === "FastLayer";
    t || i || Q.throw("You may only add layers to the stage.");
  }
  _checkVisibility() {
    if (!this.content)
      return;
    const e = this.visible() ? "" : "none";
    this.content.style.display = e;
  }
  setContainer(e) {
    if (typeof e === GR) {
      if (e.charAt(0) === ".") {
        var t = e.slice(1);
        e = document.getElementsByClassName(t)[0];
      } else {
        var i;
        e.charAt(0) !== "#" ? i = e : i = e.slice(1), e = document.getElementById(i);
      }
      if (!e)
        throw "Can not find container in document with id " + i;
    }
    return this._setAttr("container", e), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), e.appendChild(this.content)), this;
  }
  shouldDrawHit() {
    return !0;
  }
  clear() {
    var e = this.children, t = e.length, i;
    for (i = 0; i < t; i++)
      e[i].clear();
    return this;
  }
  clone(e) {
    return e || (e = {}), e.container = typeof document < "u" && document.createElement("div"), Jo.prototype.clone.call(this, e);
  }
  destroy() {
    super.destroy();
    var e = this.content;
    return e && Q._isInDocument(e) && this.container().removeChild(e), Q.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this;
  }
  getPointerPosition() {
    const e = this._pointerPositions[0] || this._changedPointerPositions[0];
    return e ? {
      x: e.x,
      y: e.y
    } : (Q.warn($R), null);
  }
  _getPointerById(e) {
    return this._pointerPositions.find((t) => t.id === e);
  }
  getPointersPositions() {
    return this._pointerPositions;
  }
  getStage() {
    return this;
  }
  getContent() {
    return this.content;
  }
  _toKonvaCanvas(e) {
    e = e || {}, e.x = e.x || 0, e.y = e.y || 0, e.width = e.width || this.width(), e.height = e.height || this.height();
    var t = new Ku({
      width: e.width,
      height: e.height,
      pixelRatio: e.pixelRatio || 1
    }), i = t.getContext()._context, a = this.children;
    return (e.x || e.y) && i.translate(-1 * e.x, -1 * e.y), a.forEach(function(o) {
      if (o.isVisible()) {
        var r = o._toKonvaCanvas(e);
        i.drawImage(r._canvas, e.x, e.y, r.getWidth() / r.getPixelRatio(), r.getHeight() / r.getPixelRatio());
      }
    }), t;
  }
  getIntersection(e) {
    if (!e)
      return null;
    var t = this.children, i = t.length, a = i - 1, o;
    for (o = a; o >= 0; o--) {
      const r = t[o].getIntersection(e);
      if (r)
        return r;
    }
    return null;
  }
  _resizeDOM() {
    var e = this.width(), t = this.height();
    this.content && (this.content.style.width = e + qv, this.content.style.height = t + qv), this.bufferCanvas.setSize(e, t), this.bufferHitCanvas.setSize(e, t), this.children.forEach((i) => {
      i.setSize({ width: e, height: t }), i.draw();
    });
  }
  add(e, ...t) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++)
        this.add(arguments[i]);
      return this;
    }
    super.add(e);
    var a = this.children.length;
    return a > KR && Q.warn("The stage has " + a + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), e.setSize({ width: this.width(), height: this.height() }), e.draw(), Te.isBrowser && this.content.appendChild(e.canvas._canvas), this;
  }
  getParent() {
    return null;
  }
  getLayer() {
    return null;
  }
  hasPointerCapture(e) {
    return bS(e, this);
  }
  setPointerCapture(e) {
    wS(e, this);
  }
  releaseCapture(e) {
    zu(e);
  }
  getLayers() {
    return this.children;
  }
  _bindContentEvents() {
    Te.isBrowser && zR.forEach(([e, t]) => {
      this.content.addEventListener(e, (i) => {
        this[t](i);
      }, { passive: !1 });
    });
  }
  _pointerenter(e) {
    this.setPointersPositions(e);
    const t = ls(e.type);
    this._fire(t.pointerenter, {
      evt: e,
      target: this,
      currentTarget: this
    });
  }
  _pointerover(e) {
    this.setPointersPositions(e);
    const t = ls(e.type);
    this._fire(t.pointerover, {
      evt: e,
      target: this,
      currentTarget: this
    });
  }
  _getTargetShape(e) {
    let t = this[e + "targetShape"];
    return t && !t.getStage() && (t = null), t;
  }
  _pointerleave(e) {
    const t = ls(e.type), i = Zu(e.type);
    if (t) {
      this.setPointersPositions(e);
      var a = this._getTargetShape(i), o = !rt.isDragging || Te.hitOnDragEnabled;
      a && o ? (a._fireAndBubble(t.pointerout, { evt: e }), a._fireAndBubble(t.pointerleave, { evt: e }), this._fire(t.pointerleave, {
        evt: e,
        target: this,
        currentTarget: this
      }), this[i + "targetShape"] = null) : o && (this._fire(t.pointerleave, {
        evt: e,
        target: this,
        currentTarget: this
      }), this._fire(t.pointerout, {
        evt: e,
        target: this,
        currentTarget: this
      })), this.pointerPos = void 0, this._pointerPositions = [];
    }
  }
  _pointerdown(e) {
    const t = ls(e.type), i = Zu(e.type);
    if (t) {
      this.setPointersPositions(e);
      var a = !1;
      this._changedPointerPositions.forEach((o) => {
        var r = this.getIntersection(o);
        if (rt.justDragged = !1, Te["_" + i + "ListenClick"] = !0, !(r && r.isListening()))
          return;
        Te.capturePointerEventsEnabled && r.setPointerCapture(o.id), this[i + "ClickStartShape"] = r, r._fireAndBubble(t.pointerdown, {
          evt: e,
          pointerId: o.id
        }), a = !0;
        const l = e.type.indexOf("touch") >= 0;
        r.preventDefault() && e.cancelable && l && e.preventDefault();
      }), a || this._fire(t.pointerdown, {
        evt: e,
        target: this,
        currentTarget: this,
        pointerId: this._pointerPositions[0].id
      });
    }
  }
  _pointermove(e) {
    const t = ls(e.type), i = Zu(e.type);
    if (!t)
      return;
    rt.isDragging && rt.node.preventDefault() && e.cancelable && e.preventDefault(), this.setPointersPositions(e);
    var a = !rt.isDragging || Te.hitOnDragEnabled;
    if (!a)
      return;
    var o = {};
    let r = !1;
    var s = this._getTargetShape(i);
    this._changedPointerPositions.forEach((l) => {
      const h = hf(l.id) || this.getIntersection(l), d = l.id, f = { evt: e, pointerId: d };
      var p = s !== h;
      if (p && s && (s._fireAndBubble(t.pointerout, Object.assign({}, f), h), s._fireAndBubble(t.pointerleave, Object.assign({}, f), h)), h) {
        if (o[h._id])
          return;
        o[h._id] = !0;
      }
      h && h.isListening() ? (r = !0, p && (h._fireAndBubble(t.pointerover, Object.assign({}, f), s), h._fireAndBubble(t.pointerenter, Object.assign({}, f), s), this[i + "targetShape"] = h), h._fireAndBubble(t.pointermove, Object.assign({}, f))) : s && (this._fire(t.pointerover, {
        evt: e,
        target: this,
        currentTarget: this,
        pointerId: d
      }), this[i + "targetShape"] = null);
    }), r || this._fire(t.pointermove, {
      evt: e,
      target: this,
      currentTarget: this,
      pointerId: this._changedPointerPositions[0].id
    });
  }
  _pointerup(e) {
    const t = ls(e.type), i = Zu(e.type);
    if (!t)
      return;
    this.setPointersPositions(e);
    const a = this[i + "ClickStartShape"], o = this[i + "ClickEndShape"];
    var r = {};
    let s = !1;
    this._changedPointerPositions.forEach((l) => {
      const h = hf(l.id) || this.getIntersection(l);
      if (h) {
        if (h.releaseCapture(l.id), r[h._id])
          return;
        r[h._id] = !0;
      }
      const d = l.id, f = { evt: e, pointerId: d };
      let p = !1;
      Te["_" + i + "InDblClickWindow"] ? (p = !0, clearTimeout(this[i + "DblTimeout"])) : rt.justDragged || (Te["_" + i + "InDblClickWindow"] = !0, clearTimeout(this[i + "DblTimeout"])), this[i + "DblTimeout"] = setTimeout(function() {
        Te["_" + i + "InDblClickWindow"] = !1;
      }, Te.dblClickWindow), h && h.isListening() ? (s = !0, this[i + "ClickEndShape"] = h, h._fireAndBubble(t.pointerup, Object.assign({}, f)), Te["_" + i + "ListenClick"] && a && a === h && (h._fireAndBubble(t.pointerclick, Object.assign({}, f)), p && o && o === h && h._fireAndBubble(t.pointerdblclick, Object.assign({}, f)))) : (this[i + "ClickEndShape"] = null, Te["_" + i + "ListenClick"] && this._fire(t.pointerclick, {
        evt: e,
        target: this,
        currentTarget: this,
        pointerId: d
      }), p && this._fire(t.pointerdblclick, {
        evt: e,
        target: this,
        currentTarget: this,
        pointerId: d
      }));
    }), s || this._fire(t.pointerup, {
      evt: e,
      target: this,
      currentTarget: this,
      pointerId: this._changedPointerPositions[0].id
    }), Te["_" + i + "ListenClick"] = !1, e.cancelable && i !== "touch" && e.preventDefault();
  }
  _contextmenu(e) {
    this.setPointersPositions(e);
    var t = this.getIntersection(this.getPointerPosition());
    t && t.isListening() ? t._fireAndBubble(cp, { evt: e }) : this._fire(cp, {
      evt: e,
      target: this,
      currentTarget: this
    });
  }
  _wheel(e) {
    this.setPointersPositions(e);
    var t = this.getIntersection(this.getPointerPosition());
    t && t.isListening() ? t._fireAndBubble(hp, { evt: e }) : this._fire(hp, {
      evt: e,
      target: this,
      currentTarget: this
    });
  }
  _pointercancel(e) {
    this.setPointersPositions(e);
    const t = hf(e.pointerId) || this.getIntersection(this.getPointerPosition());
    t && t._fireAndBubble(Ss, jm(e)), zu(e.pointerId);
  }
  _lostpointercapture(e) {
    zu(e.pointerId);
  }
  setPointersPositions(e) {
    var t = this._getContentPosition(), i = null, a = null;
    e = e || window.event, e.touches !== void 0 ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(e.touches, (o) => {
      this._pointerPositions.push({
        id: o.identifier,
        x: (o.clientX - t.left) / t.scaleX,
        y: (o.clientY - t.top) / t.scaleY
      });
    }), Array.prototype.forEach.call(e.changedTouches || e.touches, (o) => {
      this._changedPointerPositions.push({
        id: o.identifier,
        x: (o.clientX - t.left) / t.scaleX,
        y: (o.clientY - t.top) / t.scaleY
      });
    })) : (i = (e.clientX - t.left) / t.scaleX, a = (e.clientY - t.top) / t.scaleY, this.pointerPos = {
      x: i,
      y: a
    }, this._pointerPositions = [{ x: i, y: a, id: Q._getFirstPointerId(e) }], this._changedPointerPositions = [
      { x: i, y: a, id: Q._getFirstPointerId(e) }
    ]);
  }
  _setPointerPosition(e) {
    Q.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(e);
  }
  _getContentPosition() {
    if (!this.content || !this.content.getBoundingClientRect)
      return {
        top: 0,
        left: 0,
        scaleX: 1,
        scaleY: 1
      };
    var e = this.content.getBoundingClientRect();
    return {
      top: e.top,
      left: e.left,
      scaleX: e.width / this.content.clientWidth || 1,
      scaleY: e.height / this.content.clientHeight || 1
    };
  }
  _buildDOM() {
    if (this.bufferCanvas = new Ku({
      width: this.width(),
      height: this.height()
    }), this.bufferHitCanvas = new mS({
      pixelRatio: 1,
      width: this.width(),
      height: this.height()
    }), !!Te.isBrowser) {
      var e = this.container();
      if (!e)
        throw "Stage has no container. A container is required.";
      e.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), e.appendChild(this.content), this._resizeDOM();
    }
  }
  cache() {
    return Q.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this;
  }
  clearCache() {
    return this;
  }
  batchDraw() {
    return this.getChildren().forEach(function(e) {
      e.batchDraw();
    }), this;
  }
}
dl.prototype.nodeType = XR;
eu(dl);
ee.addGetterSetter(dl, "container");
const t0 = Ie.debug("app:konva:KonvaLayer");
class VR {
  constructor(e, t, i, a) {
    xe(this, "guestChain");
    xe(this, "positionCache");
    xe(this, "layerCache");
    this.canvasDep = e, this.stageMoveRestriction = i, this.factories = a, this.positionCache = a.cache.create({
      x: 0,
      y: 0
    }), this.guestChain = a.chain.create(), this.layerCache = a.sourceEmpty.create(), this.canvasDep.canvas(a.patron.create(this.guestChain.receiveKey("canvas"))), t.value(this.guestChain.receiveKey("stageSize")), this.guestChain.result(
      a.guest.create(
        ({ canvas: o }) => {
          t0("create new konva stage");
          const r = new lv.Stage({
            width: o.clientWidth,
            height: o.clientHeight,
            container: o,
            fill: "#ffeeee",
            draggable: !0
          }), s = new lv.Layer();
          r.add(s), s.draw(), this.layerCache.give(s), r.on("dragend", (h) => {
            if (!(h.target instanceof dl))
              return;
            const d = {
              x: r.x(),
              y: r.y()
            };
            t0("new position", d), this.positionCache.give(d);
          }), r.on("dragmove", (h) => {
            if (!(h.target instanceof dl))
              return;
            const d = {
              x: r.x(),
              y: r.y()
            };
            this.positionCache.give(d);
          });
          const l = this.factories.guestSync.create({
            x: 0,
            y: 0
          });
          r.dragBoundFunc((h) => (i.position(h, l), l.value()));
        }
      )
    );
  }
  layer(e) {
    return this.layerCache.value(e), e;
  }
  position(e) {
    return this.positionCache.value(e), e;
  }
  give(e) {
    this.layerCache.give(e);
    const t = e.getStage();
    return this.positionCache.give({
      x: t.x(),
      y: t.y()
    }), this;
  }
}
class UR {
  constructor(e, t) {
    this.konvaLayer = e, this.factories = t;
  }
  position(e) {
    return this.konvaLayer.position(
      this.factories.guestInTheMiddle.create(e, (t) => {
        e.give({
          x: t.x * -1,
          y: t.y * -1
        });
      })
    ), e;
  }
}
const qR = Ie.debug("position");
class eF {
  constructor(e, t, i, a, o) {
    this.layer = e, this.canvas = t, this.stageSize = i, this.stageMoveRestriction = a, this.factories = o;
  }
  move(e) {
    qR("move stage to new point", e.position), this.stageSize.value(
      this.factories.guest.create(() => {
        this.canvas.size(
          this.factories.guest.create((t) => {
            this.layer.layer(
              this.factories.guest.create((i) => {
                const [a, o] = e.position, r = {
                  x: -a - Math.round(e.width / 2) + Math.round(t.width / 2),
                  y: -o - Math.round(e.height / 2) + Math.round(t.height / 2)
                };
                this.stageMoveRestriction.position(
                  r,
                  this.factories.guest.create((s) => {
                    i.getStage().position(s), setTimeout(() => {
                      this.layer.give(i);
                    });
                  })
                );
              })
            );
          })
        );
      })
    );
  }
}
const be = vi(), rd = new HR(be), tF = new DR(rd, be), YS = new TR(rd, be), sd = new MR(be), oo = new JY(be), nF = '{"current":{"progress":0,"settings":{"colored":false,"title":"current"},"objects":{},"types":{},"url":"/current","parent":""}}', PS = be.source.create(nF), Ft = new HY(PS, oo, be), Tm = new GY(Ft, oo, be), Lm = new rS(Tm, oo, be), iF = new sS(Lm, Tm, be), Hi = new rS(Ft, oo, be), aF = new q1((n) => {
  Ft.currentMap(new LA(n));
}), ud = new WY(YS, be), oF = new c2(be), rF = new l2(Ft, Hi, be), Hr = new IR(be), Xr = new v2(), RS = new C2(Hr, Xr, be), Xi = new VR(Hr, Xr, RS, be), sF = new FR(be), uF = new SR(Xi, Ft, sF, be), tu = new sS(Hi, Ft, be), lF = new VY(
  Hi,
  Ft,
  [new Cm(sd, new QY(Ft, be), be)],
  be
), cF = new UR(Xi, be), hF = new KY(Hi, tu, Hr, cF, be), FS = new p2(Ft, be), IS = new g2(
  Hi,
  Ft,
  [
    new Cm(
      sd,
      new m2(FS, be),
      be
    )
  ],
  be
), dF = new d2(
  Hi,
  Ft,
  [new Cm(sd, FS, be)],
  be
), gF = new h2(IS), ld = new S2(Xi, Hr, Tm, be), fF = new NR(
  ld,
  Ft,
  Hi,
  be
), pF = new OR(
  Xi,
  Ft,
  tu,
  ld,
  ud,
  iF,
  new r2(new o2(Xr, be), be),
  be
), mF = new ZR(Xi, be), yF = new jR(ld, mF, be), JS = new T2(), ZS = new CR(Xi, yF, JS, be), bF = new vR(Xi, Ft, Lm, JS, be), wF = new ER(Lm, Xi, Xr, be), vF = new qY(
  ud,
  Hi,
  tu,
  ZS,
  be
), CF = new AR(Ft, Hr, Xi, be), SF = new j2(
  ud,
  Ft,
  tu,
  be
), kF = new BY(Ft, oo, be), _F = new $Y(tu), jF = new LR(), xm = new zY(oo, be), TF = new _R(xm, Ft, be), LF = new i2(oo, be), xF = new y2(xm, Ft, be), EF = new BR(rd, be), DF = new xR(Ft, be), BS = new eF(Xi, Hr, Xr, RS, be), MF = new PR(BS), NF = new RR(BS, be), OF = new b2(Hi, be), AF = new ZY(Ft, Hi, oo, be), YF = new u2(Hi, Xr, Xi, be), PF = {
  mapCurrentID: oo,
  mapFile: Ft,
  mapCurrent: Hi,
  mapCurrentSource: aF,
  mapRemoved: kF,
  mapSettings: rF,
  mapObject: tu,
  mapObjectRemoved: lF,
  mapType: IS,
  mapTypeRemoved: dF,
  mapTypeNew: gF,
  mapObjectsVisible: ld,
  mapObjectCurrent: ud,
  mapObjectNew: hF,
  mapObjectsLink: vF,
  mapTypeCurrent: oF,
  mapRects: pF,
  mapBackground: uF,
  mapObjectArrows: bF,
  mapObjectsGeometryFix: fF,
  canvas: Hr,
  miniMap: wF,
  notification: sd,
  modal: tF,
  drawer: YS,
  konvaLayer: Xi,
  resizing: CF,
  objectAdditionalFieldsFix: SF,
  mapObjectRelationRemoved: _F,
  fps: jF,
  breadcrumbs: TF,
  mapObjectUrl: LF,
  keyboard: rd,
  parentNames: xm,
  parentTypes: xF,
  controlCombo: EF,
  menu: DF,
  stagePosition: MF,
  stagePositionByObjectId: NF,
  objectsMatchedToQuery: OF,
  stageSize: Xr,
  mapHistory: AF,
  fileContent: PS,
  newArrow: ZS,
  objectsOutsideScreen: YF
}, qt = () => PF;
class qe {
  constructor(e = void 0) {
    xe(this, "innerRef");
    this.innerRef = vn(e);
  }
  ref() {
    return this.innerRef;
  }
  give(e) {
    return console.log("vue ref patron", e), this.innerRef.value = e, this;
  }
  introduction() {
    return "patron";
  }
}
const RF = ["onClick"], FF = /* @__PURE__ */ Xe({
  __name: "BaseBreadcrumbs",
  setup(n) {
    const {
      breadcrumbs: e,
      mapCurrentID: t
    } = qt(), i = e.list(new qe()).ref();
    return (a, o) => (q(), ie("div", null, [
      (q(!0), ie(Ht, null, Un(I(i), (r) => (q(), ie("span", {
        key: r.name
      }, [
        o[0] || (o[0] = Ue(" / ")),
        ae("a", {
          href: "#",
          onClick: Us((s) => I(t).give(r.name), ["prevent"])
        }, we(r.title), 9, RF)
      ]))), 128))
    ]));
  }
}), kt = /* @__PURE__ */ Xe({
  __name: "BaseButton",
  props: {
    size: {
      type: String,
      default: "md",
      validator: (n) => ["sm", "md", "lg"].includes(n)
    },
    type: {
      type: String,
      default: "standard"
    }
  },
  setup(n) {
    const e = n, t = ["rounded-main", `text-${e.size}`, `p-${e.size}`, `bg-${e.type} hover:bg-${e.type}-second`];
    return t.push(""), (i, a) => (q(), ie("button", {
      type: "button",
      class: va(t)
    }, [
      Ri(i.$slots, "default")
    ]));
  }
}), n0 = () => {
};
let Em = {}, HS = {}, XS = null, GS = {
  mark: n0,
  measure: n0
};
try {
  typeof window < "u" && (Em = window), typeof document < "u" && (HS = document), typeof MutationObserver < "u" && (XS = MutationObserver), typeof performance < "u" && (GS = performance);
} catch {
}
const {
  userAgent: i0 = ""
} = Em.navigator || {}, Zo = Em, Tt = HS, a0 = XS, Kc = GS;
Zo.document;
const ro = !!Tt.documentElement && !!Tt.head && typeof Tt.addEventListener == "function" && typeof Tt.createElement == "function", WS = ~i0.indexOf("MSIE") || ~i0.indexOf("Trident/");
var Dt = "classic", QS = "duotone", yi = "sharp", bi = "sharp-duotone", IF = [Dt, QS, yi, bi], JF = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds"
  }
}, o0 = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, ZF = ["kit"], BF = /fa(s|r|l|t|d|b|k|kd|ss|sr|sl|st|sds)?[\-\ ]/, HF = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i, XF = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
}, GF = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds"
  }
}, WF = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds"
  }
}, QF = {
  classic: ["fas", "far", "fal", "fat"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds"]
}, KF = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid"
  }
}, zF = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    duotone: "fad",
    brands: "fab"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds"
  }
}, KS = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fad: "duotone",
    "fa-duotone": "duotone",
    fab: "brands",
    "fa-brands": "brands"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid"
  }
}, $F = ["solid", "regular", "light", "thin", "duotone", "brands"], zS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], VF = zS.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), Bu = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, UF = [...Object.keys(QF), ...$F, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", Bu.GROUP, Bu.SWAP_OPACITY, Bu.PRIMARY, Bu.SECONDARY].concat(zS.map((n) => "".concat(n, "x"))).concat(VF.map((n) => "w-".concat(n))), qF = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, eI = {
  kit: {
    "fa-kit": "fak"
  },
  "kit-duotone": {
    "fa-kit-duotone": "fakd"
  }
}, tI = {
  kit: {
    fak: "fa-kit"
  },
  "kit-duotone": {
    fakd: "fa-kit-duotone"
  }
}, r0 = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
};
const qa = "___FONT_AWESOME___", dp = 16, $S = "fa", VS = "svg-inline--fa", Mr = "data-fa-i2svg", gp = "data-fa-pseudo-element", nI = "data-fa-pseudo-element-pending", Dm = "data-prefix", Mm = "data-icon", s0 = "fontawesome-i2svg", iI = "async", aI = ["HTML", "HEAD", "STYLE", "SCRIPT"], US = (() => {
  try {
    return process.env.NODE_ENV === "production";
  } catch {
    return !1;
  }
})(), qS = [Dt, yi, bi];
function Rl(n) {
  return new Proxy(n, {
    get(e, t) {
      return t in e ? e[t] : e[Dt];
    }
  });
}
const ek = {
  ...KS
};
ek[Dt] = {
  ...KS[Dt],
  ...o0.kit,
  ...o0["kit-duotone"]
};
const vr = Rl(ek), fp = {
  ...zF
};
fp[Dt] = {
  ...fp[Dt],
  ...r0.kit,
  ...r0["kit-duotone"]
};
const gl = Rl(fp), pp = {
  ...KF
};
pp[Dt] = {
  ...pp[Dt],
  ...tI.kit
};
const Cr = Rl(pp), mp = {
  ...WF
};
mp[Dt] = {
  ...mp[Dt],
  ...eI.kit
};
const oI = Rl(mp), rI = BF, tk = "fa-layers-text", sI = HF, uI = {
  ...JF
};
Rl(uI);
const lI = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], mf = Bu, Rs = /* @__PURE__ */ new Set();
Object.keys(gl[Dt]).map(Rs.add.bind(Rs));
Object.keys(gl[yi]).map(Rs.add.bind(Rs));
Object.keys(gl[bi]).map(Rs.add.bind(Rs));
const cI = [...ZF, ...UF], $u = Zo.FontAwesomeConfig || {};
function hI(n) {
  var e = Tt.querySelector("script[" + n + "]");
  if (e)
    return e.getAttribute(n);
}
function dI(n) {
  return n === "" ? !0 : n === "false" ? !1 : n === "true" ? !0 : n;
}
Tt && typeof Tt.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((e) => {
  let [t, i] = e;
  const a = dI(hI(t));
  a != null && ($u[i] = a);
});
const nk = {
  styleDefault: "solid",
  familyDefault: "classic",
  cssPrefix: $S,
  replacementClass: VS,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
$u.familyPrefix && ($u.cssPrefix = $u.familyPrefix);
const Fs = {
  ...nk,
  ...$u
};
Fs.autoReplaceSvg || (Fs.observeMutations = !1);
const pe = {};
Object.keys(nk).forEach((n) => {
  Object.defineProperty(pe, n, {
    enumerable: !0,
    set: function(e) {
      Fs[n] = e, Vu.forEach((t) => t(pe));
    },
    get: function() {
      return Fs[n];
    }
  });
});
Object.defineProperty(pe, "familyPrefix", {
  enumerable: !0,
  set: function(n) {
    Fs.cssPrefix = n, Vu.forEach((e) => e(pe));
  },
  get: function() {
    return Fs.cssPrefix;
  }
});
Zo.FontAwesomeConfig = pe;
const Vu = [];
function gI(n) {
  return Vu.push(n), () => {
    Vu.splice(Vu.indexOf(n), 1);
  };
}
const vo = dp, ma = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function fI(n) {
  if (!n || !ro)
    return;
  const e = Tt.createElement("style");
  e.setAttribute("type", "text/css"), e.innerHTML = n;
  const t = Tt.head.childNodes;
  let i = null;
  for (let a = t.length - 1; a > -1; a--) {
    const o = t[a], r = (o.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(r) > -1 && (i = o);
  }
  return Tt.head.insertBefore(e, i), n;
}
const pI = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function fl() {
  let n = 12, e = "";
  for (; n-- > 0; )
    e += pI[Math.random() * 62 | 0];
  return e;
}
function nu(n) {
  const e = [];
  for (let t = (n || []).length >>> 0; t--; )
    e[t] = n[t];
  return e;
}
function Nm(n) {
  return n.classList ? nu(n.classList) : (n.getAttribute("class") || "").split(" ").filter((e) => e);
}
function ik(n) {
  return "".concat(n).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function mI(n) {
  return Object.keys(n || {}).reduce((e, t) => e + "".concat(t, '="').concat(ik(n[t]), '" '), "").trim();
}
function cd(n) {
  return Object.keys(n || {}).reduce((e, t) => e + "".concat(t, ": ").concat(n[t].trim(), ";"), "");
}
function Om(n) {
  return n.size !== ma.size || n.x !== ma.x || n.y !== ma.y || n.rotate !== ma.rotate || n.flipX || n.flipY;
}
function yI(n) {
  let {
    transform: e,
    containerWidth: t,
    iconWidth: i
  } = n;
  const a = {
    transform: "translate(".concat(t / 2, " 256)")
  }, o = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "), r = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "), s = "rotate(".concat(e.rotate, " 0 0)"), l = {
    transform: "".concat(o, " ").concat(r, " ").concat(s)
  }, h = {
    transform: "translate(".concat(i / 2 * -1, " -256)")
  };
  return {
    outer: a,
    inner: l,
    path: h
  };
}
function bI(n) {
  let {
    transform: e,
    width: t = dp,
    height: i = dp,
    startCentered: a = !1
  } = n, o = "";
  return a && WS ? o += "translate(".concat(e.x / vo - t / 2, "em, ").concat(e.y / vo - i / 2, "em) ") : a ? o += "translate(calc(-50% + ".concat(e.x / vo, "em), calc(-50% + ").concat(e.y / vo, "em)) ") : o += "translate(".concat(e.x / vo, "em, ").concat(e.y / vo, "em) "), o += "scale(".concat(e.size / vo * (e.flipX ? -1 : 1), ", ").concat(e.size / vo * (e.flipY ? -1 : 1), ") "), o += "rotate(".concat(e.rotate, "deg) "), o;
}
var wI = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`;
function ak() {
  const n = $S, e = VS, t = pe.cssPrefix, i = pe.replacementClass;
  let a = wI;
  if (t !== n || i !== e) {
    const o = new RegExp("\\.".concat(n, "\\-"), "g"), r = new RegExp("\\--".concat(n, "\\-"), "g"), s = new RegExp("\\.".concat(e), "g");
    a = a.replace(o, ".".concat(t, "-")).replace(r, "--".concat(t, "-")).replace(s, ".".concat(i));
  }
  return a;
}
let u0 = !1;
function yf() {
  pe.autoAddCss && !u0 && (fI(ak()), u0 = !0);
}
var vI = {
  mixout() {
    return {
      dom: {
        css: ak,
        insertCss: yf
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        yf();
      },
      beforeI2svg() {
        yf();
      }
    };
  }
};
const eo = Zo || {};
eo[qa] || (eo[qa] = {});
eo[qa].styles || (eo[qa].styles = {});
eo[qa].hooks || (eo[qa].hooks = {});
eo[qa].shims || (eo[qa].shims = []);
var ya = eo[qa];
const ok = [], rk = function() {
  Tt.removeEventListener("DOMContentLoaded", rk), jh = 1, ok.map((n) => n());
};
let jh = !1;
ro && (jh = (Tt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(Tt.readyState), jh || Tt.addEventListener("DOMContentLoaded", rk));
function CI(n) {
  ro && (jh ? setTimeout(n, 0) : ok.push(n));
}
function Fl(n) {
  const {
    tag: e,
    attributes: t = {},
    children: i = []
  } = n;
  return typeof n == "string" ? ik(n) : "<".concat(e, " ").concat(mI(t), ">").concat(i.map(Fl).join(""), "</").concat(e, ">");
}
function l0(n, e, t) {
  if (n && n[e] && n[e][t])
    return {
      prefix: e,
      iconName: t,
      icon: n[e][t]
    };
}
var bf = function(e, t, i, a) {
  var o = Object.keys(e), r = o.length, s = t, l, h, d;
  for (i === void 0 ? (l = 1, d = e[o[0]]) : (l = 0, d = i); l < r; l++)
    h = o[l], d = s(d, e[h], h, e);
  return d;
};
function SI(n) {
  const e = [];
  let t = 0;
  const i = n.length;
  for (; t < i; ) {
    const a = n.charCodeAt(t++);
    if (a >= 55296 && a <= 56319 && t < i) {
      const o = n.charCodeAt(t++);
      (o & 64512) == 56320 ? e.push(((a & 1023) << 10) + (o & 1023) + 65536) : (e.push(a), t--);
    } else
      e.push(a);
  }
  return e;
}
function yp(n) {
  const e = SI(n);
  return e.length === 1 ? e[0].toString(16) : null;
}
function kI(n, e) {
  const t = n.length;
  let i = n.charCodeAt(e), a;
  return i >= 55296 && i <= 56319 && t > e + 1 && (a = n.charCodeAt(e + 1), a >= 56320 && a <= 57343) ? (i - 55296) * 1024 + a - 56320 + 65536 : i;
}
function c0(n) {
  return Object.keys(n).reduce((e, t) => {
    const i = n[t];
    return !!i.icon ? e[i.iconName] = i.icon : e[t] = i, e;
  }, {});
}
function bp(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks: i = !1
  } = t, a = c0(e);
  typeof ya.hooks.addPack == "function" && !i ? ya.hooks.addPack(n, c0(e)) : ya.styles[n] = {
    ...ya.styles[n] || {},
    ...a
  }, n === "fas" && bp("fa", e);
}
const {
  styles: fr,
  shims: _I
} = ya, jI = {
  [Dt]: Object.values(Cr[Dt]),
  [yi]: Object.values(Cr[yi]),
  [bi]: Object.values(Cr[bi])
};
let Am = null, sk = {}, uk = {}, lk = {}, ck = {}, hk = {};
const TI = {
  [Dt]: Object.keys(vr[Dt]),
  [yi]: Object.keys(vr[yi]),
  [bi]: Object.keys(vr[bi])
};
function LI(n) {
  return ~cI.indexOf(n);
}
function xI(n, e) {
  const t = e.split("-"), i = t[0], a = t.slice(1).join("-");
  return i === n && a !== "" && !LI(a) ? a : null;
}
const dk = () => {
  const n = (i) => bf(fr, (a, o, r) => (a[r] = bf(o, i, {}), a), {});
  sk = n((i, a, o) => (a[3] && (i[a[3]] = o), a[2] && a[2].filter((s) => typeof s == "number").forEach((s) => {
    i[s.toString(16)] = o;
  }), i)), uk = n((i, a, o) => (i[o] = o, a[2] && a[2].filter((s) => typeof s == "string").forEach((s) => {
    i[s] = o;
  }), i)), hk = n((i, a, o) => {
    const r = a[2];
    return i[o] = o, r.forEach((s) => {
      i[s] = o;
    }), i;
  });
  const e = "far" in fr || pe.autoFetchSvg, t = bf(_I, (i, a) => {
    const o = a[0];
    let r = a[1];
    const s = a[2];
    return r === "far" && !e && (r = "fas"), typeof o == "string" && (i.names[o] = {
      prefix: r,
      iconName: s
    }), typeof o == "number" && (i.unicodes[o.toString(16)] = {
      prefix: r,
      iconName: s
    }), i;
  }, {
    names: {},
    unicodes: {}
  });
  lk = t.names, ck = t.unicodes, Am = hd(pe.styleDefault, {
    family: pe.familyDefault
  });
};
gI((n) => {
  Am = hd(n.styleDefault, {
    family: pe.familyDefault
  });
});
dk();
function Ym(n, e) {
  return (sk[n] || {})[e];
}
function EI(n, e) {
  return (uk[n] || {})[e];
}
function Do(n, e) {
  return (hk[n] || {})[e];
}
function gk(n) {
  return lk[n] || {
    prefix: null,
    iconName: null
  };
}
function DI(n) {
  const e = ck[n], t = Ym("fas", n);
  return e || (t ? {
    prefix: "fas",
    iconName: t
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function Bo() {
  return Am;
}
const Pm = () => ({
  prefix: null,
  iconName: null,
  rest: []
});
function hd(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family: t = Dt
  } = e, i = vr[t][n], a = gl[t][n] || gl[t][i], o = n in ya.styles ? n : null;
  return a || o || null;
}
const MI = {
  [Dt]: Object.keys(Cr[Dt]),
  [yi]: Object.keys(Cr[yi]),
  [bi]: Object.keys(Cr[bi])
};
function dd(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups: t = !1
  } = e, i = {
    [Dt]: "".concat(pe.cssPrefix, "-").concat(Dt),
    [yi]: "".concat(pe.cssPrefix, "-").concat(yi),
    [bi]: "".concat(pe.cssPrefix, "-").concat(bi)
  };
  let a = null, o = Dt;
  const r = IF.filter((l) => l !== QS);
  r.forEach((l) => {
    (n.includes(i[l]) || n.some((h) => MI[l].includes(h))) && (o = l);
  });
  const s = n.reduce((l, h) => {
    const d = xI(pe.cssPrefix, h);
    if (fr[h] ? (h = jI[o].includes(h) ? oI[o][h] : h, a = h, l.prefix = h) : TI[o].indexOf(h) > -1 ? (a = h, l.prefix = hd(h, {
      family: o
    })) : d ? l.iconName = d : h !== pe.replacementClass && !r.some((f) => h === i[f]) && l.rest.push(h), !t && l.prefix && l.iconName) {
      const f = a === "fa" ? gk(l.iconName) : {}, p = Do(l.prefix, l.iconName);
      f.prefix && (a = null), l.iconName = f.iconName || p || l.iconName, l.prefix = f.prefix || l.prefix, l.prefix === "far" && !fr.far && fr.fas && !pe.autoFetchSvg && (l.prefix = "fas");
    }
    return l;
  }, Pm());
  return (n.includes("fa-brands") || n.includes("fab")) && (s.prefix = "fab"), (n.includes("fa-duotone") || n.includes("fad")) && (s.prefix = "fad"), !s.prefix && o === yi && (fr.fass || pe.autoFetchSvg) && (s.prefix = "fass", s.iconName = Do(s.prefix, s.iconName) || s.iconName), !s.prefix && o === bi && (fr.fasds || pe.autoFetchSvg) && (s.prefix = "fasds", s.iconName = Do(s.prefix, s.iconName) || s.iconName), (s.prefix === "fa" || a === "fa") && (s.prefix = Bo() || "fas"), s;
}
class NI {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    const a = t.reduce(this._pullDefinitions, {});
    Object.keys(a).forEach((o) => {
      this.definitions[o] = {
        ...this.definitions[o] || {},
        ...a[o]
      }, bp(o, a[o]);
      const r = Cr[Dt][o];
      r && bp(r, a[o]), dk();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(e, t) {
    const i = t.prefix && t.iconName && t.icon ? {
      0: t
    } : t;
    return Object.keys(i).map((a) => {
      const {
        prefix: o,
        iconName: r,
        icon: s
      } = i[a], l = s[2];
      e[o] || (e[o] = {}), l.length > 0 && l.forEach((h) => {
        typeof h == "string" && (e[o][h] = s);
      }), e[o][r] = s;
    }), e;
  }
}
let h0 = [], ks = {};
const xs = {}, OI = Object.keys(xs);
function AI(n, e) {
  let {
    mixoutsTo: t
  } = e;
  return h0 = n, ks = {}, Object.keys(xs).forEach((i) => {
    OI.indexOf(i) === -1 && delete xs[i];
  }), h0.forEach((i) => {
    const a = i.mixout ? i.mixout() : {};
    if (Object.keys(a).forEach((o) => {
      typeof a[o] == "function" && (t[o] = a[o]), typeof a[o] == "object" && Object.keys(a[o]).forEach((r) => {
        t[o] || (t[o] = {}), t[o][r] = a[o][r];
      });
    }), i.hooks) {
      const o = i.hooks();
      Object.keys(o).forEach((r) => {
        ks[r] || (ks[r] = []), ks[r].push(o[r]);
      });
    }
    i.provides && i.provides(xs);
  }), t;
}
function wp(n, e) {
  for (var t = arguments.length, i = new Array(t > 2 ? t - 2 : 0), a = 2; a < t; a++)
    i[a - 2] = arguments[a];
  return (ks[n] || []).forEach((r) => {
    e = r.apply(null, [e, ...i]);
  }), e;
}
function Nr(n) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
    t[i - 1] = arguments[i];
  (ks[n] || []).forEach((o) => {
    o.apply(null, t);
  });
}
function Ho() {
  const n = arguments[0], e = Array.prototype.slice.call(arguments, 1);
  return xs[n] ? xs[n].apply(null, e) : void 0;
}
function vp(n) {
  n.prefix === "fa" && (n.prefix = "fas");
  let {
    iconName: e
  } = n;
  const t = n.prefix || Bo();
  if (e)
    return e = Do(t, e) || e, l0(fk.definitions, t, e) || l0(ya.styles, t, e);
}
const fk = new NI(), YI = () => {
  pe.autoReplaceSvg = !1, pe.observeMutations = !1, Nr("noAuto");
}, PI = {
  i2svg: function() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ro ? (Nr("beforeI2svg", n), Ho("pseudoElements2svg", n), Ho("i2svg", n)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot: e
    } = n;
    pe.autoReplaceSvg === !1 && (pe.autoReplaceSvg = !0), pe.observeMutations = !0, CI(() => {
      FI({
        autoReplaceSvgRoot: e
      }), Nr("watch", n);
    });
  }
}, RI = {
  icon: (n) => {
    if (n === null)
      return null;
    if (typeof n == "object" && n.prefix && n.iconName)
      return {
        prefix: n.prefix,
        iconName: Do(n.prefix, n.iconName) || n.iconName
      };
    if (Array.isArray(n) && n.length === 2) {
      const e = n[1].indexOf("fa-") === 0 ? n[1].slice(3) : n[1], t = hd(n[0]);
      return {
        prefix: t,
        iconName: Do(t, e) || e
      };
    }
    if (typeof n == "string" && (n.indexOf("".concat(pe.cssPrefix, "-")) > -1 || n.match(rI))) {
      const e = dd(n.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: e.prefix || Bo(),
        iconName: Do(e.prefix, e.iconName) || e.iconName
      };
    }
    if (typeof n == "string") {
      const e = Bo();
      return {
        prefix: e,
        iconName: Do(e, n) || n
      };
    }
  }
}, Ci = {
  noAuto: YI,
  config: pe,
  dom: PI,
  parse: RI,
  library: fk,
  findIconDefinition: vp,
  toHtml: Fl
}, FI = function() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot: e = Tt
  } = n;
  (Object.keys(ya.styles).length > 0 || pe.autoFetchSvg) && ro && pe.autoReplaceSvg && Ci.dom.i2svg({
    node: e
  });
};
function gd(n, e) {
  return Object.defineProperty(n, "abstract", {
    get: e
  }), Object.defineProperty(n, "html", {
    get: function() {
      return n.abstract.map((t) => Fl(t));
    }
  }), Object.defineProperty(n, "node", {
    get: function() {
      if (!ro) return;
      const t = Tt.createElement("div");
      return t.innerHTML = n.html, t.children;
    }
  }), n;
}
function II(n) {
  let {
    children: e,
    main: t,
    mask: i,
    attributes: a,
    styles: o,
    transform: r
  } = n;
  if (Om(r) && t.found && !i.found) {
    const {
      width: s,
      height: l
    } = t, h = {
      x: s / l / 2,
      y: 0.5
    };
    a.style = cd({
      ...o,
      "transform-origin": "".concat(h.x + r.x / 16, "em ").concat(h.y + r.y / 16, "em")
    });
  }
  return [{
    tag: "svg",
    attributes: a,
    children: e
  }];
}
function JI(n) {
  let {
    prefix: e,
    iconName: t,
    children: i,
    attributes: a,
    symbol: o
  } = n;
  const r = o === !0 ? "".concat(e, "-").concat(pe.cssPrefix, "-").concat(t) : o;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: {
        ...a,
        id: r
      },
      children: i
    }]
  }];
}
function Rm(n) {
  const {
    icons: {
      main: e,
      mask: t
    },
    prefix: i,
    iconName: a,
    transform: o,
    symbol: r,
    title: s,
    maskId: l,
    titleId: h,
    extra: d,
    watchable: f = !1
  } = n, {
    width: p,
    height: y
  } = t.found ? t : e, m = i === "fak", w = [pe.replacementClass, a ? "".concat(pe.cssPrefix, "-").concat(a) : ""].filter((A) => d.classes.indexOf(A) === -1).filter((A) => A !== "" || !!A).concat(d.classes).join(" ");
  let v = {
    children: [],
    attributes: {
      ...d.attributes,
      "data-prefix": i,
      "data-icon": a,
      class: w,
      role: d.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(p, " ").concat(y)
    }
  };
  const _ = m && !~d.classes.indexOf("fa-fw") ? {
    width: "".concat(p / y * 16 * 0.0625, "em")
  } : {};
  f && (v.attributes[Mr] = ""), s && (v.children.push({
    tag: "title",
    attributes: {
      id: v.attributes["aria-labelledby"] || "title-".concat(h || fl())
    },
    children: [s]
  }), delete v.attributes.title);
  const L = {
    ...v,
    prefix: i,
    iconName: a,
    main: e,
    mask: t,
    maskId: l,
    transform: o,
    symbol: r,
    styles: {
      ..._,
      ...d.styles
    }
  }, {
    children: T,
    attributes: S
  } = t.found && e.found ? Ho("generateAbstractMask", L) || {
    children: [],
    attributes: {}
  } : Ho("generateAbstractIcon", L) || {
    children: [],
    attributes: {}
  };
  return L.children = T, L.attributes = S, r ? JI(L) : II(L);
}
function d0(n) {
  const {
    content: e,
    width: t,
    height: i,
    transform: a,
    title: o,
    extra: r,
    watchable: s = !1
  } = n, l = {
    ...r.attributes,
    ...o ? {
      title: o
    } : {},
    class: r.classes.join(" ")
  };
  s && (l[Mr] = "");
  const h = {
    ...r.styles
  };
  Om(a) && (h.transform = bI({
    transform: a,
    startCentered: !0,
    width: t,
    height: i
  }), h["-webkit-transform"] = h.transform);
  const d = cd(h);
  d.length > 0 && (l.style = d);
  const f = [];
  return f.push({
    tag: "span",
    attributes: l,
    children: [e]
  }), o && f.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [o]
  }), f;
}
function ZI(n) {
  const {
    content: e,
    title: t,
    extra: i
  } = n, a = {
    ...i.attributes,
    ...t ? {
      title: t
    } : {},
    class: i.classes.join(" ")
  }, o = cd(i.styles);
  o.length > 0 && (a.style = o);
  const r = [];
  return r.push({
    tag: "span",
    attributes: a,
    children: [e]
  }), t && r.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [t]
  }), r;
}
const {
  styles: wf
} = ya;
function Cp(n) {
  const e = n[0], t = n[1], [i] = n.slice(4);
  let a = null;
  return Array.isArray(i) ? a = {
    tag: "g",
    attributes: {
      class: "".concat(pe.cssPrefix, "-").concat(mf.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(pe.cssPrefix, "-").concat(mf.SECONDARY),
        fill: "currentColor",
        d: i[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(pe.cssPrefix, "-").concat(mf.PRIMARY),
        fill: "currentColor",
        d: i[1]
      }
    }]
  } : a = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: i
    }
  }, {
    found: !0,
    width: e,
    height: t,
    icon: a
  };
}
const BI = {
  found: !1,
  width: 512,
  height: 512
};
function HI(n, e) {
  !US && !pe.showMissingIcons && n && console.error('Icon with name "'.concat(n, '" and prefix "').concat(e, '" is missing.'));
}
function Sp(n, e) {
  let t = e;
  return e === "fa" && pe.styleDefault !== null && (e = Bo()), new Promise((i, a) => {
    if (t === "fa") {
      const o = gk(n) || {};
      n = o.iconName || n, e = o.prefix || e;
    }
    if (n && e && wf[e] && wf[e][n]) {
      const o = wf[e][n];
      return i(Cp(o));
    }
    HI(n, e), i({
      ...BI,
      icon: pe.showMissingIcons && n ? Ho("missingIconAbstract") || {} : {}
    });
  });
}
const g0 = () => {
}, kp = pe.measurePerformance && Kc && Kc.mark && Kc.measure ? Kc : {
  mark: g0,
  measure: g0
}, Hu = 'FA "6.6.0"', XI = (n) => (kp.mark("".concat(Hu, " ").concat(n, " begins")), () => pk(n)), pk = (n) => {
  kp.mark("".concat(Hu, " ").concat(n, " ends")), kp.measure("".concat(Hu, " ").concat(n), "".concat(Hu, " ").concat(n, " begins"), "".concat(Hu, " ").concat(n, " ends"));
};
var Fm = {
  begin: XI,
  end: pk
};
const fh = () => {
};
function f0(n) {
  return typeof (n.getAttribute ? n.getAttribute(Mr) : null) == "string";
}
function GI(n) {
  const e = n.getAttribute ? n.getAttribute(Dm) : null, t = n.getAttribute ? n.getAttribute(Mm) : null;
  return e && t;
}
function WI(n) {
  return n && n.classList && n.classList.contains && n.classList.contains(pe.replacementClass);
}
function QI() {
  return pe.autoReplaceSvg === !0 ? ph.replace : ph[pe.autoReplaceSvg] || ph.replace;
}
function KI(n) {
  return Tt.createElementNS("http://www.w3.org/2000/svg", n);
}
function zI(n) {
  return Tt.createElement(n);
}
function mk(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn: t = n.tag === "svg" ? KI : zI
  } = e;
  if (typeof n == "string")
    return Tt.createTextNode(n);
  const i = t(n.tag);
  return Object.keys(n.attributes || []).forEach(function(o) {
    i.setAttribute(o, n.attributes[o]);
  }), (n.children || []).forEach(function(o) {
    i.appendChild(mk(o, {
      ceFn: t
    }));
  }), i;
}
function $I(n) {
  let e = " ".concat(n.outerHTML, " ");
  return e = "".concat(e, "Font Awesome fontawesome.com "), e;
}
const ph = {
  replace: function(n) {
    const e = n[0];
    if (e.parentNode)
      if (n[1].forEach((t) => {
        e.parentNode.insertBefore(mk(t), e);
      }), e.getAttribute(Mr) === null && pe.keepOriginalSource) {
        let t = Tt.createComment($I(e));
        e.parentNode.replaceChild(t, e);
      } else
        e.remove();
  },
  nest: function(n) {
    const e = n[0], t = n[1];
    if (~Nm(e).indexOf(pe.replacementClass))
      return ph.replace(n);
    const i = new RegExp("".concat(pe.cssPrefix, "-.*"));
    if (delete t[0].attributes.id, t[0].attributes.class) {
      const o = t[0].attributes.class.split(" ").reduce((r, s) => (s === pe.replacementClass || s.match(i) ? r.toSvg.push(s) : r.toNode.push(s), r), {
        toNode: [],
        toSvg: []
      });
      t[0].attributes.class = o.toSvg.join(" "), o.toNode.length === 0 ? e.removeAttribute("class") : e.setAttribute("class", o.toNode.join(" "));
    }
    const a = t.map((o) => Fl(o)).join(`
`);
    e.setAttribute(Mr, ""), e.innerHTML = a;
  }
};
function p0(n) {
  n();
}
function yk(n, e) {
  const t = typeof e == "function" ? e : fh;
  if (n.length === 0)
    t();
  else {
    let i = p0;
    pe.mutateApproach === iI && (i = Zo.requestAnimationFrame || p0), i(() => {
      const a = QI(), o = Fm.begin("mutate");
      n.map(a), o(), t();
    });
  }
}
let Im = !1;
function bk() {
  Im = !0;
}
function _p() {
  Im = !1;
}
let Th = null;
function m0(n) {
  if (!a0 || !pe.observeMutations)
    return;
  const {
    treeCallback: e = fh,
    nodeCallback: t = fh,
    pseudoElementsCallback: i = fh,
    observeMutationsRoot: a = Tt
  } = n;
  Th = new a0((o) => {
    if (Im) return;
    const r = Bo();
    nu(o).forEach((s) => {
      if (s.type === "childList" && s.addedNodes.length > 0 && !f0(s.addedNodes[0]) && (pe.searchPseudoElements && i(s.target), e(s.target)), s.type === "attributes" && s.target.parentNode && pe.searchPseudoElements && i(s.target.parentNode), s.type === "attributes" && f0(s.target) && ~lI.indexOf(s.attributeName))
        if (s.attributeName === "class" && GI(s.target)) {
          const {
            prefix: l,
            iconName: h
          } = dd(Nm(s.target));
          s.target.setAttribute(Dm, l || r), h && s.target.setAttribute(Mm, h);
        } else WI(s.target) && t(s.target);
    });
  }), ro && Th.observe(a, {
    childList: !0,
    attributes: !0,
    characterData: !0,
    subtree: !0
  });
}
function VI() {
  Th && Th.disconnect();
}
function UI(n) {
  const e = n.getAttribute("style");
  let t = [];
  return e && (t = e.split(";").reduce((i, a) => {
    const o = a.split(":"), r = o[0], s = o.slice(1);
    return r && s.length > 0 && (i[r] = s.join(":").trim()), i;
  }, {})), t;
}
function qI(n) {
  const e = n.getAttribute("data-prefix"), t = n.getAttribute("data-icon"), i = n.innerText !== void 0 ? n.innerText.trim() : "";
  let a = dd(Nm(n));
  return a.prefix || (a.prefix = Bo()), e && t && (a.prefix = e, a.iconName = t), a.iconName && a.prefix || (a.prefix && i.length > 0 && (a.iconName = EI(a.prefix, n.innerText) || Ym(a.prefix, yp(n.innerText))), !a.iconName && pe.autoFetchSvg && n.firstChild && n.firstChild.nodeType === Node.TEXT_NODE && (a.iconName = n.firstChild.data)), a;
}
function eJ(n) {
  const e = nu(n.attributes).reduce((a, o) => (a.name !== "class" && a.name !== "style" && (a[o.name] = o.value), a), {}), t = n.getAttribute("title"), i = n.getAttribute("data-fa-title-id");
  return pe.autoA11y && (t ? e["aria-labelledby"] = "".concat(pe.replacementClass, "-title-").concat(i || fl()) : (e["aria-hidden"] = "true", e.focusable = "false")), e;
}
function tJ() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: ma,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function y0(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  };
  const {
    iconName: t,
    prefix: i,
    rest: a
  } = qI(n), o = eJ(n), r = wp("parseNodeAttributes", {}, n);
  let s = e.styleParser ? UI(n) : [];
  return {
    iconName: t,
    title: n.getAttribute("title"),
    titleId: n.getAttribute("data-fa-title-id"),
    prefix: i,
    transform: ma,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: a,
      styles: s,
      attributes: o
    },
    ...r
  };
}
const {
  styles: nJ
} = ya;
function wk(n) {
  const e = pe.autoReplaceSvg === "nest" ? y0(n, {
    styleParser: !1
  }) : y0(n);
  return ~e.extra.classes.indexOf(tk) ? Ho("generateLayersText", n, e) : Ho("generateSvgReplacementMutation", n, e);
}
let Sa = /* @__PURE__ */ new Set();
qS.map((n) => {
  Sa.add("fa-".concat(n));
});
Object.keys(vr[Dt]).map(Sa.add.bind(Sa));
Object.keys(vr[yi]).map(Sa.add.bind(Sa));
Object.keys(vr[bi]).map(Sa.add.bind(Sa));
Sa = [...Sa];
function b0(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!ro) return Promise.resolve();
  const t = Tt.documentElement.classList, i = (d) => t.add("".concat(s0, "-").concat(d)), a = (d) => t.remove("".concat(s0, "-").concat(d)), o = pe.autoFetchSvg ? Sa : qS.map((d) => "fa-".concat(d)).concat(Object.keys(nJ));
  o.includes("fa") || o.push("fa");
  const r = [".".concat(tk, ":not([").concat(Mr, "])")].concat(o.map((d) => ".".concat(d, ":not([").concat(Mr, "])"))).join(", ");
  if (r.length === 0)
    return Promise.resolve();
  let s = [];
  try {
    s = nu(n.querySelectorAll(r));
  } catch {
  }
  if (s.length > 0)
    i("pending"), a("complete");
  else
    return Promise.resolve();
  const l = Fm.begin("onTree"), h = s.reduce((d, f) => {
    try {
      const p = wk(f);
      p && d.push(p);
    } catch (p) {
      US || p.name === "MissingIcon" && console.error(p);
    }
    return d;
  }, []);
  return new Promise((d, f) => {
    Promise.all(h).then((p) => {
      yk(p, () => {
        i("active"), i("complete"), a("pending"), typeof e == "function" && e(), l(), d();
      });
    }).catch((p) => {
      l(), f(p);
    });
  });
}
function iJ(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  wk(n).then((t) => {
    t && yk([t], e);
  });
}
function aJ(n) {
  return function(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = (e || {}).icon ? e : vp(e || {});
    let {
      mask: a
    } = t;
    return a && (a = (a || {}).icon ? a : vp(a || {})), n(i, {
      ...t,
      mask: a
    });
  };
}
const oJ = function(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: t = ma,
    symbol: i = !1,
    mask: a = null,
    maskId: o = null,
    title: r = null,
    titleId: s = null,
    classes: l = [],
    attributes: h = {},
    styles: d = {}
  } = e;
  if (!n) return;
  const {
    prefix: f,
    iconName: p,
    icon: y
  } = n;
  return gd({
    type: "icon",
    ...n
  }, () => (Nr("beforeDOMElementCreation", {
    iconDefinition: n,
    params: e
  }), pe.autoA11y && (r ? h["aria-labelledby"] = "".concat(pe.replacementClass, "-title-").concat(s || fl()) : (h["aria-hidden"] = "true", h.focusable = "false")), Rm({
    icons: {
      main: Cp(y),
      mask: a ? Cp(a.icon) : {
        found: !1,
        width: null,
        height: null,
        icon: {}
      }
    },
    prefix: f,
    iconName: p,
    transform: {
      ...ma,
      ...t
    },
    symbol: i,
    title: r,
    maskId: o,
    titleId: s,
    extra: {
      attributes: h,
      styles: d,
      classes: l
    }
  })));
};
var rJ = {
  mixout() {
    return {
      icon: aJ(oJ)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(n) {
        return n.treeCallback = b0, n.nodeCallback = iJ, n;
      }
    };
  },
  provides(n) {
    n.i2svg = function(e) {
      const {
        node: t = Tt,
        callback: i = () => {
        }
      } = e;
      return b0(t, i);
    }, n.generateSvgReplacementMutation = function(e, t) {
      const {
        iconName: i,
        title: a,
        titleId: o,
        prefix: r,
        transform: s,
        symbol: l,
        mask: h,
        maskId: d,
        extra: f
      } = t;
      return new Promise((p, y) => {
        Promise.all([Sp(i, r), h.iconName ? Sp(h.iconName, h.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then((m) => {
          let [w, v] = m;
          p([e, Rm({
            icons: {
              main: w,
              mask: v
            },
            prefix: r,
            iconName: i,
            transform: s,
            symbol: l,
            maskId: d,
            title: a,
            titleId: o,
            extra: f,
            watchable: !0
          })]);
        }).catch(y);
      });
    }, n.generateAbstractIcon = function(e) {
      let {
        children: t,
        attributes: i,
        main: a,
        transform: o,
        styles: r
      } = e;
      const s = cd(r);
      s.length > 0 && (i.style = s);
      let l;
      return Om(o) && (l = Ho("generateAbstractTransformGrouping", {
        main: a,
        transform: o,
        containerWidth: a.width,
        iconWidth: a.width
      })), t.push(l || a.icon), {
        children: t,
        attributes: i
      };
    };
  }
}, sJ = {
  mixout() {
    return {
      layer(n) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes: t = []
        } = e;
        return gd({
          type: "layer"
        }, () => {
          Nr("beforeDOMElementCreation", {
            assembler: n,
            params: e
          });
          let i = [];
          return n((a) => {
            Array.isArray(a) ? a.map((o) => {
              i = i.concat(o.abstract);
            }) : i = i.concat(a.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(pe.cssPrefix, "-layers"), ...t].join(" ")
            },
            children: i
          }];
        });
      }
    };
  }
}, uJ = {
  mixout() {
    return {
      counter(n) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title: t = null,
          classes: i = [],
          attributes: a = {},
          styles: o = {}
        } = e;
        return gd({
          type: "counter",
          content: n
        }, () => (Nr("beforeDOMElementCreation", {
          content: n,
          params: e
        }), ZI({
          content: n.toString(),
          title: t,
          extra: {
            attributes: a,
            styles: o,
            classes: ["".concat(pe.cssPrefix, "-layers-counter"), ...i]
          }
        })));
      }
    };
  }
}, lJ = {
  mixout() {
    return {
      text(n) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: t = ma,
          title: i = null,
          classes: a = [],
          attributes: o = {},
          styles: r = {}
        } = e;
        return gd({
          type: "text",
          content: n
        }, () => (Nr("beforeDOMElementCreation", {
          content: n,
          params: e
        }), d0({
          content: n,
          transform: {
            ...ma,
            ...t
          },
          title: i,
          extra: {
            attributes: o,
            styles: r,
            classes: ["".concat(pe.cssPrefix, "-layers-text"), ...a]
          }
        })));
      }
    };
  },
  provides(n) {
    n.generateLayersText = function(e, t) {
      const {
        title: i,
        transform: a,
        extra: o
      } = t;
      let r = null, s = null;
      if (WS) {
        const l = parseInt(getComputedStyle(e).fontSize, 10), h = e.getBoundingClientRect();
        r = h.width / l, s = h.height / l;
      }
      return pe.autoA11y && !i && (o.attributes["aria-hidden"] = "true"), Promise.resolve([e, d0({
        content: e.innerHTML,
        width: r,
        height: s,
        transform: a,
        title: i,
        extra: o,
        watchable: !0
      })]);
    };
  }
};
const cJ = new RegExp('"', "ug"), w0 = [1105920, 1112319], v0 = {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  },
  ...GF,
  ...XF,
  ...qF
}, jp = Object.keys(v0).reduce((n, e) => (n[e.toLowerCase()] = v0[e], n), {}), hJ = Object.keys(jp).reduce((n, e) => {
  const t = jp[e];
  return n[e] = t[900] || [...Object.entries(t)][0][1], n;
}, {});
function dJ(n) {
  const e = n.replace(cJ, ""), t = kI(e, 0), i = t >= w0[0] && t <= w0[1], a = e.length === 2 ? e[0] === e[1] : !1;
  return {
    value: yp(a ? e[0] : e),
    isSecondary: i || a
  };
}
function gJ(n, e) {
  const t = n.replace(/^['"]|['"]$/g, "").toLowerCase(), i = parseInt(e), a = isNaN(i) ? "normal" : i;
  return (jp[t] || {})[a] || hJ[t];
}
function C0(n, e) {
  const t = "".concat(nI).concat(e.replace(":", "-"));
  return new Promise((i, a) => {
    if (n.getAttribute(t) !== null)
      return i();
    const r = nu(n.children).filter((p) => p.getAttribute(gp) === e)[0], s = Zo.getComputedStyle(n, e), l = s.getPropertyValue("font-family"), h = l.match(sI), d = s.getPropertyValue("font-weight"), f = s.getPropertyValue("content");
    if (r && !h)
      return n.removeChild(r), i();
    if (h && f !== "none" && f !== "") {
      const p = s.getPropertyValue("content");
      let y = gJ(l, d);
      const {
        value: m,
        isSecondary: w
      } = dJ(p), v = h[0].startsWith("FontAwesome");
      let _ = Ym(y, m), L = _;
      if (v) {
        const T = DI(m);
        T.iconName && T.prefix && (_ = T.iconName, y = T.prefix);
      }
      if (_ && !w && (!r || r.getAttribute(Dm) !== y || r.getAttribute(Mm) !== L)) {
        n.setAttribute(t, L), r && n.removeChild(r);
        const T = tJ(), {
          extra: S
        } = T;
        S.attributes[gp] = e, Sp(_, y).then((A) => {
          const x = Rm({
            ...T,
            icons: {
              main: A,
              mask: Pm()
            },
            prefix: y,
            iconName: L,
            extra: S,
            watchable: !0
          }), M = Tt.createElementNS("http://www.w3.org/2000/svg", "svg");
          e === "::before" ? n.insertBefore(M, n.firstChild) : n.appendChild(M), M.outerHTML = x.map((P) => Fl(P)).join(`
`), n.removeAttribute(t), i();
        }).catch(a);
      } else
        i();
    } else
      i();
  });
}
function fJ(n) {
  return Promise.all([C0(n, "::before"), C0(n, "::after")]);
}
function pJ(n) {
  return n.parentNode !== document.head && !~aI.indexOf(n.tagName.toUpperCase()) && !n.getAttribute(gp) && (!n.parentNode || n.parentNode.tagName !== "svg");
}
function S0(n) {
  if (ro)
    return new Promise((e, t) => {
      const i = nu(n.querySelectorAll("*")).filter(pJ).map(fJ), a = Fm.begin("searchPseudoElements");
      bk(), Promise.all(i).then(() => {
        a(), _p(), e();
      }).catch(() => {
        a(), _p(), t();
      });
    });
}
var mJ = {
  hooks() {
    return {
      mutationObserverCallbacks(n) {
        return n.pseudoElementsCallback = S0, n;
      }
    };
  },
  provides(n) {
    n.pseudoElements2svg = function(e) {
      const {
        node: t = Tt
      } = e;
      pe.searchPseudoElements && S0(t);
    };
  }
};
let k0 = !1;
var yJ = {
  mixout() {
    return {
      dom: {
        unwatch() {
          bk(), k0 = !0;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        m0(wp("mutationObserverCallbacks", {}));
      },
      noAuto() {
        VI();
      },
      watch(n) {
        const {
          observeMutationsRoot: e
        } = n;
        k0 ? _p() : m0(wp("mutationObserverCallbacks", {
          observeMutationsRoot: e
        }));
      }
    };
  }
};
const _0 = (n) => {
  let e = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return n.toLowerCase().split(" ").reduce((t, i) => {
    const a = i.toLowerCase().split("-"), o = a[0];
    let r = a.slice(1).join("-");
    if (o && r === "h")
      return t.flipX = !0, t;
    if (o && r === "v")
      return t.flipY = !0, t;
    if (r = parseFloat(r), isNaN(r))
      return t;
    switch (o) {
      case "grow":
        t.size = t.size + r;
        break;
      case "shrink":
        t.size = t.size - r;
        break;
      case "left":
        t.x = t.x - r;
        break;
      case "right":
        t.x = t.x + r;
        break;
      case "up":
        t.y = t.y - r;
        break;
      case "down":
        t.y = t.y + r;
        break;
      case "rotate":
        t.rotate = t.rotate + r;
        break;
    }
    return t;
  }, e);
};
var bJ = {
  mixout() {
    return {
      parse: {
        transform: (n) => _0(n)
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(n, e) {
        const t = e.getAttribute("data-fa-transform");
        return t && (n.transform = _0(t)), n;
      }
    };
  },
  provides(n) {
    n.generateAbstractTransformGrouping = function(e) {
      let {
        main: t,
        transform: i,
        containerWidth: a,
        iconWidth: o
      } = e;
      const r = {
        transform: "translate(".concat(a / 2, " 256)")
      }, s = "translate(".concat(i.x * 32, ", ").concat(i.y * 32, ") "), l = "scale(".concat(i.size / 16 * (i.flipX ? -1 : 1), ", ").concat(i.size / 16 * (i.flipY ? -1 : 1), ") "), h = "rotate(".concat(i.rotate, " 0 0)"), d = {
        transform: "".concat(s, " ").concat(l, " ").concat(h)
      }, f = {
        transform: "translate(".concat(o / 2 * -1, " -256)")
      }, p = {
        outer: r,
        inner: d,
        path: f
      };
      return {
        tag: "g",
        attributes: {
          ...p.outer
        },
        children: [{
          tag: "g",
          attributes: {
            ...p.inner
          },
          children: [{
            tag: t.icon.tag,
            children: t.icon.children,
            attributes: {
              ...t.icon.attributes,
              ...p.path
            }
          }]
        }]
      };
    };
  }
};
const vf = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function j0(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return n.attributes && (n.attributes.fill || e) && (n.attributes.fill = "black"), n;
}
function wJ(n) {
  return n.tag === "g" ? n.children : [n];
}
var vJ = {
  hooks() {
    return {
      parseNodeAttributes(n, e) {
        const t = e.getAttribute("data-fa-mask"), i = t ? dd(t.split(" ").map((a) => a.trim())) : Pm();
        return i.prefix || (i.prefix = Bo()), n.mask = i, n.maskId = e.getAttribute("data-fa-mask-id"), n;
      }
    };
  },
  provides(n) {
    n.generateAbstractMask = function(e) {
      let {
        children: t,
        attributes: i,
        main: a,
        mask: o,
        maskId: r,
        transform: s
      } = e;
      const {
        width: l,
        icon: h
      } = a, {
        width: d,
        icon: f
      } = o, p = yI({
        transform: s,
        containerWidth: d,
        iconWidth: l
      }), y = {
        tag: "rect",
        attributes: {
          ...vf,
          fill: "white"
        }
      }, m = h.children ? {
        children: h.children.map(j0)
      } : {}, w = {
        tag: "g",
        attributes: {
          ...p.inner
        },
        children: [j0({
          tag: h.tag,
          attributes: {
            ...h.attributes,
            ...p.path
          },
          ...m
        })]
      }, v = {
        tag: "g",
        attributes: {
          ...p.outer
        },
        children: [w]
      }, _ = "mask-".concat(r || fl()), L = "clip-".concat(r || fl()), T = {
        tag: "mask",
        attributes: {
          ...vf,
          id: _,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        },
        children: [y, v]
      }, S = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: L
          },
          children: wJ(f)
        }, T]
      };
      return t.push(S, {
        tag: "rect",
        attributes: {
          fill: "currentColor",
          "clip-path": "url(#".concat(L, ")"),
          mask: "url(#".concat(_, ")"),
          ...vf
        }
      }), {
        children: t,
        attributes: i
      };
    };
  }
}, CJ = {
  provides(n) {
    let e = !1;
    Zo.matchMedia && (e = Zo.matchMedia("(prefers-reduced-motion: reduce)").matches), n.missingIconAbstract = function() {
      const t = [], i = {
        fill: "currentColor"
      }, a = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      t.push({
        tag: "path",
        attributes: {
          ...i,
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        }
      });
      const o = {
        ...a,
        attributeName: "opacity"
      }, r = {
        tag: "circle",
        attributes: {
          ...i,
          cx: "256",
          cy: "364",
          r: "28"
        },
        children: []
      };
      return e || r.children.push({
        tag: "animate",
        attributes: {
          ...a,
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        }
      }, {
        tag: "animate",
        attributes: {
          ...o,
          values: "1;0;1;1;0;1;"
        }
      }), t.push(r), t.push({
        tag: "path",
        attributes: {
          ...i,
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        },
        children: e ? [] : [{
          tag: "animate",
          attributes: {
            ...o,
            values: "1;0;0;0;0;1;"
          }
        }]
      }), e || t.push({
        tag: "path",
        attributes: {
          ...i,
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        },
        children: [{
          tag: "animate",
          attributes: {
            ...o,
            values: "0;0;1;1;0;0;"
          }
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: t
      };
    };
  }
}, SJ = {
  hooks() {
    return {
      parseNodeAttributes(n, e) {
        const t = e.getAttribute("data-fa-symbol"), i = t === null ? !1 : t === "" ? !0 : t;
        return n.symbol = i, n;
      }
    };
  }
}, kJ = [vI, rJ, sJ, uJ, lJ, mJ, yJ, bJ, vJ, CJ, SJ];
AI(kJ, {
  mixoutsTo: Ci
});
Ci.noAuto;
const vk = Ci.config;
Ci.library;
Ci.dom;
const Lh = Ci.parse;
Ci.findIconDefinition;
Ci.toHtml;
const _J = Ci.icon;
Ci.layer;
const jJ = Ci.text;
Ci.counter;
function T0(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e && (i = i.filter(function(a) {
      return Object.getOwnPropertyDescriptor(n, a).enumerable;
    })), t.push.apply(t, i);
  }
  return t;
}
function Vi(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? T0(Object(t), !0).forEach(function(i) {
      zn(n, i, t[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : T0(Object(t)).forEach(function(i) {
      Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
    });
  }
  return n;
}
function TJ(n, e) {
  if (typeof n != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || "default");
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function LJ(n) {
  var e = TJ(n, "string");
  return typeof e == "symbol" ? e : e + "";
}
function xh(n) {
  "@babel/helpers - typeof";
  return xh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, xh(n);
}
function zn(n, e, t) {
  return e = LJ(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function xJ(n, e) {
  if (n == null) return {};
  var t = {};
  for (var i in n)
    if (Object.prototype.hasOwnProperty.call(n, i)) {
      if (e.indexOf(i) >= 0) continue;
      t[i] = n[i];
    }
  return t;
}
function EJ(n, e) {
  if (n == null) return {};
  var t = xJ(n, e), i, a;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(n);
    for (a = 0; a < o.length; a++)
      i = o[a], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(n, i) && (t[i] = n[i]);
  }
  return t;
}
function Tp(n) {
  return DJ(n) || MJ(n) || NJ(n) || OJ();
}
function DJ(n) {
  if (Array.isArray(n)) return Lp(n);
}
function MJ(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n);
}
function NJ(n, e) {
  if (n) {
    if (typeof n == "string") return Lp(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set") return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return Lp(n, e);
  }
}
function Lp(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t];
  return i;
}
function OJ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var AJ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ck = { exports: {} };
(function(n) {
  (function(e) {
    var t = function(_, L, T) {
      if (!h(L) || f(L) || p(L) || y(L) || l(L))
        return L;
      var S, A = 0, x = 0;
      if (d(L))
        for (S = [], x = L.length; A < x; A++)
          S.push(t(_, L[A], T));
      else {
        S = {};
        for (var M in L)
          Object.prototype.hasOwnProperty.call(L, M) && (S[_(M, T)] = t(_, L[M], T));
      }
      return S;
    }, i = function(_, L) {
      L = L || {};
      var T = L.separator || "_", S = L.split || /(?=[A-Z])/;
      return _.split(S).join(T);
    }, a = function(_) {
      return m(_) ? _ : (_ = _.replace(/[\-_\s]+(.)?/g, function(L, T) {
        return T ? T.toUpperCase() : "";
      }), _.substr(0, 1).toLowerCase() + _.substr(1));
    }, o = function(_) {
      var L = a(_);
      return L.substr(0, 1).toUpperCase() + L.substr(1);
    }, r = function(_, L) {
      return i(_, L).toLowerCase();
    }, s = Object.prototype.toString, l = function(_) {
      return typeof _ == "function";
    }, h = function(_) {
      return _ === Object(_);
    }, d = function(_) {
      return s.call(_) == "[object Array]";
    }, f = function(_) {
      return s.call(_) == "[object Date]";
    }, p = function(_) {
      return s.call(_) == "[object RegExp]";
    }, y = function(_) {
      return s.call(_) == "[object Boolean]";
    }, m = function(_) {
      return _ = _ - 0, _ === _;
    }, w = function(_, L) {
      var T = L && "process" in L ? L.process : L;
      return typeof T != "function" ? _ : function(S, A) {
        return T(S, _, A);
      };
    }, v = {
      camelize: a,
      decamelize: r,
      pascalize: o,
      depascalize: r,
      camelizeKeys: function(_, L) {
        return t(w(a, L), _);
      },
      decamelizeKeys: function(_, L) {
        return t(w(r, L), _, L);
      },
      pascalizeKeys: function(_, L) {
        return t(w(o, L), _);
      },
      depascalizeKeys: function() {
        return this.decamelizeKeys.apply(this, arguments);
      }
    };
    n.exports ? n.exports = v : e.humps = v;
  })(AJ);
})(Ck);
var YJ = Ck.exports, PJ = ["class", "style"];
function RJ(n) {
  return n.split(";").map(function(e) {
    return e.trim();
  }).filter(function(e) {
    return e;
  }).reduce(function(e, t) {
    var i = t.indexOf(":"), a = YJ.camelize(t.slice(0, i)), o = t.slice(i + 1).trim();
    return e[a] = o, e;
  }, {});
}
function FJ(n) {
  return n.split(/\s+/).reduce(function(e, t) {
    return e[t] = !0, e;
  }, {});
}
function Jm(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof n == "string")
    return n;
  var i = (n.children || []).map(function(l) {
    return Jm(l);
  }), a = Object.keys(n.attributes || {}).reduce(function(l, h) {
    var d = n.attributes[h];
    switch (h) {
      case "class":
        l.class = FJ(d);
        break;
      case "style":
        l.style = RJ(d);
        break;
      default:
        l.attrs[h] = d;
    }
    return l;
  }, {
    attrs: {},
    class: {},
    style: {}
  });
  t.class;
  var o = t.style, r = o === void 0 ? {} : o, s = EJ(t, PJ);
  return ao(n.tag, Vi(Vi(Vi({}, e), {}, {
    class: a.class,
    style: Vi(Vi({}, a.style), r)
  }, a.attrs), s), i);
}
var Sk = !1;
try {
  Sk = process.env.NODE_ENV === "production";
} catch {
}
function IJ() {
  if (!Sk && console && typeof console.error == "function") {
    var n;
    (n = console).error.apply(n, arguments);
  }
}
function Uu(n, e) {
  return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? zn({}, n, e) : {};
}
function JJ(n) {
  var e, t = (e = {
    "fa-spin": n.spin,
    "fa-pulse": n.pulse,
    "fa-fw": n.fixedWidth,
    "fa-border": n.border,
    "fa-li": n.listItem,
    "fa-inverse": n.inverse,
    "fa-flip": n.flip === !0,
    "fa-flip-horizontal": n.flip === "horizontal" || n.flip === "both",
    "fa-flip-vertical": n.flip === "vertical" || n.flip === "both"
  }, zn(zn(zn(zn(zn(zn(zn(zn(zn(zn(e, "fa-".concat(n.size), n.size !== null), "fa-rotate-".concat(n.rotation), n.rotation !== null), "fa-pull-".concat(n.pull), n.pull !== null), "fa-swap-opacity", n.swapOpacity), "fa-bounce", n.bounce), "fa-shake", n.shake), "fa-beat", n.beat), "fa-fade", n.fade), "fa-beat-fade", n.beatFade), "fa-flash", n.flash), zn(zn(e, "fa-spin-pulse", n.spinPulse), "fa-spin-reverse", n.spinReverse));
  return Object.keys(t).map(function(i) {
    return t[i] ? i : null;
  }).filter(function(i) {
    return i;
  });
}
function L0(n) {
  if (n && xh(n) === "object" && n.prefix && n.iconName && n.icon)
    return n;
  if (Lh.icon)
    return Lh.icon(n);
  if (n === null)
    return null;
  if (xh(n) === "object" && n.prefix && n.iconName)
    return n;
  if (Array.isArray(n) && n.length === 2)
    return {
      prefix: n[0],
      iconName: n[1]
    };
  if (typeof n == "string")
    return {
      prefix: "fas",
      iconName: n
    };
}
var ZJ = Xe({
  name: "FontAwesomeIcon",
  props: {
    border: {
      type: Boolean,
      default: !1
    },
    fixedWidth: {
      type: Boolean,
      default: !1
    },
    flip: {
      type: [Boolean, String],
      default: !1,
      validator: function(e) {
        return [!0, !1, "horizontal", "vertical", "both"].indexOf(e) > -1;
      }
    },
    icon: {
      type: [Object, Array, String],
      required: !0
    },
    mask: {
      type: [Object, Array, String],
      default: null
    },
    maskId: {
      type: String,
      default: null
    },
    listItem: {
      type: Boolean,
      default: !1
    },
    pull: {
      type: String,
      default: null,
      validator: function(e) {
        return ["right", "left"].indexOf(e) > -1;
      }
    },
    pulse: {
      type: Boolean,
      default: !1
    },
    rotation: {
      type: [String, Number],
      default: null,
      validator: function(e) {
        return [90, 180, 270].indexOf(Number.parseInt(e, 10)) > -1;
      }
    },
    swapOpacity: {
      type: Boolean,
      default: !1
    },
    size: {
      type: String,
      default: null,
      validator: function(e) {
        return ["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(e) > -1;
      }
    },
    spin: {
      type: Boolean,
      default: !1
    },
    transform: {
      type: [String, Object],
      default: null
    },
    symbol: {
      type: [Boolean, String],
      default: !1
    },
    title: {
      type: String,
      default: null
    },
    titleId: {
      type: String,
      default: null
    },
    inverse: {
      type: Boolean,
      default: !1
    },
    bounce: {
      type: Boolean,
      default: !1
    },
    shake: {
      type: Boolean,
      default: !1
    },
    beat: {
      type: Boolean,
      default: !1
    },
    fade: {
      type: Boolean,
      default: !1
    },
    beatFade: {
      type: Boolean,
      default: !1
    },
    flash: {
      type: Boolean,
      default: !1
    },
    spinPulse: {
      type: Boolean,
      default: !1
    },
    spinReverse: {
      type: Boolean,
      default: !1
    }
  },
  setup: function(e, t) {
    var i = t.attrs, a = wt(function() {
      return L0(e.icon);
    }), o = wt(function() {
      return Uu("classes", JJ(e));
    }), r = wt(function() {
      return Uu("transform", typeof e.transform == "string" ? Lh.transform(e.transform) : e.transform);
    }), s = wt(function() {
      return Uu("mask", L0(e.mask));
    }), l = wt(function() {
      return _J(a.value, Vi(Vi(Vi(Vi({}, o.value), r.value), s.value), {}, {
        symbol: e.symbol,
        title: e.title,
        titleId: e.titleId,
        maskId: e.maskId
      }));
    });
    Ua(l, function(d) {
      if (!d)
        return IJ("Could not find one or more icon(s)", a.value, s.value);
    }, {
      immediate: !0
    });
    var h = wt(function() {
      return l.value ? Jm(l.value.abstract[0], {}, i) : null;
    });
    return function() {
      return h.value;
    };
  }
});
Xe({
  name: "FontAwesomeLayers",
  props: {
    fixedWidth: {
      type: Boolean,
      default: !1
    }
  },
  setup: function(e, t) {
    var i = t.slots, a = vk.familyPrefix, o = wt(function() {
      return ["".concat(a, "-layers")].concat(Tp(e.fixedWidth ? ["".concat(a, "-fw")] : []));
    });
    return function() {
      return ao("div", {
        class: o.value
      }, i.default ? i.default() : []);
    };
  }
});
Xe({
  name: "FontAwesomeLayersText",
  props: {
    value: {
      type: [String, Number],
      default: ""
    },
    transform: {
      type: [String, Object],
      default: null
    },
    counter: {
      type: Boolean,
      default: !1
    },
    position: {
      type: String,
      default: null,
      validator: function(e) {
        return ["bottom-left", "bottom-right", "top-left", "top-right"].indexOf(e) > -1;
      }
    }
  },
  setup: function(e, t) {
    var i = t.attrs, a = vk.familyPrefix, o = wt(function() {
      return Uu("classes", [].concat(Tp(e.counter ? ["".concat(a, "-layers-counter")] : []), Tp(e.position ? ["".concat(a, "-layers-").concat(e.position)] : [])));
    }), r = wt(function() {
      return Uu("transform", typeof e.transform == "string" ? Lh.transform(e.transform) : e.transform);
    }), s = wt(function() {
      var h = jJ(e.value.toString(), Vi(Vi({}, r.value), o.value)), d = h.abstract;
      return e.counter && (d[0].attributes.class = d[0].attributes.class.replace("fa-layers-text", "")), d[0];
    }), l = wt(function() {
      return Jm(s.value, {}, i);
    });
    return function() {
      return l.value;
    };
  }
});
const BJ = {
  prefix: "fas",
  iconName: "file-lines",
  icon: [384, 512, [128441, 128462, 61686, "file-alt", "file-text"], "f15c", "M64 0C28.7 0 0 28.7 0 64L0 448c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-288-128 0c-17.7 0-32-14.3-32-32L224 0 64 0zM256 0l0 128 128 0L256 0zM112 256l160 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-160 0c-8.8 0-16-7.2-16-16s7.2-16 16-16zm0 64l160 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-160 0c-8.8 0-16-7.2-16-16s7.2-16 16-16zm0 64l160 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-160 0c-8.8 0-16-7.2-16-16s7.2-16 16-16z"]
}, HJ = BJ, XJ = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
}, GJ = {
  prefix: "fas",
  iconName: "square-plus",
  icon: [448, 512, [61846, "plus-square"], "f0fe", "M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM200 344l0-64-64 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l64 0 0-64c0-13.3 10.7-24 24-24s24 10.7 24 24l0 64 64 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-64 0 0 64c0 13.3-10.7 24-24 24s-24-10.7-24-24z"]
}, WJ = GJ, QJ = {
  prefix: "fas",
  iconName: "rotate-left",
  icon: [512, 512, ["rotate-back", "rotate-backward", "undo-alt"], "f2ea", "M48.5 224L40 224c-13.3 0-24-10.7-24-24L16 72c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2L98.6 96.6c87.6-86.5 228.7-86.2 315.8 1c87.5 87.5 87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3c-62.2-62.2-162.7-62.5-225.3-1L185 183c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8L48.5 224z"]
}, KJ = {
  prefix: "fas",
  iconName: "arrow-right",
  icon: [448, 512, [8594], "f061", "M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"]
}, zJ = {
  prefix: "fas",
  iconName: "text-width",
  icon: [448, 512, [], "f035", "M64 128l0-32 128 0 0 128-16 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-16 0 0-128 128 0 0 32c0 17.7 14.3 32 32 32s32-14.3 32-32l0-48c0-26.5-21.5-48-48-48L224 32 48 32C21.5 32 0 53.5 0 80l0 48c0 17.7 14.3 32 32 32s32-14.3 32-32zM9.4 361.4c-12.5 12.5-12.5 32.8 0 45.3l64 64c9.2 9.2 22.9 11.9 34.9 6.9s19.8-16.6 19.8-29.6l0-32 192 0 0 32c0 12.9 7.8 24.6 19.8 29.6s25.7 2.2 34.9-6.9l64-64c12.5-12.5 12.5-32.8 0-45.3l-64-64c-9.2-9.2-22.9-11.9-34.9-6.9s-19.8 16.6-19.8 29.6l0 32-192 0 0-32c0-12.9-7.8-24.6-19.8-29.6s-25.7-2.2-34.9 6.9l-64 64z"]
}, $J = {
  prefix: "fas",
  iconName: "arrow-left",
  icon: [448, 512, [8592], "f060", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"]
}, VJ = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
}, UJ = VJ, qJ = {
  prefix: "fas",
  iconName: "rotate-right",
  icon: [512, 512, ["redo-alt", "rotate-forward"], "f2f9", "M463.5 224l8.5 0c13.3 0 24-10.7 24-24l0-128c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96.6c-87.6-86.5-228.7-86.2-315.8 1c-87.5 87.5-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3c62.2-62.2 162.7-62.5 225.3-1L327 183c-6.9 6.9-8.9 17.2-5.2 26.2s12.5 14.8 22.2 14.8l119.5 0z"]
}, eZ = {
  prefix: "fas",
  iconName: "arrow-down",
  icon: [384, 512, [8595], "f063", "M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
}, tZ = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
}, nZ = tZ, iZ = {
  prefix: "fas",
  iconName: "arrow-up",
  icon: [384, 512, [8593], "f062", "M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2 160 448c0 17.7 14.3 32 32 32s32-14.3 32-32l0-306.7L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z"]
}, aZ = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
}, oZ = aZ, rZ = {
  prefix: "fas",
  iconName: "map",
  icon: [576, 512, [128506, 62072], "f279", "M384 476.1L192 421.2l0-385.3L384 90.8l0 385.3zm32-1.2l0-386.5L543.1 37.5c15.8-6.3 32.9 5.3 32.9 22.3l0 334.8c0 9.8-6 18.6-15.1 22.3L416 474.8zM15.1 95.1L160 37.2l0 386.5L32.9 474.5C17.1 480.8 0 469.2 0 452.2L0 117.4c0-9.8 6-18.6 15.1-22.3z"]
}, sZ = {
  prefix: "fas",
  iconName: "clock-rotate-left",
  icon: [512, 512, ["history"], "f1da", "M75 75L41 41C25.9 25.9 0 36.6 0 57.9L0 168c0 13.3 10.7 24 24 24l110.1 0c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24l0 104c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65 0-94.1c0-13.3-10.7-24-24-24z"]
}, uZ = sZ, gi = /* @__PURE__ */ Xe({
  __name: "BaseIcon",
  props: {
    icon: {
      type: String
    }
  },
  setup(n) {
    const e = {
      "fa-bars": XJ,
      "fa-text-width": zJ,
      "fa-search": nZ,
      "fa-history": uZ,
      "fa-plus-square": WJ,
      "fa-cog": UJ,
      "fa-file-text": HJ,
      "fa-rotate-left": QJ,
      "fa-rotate-right": qJ,
      "fa-map": rZ,
      "fa-close": oZ,
      "fa-arrow-left": $J,
      "fa-arrow-right": KJ,
      "fa-arrow-down": eZ,
      "fa-arrow-up": iZ
    };
    return (t, i) => (q(), ln(I(ZJ), {
      icon: e[n.icon]
    }, null, 8, ["icon"]));
  }
}), lZ = { class: "flex items-center p-3 gap-3" }, cZ = { class: "ml-auto gap-1 flex" }, hZ = /* @__PURE__ */ Xe({
  __name: "TheHeader",
  setup(n) {
    const {
      drawer: e,
      modal: t,
      mapHistory: i,
      controlCombo: a
    } = qt(), { patron: o, guest: r } = vi(), s = i.isNextPossible(new qe()).ref(), l = i.isPrevPossible(new qe()).ref();
    return a.happened(
      "KeyZ",
      o.create(r.create(() => {
        l.value && i.prev();
      }))
    ), a.happened(
      "KeyP",
      o.create(r.create(() => {
        s.value && i.next();
      }))
    ), (h, d) => (q(), ie("div", lZ, [
      V(FF, { class: "TheHeader-Breadcrumbs" }),
      ae("div", cZ, [
        I(s) ? (q(), ln(kt, {
          key: 0,
          size: "sm",
          title: "ÐžÑ‚Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ",
          class: "w-7 block",
          onClick: d[0] || (d[0] = (f) => I(i).next())
        }, {
          default: se(() => [
            V(gi, { icon: "fa-rotate-left" })
          ]),
          _: 1
        })) : tt("", !0),
        I(l) ? (q(), ln(kt, {
          key: 1,
          size: "sm",
          title: "Ð’ÐµÑ€Ð½ÑƒÑ‚ÑŒ Ð¾Ñ‚Ð¼ÐµÐ½ÐµÐ½Ð½Ð¾Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ",
          class: "w-7 block",
          onClick: d[1] || (d[1] = (f) => I(i).prev())
        }, {
          default: se(() => [
            V(gi, { icon: "fa-rotate-right" })
          ]),
          _: 1
        })) : tt("", !0),
        V(kt, {
          type: "success",
          size: "sm",
          class: "w-7 block e2e-open-menu",
          title: h.$t("general.menu"),
          onClick: d[2] || (d[2] = (f) => I(e).give("menu"))
        }, {
          default: se(() => [
            V(gi, { icon: "fa-bars" })
          ]),
          _: 1
        }, 8, ["title"]),
        V(kt, {
          title: h.$t("general.byText"),
          type: "primary",
          size: "sm",
          class: "w-7 block",
          onClick: d[3] || (d[3] = (f) => I(t).give("mapAsText"))
        }, {
          default: se(() => [
            V(gi, { icon: "fa-text-width" })
          ]),
          _: 1
        }, 8, ["title"]),
        V(kt, {
          class: "w-7 block e2e-search",
          size: "sm",
          onClick: d[4] || (d[4] = (f) => I(t).give("search"))
        }, {
          default: se(() => [
            V(gi, { icon: "fa-search" })
          ]),
          _: 1
        }),
        V(kt, {
          size: "sm",
          title: "Ð’ÑÐµ ÐºÐ°Ñ€Ñ‚Ñ‹ Ñ„Ð°Ð¹Ð»Ð°",
          class: "w-7 block",
          onClick: d[5] || (d[5] = (f) => I(e).give("fileMaps"))
        }, {
          default: se(() => [
            V(gi, { icon: "fa-map" })
          ]),
          _: 1
        })
      ])
    ]));
  }
}), fd = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [i, a] of e)
    t[i] = a;
  return t;
}, dZ = {}, gZ = { class: "BaseGroup" };
function fZ(n, e) {
  return q(), ie("div", gZ, [
    Ri(n.$slots, "default")
  ]);
}
const pZ = /* @__PURE__ */ fd(dZ, [["render", fZ]]), mZ = "default", yZ = /* @__PURE__ */ Xe({
  __name: "TheLinker",
  setup(n) {
    const { mapObjectsLink: e } = qt(), t = e.objectIds(new qe([])).ref();
    return (i, a) => (q(), ln(kt, {
      type: mZ,
      onClick: a[0] || (a[0] = (o) => I(e).startLink())
    }, {
      default: se(() => [
        Ue(we(I(t).length === 1 ? "Ð’Ñ‹Ð±Ð¸Ñ€ÐµÑ‚Ð¸Ðµ Ð¾Ð±ÑŠÐµÐºÑ‚" : I(t).length === 2 ? "Ð’Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð¾Ð±ÑŠÐµÐºÑ‚" : "Ð¡Ð²ÑÐ·Ð°Ñ‚ÑŒ Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹"), 1)
      ]),
      _: 1
    }));
  }
}), bZ = { class: "flex e2e-sidebar flex-col items-center gap-3 max-h-[100%] overflow-hidden" }, wZ = { class: "flex flex-col gap-3 flex-grow w-full overflow-y-auto" }, vZ = { class: "TheSideBar-ItemName" }, CZ = ["innerHTML", "title", "onDragend"], SZ = { class: "flex gap-1" }, kZ = { class: "mt-auto w-full p-3 pt-0" }, _Z = /* @__PURE__ */ Xe({
  __name: "TheSideBar",
  setup(n) {
    const {
      mapObjectNew: e,
      mapCurrent: t,
      mapTypeCurrent: i,
      mapTypeRemoved: a,
      mapTypeNew: o,
      modal: r
    } = qt(), s = t.types(new qe()).ref(), { svgMapTypeImage: l } = vi(), h = wt(() => {
      var d;
      return (d = s.value) == null ? void 0 : d.map((f) => ({
        type: f,
        image: l.create(f).markup()
      })).sort((f, p) => +(f.type.name >= p.type.name));
    });
    return (d, f) => (q(), ie("div", bZ, [
      ae("div", wZ, [
        (q(!0), ie(Ht, null, Un(h.value, (p, y) => (q(), ie("div", {
          key: y,
          class: "flex flex-col items-center justify-center gap-2"
        }, [
          ae("div", vZ, we(p.type.name), 1),
          ae("div", {
            innerHTML: p.image,
            class: "TheSideBar-ItemImage",
            draggable: "true",
            style: pa(`width:${p.type.width}px;height:${p.type.height}px`),
            title: d.$t("general.notifications.dragToCanvasToAdd"),
            onDragend: (m) => I(e).byTypeName(p.type.id, m)
          }, null, 44, CZ),
          ae("div", SZ, [
            V(kt, {
              class: "text-white",
              size: "sm",
              type: "primary",
              onClick: (m) => I(i).give(p.type.id)
            }, {
              default: se(() => [
                Ue(we(d.$t("general.change")), 1)
              ]),
              _: 2
            }, 1032, ["onClick"]),
            V(kt, {
              class: "text-white",
              size: "sm",
              type: "danger",
              onClick: (m) => I(a).give(p.type)
            }, {
              default: se(() => [
                Ue(we(d.$t("general.delete")), 1)
              ]),
              _: 2
            }, 1032, ["onClick"])
          ])
        ]))), 128))
      ]),
      ae("div", kZ, [
        V(pZ, { class: "mb-1 grid gap-1 grid-cols-2" }, {
          default: se(() => [
            V(kt, {
              title: d.$t("general.addType"),
              type: "success",
              onClick: f[0] || (f[0] = (p) => I(o).byName())
            }, {
              default: se(() => [
                V(gi, { icon: "fa-plus-square" })
              ]),
              _: 1
            }, 8, ["title"]),
            V(kt, {
              class: "e2e-show-settings",
              title: d.$t("general.settings"),
              type: "primary",
              onClick: f[1] || (f[1] = (p) => I(r).give("settings"))
            }, {
              default: se(() => [
                V(gi, { icon: "fa-cog" })
              ]),
              _: 1
            }, 8, ["title"])
          ]),
          _: 1
        }),
        V(yZ, { class: "w-[100%] block mb-1" })
      ])
    ]));
  }
}), Cf = Ie.debug("MapObjectsWithTemplates");
class jZ {
  constructor(e, t, i) {
    this.mapObjects = e, this.map = t, this.factories = i;
  }
  objects(e) {
    const t = this.factories.chain.create();
    return this.map.types(this.factories.guestCast.create(e, t.receiveKey("types"))), this.mapObjects.objects(this.factories.guestCast.create(e, t.receiveKey("objects"))), t.result(
      this.factories.guestInTheMiddle.create(e, ({ types: i, objects: a }) => {
        Cf("visible objects", a);
        const o = a.map((r) => {
          const s = i.find((h) => String(h.id) === String(r.type));
          if (Cf("check type existed", s), !s)
            return {
              obj: r,
              template: ""
            };
          let { svg: l } = s;
          return Cf("type svg", l), r.additionalFields && Object.entries(r.additionalFields).forEach(([h, d]) => {
            l = l.replaceAll(`\${${h}}`, d);
          }), ["width", "height"].forEach((h) => {
            l = l.replaceAll(`\${${h}}`, r[h]);
          }), {
            obj: r,
            template: l
          };
        });
        e.give(o);
      })
    ), e;
  }
}
const TZ = /* @__PURE__ */ Xe({
  __name: "BaseNotify",
  setup(n) {
    const { notification: e } = qt(), t = e.message(new qe()).ref();
    return (i, a) => I(t) && I(t).text !== "hide" ? (q(), ie("div", {
      key: 0,
      class: va(["inline font-bold", `text-${I(t).type}-second`])
    }, we(I(t).text), 3)) : tt("", !0);
  }
});
class Zm {
  constructor(e) {
    xe(this, "pool", new eS(this));
    this.refSource = e, Ua(
      e,
      (t) => {
        t !== void 0 && this.pool.give(t);
      },
      {
        deep: !0
      }
    );
  }
  value(e) {
    return this.refSource.value && e.give(this.refSource.value), this.pool.add(e), this;
  }
}
const LZ = { class: "relative" }, xZ = { class: "absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden z-1" }, EZ = { class: "text-sm z-10 p-2 absolute bottom-0 left-5" }, DZ = ["title"], MZ = { class: "font-bold" }, NZ = ["title"], OZ = { class: "font-bold" }, AZ = ["title"], YZ = { class: "font-bold" }, PZ = ["title"], RZ = { class: "font-bold" }, FZ = ["data-object-id"], IZ = { class: "absolute bottom-[100%] left-[50%] translate-x-[-50%] text-center pb-2 pointer-events-auto text-sm w-[300px]" }, JZ = ["innerHTML", "onClick"], ZZ = ["innerHTML"], BZ = ["data-object-id", "innerHTML"], HZ = /* @__PURE__ */ Xe({
  __name: "TheEditor",
  setup(n) {
    const {
      canvas: e,
      mapObjectsVisible: t,
      mapCurrent: i,
      konvaLayer: a,
      fps: o,
      mapCurrentID: r,
      mapObjectUrl: s,
      stageSize: l,
      objectsOutsideScreen: h,
      stagePositionByObjectId: d,
      mapCurrentSource: f
    } = qt(), p = vi(), y = o.value(new qe()).ref(), w = new jZ(
      t,
      i,
      p
    ).objects(new qe([])).ref(), v = l.value(new qe()).ref(), _ = a.position(new qe()).ref(), L = wt(() => {
      var re;
      return (re = v.value) == null ? void 0 : re.width;
    }), T = new Zm(L), S = p.numberChunks.create(10, T).chunks(new qe()).ref(), A = vn();
    Vs(() => {
      e.give(A.value);
    });
    const x = (re) => {
      s.open(re, p.guest.create((me) => {
        r.give(me);
      }));
    }, M = h.count(
      { axis: "x", direction: "negative" },
      new qe()
    ).ref(), P = h.count(
      { axis: "x", direction: "positive" },
      new qe()
    ).ref(), Y = h.count(
      { axis: "y", direction: "negative" },
      new qe()
    ).ref(), te = h.count(
      { axis: "y", direction: "positive" },
      new qe()
    ).ref(), ge = d.move.bind(d, f);
    return (re, me) => {
      var ut, ht, ze, Ge, Ae, It, xt, ft, gt, Kt, Jt, pt;
      return q(), ie("div", LZ, [
        ae("div", xZ, [
          ae("div", EZ, [
            Ue(" Ð’Ð¸Ð´Ð¸Ð¼Ñ‹Ñ… Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð²: " + we(I(w).length) + ", FPS: " + we(I(y)) + ", ", 1),
            V(TZ)
          ]),
          me[4] || (me[4] = gA('<div class="absolute bottom-3 shadow-standard-second shadow-md drop-shadow right-3 z-10"><div class="grid-example grid grid-rows-2 grid-cols-2 bg-standard-second border border-standard-second gap-[1px] border-t-0 border-l-0"><div class="w-[14px] h-[14px] bg-white"></div><div class="w-[14px] h-[14px] bg-white"></div><div class="w-[14px] h-[14px] bg-white"></div><div class="w-[14px] h-[14px] bg-white"></div></div></div><div class="absolute z-30 top-0 left-0 h-[18px] w-[22px] bg-white"></div>', 2)),
          ((ut = I(M)) == null ? void 0 : ut.count) > 0 ? (q(), ie("div", {
            key: 0,
            class: "pointer-events-auto absolute z-30 top-0 left-4 h-[18px] bg-white flex items-center gap-1 text-body-dark text-sm cursor-pointer",
            title: `${(ht = I(M)) == null ? void 0 : ht.count} ÑˆÑ‚. Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð² Ð»ÐµÐ²ÐµÐµ`,
            onClick: me[0] || (me[0] = (Ee) => I(ge)(I(M).nearestObjectId))
          }, [
            V(gi, { icon: "fa-arrow-left" }),
            ae("span", MZ, we((ze = I(M)) == null ? void 0 : ze.count), 1)
          ], 8, DZ)) : tt("", !0),
          ((Ge = I(P)) == null ? void 0 : Ge.count) > 0 ? (q(), ie("div", {
            key: 1,
            class: "pointer-events-auto absolute z-30 p-1 top-0 right-0 h-[18px] bg-white flex items-center gap-1 text-body-dark text-sm cursor-pointer",
            title: `${(Ae = I(P)) == null ? void 0 : Ae.count} ÑˆÑ‚. Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð² Ð¿Ñ€Ð°Ð²ÐµÐµ`,
            onClick: me[1] || (me[1] = (Ee) => I(ge)(I(P).nearestObjectId))
          }, [
            ae("span", OZ, we((It = I(P)) == null ? void 0 : It.count), 1),
            V(gi, { icon: "fa-arrow-right" })
          ], 8, NZ)) : tt("", !0),
          ((xt = I(Y)) == null ? void 0 : xt.count) > 0 ? (q(), ie("div", {
            key: 2,
            class: "pointer-events-auto absolute z-30 top-[18px] left-0 w-[18px] bg-white flex flex-col leading-4 items-center gap-1 text-body-dark text-sm cursor-pointer",
            title: `${(ft = I(Y)) == null ? void 0 : ft.count} ÑˆÑ‚. Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð² Ð²Ñ‹ÑˆÐµ`,
            onClick: me[2] || (me[2] = (Ee) => I(ge)(I(Y).nearestObjectId))
          }, [
            V(gi, { icon: "fa-arrow-up" }),
            ae("span", YZ, we((gt = I(Y)) == null ? void 0 : gt.count), 1)
          ], 8, AZ)) : tt("", !0),
          ((Kt = I(te)) == null ? void 0 : Kt.count) > 0 ? (q(), ie("div", {
            key: 3,
            class: "pointer-events-auto absolute z-30 p-1 bottom-0 left-0 w-[18px] bg-white flex flex-col-reverse leading-4 items-center gap-1 text-body-dark text-sm cursor-pointer",
            title: `${(Jt = I(te)) == null ? void 0 : Jt.count} ÑˆÑ‚. Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð² Ð½Ð¸Ð¶Ðµ`,
            onClick: me[3] || (me[3] = (Ee) => I(ge)(I(te).nearestObjectId))
          }, [
            V(gi, { icon: "fa-arrow-down" }),
            ae("span", RZ, we((pt = I(te)) == null ? void 0 : pt.count), 1)
          ], 8, PZ)) : tt("", !0),
          ae("div", {
            class: va({ "objects-container absolute top-0 left-0": !0 }),
            style: pa({ width: `${I(v).width}px`, height: `${I(v).height}px`, transform: `translate(${I(_).x}px, ${I(_).y}px)` })
          }, [
            ae("div", {
              class: "absolute flex top-0 left-0 w-full z-20 h-[20px] bg-default border-b-2 border-border text-right text-sm px-2",
              style: pa({ transform: `translate(0, ${-I(_).y}px)` })
            }, [
              (q(!0), ie(Ht, null, Un(I(S), (Ee) => (q(), ie("span", {
                class: "flex-1 text-body-dark",
                key: `horiz_${Ee}`
              }, we(Ee) + "px", 1))), 128))
            ], 4),
            ae("div", {
              class: "absolute flex [writing-mode:vertical-lr] top-0 left-0 h-full z-20 w-[20px] bg-default border-r-2 border-border text-left text-sm py-2",
              style: pa({ transform: `translate(${-I(_).x}px, 0)` })
            }, [
              (q(!0), ie(Ht, null, Un(I(S), (Ee) => (q(), ie("span", {
                class: "flex-1 rotate-180 text-body-dark",
                key: `vert_${Ee}`
              }, we(Ee) + "px", 1))), 128))
            ], 4),
            (q(!0), ie(Ht, null, Un(I(w), (Ee) => (q(), ie("div", {
              key: Ee.obj.id,
              class: "absolute z-10",
              "data-object-id": Ee.obj.id,
              style: pa(`width:${Ee.obj.width}px;height: ${Ee.obj.height}px;top: ${Ee.obj.position[1]}px;left:${Ee.obj.position[0]}px;z-index:${Ee.obj.zindex}`)
            }, [
              ae("div", IZ, [
                ae("span", {
                  innerHTML: Ee.obj.additionalName,
                  class: va([Ee.obj.linked && "cursor-pointer underline"]),
                  onClick: (xn) => x(Ee.obj)
                }, null, 10, JZ)
              ]),
              ae("div", {
                class: "absolute top-[100%] left-[50%] translate-x-[-50%] text-center pt-2 text-sm w-[300px]",
                innerHTML: Ee.obj.name
              }, null, 8, ZZ),
              ae("div", {
                "data-object-id": Ee.obj.id,
                class: "rendered-object",
                innerHTML: Ee.template
              }, null, 8, BZ)
            ], 12, FZ))), 128))
          ], 4)
        ]),
        ae("div", {
          class: "h-full",
          ref_key: "canvasWrapper",
          ref: A
        }, null, 512)
      ]);
    };
  }
}), XZ = { key: 1 }, GZ = /* @__PURE__ */ Xe({
  __name: "TheMiniMap",
  setup(n) {
    const { miniMap: e } = qt(), t = e.points(new qe()).ref(), i = e.size(new qe()).ref(), a = e.viewportSize(new qe()).ref(), o = e.viewportPosition(new qe()).ref();
    return (r, s) => I(i) ? (q(), ie("div", {
      key: 0,
      style: pa({
        width: `${I(i).width}px`,
        height: `${I(i).height}px`
      }),
      class: "absolute pointer-events-none block bg-white bottom-[10px] mt-3 right-3 z-1 border border-solid border-body-dark"
    }, [
      I(o) ? (q(), ie("div", {
        key: 0,
        style: pa({
          width: `${I(a).width}px`,
          height: `${I(a).height}px`,
          top: `${I(o).y}px`,
          left: `${I(o).x}px`
        }),
        class: "absolute bg-primary/50"
      }, null, 4)) : tt("", !0),
      I(t) ? (q(), ie("div", XZ, [
        (q(!0), ie(Ht, null, Un(I(t), (l) => (q(), ie("div", {
          key: l.id,
          class: "absolute w-1 h-1 block bg-danger",
          style: pa({
            top: `${l.y}px`,
            left: `${l.x}px`,
            width: `${l.width}px`,
            height: `${l.height}px`
          })
        }, null, 4))), 128))
      ])) : tt("", !0)
    ], 4)) : tt("", !0);
  }
});
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function WZ(n) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const t of n.split(",")) e[t] = 1;
  return (t) => t in e;
}
const ha = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
process.env.NODE_ENV !== "production" && Object.freeze([]);
const Es = () => {
}, QZ = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // uppercase letter
(n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), Ji = Object.assign, KZ = Object.prototype.hasOwnProperty, Gt = (n, e) => KZ.call(n, e), Yt = Array.isArray, Ds = (n) => pd(n) === "[object Map]", zZ = (n) => pd(n) === "[object Set]", rn = (n) => typeof n == "function", na = (n) => typeof n == "string", Il = (n) => typeof n == "symbol", ia = (n) => n !== null && typeof n == "object", $Z = (n) => (ia(n) || rn(n)) && rn(n.then) && rn(n.catch), VZ = Object.prototype.toString, pd = (n) => VZ.call(n), kk = (n) => pd(n).slice(8, -1), UZ = (n) => pd(n) === "[object Object]", Bm = (n) => na(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, qZ = (n) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = n(t));
}, eB = qZ((n) => n.charAt(0).toUpperCase() + n.slice(1)), Ao = (n, e) => !Object.is(n, e), tB = (n, e, t, i = !1) => {
  Object.defineProperty(n, e, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: t
  });
};
let x0;
const md = () => x0 || (x0 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Hm(n) {
  if (Yt(n)) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
      const i = n[t], a = na(i) ? oB(i) : Hm(i);
      if (a)
        for (const o in a)
          e[o] = a[o];
    }
    return e;
  } else if (na(n) || ia(n))
    return n;
}
const nB = /;(?![^(]*\))/g, iB = /:([^]+)/, aB = /\/\*[^]*?\*\//g;
function oB(n) {
  const e = {};
  return n.replace(aB, "").split(nB).forEach((t) => {
    if (t) {
      const i = t.split(iB);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Xm(n) {
  let e = "";
  if (na(n))
    e = n;
  else if (Yt(n))
    for (let t = 0; t < n.length; t++) {
      const i = Xm(n[t]);
      i && (e += i + " ");
    }
  else if (ia(n))
    for (const t in n)
      n[t] && (e += t + " ");
  return e.trim();
}
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function to(n, ...e) {
  console.warn(`[Vue warn] ${n}`, ...e);
}
let ct;
const Sf = /* @__PURE__ */ new WeakSet();
class rB {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0;
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Sf.has(this) && (Sf.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || jk(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, E0(this), Tk(this);
    const e = ct, t = qi;
    ct = this, qi = !0;
    try {
      return this.fn();
    } finally {
      process.env.NODE_ENV !== "production" && ct !== this && to(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), Lk(this), ct = e, qi = t, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Qm(e);
      this.deps = this.depsTail = void 0, E0(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Sf.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    xp(this) && this.run();
  }
  get dirty() {
    return xp(this);
  }
}
let _k = 0, qu, el;
function jk(n, e = !1) {
  if (n.flags |= 8, e) {
    n.next = el, el = n;
    return;
  }
  n.next = qu, qu = n;
}
function Gm() {
  _k++;
}
function Wm() {
  if (--_k > 0)
    return;
  if (el) {
    let e = el;
    for (el = void 0; e; ) {
      const t = e.next;
      e.next = void 0, e.flags &= -9, e = t;
    }
  }
  let n;
  for (; qu; ) {
    let e = qu;
    for (qu = void 0; e; ) {
      const t = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (i) {
          n || (n = i);
        }
      e = t;
    }
  }
  if (n) throw n;
}
function Tk(n) {
  for (let e = n.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function Lk(n) {
  let e, t = n.depsTail, i = t;
  for (; i; ) {
    const a = i.prevDep;
    i.version === -1 ? (i === t && (t = a), Qm(i), sB(i)) : e = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = a;
  }
  n.deps = e, n.depsTail = t;
}
function xp(n) {
  for (let e = n.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (xk(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!n._dirty;
}
function xk(n) {
  if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17, n.globalVersion === pl))
    return;
  n.globalVersion = pl;
  const e = n.dep;
  if (n.flags |= 2, e.version > 0 && !n.isSSR && n.deps && !xp(n)) {
    n.flags &= -3;
    return;
  }
  const t = ct, i = qi;
  ct = n, qi = !0;
  try {
    Tk(n);
    const a = n.fn(n._value);
    (e.version === 0 || Ao(a, n._value)) && (n._value = a, e.version++);
  } catch (a) {
    throw e.version++, a;
  } finally {
    ct = t, qi = i, Lk(n), n.flags &= -3;
  }
}
function Qm(n, e = !1) {
  const { dep: t, prevSub: i, nextSub: a } = n;
  if (i && (i.nextSub = a, n.prevSub = void 0), a && (a.prevSub = i, n.nextSub = void 0), process.env.NODE_ENV !== "production" && t.subsHead === n && (t.subsHead = a), t.subs === n && (t.subs = i, !i && t.computed)) {
    t.computed.flags &= -5;
    for (let o = t.computed.deps; o; o = o.nextDep)
      Qm(o, !0);
  }
  !e && !--t.sc && t.map && t.map.delete(t.key);
}
function sB(n) {
  const { prevDep: e, nextDep: t } = n;
  e && (e.nextDep = t, n.prevDep = void 0), t && (t.prevDep = e, n.nextDep = void 0);
}
let qi = !0;
const Ek = [];
function yd() {
  Ek.push(qi), qi = !1;
}
function bd() {
  const n = Ek.pop();
  qi = n === void 0 ? !0 : n;
}
function E0(n) {
  const { cleanup: e } = n;
  if (n.cleanup = void 0, e) {
    const t = ct;
    ct = void 0;
    try {
      e();
    } finally {
      ct = t;
    }
  }
}
let pl = 0;
class uB {
  constructor(e, t) {
    this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Km {
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, process.env.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(e) {
    if (!ct || !qi || ct === this.computed)
      return;
    let t = this.activeLink;
    if (t === void 0 || t.sub !== ct)
      t = this.activeLink = new uB(ct, this), ct.deps ? (t.prevDep = ct.depsTail, ct.depsTail.nextDep = t, ct.depsTail = t) : ct.deps = ct.depsTail = t, Dk(t);
    else if (t.version === -1 && (t.version = this.version, t.nextDep)) {
      const i = t.nextDep;
      i.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = i), t.prevDep = ct.depsTail, t.nextDep = void 0, ct.depsTail.nextDep = t, ct.depsTail = t, ct.deps === t && (ct.deps = i);
    }
    return process.env.NODE_ENV !== "production" && ct.onTrack && ct.onTrack(
      Ji(
        {
          effect: ct
        },
        e
      )
    ), t;
  }
  trigger(e) {
    this.version++, pl++, this.notify(e);
  }
  notify(e) {
    Gm();
    try {
      if (process.env.NODE_ENV !== "production")
        for (let t = this.subsHead; t; t = t.nextSub)
          t.sub.onTrigger && !(t.sub.flags & 8) && t.sub.onTrigger(
            Ji(
              {
                effect: t.sub
              },
              e
            )
          );
      for (let t = this.subs; t; t = t.prevSub)
        t.sub.notify() && t.sub.dep.notify();
    } finally {
      Wm();
    }
  }
}
function Dk(n) {
  if (n.dep.sc++, n.sub.flags & 4) {
    const e = n.dep.computed;
    if (e && !n.dep.subs) {
      e.flags |= 20;
      for (let i = e.deps; i; i = i.nextDep)
        Dk(i);
    }
    const t = n.dep.subs;
    t !== n && (n.prevSub = t, t && (t.nextSub = n)), process.env.NODE_ENV !== "production" && n.dep.subsHead === void 0 && (n.dep.subsHead = n), n.dep.subs = n;
  }
}
const Ep = /* @__PURE__ */ new WeakMap(), Sr = Symbol(
  process.env.NODE_ENV !== "production" ? "Object iterate" : ""
), Dp = Symbol(
  process.env.NODE_ENV !== "production" ? "Map keys iterate" : ""
), ml = Symbol(
  process.env.NODE_ENV !== "production" ? "Array iterate" : ""
);
function an(n, e, t) {
  if (qi && ct) {
    let i = Ep.get(n);
    i || Ep.set(n, i = /* @__PURE__ */ new Map());
    let a = i.get(t);
    a || (i.set(t, a = new Km()), a.map = i, a.key = t), process.env.NODE_ENV !== "production" ? a.track({
      target: n,
      type: e,
      key: t
    }) : a.track();
  }
}
function Lo(n, e, t, i, a, o) {
  const r = Ep.get(n);
  if (!r) {
    pl++;
    return;
  }
  const s = (l) => {
    l && (process.env.NODE_ENV !== "production" ? l.trigger({
      target: n,
      type: e,
      key: t,
      newValue: i,
      oldValue: a,
      oldTarget: o
    }) : l.trigger());
  };
  if (Gm(), e === "clear")
    r.forEach(s);
  else {
    const l = Yt(n), h = l && Bm(t);
    if (l && t === "length") {
      const d = Number(i);
      r.forEach((f, p) => {
        (p === "length" || p === ml || !Il(p) && p >= d) && s(f);
      });
    } else
      switch ((t !== void 0 || r.has(void 0)) && s(r.get(t)), h && s(r.get(ml)), e) {
        case "add":
          l ? h && s(r.get("length")) : (s(r.get(Sr)), Ds(n) && s(r.get(Dp)));
          break;
        case "delete":
          l || (s(r.get(Sr)), Ds(n) && s(r.get(Dp)));
          break;
        case "set":
          Ds(n) && s(r.get(Sr));
          break;
      }
  }
  Wm();
}
function cs(n) {
  const e = at(n);
  return e === n ? e : (an(e, "iterate", ml), ea(n) ? e : e.map(Pn));
}
function zm(n) {
  return an(n = at(n), "iterate", ml), n;
}
const lB = {
  __proto__: null,
  [Symbol.iterator]() {
    return kf(this, Symbol.iterator, Pn);
  },
  concat(...n) {
    return cs(this).concat(
      ...n.map((e) => Yt(e) ? cs(e) : e)
    );
  },
  entries() {
    return kf(this, "entries", (n) => (n[1] = Pn(n[1]), n));
  },
  every(n, e) {
    return Ia(this, "every", n, e, void 0, arguments);
  },
  filter(n, e) {
    return Ia(this, "filter", n, e, (t) => t.map(Pn), arguments);
  },
  find(n, e) {
    return Ia(this, "find", n, e, Pn, arguments);
  },
  findIndex(n, e) {
    return Ia(this, "findIndex", n, e, void 0, arguments);
  },
  findLast(n, e) {
    return Ia(this, "findLast", n, e, Pn, arguments);
  },
  findLastIndex(n, e) {
    return Ia(this, "findLastIndex", n, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(n, e) {
    return Ia(this, "forEach", n, e, void 0, arguments);
  },
  includes(...n) {
    return _f(this, "includes", n);
  },
  indexOf(...n) {
    return _f(this, "indexOf", n);
  },
  join(n) {
    return cs(this).join(n);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...n) {
    return _f(this, "lastIndexOf", n);
  },
  map(n, e) {
    return Ia(this, "map", n, e, void 0, arguments);
  },
  pop() {
    return Ou(this, "pop");
  },
  push(...n) {
    return Ou(this, "push", n);
  },
  reduce(n, ...e) {
    return D0(this, "reduce", n, e);
  },
  reduceRight(n, ...e) {
    return D0(this, "reduceRight", n, e);
  },
  shift() {
    return Ou(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(n, e) {
    return Ia(this, "some", n, e, void 0, arguments);
  },
  splice(...n) {
    return Ou(this, "splice", n);
  },
  toReversed() {
    return cs(this).toReversed();
  },
  toSorted(n) {
    return cs(this).toSorted(n);
  },
  toSpliced(...n) {
    return cs(this).toSpliced(...n);
  },
  unshift(...n) {
    return Ou(this, "unshift", n);
  },
  values() {
    return kf(this, "values", Pn);
  }
};
function kf(n, e, t) {
  const i = zm(n), a = i[e]();
  return i !== n && !ea(n) && (a._next = a.next, a.next = () => {
    const o = a._next();
    return o.value && (o.value = t(o.value)), o;
  }), a;
}
const cB = Array.prototype;
function Ia(n, e, t, i, a, o) {
  const r = zm(n), s = r !== n && !ea(n), l = r[e];
  if (l !== cB[e]) {
    const f = l.apply(n, o);
    return s ? Pn(f) : f;
  }
  let h = t;
  r !== n && (s ? h = function(f, p) {
    return t.call(this, Pn(f), p, n);
  } : t.length > 2 && (h = function(f, p) {
    return t.call(this, f, p, n);
  }));
  const d = l.call(r, h, i);
  return s && a ? a(d) : d;
}
function D0(n, e, t, i) {
  const a = zm(n);
  let o = t;
  return a !== n && (ea(n) ? t.length > 3 && (o = function(r, s, l) {
    return t.call(this, r, s, l, n);
  }) : o = function(r, s, l) {
    return t.call(this, r, Pn(s), l, n);
  }), a[e](o, ...i);
}
function _f(n, e, t) {
  const i = at(n);
  an(i, "iterate", ml);
  const a = i[e](...t);
  return (a === -1 || a === !1) && Eh(t[0]) ? (t[0] = at(t[0]), i[e](...t)) : a;
}
function Ou(n, e, t = []) {
  yd(), Gm();
  const i = at(n)[e].apply(n, t);
  return Wm(), bd(), i;
}
const hB = /* @__PURE__ */ WZ("__proto__,__v_isRef,__isVue"), Mk = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(Il)
);
function dB(n) {
  Il(n) || (n = String(n));
  const e = at(this);
  return an(e, "has", n), e.hasOwnProperty(n);
}
class Nk {
  constructor(e = !1, t = !1) {
    this._isReadonly = e, this._isShallow = t;
  }
  get(e, t, i) {
    if (t === "__v_skip") return e.__v_skip;
    const a = this._isReadonly, o = this._isShallow;
    if (t === "__v_isReactive")
      return !a;
    if (t === "__v_isReadonly")
      return a;
    if (t === "__v_isShallow")
      return o;
    if (t === "__v_raw")
      return i === (a ? o ? Pk : Yk : o ? SB : Ak).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
    const r = Yt(e);
    if (!a) {
      let l;
      if (r && (l = lB[t]))
        return l;
      if (t === "hasOwnProperty")
        return dB;
    }
    const s = Reflect.get(
      e,
      t,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      qn(e) ? e : i
    );
    return (Il(t) ? Mk.has(t) : hB(t)) || (a || an(e, "get", t), o) ? s : qn(s) ? r && Bm(t) ? s : s.value : ia(s) ? a ? Fk(s) : Rk(s) : s;
  }
}
class gB extends Nk {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, t, i, a) {
    let o = e[t];
    if (!this._isShallow) {
      const l = Or(o);
      if (!ea(i) && !Or(i) && (o = at(o), i = at(i)), !Yt(e) && qn(o) && !qn(i))
        return l ? !1 : (o.value = i, !0);
    }
    const r = Yt(e) && Bm(t) ? Number(t) < e.length : Gt(e, t), s = Reflect.set(
      e,
      t,
      i,
      qn(e) ? e : a
    );
    return e === at(a) && (r ? Ao(i, o) && Lo(e, "set", t, i, o) : Lo(e, "add", t, i)), s;
  }
  deleteProperty(e, t) {
    const i = Gt(e, t), a = e[t], o = Reflect.deleteProperty(e, t);
    return o && i && Lo(e, "delete", t, void 0, a), o;
  }
  has(e, t) {
    const i = Reflect.has(e, t);
    return (!Il(t) || !Mk.has(t)) && an(e, "has", t), i;
  }
  ownKeys(e) {
    return an(
      e,
      "iterate",
      Yt(e) ? "length" : Sr
    ), Reflect.ownKeys(e);
  }
}
class Ok extends Nk {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, t) {
    return process.env.NODE_ENV !== "production" && to(
      `Set operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  }
  deleteProperty(e, t) {
    return process.env.NODE_ENV !== "production" && to(
      `Delete operation on key "${String(t)}" failed: target is readonly.`,
      e
    ), !0;
  }
}
const fB = /* @__PURE__ */ new gB(), pB = /* @__PURE__ */ new Ok(), mB = /* @__PURE__ */ new Ok(!0), Mp = (n) => n, zc = (n) => Reflect.getPrototypeOf(n);
function yB(n, e, t) {
  return function(...i) {
    const a = this.__v_raw, o = at(a), r = Ds(o), s = n === "entries" || n === Symbol.iterator && r, l = n === "keys" && r, h = a[n](...i), d = t ? Mp : e ? Np : Pn;
    return !e && an(
      o,
      "iterate",
      l ? Dp : Sr
    ), {
      // iterator protocol
      next() {
        const { value: f, done: p } = h.next();
        return p ? { value: f, done: p } : {
          value: s ? [d(f[0]), d(f[1])] : d(f),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function $c(n) {
  return function(...e) {
    if (process.env.NODE_ENV !== "production") {
      const t = e[0] ? `on key "${e[0]}" ` : "";
      to(
        `${eB(n)} operation ${t}failed: target is readonly.`,
        at(this)
      );
    }
    return n === "delete" ? !1 : n === "clear" ? void 0 : this;
  };
}
function bB(n, e) {
  const t = {
    get(a) {
      const o = this.__v_raw, r = at(o), s = at(a);
      n || (Ao(a, s) && an(r, "get", a), an(r, "get", s));
      const { has: l } = zc(r), h = e ? Mp : n ? Np : Pn;
      if (l.call(r, a))
        return h(o.get(a));
      if (l.call(r, s))
        return h(o.get(s));
      o !== r && o.get(a);
    },
    get size() {
      const a = this.__v_raw;
      return !n && an(at(a), "iterate", Sr), Reflect.get(a, "size", a);
    },
    has(a) {
      const o = this.__v_raw, r = at(o), s = at(a);
      return n || (Ao(a, s) && an(r, "has", a), an(r, "has", s)), a === s ? o.has(a) : o.has(a) || o.has(s);
    },
    forEach(a, o) {
      const r = this, s = r.__v_raw, l = at(s), h = e ? Mp : n ? Np : Pn;
      return !n && an(l, "iterate", Sr), s.forEach((d, f) => a.call(o, h(d), h(f), r));
    }
  };
  return Ji(
    t,
    n ? {
      add: $c("add"),
      set: $c("set"),
      delete: $c("delete"),
      clear: $c("clear")
    } : {
      add(a) {
        !e && !ea(a) && !Or(a) && (a = at(a));
        const o = at(this);
        return zc(o).has.call(o, a) || (o.add(a), Lo(o, "add", a, a)), this;
      },
      set(a, o) {
        !e && !ea(o) && !Or(o) && (o = at(o));
        const r = at(this), { has: s, get: l } = zc(r);
        let h = s.call(r, a);
        h ? process.env.NODE_ENV !== "production" && M0(r, s, a) : (a = at(a), h = s.call(r, a));
        const d = l.call(r, a);
        return r.set(a, o), h ? Ao(o, d) && Lo(r, "set", a, o, d) : Lo(r, "add", a, o), this;
      },
      delete(a) {
        const o = at(this), { has: r, get: s } = zc(o);
        let l = r.call(o, a);
        l ? process.env.NODE_ENV !== "production" && M0(o, r, a) : (a = at(a), l = r.call(o, a));
        const h = s ? s.call(o, a) : void 0, d = o.delete(a);
        return l && Lo(o, "delete", a, void 0, h), d;
      },
      clear() {
        const a = at(this), o = a.size !== 0, r = process.env.NODE_ENV !== "production" ? Ds(a) ? new Map(a) : new Set(a) : void 0, s = a.clear();
        return o && Lo(
          a,
          "clear",
          void 0,
          void 0,
          r
        ), s;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((a) => {
    t[a] = yB(a, n, e);
  }), t;
}
function $m(n, e) {
  const t = bB(n, e);
  return (i, a, o) => a === "__v_isReactive" ? !n : a === "__v_isReadonly" ? n : a === "__v_raw" ? i : Reflect.get(
    Gt(t, a) && a in i ? t : i,
    a,
    o
  );
}
const wB = {
  get: /* @__PURE__ */ $m(!1, !1)
}, vB = {
  get: /* @__PURE__ */ $m(!0, !1)
}, CB = {
  get: /* @__PURE__ */ $m(!0, !0)
};
function M0(n, e, t) {
  const i = at(t);
  if (i !== t && e.call(n, i)) {
    const a = kk(n);
    to(
      `Reactive ${a} contains both the raw and reactive versions of the same object${a === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const Ak = /* @__PURE__ */ new WeakMap(), SB = /* @__PURE__ */ new WeakMap(), Yk = /* @__PURE__ */ new WeakMap(), Pk = /* @__PURE__ */ new WeakMap();
function kB(n) {
  switch (n) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function _B(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : kB(kk(n));
}
function Rk(n) {
  return Or(n) ? n : Vm(
    n,
    !1,
    fB,
    wB,
    Ak
  );
}
function Fk(n) {
  return Vm(
    n,
    !0,
    pB,
    vB,
    Yk
  );
}
function Vc(n) {
  return Vm(
    n,
    !0,
    mB,
    CB,
    Pk
  );
}
function Vm(n, e, t, i, a) {
  if (!ia(n))
    return process.env.NODE_ENV !== "production" && to(
      `value cannot be made ${e ? "readonly" : "reactive"}: ${String(
        n
      )}`
    ), n;
  if (n.__v_raw && !(e && n.__v_isReactive))
    return n;
  const o = a.get(n);
  if (o)
    return o;
  const r = _B(n);
  if (r === 0)
    return n;
  const s = new Proxy(
    n,
    r === 2 ? i : t
  );
  return a.set(n, s), s;
}
function tl(n) {
  return Or(n) ? tl(n.__v_raw) : !!(n && n.__v_isReactive);
}
function Or(n) {
  return !!(n && n.__v_isReadonly);
}
function ea(n) {
  return !!(n && n.__v_isShallow);
}
function Eh(n) {
  return n ? !!n.__v_raw : !1;
}
function at(n) {
  const e = n && n.__v_raw;
  return e ? at(e) : n;
}
function jB(n) {
  return !Gt(n, "__v_skip") && Object.isExtensible(n) && tB(n, "__v_skip", !0), n;
}
const Pn = (n) => ia(n) ? Rk(n) : n, Np = (n) => ia(n) ? Fk(n) : n;
function qn(n) {
  return n ? n.__v_isRef === !0 : !1;
}
function Ms(n) {
  return TB(n, !1);
}
function TB(n, e) {
  return qn(n) ? n : new LB(n, e);
}
class LB {
  constructor(e, t) {
    this.dep = new Km(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : at(e), this._value = t ? e : Pn(e), this.__v_isShallow = t;
  }
  get value() {
    return process.env.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(e) {
    const t = this._rawValue, i = this.__v_isShallow || ea(e) || Or(e);
    e = i ? e : at(e), Ao(e, t) && (this._rawValue = e, this._value = i ? e : Pn(e), process.env.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: e,
      oldValue: t
    }) : this.dep.trigger());
  }
}
function xB(n) {
  return qn(n) ? n.value : n;
}
const EB = {
  get: (n, e, t) => e === "__v_raw" ? n : xB(Reflect.get(n, e, t)),
  set: (n, e, t, i) => {
    const a = n[e];
    return qn(a) && !qn(t) ? (a.value = t, !0) : Reflect.set(n, e, t, i);
  }
};
function DB(n) {
  return tl(n) ? n : new Proxy(n, EB);
}
class MB {
  constructor(e, t, i) {
    this.fn = e, this.setter = t, this._value = void 0, this.dep = new Km(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = pl - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    ct !== this)
      return jk(this, !0), !0;
    process.env.NODE_ENV;
  }
  get value() {
    const e = process.env.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return xk(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter ? this.setter(e) : process.env.NODE_ENV !== "production" && to("Write operation failed: computed value is readonly");
  }
}
function NB(n, e, t = !1) {
  let i, a;
  rn(n) ? i = n : (i = n.get, a = n.set);
  const o = new MB(i, a, t);
  return process.env.NODE_ENV !== "production" && e && !t && (o.onTrack = e.onTrack, o.onTrigger = e.onTrigger), o;
}
const Uc = {}, Dh = /* @__PURE__ */ new WeakMap();
let dr;
function OB(n, e = !1, t = dr) {
  if (t) {
    let i = Dh.get(t);
    i || Dh.set(t, i = []), i.push(n);
  } else process.env.NODE_ENV !== "production" && !e && to(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function AB(n, e, t = ha) {
  const { immediate: i, deep: a, once: o, scheduler: r, augmentJob: s, call: l } = t, h = (S) => {
    (t.onWarn || to)(
      "Invalid watch source: ",
      S,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, d = (S) => a ? S : ea(S) || a === !1 || a === 0 ? xo(S, 1) : xo(S);
  let f, p, y, m, w = !1, v = !1;
  if (qn(n) ? (p = () => n.value, w = ea(n)) : tl(n) ? (p = () => d(n), w = !0) : Yt(n) ? (v = !0, w = n.some((S) => tl(S) || ea(S)), p = () => n.map((S) => {
    if (qn(S))
      return S.value;
    if (tl(S))
      return d(S);
    if (rn(S))
      return l ? l(S, 2) : S();
    process.env.NODE_ENV !== "production" && h(S);
  })) : rn(n) ? e ? p = l ? () => l(n, 2) : n : p = () => {
    if (y) {
      yd();
      try {
        y();
      } finally {
        bd();
      }
    }
    const S = dr;
    dr = f;
    try {
      return l ? l(n, 3, [m]) : n(m);
    } finally {
      dr = S;
    }
  } : (p = Es, process.env.NODE_ENV !== "production" && h(n)), e && a) {
    const S = p, A = a === !0 ? 1 / 0 : a;
    p = () => xo(S(), A);
  }
  const _ = () => {
    f.stop();
  };
  if (o && e) {
    const S = e;
    e = (...A) => {
      S(...A), _();
    };
  }
  let L = v ? new Array(n.length).fill(Uc) : Uc;
  const T = (S) => {
    if (!(!(f.flags & 1) || !f.dirty && !S))
      if (e) {
        const A = f.run();
        if (a || w || (v ? A.some((x, M) => Ao(x, L[M])) : Ao(A, L))) {
          y && y();
          const x = dr;
          dr = f;
          try {
            const M = [
              A,
              // pass undefined as the old value when it's changed for the first time
              L === Uc ? void 0 : v && L[0] === Uc ? [] : L,
              m
            ];
            l ? l(e, 3, M) : (
              // @ts-expect-error
              e(...M)
            ), L = A;
          } finally {
            dr = x;
          }
        }
      } else
        f.run();
  };
  return s && s(T), f = new rB(p), f.scheduler = r ? () => r(T, !1) : T, m = (S) => OB(S, !1, f), y = f.onStop = () => {
    const S = Dh.get(f);
    if (S) {
      if (l)
        l(S, 4);
      else
        for (const A of S) A();
      Dh.delete(f);
    }
  }, process.env.NODE_ENV !== "production" && (f.onTrack = t.onTrack, f.onTrigger = t.onTrigger), e ? i ? T(!0) : L = f.run() : r ? r(T.bind(null, !0), !0) : f.run(), _.pause = f.pause.bind(f), _.resume = f.resume.bind(f), _.stop = _, _;
}
function xo(n, e = 1 / 0, t) {
  if (e <= 0 || !ia(n) || n.__v_skip || (t = t || /* @__PURE__ */ new Set(), t.has(n)))
    return n;
  if (t.add(n), e--, qn(n))
    xo(n.value, e, t);
  else if (Yt(n))
    for (let i = 0; i < n.length; i++)
      xo(n[i], e, t);
  else if (zZ(n) || Ds(n))
    n.forEach((i) => {
      xo(i, e, t);
    });
  else if (UZ(n)) {
    for (const i in n)
      xo(n[i], e, t);
    for (const i of Object.getOwnPropertySymbols(n))
      Object.prototype.propertyIsEnumerable.call(n, i) && xo(n[i], e, t);
  }
  return n;
}
const YB = { key: 0 }, PB = { class: "flex-grow overflow-y-auto" }, RB = {
  key: 1,
  class: "flex gap-1"
}, Um = /* @__PURE__ */ Xe({
  __name: "BaseDrawer",
  props: {
    name: {
      type: String,
      required: !0
    },
    direction: {
      type: String,
      default: "ltr",
      validator: (n) => ["ltr", "rtl", "ttb", "btt"].includes(n)
    }
  },
  emits: ["close"],
  setup(n, { emit: e }) {
    const t = n, i = e, a = NB(() => ["e2e-drawer-back absolute z-10 top-0 left-0 w-full h-full bg-black/50"]), o = {
      ltr: "top-0 left-0 w-[50%] max-w-[900px] ",
      rtl: "top-0 right-0 w-[50%] max-w-[900px] ",
      ttb: "top-0 right-0 left-0",
      btt: "top-auto h-[900px] max-h-[50%] bottom-0 right-0 left-0"
    }, { drawer: r } = qt(), s = () => {
      r.give(""), i("close");
    }, l = r.isOpenedByName(t.name, new qe()).ref();
    return (h, d) => (q(), ln(K1, { name: "fade" }, {
      default: se(() => [
        I(l) ? (q(), ie("div", {
          key: 0,
          class: va(I(a)),
          onClick: s
        }, [
          ae("div", {
            class: va(["absolute bg-white h-full p-3 flex flex-col overflow-hidden", o[n.direction]]),
            onClick: d[0] || (d[0] = Us(() => {
            }, ["stop"]))
          }, [
            h.$slots.header ? (q(), ie("div", YB, [
              Ri(h.$slots, "header", { class: "BaseDrawer-Header" })
            ])) : tt("", !0),
            ae("div", PB, [
              Ri(h.$slots, "default")
            ]),
            h.$slots.footer ? (q(), ie("div", RB, [
              Ri(h.$slots, "footer")
            ])) : tt("", !0)
          ], 2)
        ], 2)) : tt("", !0)
      ]),
      _: 3
    }));
  }
});
class Ik {
  constructor(e, t = void 0) {
    xe(this, "innerRef");
    this.executor = e, this.innerRef = vn(t);
  }
  ref() {
    return this.executor(this.innerRef), this.innerRef;
  }
}
const FB = { class: "flex gap-2" }, jf = /* @__PURE__ */ Xe({
  __name: "BaseCheckbox",
  props: {
    modelValue: {
      type: Boolean
    },
    label: {
      type: String,
      required: !0
    }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const a = od(n, "modelValue", e);
    return (o, r) => (q(), ie("label", FB, [
      id(ae("input", {
        "onUpdate:modelValue": r[0] || (r[0] = (s) => Ol(a) ? a.value = s : null),
        type: "checkbox"
      }, null, 512), [
        [fA, I(a)]
      ]),
      o.$slots.default ? Ri(o.$slots, "default", { key: 0 }) : (q(), ie(Ht, { key: 1 }, [
        Ue(we(n.label), 1)
      ], 64))
    ]));
  }
}), IB = {}, JB = { class: "text-sm font-bold" };
function ZB(n, e) {
  return q(), ie("div", JB, [
    Ri(n.$slots, "default")
  ]);
}
const di = /* @__PURE__ */ fd(IB, [["render", ZB]]);
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const kr = [];
function BB(n) {
  kr.push(n);
}
function HB() {
  kr.pop();
}
let Tf = !1;
function At(n, ...e) {
  if (Tf) return;
  Tf = !0, yd();
  const t = kr.length ? kr[kr.length - 1].component : null, i = t && t.appContext.config.warnHandler, a = XB();
  if (i)
    wd(
      i,
      t,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        n + e.map((o) => {
          var r, s;
          return (s = (r = o.toString) == null ? void 0 : r.call(o)) != null ? s : JSON.stringify(o);
        }).join(""),
        t && t.proxy,
        a.map(
          ({ vnode: o }) => `at <${i_(t, o.type)}>`
        ).join(`
`),
        a
      ]
    );
  else {
    const o = [`[Vue warn]: ${n}`, ...e];
    a.length && o.push(`
`, ...GB(a)), console.warn(...o);
  }
  bd(), Tf = !1;
}
function XB() {
  let n = kr[kr.length - 1];
  if (!n)
    return [];
  const e = [];
  for (; n; ) {
    const t = e[0];
    t && t.vnode === n ? t.recurseCount++ : e.push({
      vnode: n,
      recurseCount: 0
    });
    const i = n.component && n.component.parent;
    n = i && i.vnode;
  }
  return e;
}
function GB(n) {
  const e = [];
  return n.forEach((t, i) => {
    e.push(...i === 0 ? [] : [`
`], ...WB(t));
  }), e;
}
function WB({ vnode: n, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", i = n.component ? n.component.parent == null : !1, a = ` at <${i_(
    n.component,
    n.type,
    i
  )}`, o = ">" + t;
  return n.props ? [a, ...QB(n.props), o] : [a + o];
}
function QB(n) {
  const e = [], t = Object.keys(n);
  return t.slice(0, 3).forEach((i) => {
    e.push(...Jk(i, n[i]));
  }), t.length > 3 && e.push(" ..."), e;
}
function Jk(n, e, t) {
  return na(e) ? (e = JSON.stringify(e), t ? e : [`${n}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${n}=${e}`] : qn(e) ? (e = Jk(n, at(e.value), !0), t ? e : [`${n}=Ref<`, e, ">"]) : rn(e) ? [`${n}=fn${e.name ? `<${e.name}>` : ""}`] : (e = at(e), t ? e : [`${n}=`, e]);
}
const Zk = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function wd(n, e, t, i) {
  try {
    return i ? n(...i) : n();
  } catch (a) {
    qm(a, e, t);
  }
}
function Bk(n, e, t, i) {
  if (rn(n)) {
    const a = wd(n, e, t, i);
    return a && $Z(a) && a.catch((o) => {
      qm(o, e, t);
    }), a;
  }
  if (Yt(n)) {
    const a = [];
    for (let o = 0; o < n.length; o++)
      a.push(Bk(n[o], e, t, i));
    return a;
  } else process.env.NODE_ENV !== "production" && At(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof n}`
  );
}
function qm(n, e, t, i = !0) {
  const a = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: r } = e && e.appContext.config || ha;
  if (e) {
    let s = e.parent;
    const l = e.proxy, h = process.env.NODE_ENV !== "production" ? Zk[t] : `https://vuejs.org/error-reference/#runtime-${t}`;
    for (; s; ) {
      const d = s.ec;
      if (d) {
        for (let f = 0; f < d.length; f++)
          if (d[f](n, l, h) === !1)
            return;
      }
      s = s.parent;
    }
    if (o) {
      yd(), wd(o, null, 10, [
        n,
        l,
        h
      ]), bd();
      return;
    }
  }
  KB(n, t, a, i, r);
}
function KB(n, e, t, i = !0, a = !1) {
  if (process.env.NODE_ENV !== "production") {
    const o = Zk[e];
    if (t && BB(t), At(`Unhandled error${o ? ` during execution of ${o}` : ""}`), t && HB(), i)
      throw n;
    console.error(n);
  } else {
    if (a)
      throw n;
    console.error(n);
  }
}
const Ai = [];
let Xa = -1;
const Ns = [];
let _o = null, fs = 0;
const Hk = /* @__PURE__ */ Promise.resolve();
let Mh = null;
const zB = 100;
function $B(n) {
  const e = Mh || Hk;
  return n ? e.then(this ? n.bind(this) : n) : e;
}
function VB(n) {
  let e = Xa + 1, t = Ai.length;
  for (; e < t; ) {
    const i = e + t >>> 1, a = Ai[i], o = yl(a);
    o < n || o === n && a.flags & 2 ? e = i + 1 : t = i;
  }
  return e;
}
function ey(n) {
  if (!(n.flags & 1)) {
    const e = yl(n), t = Ai[Ai.length - 1];
    !t || // fast path when the job id is larger than the tail
    !(n.flags & 2) && e >= yl(t) ? Ai.push(n) : Ai.splice(VB(e), 0, n), n.flags |= 1, Xk();
  }
}
function Xk() {
  Mh || (Mh = Hk.then(Wk));
}
function Gk(n) {
  Yt(n) ? Ns.push(...n) : _o && n.id === -1 ? _o.splice(fs + 1, 0, n) : n.flags & 1 || (Ns.push(n), n.flags |= 1), Xk();
}
function UB(n) {
  if (Ns.length) {
    const e = [...new Set(Ns)].sort(
      (t, i) => yl(t) - yl(i)
    );
    if (Ns.length = 0, _o) {
      _o.push(...e);
      return;
    }
    for (_o = e, process.env.NODE_ENV !== "production" && (n = n || /* @__PURE__ */ new Map()), fs = 0; fs < _o.length; fs++) {
      const t = _o[fs];
      process.env.NODE_ENV !== "production" && Qk(n, t) || (t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), t.flags &= -2);
    }
    _o = null, fs = 0;
  }
}
const yl = (n) => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function Wk(n) {
  process.env.NODE_ENV !== "production" && (n = n || /* @__PURE__ */ new Map());
  const e = process.env.NODE_ENV !== "production" ? (t) => Qk(n, t) : Es;
  try {
    for (Xa = 0; Xa < Ai.length; Xa++) {
      const t = Ai[Xa];
      if (t && !(t.flags & 8)) {
        if (process.env.NODE_ENV !== "production" && e(t))
          continue;
        t.flags & 4 && (t.flags &= -2), wd(
          t,
          t.i,
          t.i ? 15 : 14
        ), t.flags & 4 || (t.flags &= -2);
      }
    }
  } finally {
    for (; Xa < Ai.length; Xa++) {
      const t = Ai[Xa];
      t && (t.flags &= -2);
    }
    Xa = -1, Ai.length = 0, UB(n), Mh = null, (Ai.length || Ns.length) && Wk(n);
  }
}
function Qk(n, e) {
  const t = n.get(e) || 0;
  if (t > zB) {
    const i = e.i, a = i && n_(i.type);
    return qm(
      `Maximum recursive updates exceeded${a ? ` in component <${a}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return n.set(e, t + 1), !1;
}
const Lf = /* @__PURE__ */ new Map();
process.env.NODE_ENV !== "production" && (md().__VUE_HMR_RUNTIME__ = {
  createRecord: xf(qB),
  rerender: xf(eH),
  reload: xf(tH)
});
const Nh = /* @__PURE__ */ new Map();
function qB(n, e) {
  return Nh.has(n) ? !1 : (Nh.set(n, {
    initialDef: Oh(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Oh(n) {
  return a_(n) ? n.__vccOpts : n;
}
function eH(n, e) {
  const t = Nh.get(n);
  t && (t.initialDef.render = e, [...t.instances].forEach((i) => {
    e && (i.render = e, Oh(i.type).render = e), i.renderCache = [], i.update();
  }));
}
function tH(n, e) {
  const t = Nh.get(n);
  if (!t) return;
  e = Oh(e), N0(t.initialDef, e);
  const i = [...t.instances];
  for (let a = 0; a < i.length; a++) {
    const o = i[a], r = Oh(o.type);
    let s = Lf.get(r);
    s || (r !== t.initialDef && N0(r, e), Lf.set(r, s = /* @__PURE__ */ new Set())), s.add(o), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (s.add(o), o.ceReload(e.styles), s.delete(o)) : o.parent ? ey(() => {
      o.parent.update(), s.delete(o);
    }) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), o.root.ce && o !== o.root && o.root.ce._removeChildStyle(r);
  }
  Gk(() => {
    Lf.clear();
  });
}
function N0(n, e) {
  Ji(n, e);
  for (const t in n)
    t !== "__file" && !(t in e) && delete n[t];
}
function xf(n) {
  return (e, t) => {
    try {
      return n(e, t);
    } catch (i) {
      console.error(i), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let ps, qc = [];
function Kk(n, e) {
  var t, i;
  ps = n, ps ? (ps.enabled = !0, qc.forEach(({ event: a, args: o }) => ps.emit(a, ...o)), qc = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((i = (t = window.navigator) == null ? void 0 : t.userAgent) != null && i.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    Kk(o, e);
  }), setTimeout(() => {
    ps || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, qc = []);
  }, 3e3)) : qc = [];
}
let za = null, nH = null;
const iH = (n) => n.__isTeleport;
function zk(n, e) {
  n.shapeFlag & 6 && n.component ? (n.transition = e, zk(n.component.subTree, e)) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent), n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e;
}
md().requestIdleCallback;
md().cancelIdleCallback;
const aH = Symbol.for("v-ndc"), Op = (n) => n ? NH(n) ? OH(n) : Op(n.parent) : null, nl = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ji(/* @__PURE__ */ Object.create(null), {
    $: (n) => n,
    $el: (n) => n.vnode.el,
    $data: (n) => n.data,
    $props: (n) => process.env.NODE_ENV !== "production" ? Vc(n.props) : n.props,
    $attrs: (n) => process.env.NODE_ENV !== "production" ? Vc(n.attrs) : n.attrs,
    $slots: (n) => process.env.NODE_ENV !== "production" ? Vc(n.slots) : n.slots,
    $refs: (n) => process.env.NODE_ENV !== "production" ? Vc(n.refs) : n.refs,
    $parent: (n) => Op(n.parent),
    $root: (n) => Op(n.root),
    $host: (n) => n.ce,
    $emit: (n) => n.emit,
    $options: (n) => sH(n),
    $forceUpdate: (n) => n.f || (n.f = () => {
      ey(n.update);
    }),
    $nextTick: (n) => n.n || (n.n = $B.bind(n.proxy)),
    $watch: (n) => bH.bind(n)
  })
), oH = (n) => n === "_" || n === "$", Ef = (n, e) => n !== ha && !n.__isScriptSetup && Gt(n, e), rH = {
  get({ _: n }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: t, setupState: i, data: a, props: o, accessCache: r, type: s, appContext: l } = n;
    if (process.env.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let h;
    if (e[0] !== "$") {
      const y = r[e];
      if (y !== void 0)
        switch (y) {
          case 1:
            return i[e];
          case 2:
            return a[e];
          case 4:
            return t[e];
          case 3:
            return o[e];
        }
      else {
        if (Ef(i, e))
          return r[e] = 1, i[e];
        if (a !== ha && Gt(a, e))
          return r[e] = 2, a[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (h = n.propsOptions[0]) && Gt(h, e)
        )
          return r[e] = 3, o[e];
        if (t !== ha && Gt(t, e))
          return r[e] = 4, t[e];
        r[e] = 0;
      }
    }
    const d = nl[e];
    let f, p;
    if (d)
      return e === "$attrs" ? (an(n.attrs, "get", ""), process.env.NODE_ENV !== "production" && void 0) : process.env.NODE_ENV !== "production" && e === "$slots" && an(n, "get", e), d(n);
    if (
      // css module (injected by vue-loader)
      (f = s.__cssModules) && (f = f[e])
    )
      return f;
    if (t !== ha && Gt(t, e))
      return r[e] = 4, t[e];
    if (
      // global properties
      p = l.config.globalProperties, Gt(p, e)
    )
      return p[e];
    process.env.NODE_ENV !== "production" && za && (!na(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (a !== ha && oH(e[0]) && Gt(a, e) ? At(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : n === za && At(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: n }, e, t) {
    const { data: i, setupState: a, ctx: o } = n;
    return Ef(a, e) ? (a[e] = t, !0) : process.env.NODE_ENV !== "production" && a.__isScriptSetup && Gt(a, e) ? (At(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : i !== ha && Gt(i, e) ? (i[e] = t, !0) : Gt(n.props, e) ? (process.env.NODE_ENV !== "production" && At(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in n ? (process.env.NODE_ENV !== "production" && At(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : (process.env.NODE_ENV !== "production" && e in n.appContext.config.globalProperties ? Object.defineProperty(o, e, {
      enumerable: !0,
      configurable: !0,
      value: t
    }) : o[e] = t, !0);
  },
  has({
    _: { data: n, setupState: e, accessCache: t, ctx: i, appContext: a, propsOptions: o }
  }, r) {
    let s;
    return !!t[r] || n !== ha && Gt(n, r) || Ef(e, r) || (s = o[0]) && Gt(s, r) || Gt(i, r) || Gt(nl, r) || Gt(a.config.globalProperties, r);
  },
  defineProperty(n, e, t) {
    return t.get != null ? n._.accessCache[e] = 0 : Gt(t, "value") && this.set(n, e, t.value, null), Reflect.defineProperty(n, e, t);
  }
};
process.env.NODE_ENV !== "production" && (rH.ownKeys = (n) => (At(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(n)));
function O0(n) {
  return Yt(n) ? n.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : n;
}
function sH(n) {
  const e = n.type, { mixins: t, extends: i } = e, {
    mixins: a,
    optionsCache: o,
    config: { optionMergeStrategies: r }
  } = n.appContext, s = o.get(e);
  let l;
  return s ? l = s : !a.length && !t && !i ? l = e : (l = {}, a.length && a.forEach(
    (h) => Ah(l, h, r, !0)
  ), Ah(l, e, r)), ia(e) && o.set(e, l), l;
}
function Ah(n, e, t, i = !1) {
  const { mixins: a, extends: o } = e;
  o && Ah(n, o, t, !0), a && a.forEach(
    (r) => Ah(n, r, t, !0)
  );
  for (const r in e)
    if (i && r === "expose")
      process.env.NODE_ENV !== "production" && At(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const s = uH[r] || t && t[r];
      n[r] = s ? s(n[r], e[r]) : e[r];
    }
  return n;
}
const uH = {
  data: A0,
  props: P0,
  emits: P0,
  // objects
  methods: Xu,
  computed: Xu,
  // lifecycle
  beforeCreate: On,
  created: On,
  beforeMount: On,
  mounted: On,
  beforeUpdate: On,
  updated: On,
  beforeDestroy: On,
  beforeUnmount: On,
  destroyed: On,
  unmounted: On,
  activated: On,
  deactivated: On,
  errorCaptured: On,
  serverPrefetch: On,
  // assets
  components: Xu,
  directives: Xu,
  // watch
  watch: cH,
  // provide / inject
  provide: A0,
  inject: lH
};
function A0(n, e) {
  return e ? n ? function() {
    return Ji(
      rn(n) ? n.call(this, this) : n,
      rn(e) ? e.call(this, this) : e
    );
  } : e : n;
}
function lH(n, e) {
  return Xu(Y0(n), Y0(e));
}
function Y0(n) {
  if (Yt(n)) {
    const e = {};
    for (let t = 0; t < n.length; t++)
      e[n[t]] = n[t];
    return e;
  }
  return n;
}
function On(n, e) {
  return n ? [...new Set([].concat(n, e))] : e;
}
function Xu(n, e) {
  return n ? Ji(/* @__PURE__ */ Object.create(null), n, e) : e;
}
function P0(n, e) {
  return n ? Yt(n) && Yt(e) ? [.../* @__PURE__ */ new Set([...n, ...e])] : Ji(
    /* @__PURE__ */ Object.create(null),
    O0(n),
    O0(e ?? {})
  ) : e;
}
function cH(n, e) {
  if (!n) return e;
  if (!e) return n;
  const t = Ji(/* @__PURE__ */ Object.create(null), n);
  for (const i in e)
    t[i] = On(n[i], e[i]);
  return t;
}
let hH = null;
function dH(n, e, t = !1) {
  const i = vd || za;
  if (i || hH) {
    const a = i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (a && n in a)
      return a[n];
    if (arguments.length > 1)
      return t && rn(e) ? e.call(i && i.proxy) : e;
    process.env.NODE_ENV !== "production" && At(`injection "${String(n)}" not found.`);
  } else process.env.NODE_ENV !== "production" && At("inject() can only be used inside setup() or functional components.");
}
const gH = {}, $k = (n) => Object.getPrototypeOf(n) === gH, fH = CH, pH = Symbol.for("v-scx"), mH = () => {
  {
    const n = dH(pH);
    return n || process.env.NODE_ENV !== "production" && At(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), n;
  }
};
function yH(n, e, t) {
  return process.env.NODE_ENV !== "production" && !rn(e) && At(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), Vk(n, e, t);
}
function Vk(n, e, t = ha) {
  const { immediate: i, deep: a, flush: o, once: r } = t;
  process.env.NODE_ENV !== "production" && !e && (i !== void 0 && At(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), a !== void 0 && At(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), r !== void 0 && At(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const s = Ji({}, t);
  process.env.NODE_ENV !== "production" && (s.onWarn = At);
  const l = e && i || !e && o !== "post";
  let h;
  if (Yp) {
    if (o === "sync") {
      const y = mH();
      h = y.__watcherHandles || (y.__watcherHandles = []);
    } else if (!l) {
      const y = () => {
      };
      return y.stop = Es, y.resume = Es, y.pause = Es, y;
    }
  }
  const d = vd;
  s.call = (y, m, w) => Bk(y, d, m, w);
  let f = !1;
  o === "post" ? s.scheduler = (y) => {
    fH(y, d && d.suspense);
  } : o !== "sync" && (f = !0, s.scheduler = (y, m) => {
    m ? y() : ey(y);
  }), s.augmentJob = (y) => {
    e && (y.flags |= 4), f && (y.flags |= 2, d && (y.id = d.uid, y.i = d));
  };
  const p = AB(n, e, s);
  return Yp && (h ? h.push(p) : l && p()), p;
}
function bH(n, e, t) {
  const i = this.proxy, a = na(n) ? n.includes(".") ? wH(i, n) : () => i[n] : n.bind(i, i);
  let o;
  rn(e) ? o = e : (o = e.handler, t = e);
  const r = MH(this), s = Vk(a, o.bind(i), t);
  return r(), s;
}
function wH(n, e) {
  const t = e.split(".");
  return () => {
    let i = n;
    for (let a = 0; a < t.length && i; a++)
      i = i[t[a]];
    return i;
  };
}
const vH = (n) => n.__isSuspense;
function CH(n, e) {
  e && e.pendingBranch ? Yt(n) ? e.effects.push(...n) : e.effects.push(n) : Gk(n);
}
const Uk = Symbol.for("v-fgt"), SH = Symbol.for("v-txt"), kH = Symbol.for("v-cmt");
let _s = null;
function _H(n) {
  return n ? n.__v_isVNode === !0 : !1;
}
const jH = (...n) => e_(
  ...n
), qk = ({ key: n }) => n ?? null, mh = ({
  ref: n,
  ref_key: e,
  ref_for: t
}) => (typeof n == "number" && (n = "" + n), n != null ? na(n) || qn(n) || rn(n) ? { i: za, r: n, k: e, f: !!t } : n : null);
function TH(n, e = null, t = null, i = 0, a = null, o = n === Uk ? 0 : 1, r = !1, s = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: e,
    key: e && qk(e),
    ref: e && mh(e),
    scopeId: nH,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: i,
    dynamicProps: a,
    dynamicChildren: null,
    appContext: null,
    ctx: za
  };
  return s ? (ty(l, t), o & 128 && n.normalize(l)) : t && (l.shapeFlag |= na(t) ? 8 : 16), process.env.NODE_ENV !== "production" && l.key !== l.key && At("VNode created with invalid key (NaN). VNode type:", l.type), // avoid a block node from tracking itself
  !r && // has current parent block
  _s && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && _s.push(l), l;
}
const LH = process.env.NODE_ENV !== "production" ? jH : e_;
function e_(n, e = null, t = null, i = 0, a = null, o = !1) {
  if ((!n || n === aH) && (process.env.NODE_ENV !== "production" && !n && At(`Invalid vnode type when creating vnode: ${n}.`), n = kH), _H(n)) {
    const s = Yh(
      n,
      e,
      !0
      /* mergeRef: true */
    );
    return t && ty(s, t), !o && _s && (s.shapeFlag & 6 ? _s[_s.indexOf(n)] = s : _s.push(s)), s.patchFlag = -2, s;
  }
  if (a_(n) && (n = n.__vccOpts), e) {
    e = xH(e);
    let { class: s, style: l } = e;
    s && !na(s) && (e.class = Xm(s)), ia(l) && (Eh(l) && !Yt(l) && (l = Ji({}, l)), e.style = Hm(l));
  }
  const r = na(n) ? 1 : vH(n) ? 128 : iH(n) ? 64 : ia(n) ? 4 : rn(n) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && r & 4 && Eh(n) && (n = at(n), At(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    n
  )), TH(
    n,
    e,
    t,
    i,
    a,
    r,
    o,
    !0
  );
}
function xH(n) {
  return n ? Eh(n) || $k(n) ? Ji({}, n) : n : null;
}
function Yh(n, e, t = !1, i = !1) {
  const { props: a, ref: o, patchFlag: r, children: s, transition: l } = n, h = e ? DH(a || {}, e) : a, d = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n.type,
    props: h,
    key: h && qk(h),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && o ? Yt(o) ? o.concat(mh(e)) : [o, mh(e)] : mh(e)
    ) : o,
    scopeId: n.scopeId,
    slotScopeIds: n.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && r === -1 && Yt(s) ? s.map(t_) : s,
    target: n.target,
    targetStart: n.targetStart,
    targetAnchor: n.targetAnchor,
    staticCount: n.staticCount,
    shapeFlag: n.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && n.type !== Uk ? r === -1 ? 16 : r | 16 : r,
    dynamicProps: n.dynamicProps,
    dynamicChildren: n.dynamicChildren,
    appContext: n.appContext,
    dirs: n.dirs,
    transition: l,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: n.component,
    suspense: n.suspense,
    ssContent: n.ssContent && Yh(n.ssContent),
    ssFallback: n.ssFallback && Yh(n.ssFallback),
    el: n.el,
    anchor: n.anchor,
    ctx: n.ctx,
    ce: n.ce
  };
  return l && i && zk(
    d,
    l.clone(d)
  ), d;
}
function t_(n) {
  const e = Yh(n);
  return Yt(n.children) && (e.children = n.children.map(t_)), e;
}
function EH(n = " ", e = 0) {
  return LH(SH, null, n, e);
}
function ty(n, e) {
  let t = 0;
  const { shapeFlag: i } = n;
  if (e == null)
    e = null;
  else if (Yt(e))
    t = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const a = e.default;
      a && (a._c && (a._d = !1), ty(n, a()), a._c && (a._d = !0));
      return;
    } else {
      t = 32;
      const a = e._;
      !a && !$k(e) ? e._ctx = za : a === 3 && za && (za.slots._ === 1 ? e._ = 1 : (e._ = 2, n.patchFlag |= 1024));
    }
  else rn(e) ? (e = { default: e, _ctx: za }, t = 32) : (e = String(e), i & 64 ? (t = 16, e = [EH(e)]) : t = 8);
  n.children = e, n.shapeFlag |= t;
}
function DH(...n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = n[t];
    for (const a in i)
      if (a === "class")
        e.class !== i.class && (e.class = Xm([e.class, i.class]));
      else if (a === "style")
        e.style = Hm([e.style, i.style]);
      else if (QZ(a)) {
        const o = e[a], r = i[a];
        r && o !== r && !(Yt(o) && o.includes(r)) && (e[a] = o ? [].concat(o, r) : r);
      } else a !== "" && (e[a] = i[a]);
  }
  return e;
}
let vd = null, Ap;
{
  const n = md(), e = (t, i) => {
    let a;
    return (a = n[t]) || (a = n[t] = []), a.push(i), (o) => {
      a.length > 1 ? a.forEach((r) => r(o)) : a[0](o);
    };
  };
  Ap = e(
    "__VUE_INSTANCE_SETTERS__",
    (t) => vd = t
  ), e(
    "__VUE_SSR_SETTERS__",
    (t) => Yp = t
  );
}
const MH = (n) => {
  const e = vd;
  return Ap(n), n.scope.on(), () => {
    n.scope.off(), Ap(e);
  };
};
function NH(n) {
  return n.vnode.shapeFlag & 4;
}
let Yp = !1;
process.env.NODE_ENV;
function OH(n) {
  return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(DB(jB(n.exposed)), {
    get(e, t) {
      if (t in e)
        return e[t];
      if (t in nl)
        return nl[t](n);
    },
    has(e, t) {
      return t in e || t in nl;
    }
  })) : n.proxy;
}
const AH = /(?:^|[-_])(\w)/g, YH = (n) => n.replace(AH, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function n_(n, e = !0) {
  return rn(n) ? n.displayName || n.name : n.name || e && n.__name;
}
function i_(n, e, t = !1) {
  let i = n_(e);
  if (!i && e.__file) {
    const a = e.__file.match(/([^/\\]+)\.\w+$/);
    a && (i = a[1]);
  }
  if (!i && n && n.parent) {
    const a = (o) => {
      for (const r in o)
        if (o[r] === e)
          return r;
    };
    i = a(
      n.components || n.parent.type.components
    ) || a(n.appContext.components);
  }
  return i ? YH(i) : t ? "App" : "Anonymous";
}
function a_(n) {
  return rn(n) && "__vccOpts" in n;
}
process.env.NODE_ENV;
process.env.NODE_ENV;
process.env.NODE_ENV;
const ga = /* @__PURE__ */ Xe({
  __name: "BaseInput",
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    autofocus: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, i = e, a = Ms(null);
    yH(
      a,
      qs(() => {
        t.autofocus && a.value.focus();
      }, 500)
    );
    const o = od(t, "modelValue", i);
    return (r, s) => id((q(), ie("input", {
      ref_key: "input",
      ref: a,
      "onUpdate:modelValue": s[0] || (s[0] = (l) => Ol(o) ? o.value = l : null),
      class: "block rounded-main w-full p-2 border border-solid border-body-dark",
      type: "text"
    }, null, 512)), [
      [z1, I(o)]
    ]);
  }
}), PH = {}, RH = { class: "mb-2" };
function FH(n, e) {
  return q(), ie("div", RH, [
    Ri(n.$slots, "default")
  ]);
}
const Ni = /* @__PURE__ */ fd(PH, [["render", FH]]);
function mn(n) {
  this.content = n;
}
mn.prototype = {
  constructor: mn,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string) â†’ ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) â†’ OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var i = t && t != n ? this.remove(t) : this, a = i.find(n), o = i.content.slice();
    return a == -1 ? o.push(t || n, e) : (o[a + 1] = e, t && (o[a] = t)), new mn(o);
  },
  // :: (string) â†’ OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new mn(t);
  },
  // :: (string, any) â†’ OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new mn([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) â†’ OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new mn(t);
  },
  // :: (string, string, any) â†’ OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var i = this.remove(e), a = i.content.slice(), o = i.find(n);
    return a.splice(o == -1 ? a.length : o, 0, e, t), new mn(a);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) â†’ OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = mn.from(n), n.size ? new mn(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) â†’ OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = mn.from(n), n.size ? new mn(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) â†’ OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = mn.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () â†’ Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
mn.from = function(n) {
  if (n instanceof mn) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new mn(e);
};
function o_(n, e, t) {
  for (let i = 0; ; i++) {
    if (i == n.childCount || i == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let a = n.child(i), o = e.child(i);
    if (a == o) {
      t += a.nodeSize;
      continue;
    }
    if (!a.sameMarkup(o))
      return t;
    if (a.isText && a.text != o.text) {
      for (let r = 0; a.text[r] == o.text[r]; r++)
        t++;
      return t;
    }
    if (a.content.size || o.content.size) {
      let r = o_(a.content, o.content, t + 1);
      if (r != null)
        return r;
    }
    t += a.nodeSize;
  }
}
function r_(n, e, t, i) {
  for (let a = n.childCount, o = e.childCount; ; ) {
    if (a == 0 || o == 0)
      return a == o ? null : { a: t, b: i };
    let r = n.child(--a), s = e.child(--o), l = r.nodeSize;
    if (r == s) {
      t -= l, i -= l;
      continue;
    }
    if (!r.sameMarkup(s))
      return { a: t, b: i };
    if (r.isText && r.text != s.text) {
      let h = 0, d = Math.min(r.text.length, s.text.length);
      for (; h < d && r.text[r.text.length - h - 1] == s.text[s.text.length - h - 1]; )
        h++, t--, i--;
      return { a: t, b: i };
    }
    if (r.content.size || s.content.size) {
      let h = r_(r.content, s.content, t - 1, i - 1);
      if (h)
        return h;
    }
    t -= l, i -= l;
  }
}
class U {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let i = 0; i < e.length; i++)
        this.size += e[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, i, a = 0, o) {
    for (let r = 0, s = 0; s < t; r++) {
      let l = this.content[r], h = s + l.nodeSize;
      if (h > e && i(l, a + s, o || null, r) !== !1 && l.content.size) {
        let d = s + 1;
        l.nodesBetween(Math.max(0, e - d), Math.min(l.content.size, t - d), i, a + d);
      }
      s = h;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, i, a) {
    let o = "", r = !0;
    return this.nodesBetween(e, t, (s, l) => {
      let h = s.isText ? s.text.slice(Math.max(e, l) - l, t - l) : s.isLeaf ? a ? typeof a == "function" ? a(s) : a : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : "";
      s.isBlock && (s.isLeaf && h || s.isTextblock) && i && (r ? r = !1 : o += i), o += h;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, i = e.firstChild, a = this.content.slice(), o = 0;
    for (t.isText && t.sameMarkup(i) && (a[a.length - 1] = t.withText(t.text + i.text), o = 1); o < e.content.length; o++)
      a.push(e.content[o]);
    return new U(a, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let i = [], a = 0;
    if (t > e)
      for (let o = 0, r = 0; r < t; o++) {
        let s = this.content[o], l = r + s.nodeSize;
        l > e && ((r < e || l > t) && (s.isText ? s = s.cut(Math.max(0, e - r), Math.min(s.text.length, t - r)) : s = s.cut(Math.max(0, e - r - 1), Math.min(s.content.size, t - r - 1))), i.push(s), a += s.nodeSize), r = l;
      }
    return new U(i, a);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? U.empty : e == 0 && t == this.content.length ? this : new U(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let i = this.content[e];
    if (i == t)
      return this;
    let a = this.content.slice(), o = this.size + t.nodeSize - i.nodeSize;
    return a[e] = t, new U(a, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new U([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new U(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, i = 0; t < this.content.length; t++) {
      let a = this.content[t];
      e(a, i, t), i += a.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return o_(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, i = e.size) {
    return r_(this, e, t, i);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, t = -1) {
    if (e == 0)
      return eh(0, e);
    if (e == this.size)
      return eh(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let i = 0, a = 0; ; i++) {
      let o = this.child(i), r = a + o.nodeSize;
      if (r >= e)
        return r == e || t > 0 ? eh(i + 1, r) : eh(i, a);
      a = r;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return U.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new U(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return U.empty;
    let t, i = 0;
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      i += o.nodeSize, a && o.isText && e[a - 1].sameMarkup(o) ? (t || (t = e.slice(0, a)), t[t.length - 1] = o.withText(t[t.length - 1].text + o.text)) : t && t.push(o);
    }
    return new U(t || e, i);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return U.empty;
    if (e instanceof U)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new U([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
U.empty = new U([], 0);
const Df = { index: 0, offset: 0 };
function eh(n, e) {
  return Df.index = n, Df.offset = e, Df;
}
function Ph(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let i = 0; i < n.length; i++)
      if (!Ph(n[i], e[i]))
        return !1;
  } else {
    for (let i in n)
      if (!(i in e) || !Ph(n[i], e[i]))
        return !1;
    for (let i in e)
      if (!(i in n))
        return !1;
  }
  return !0;
}
let vt = class Pp {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, i = !1;
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      if (this.eq(o))
        return e;
      if (this.type.excludes(o.type))
        t || (t = e.slice(0, a));
      else {
        if (o.type.excludes(this.type))
          return e;
        !i && o.type.rank > this.type.rank && (t || (t = e.slice(0, a)), t.push(this), i = !0), t && t.push(o);
      }
    }
    return t || (t = e.slice()), i || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && Ph(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let i = e.marks[t.type];
    if (!i)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let a = i.create(t.attrs);
    return i.checkAttrs(a.attrs), a;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++)
      if (!e[i].eq(t[i]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Pp.none;
    if (e instanceof Pp)
      return [e];
    let t = e.slice();
    return t.sort((i, a) => i.type.rank - a.type.rank), t;
  }
};
vt.none = [];
class Rh extends Error {
}
class ue {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmentâ€”i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, i) {
    this.content = e, this.openStart = t, this.openEnd = i;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let i = u_(this.content, e + this.openStart, t);
    return i && new ue(i, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new ue(s_(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return ue.empty;
    let i = t.openStart || 0, a = t.openEnd || 0;
    if (typeof i != "number" || typeof a != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ue(U.fromJSON(e, t.content), i, a);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let i = 0, a = 0;
    for (let o = e.firstChild; o && !o.isLeaf && (t || !o.type.spec.isolating); o = o.firstChild)
      i++;
    for (let o = e.lastChild; o && !o.isLeaf && (t || !o.type.spec.isolating); o = o.lastChild)
      a++;
    return new ue(e, i, a);
  }
}
ue.empty = new ue(U.empty, 0, 0);
function s_(n, e, t) {
  let { index: i, offset: a } = n.findIndex(e), o = n.maybeChild(i), { index: r, offset: s } = n.findIndex(t);
  if (a == e || o.isText) {
    if (s != t && !n.child(r).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (i != r)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(i, o.copy(s_(o.content, e - a - 1, t - a - 1)));
}
function u_(n, e, t, i) {
  let { index: a, offset: o } = n.findIndex(e), r = n.maybeChild(a);
  if (o == e || r.isText)
    return n.cut(0, e).append(t).append(n.cut(e));
  let s = u_(r.content, e - o - 1, t);
  return s && n.replaceChild(a, r.copy(s));
}
function IH(n, e, t) {
  if (t.openStart > n.depth)
    throw new Rh("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new Rh("Inconsistent open depths");
  return l_(n, e, t, 0);
}
function l_(n, e, t, i) {
  let a = n.index(i), o = n.node(i);
  if (a == e.index(i) && i < n.depth - t.openStart) {
    let r = l_(n, e, t, i + 1);
    return o.copy(o.content.replaceChild(a, r));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == i && e.depth == i) {
      let r = n.parent, s = r.content;
      return jr(r, s.cut(0, n.parentOffset).append(t.content).append(s.cut(e.parentOffset)));
    } else {
      let { start: r, end: s } = JH(t, n);
      return jr(o, h_(n, r, s, e, i));
    }
  else return jr(o, Fh(n, e, i));
}
function c_(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new Rh("Cannot join " + e.type.name + " onto " + n.type.name);
}
function Rp(n, e, t) {
  let i = n.node(t);
  return c_(i, e.node(t)), i;
}
function _r(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function il(n, e, t, i) {
  let a = (e || n).node(t), o = 0, r = e ? e.index(t) : a.childCount;
  n && (o = n.index(t), n.depth > t ? o++ : n.textOffset && (_r(n.nodeAfter, i), o++));
  for (let s = o; s < r; s++)
    _r(a.child(s), i);
  e && e.depth == t && e.textOffset && _r(e.nodeBefore, i);
}
function jr(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function h_(n, e, t, i, a) {
  let o = n.depth > a && Rp(n, e, a + 1), r = i.depth > a && Rp(t, i, a + 1), s = [];
  return il(null, n, a, s), o && r && e.index(a) == t.index(a) ? (c_(o, r), _r(jr(o, h_(n, e, t, i, a + 1)), s)) : (o && _r(jr(o, Fh(n, e, a + 1)), s), il(e, t, a, s), r && _r(jr(r, Fh(t, i, a + 1)), s)), il(i, null, a, s), new U(s);
}
function Fh(n, e, t) {
  let i = [];
  if (il(null, n, t, i), n.depth > t) {
    let a = Rp(n, e, t + 1);
    _r(jr(a, Fh(n, e, t + 1)), i);
  }
  return il(e, null, t, i), new U(i);
}
function JH(n, e) {
  let t = e.depth - n.openStart, a = e.node(t).copy(n.content);
  for (let o = t - 1; o >= 0; o--)
    a = e.node(o).copy(U.from(a));
  return {
    start: a.resolveNoCache(n.openStart + t),
    end: a.resolveNoCache(a.content.size - n.openEnd - t)
  };
}
class bl {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.pos = e, this.path = t, this.parentOffset = i, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let i = this.pos - this.path[this.path.length - 1], a = e.child(t);
    return i ? e.child(t).cut(i) : a;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let i = this.path[t * 3], a = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let o = 0; o < e; o++)
      a += i.child(o).nodeSize;
    return a;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return vt.none;
    if (this.textOffset)
      return e.child(t).marks;
    let i = e.maybeChild(t - 1), a = e.maybeChild(t);
    if (!i) {
      let s = i;
      i = a, a = s;
    }
    let o = i.marks;
    for (var r = 0; r < o.length; r++)
      o[r].type.spec.inclusive === !1 && (!a || !o[r].isInSet(a.marks)) && (o = o[r--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let i = t.marks, a = e.parent.maybeChild(e.index());
    for (var o = 0; o < i.length; o++)
      i[o].type.spec.inclusive === !1 && (!a || !i[o].isInSet(a.marks)) && (i = i[o--].removeFromSet(i));
    return i;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let i = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); i >= 0; i--)
      if (e.pos <= this.end(i) && (!t || t(this.node(i))))
        return new Ih(this, e, i);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let i = [], a = 0, o = t;
    for (let r = e; ; ) {
      let { index: s, offset: l } = r.content.findIndex(o), h = o - l;
      if (i.push(r, s, a + l), !h || (r = r.child(s), r.isText))
        break;
      o = h - 1, a += l + 1;
    }
    return new bl(t, i, o);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let i = R0.get(e);
    if (i)
      for (let o = 0; o < i.elts.length; o++) {
        let r = i.elts[o];
        if (r.pos == t)
          return r;
      }
    else
      R0.set(e, i = new ZH());
    let a = i.elts[i.i] = bl.resolve(e, t);
    return i.i = (i.i + 1) % BH, a;
  }
}
class ZH {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const BH = 12, R0 = /* @__PURE__ */ new WeakMap();
class Ih {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, i) {
    this.$from = e, this.$to = t, this.depth = i;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const HH = /* @__PURE__ */ Object.create(null);
let Tr = class Fp {
  /**
  @internal
  */
  constructor(e, t, i, a = vt.none) {
    this.type = e, this.attrs = t, this.marks = a, this.content = i || U.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, i, a = 0) {
    this.content.nodesBetween(e, t, i, a, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, t, i, a) {
    return this.content.textBetween(e, t, i, a);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, i) {
    return this.type == e && Ph(this.attrs, t || e.defaultAttrs || HH) && vt.sameSet(this.marks, i || vt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Fp(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Fp(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, i = !1) {
    if (e == t)
      return ue.empty;
    let a = this.resolve(e), o = this.resolve(t), r = i ? 0 : a.sharedDepth(t), s = a.start(r), h = a.node(r).content.cut(a.pos - s, o.pos - s);
    return new ue(h, a.depth - r, o.depth - r);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, i) {
    return IH(this.resolve(e), this.resolve(t), i);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: i, offset: a } = t.content.findIndex(e);
      if (t = t.maybeChild(i), !t)
        return null;
      if (a == e || t.isText)
        return t;
      e -= a + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: i } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: i };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: i } = this.content.findIndex(e);
    if (i < e)
      return { node: this.content.child(t), index: t, offset: i };
    let a = this.content.child(t - 1);
    return { node: a, index: t - 1, offset: i - a.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return bl.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return bl.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, i) {
    let a = !1;
    return t > e && this.nodesBetween(e, t, (o) => (i.isInSet(o.marks) && (a = !0), !a)), a;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), d_(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, i = U.empty, a = 0, o = i.childCount) {
    let r = this.contentMatchAt(e).matchFragment(i, a, o), s = r && r.matchFragment(this.content, t);
    if (!s || !s.validEnd)
      return !1;
    for (let l = a; l < o; l++)
      if (!this.type.allowsMarks(i.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, i, a) {
    if (a && !this.type.allowsMarks(a))
      return !1;
    let o = this.contentMatchAt(e).matchType(i), r = o && o.matchFragment(this.content, t);
    return r ? r.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = vt.none;
    for (let t = 0; t < this.marks.length; t++) {
      let i = this.marks[t];
      i.type.checkAttrs(i.attrs), e = i.addToSet(e);
    }
    if (!vt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let i;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      i = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, i);
    }
    let a = U.fromJSON(e, t.content), o = e.nodeType(t.type).create(t.attrs, a, i);
    return o.type.checkAttrs(o.attrs), o;
  }
};
Tr.prototype.text = void 0;
class Jh extends Tr {
  /**
  @internal
  */
  constructor(e, t, i, a) {
    if (super(e, t, null, a), !i)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = i;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : d_(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Jh(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Jh(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function d_(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class Ar {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let i = new XH(e, t);
    if (i.next == null)
      return Ar.empty;
    let a = g_(i);
    i.next && i.err("Unexpected trailing text");
    let o = VH($H(a));
    return UH(o, i), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, i = e.childCount) {
    let a = this;
    for (let o = t; a && o < i; o++)
      a = a.matchType(e.child(o).type);
    return a;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let i = 0; i < e.next.length; i++)
        if (this.next[t].type == e.next[i].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, i = 0) {
    let a = [this];
    function o(r, s) {
      let l = r.matchFragment(e, i);
      if (l && (!t || l.validEnd))
        return U.from(s.map((h) => h.createAndFill()));
      for (let h = 0; h < r.next.length; h++) {
        let { type: d, next: f } = r.next[h];
        if (!(d.isText || d.hasRequiredAttrs()) && a.indexOf(f) == -1) {
          a.push(f);
          let p = o(f, s.concat(d));
          if (p)
            return p;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == e)
        return this.wrapCache[i + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), i = [{ match: this, type: null, via: null }];
    for (; i.length; ) {
      let a = i.shift(), o = a.match;
      if (o.matchType(e)) {
        let r = [];
        for (let s = a; s.type; s = s.via)
          r.push(s.type);
        return r.reverse();
      }
      for (let r = 0; r < o.next.length; r++) {
        let { type: s, next: l } = o.next[r];
        !s.isLeaf && !s.hasRequiredAttrs() && !(s.name in t) && (!a.type || l.validEnd) && (i.push({ match: s.contentMatch, type: s, via: a }), t[s.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_â€‹th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(i) {
      e.push(i);
      for (let a = 0; a < i.next.length; a++)
        e.indexOf(i.next[a].next) == -1 && t(i.next[a].next);
    }
    return t(this), e.map((i, a) => {
      let o = a + (i.validEnd ? "*" : " ") + " ";
      for (let r = 0; r < i.next.length; r++)
        o += (r ? ", " : "") + i.next[r].type.name + "->" + e.indexOf(i.next[r].next);
      return o;
    }).join(`
`);
  }
}
Ar.empty = new Ar(!0);
class XH {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function g_(n) {
  let e = [];
  do
    e.push(GH(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function GH(n) {
  let e = [];
  do
    e.push(WH(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function WH(n) {
  let e = zH(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = QH(n, e);
    else
      break;
  return e;
}
function F0(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function QH(n, e) {
  let t = F0(n), i = t;
  return n.eat(",") && (n.next != "}" ? i = F0(n) : i = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: i, expr: e };
}
function KH(n, e) {
  let t = n.nodeTypes, i = t[e];
  if (i)
    return [i];
  let a = [];
  for (let o in t) {
    let r = t[o];
    r.groups.indexOf(e) > -1 && a.push(r);
  }
  return a.length == 0 && n.err("No node type or group '" + e + "' found"), a;
}
function zH(n) {
  if (n.eat("(")) {
    let e = g_(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = KH(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function $H(n) {
  let e = [[]];
  return a(o(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function i(r, s, l) {
    let h = { term: l, to: s };
    return e[r].push(h), h;
  }
  function a(r, s) {
    r.forEach((l) => l.to = s);
  }
  function o(r, s) {
    if (r.type == "choice")
      return r.exprs.reduce((l, h) => l.concat(o(h, s)), []);
    if (r.type == "seq")
      for (let l = 0; ; l++) {
        let h = o(r.exprs[l], s);
        if (l == r.exprs.length - 1)
          return h;
        a(h, s = t());
      }
    else if (r.type == "star") {
      let l = t();
      return i(s, l), a(o(r.expr, l), l), [i(l)];
    } else if (r.type == "plus") {
      let l = t();
      return a(o(r.expr, s), l), a(o(r.expr, l), l), [i(l)];
    } else {
      if (r.type == "opt")
        return [i(s)].concat(o(r.expr, s));
      if (r.type == "range") {
        let l = s;
        for (let h = 0; h < r.min; h++) {
          let d = t();
          a(o(r.expr, l), d), l = d;
        }
        if (r.max == -1)
          a(o(r.expr, l), l);
        else
          for (let h = r.min; h < r.max; h++) {
            let d = t();
            i(l, d), a(o(r.expr, l), d), l = d;
          }
        return [i(l)];
      } else {
        if (r.type == "name")
          return [i(s, void 0, r.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function f_(n, e) {
  return e - n;
}
function I0(n, e) {
  let t = [];
  return i(e), t.sort(f_);
  function i(a) {
    let o = n[a];
    if (o.length == 1 && !o[0].term)
      return i(o[0].to);
    t.push(a);
    for (let r = 0; r < o.length; r++) {
      let { term: s, to: l } = o[r];
      !s && t.indexOf(l) == -1 && i(l);
    }
  }
}
function VH(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(I0(n, 0));
  function t(i) {
    let a = [];
    i.forEach((r) => {
      n[r].forEach(({ term: s, to: l }) => {
        if (!s)
          return;
        let h;
        for (let d = 0; d < a.length; d++)
          a[d][0] == s && (h = a[d][1]);
        I0(n, l).forEach((d) => {
          h || a.push([s, h = []]), h.indexOf(d) == -1 && h.push(d);
        });
      });
    });
    let o = e[i.join(",")] = new Ar(i.indexOf(n.length - 1) > -1);
    for (let r = 0; r < a.length; r++) {
      let s = a[r][1].sort(f_);
      o.next.push({ type: a[r][0], next: e[s.join(",")] || t(s) });
    }
    return o;
  }
}
function UH(n, e) {
  for (let t = 0, i = [n]; t < i.length; t++) {
    let a = i[t], o = !a.validEnd, r = [];
    for (let s = 0; s < a.next.length; s++) {
      let { type: l, next: h } = a.next[s];
      r.push(l.name), o && !(l.isText || l.hasRequiredAttrs()) && (o = !1), i.indexOf(h) == -1 && i.push(h);
    }
    o && e.err("Only non-generatable nodes (" + r.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function p_(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let i = n[t];
    if (!i.hasDefault)
      return null;
    e[t] = i.default;
  }
  return e;
}
function m_(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i in n) {
    let a = e && e[i];
    if (a === void 0) {
      let o = n[i];
      if (o.hasDefault)
        a = o.default;
      else
        throw new RangeError("No value supplied for attribute " + i);
    }
    t[i] = a;
  }
  return t;
}
function y_(n, e, t, i) {
  for (let a in e)
    if (!(a in n))
      throw new RangeError(`Unsupported attribute ${a} for ${t} of type ${a}`);
  for (let a in n) {
    let o = n[a];
    o.validate && o.validate(e[a]);
  }
}
function b_(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let i in e)
      t[i] = new eX(n, i, e[i]);
  return t;
}
let J0 = class w_ {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.name = e, this.schema = t, this.spec = i, this.markSet = null, this.groups = i.group ? i.group.split(" ") : [], this.attrs = b_(e, i.attrs), this.defaultAttrs = p_(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(i.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Ar.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : m_(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, i) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Tr(this, this.computeAttrs(e), U.from(t), vt.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, i) {
    return t = U.from(t), this.checkContent(t), new Tr(this, this.computeAttrs(e), t, vt.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, i) {
    if (e = this.computeAttrs(e), t = U.from(t), t.size) {
      let r = this.contentMatch.fillBefore(t);
      if (!r)
        return null;
      t = r.append(t);
    }
    let a = this.contentMatch.matchFragment(t), o = a && a.fillBefore(U.empty, !0);
    return o ? new Tr(this, e, t.append(o), vt.setFrom(i)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let i = 0; i < e.childCount; i++)
      if (!this.allowsMarks(e.child(i).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    y_(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let i = 0; i < e.length; i++)
      this.allowsMarkType(e[i].type) ? t && t.push(e[i]) : t || (t = e.slice(0, i));
    return t ? t.length ? t : vt.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let i = /* @__PURE__ */ Object.create(null);
    e.forEach((o, r) => i[o] = new w_(o, t, r));
    let a = t.spec.topNode || "doc";
    if (!i[a])
      throw new RangeError("Schema is missing its top node type ('" + a + "')");
    if (!i.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in i.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return i;
  }
};
function qH(n, e, t) {
  let i = t.split("|");
  return (a) => {
    let o = a === null ? "null" : typeof a;
    if (i.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${i} for attribute ${e} on type ${n}, got ${o}`);
  };
}
class eX {
  constructor(e, t, i) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(i, "default"), this.default = i.default, this.validate = typeof i.validate == "string" ? qH(e, t, i.validate) : i.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Cd {
  /**
  @internal
  */
  constructor(e, t, i, a) {
    this.name = e, this.rank = t, this.schema = i, this.spec = a, this.attrs = b_(e, a.attrs), this.excluded = null;
    let o = p_(this.attrs);
    this.instance = o ? new vt(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new vt(this, m_(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let i = /* @__PURE__ */ Object.create(null), a = 0;
    return e.forEach((o, r) => i[o] = new Cd(o, a++, t, r)), i;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    y_(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class v_ {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let a in e)
      t[a] = e[a];
    t.nodes = mn.from(e.nodes), t.marks = mn.from(e.marks || {}), this.nodes = J0.compile(this.spec.nodes, this), this.marks = Cd.compile(this.spec.marks, this);
    let i = /* @__PURE__ */ Object.create(null);
    for (let a in this.nodes) {
      if (a in this.marks)
        throw new RangeError(a + " can not be both a node and a mark");
      let o = this.nodes[a], r = o.spec.content || "", s = o.spec.marks;
      if (o.contentMatch = i[r] || (i[r] = Ar.parse(r, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = s == "_" ? null : s ? Z0(this, s.split(" ")) : s == "" || !o.inlineContent ? [] : null;
    }
    for (let a in this.marks) {
      let o = this.marks[a], r = o.spec.excludes;
      o.excluded = r == null ? [o] : r == "" ? [] : Z0(this, r.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, i, a) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof J0) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, i, a);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let i = this.nodes.text;
    return new Jh(i, i.defaultAttrs, e, vt.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Tr.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return vt.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function Z0(n, e) {
  let t = [];
  for (let i = 0; i < e.length; i++) {
    let a = e[i], o = n.marks[a], r = o;
    if (o)
      t.push(o);
    else
      for (let s in n.marks) {
        let l = n.marks[s];
        (a == "_" || l.spec.group && l.spec.group.split(" ").indexOf(a) > -1) && t.push(r = l);
      }
    if (!r)
      throw new SyntaxError("Unknown mark type: '" + e[i] + "'");
  }
  return t;
}
function tX(n) {
  return n.tag != null;
}
function nX(n) {
  return n.style != null;
}
class Yo {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let i = this.matchedStyles = [];
    t.forEach((a) => {
      if (tX(a))
        this.tags.push(a);
      else if (nX(a)) {
        let o = /[^=]*/.exec(a.style)[0];
        i.indexOf(o) < 0 && i.push(o), this.styles.push(a);
      }
    }), this.normalizeLists = !this.tags.some((a) => {
      if (!/^(ul|ol)\b/.test(a.tag) || !a.node)
        return !1;
      let o = e.nodes[a.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let i = new H0(this, t, !1);
    return i.addAll(e, vt.none, t.from, t.to), i.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let i = new H0(this, t, !0);
    return i.addAll(e, vt.none, t.from, t.to), ue.maxOpen(i.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, i) {
    for (let a = i ? this.tags.indexOf(i) + 1 : 0; a < this.tags.length; a++) {
      let o = this.tags[a];
      if (oX(e, o.tag) && (o.namespace === void 0 || e.namespaceURI == o.namespace) && (!o.context || t.matchesContext(o.context))) {
        if (o.getAttrs) {
          let r = o.getAttrs(e);
          if (r === !1)
            continue;
          o.attrs = r || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, i, a) {
    for (let o = a ? this.styles.indexOf(a) + 1 : 0; o < this.styles.length; o++) {
      let r = this.styles[o], s = r.style;
      if (!(s.indexOf(e) != 0 || r.context && !i.matchesContext(r.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      s.length > e.length && (s.charCodeAt(e.length) != 61 || s.slice(e.length + 1) != t))) {
        if (r.getAttrs) {
          let l = r.getAttrs(t);
          if (l === !1)
            continue;
          r.attrs = l || void 0;
        }
        return r;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function i(a) {
      let o = a.priority == null ? 50 : a.priority, r = 0;
      for (; r < t.length; r++) {
        let s = t[r];
        if ((s.priority == null ? 50 : s.priority) < o)
          break;
      }
      t.splice(r, 0, a);
    }
    for (let a in e.marks) {
      let o = e.marks[a].spec.parseDOM;
      o && o.forEach((r) => {
        i(r = X0(r)), r.mark || r.ignore || r.clearMark || (r.mark = a);
      });
    }
    for (let a in e.nodes) {
      let o = e.nodes[a].spec.parseDOM;
      o && o.forEach((r) => {
        i(r = X0(r)), r.node || r.ignore || r.mark || (r.node = a);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Yo(e, Yo.schemaRules(e)));
  }
}
const C_ = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, iX = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, S_ = { ol: !0, ul: !0 }, Zh = 1, Bh = 2, al = 4;
function B0(n, e, t) {
  return e != null ? (e ? Zh : 0) | (e === "full" ? Bh : 0) : n && n.whitespace == "pre" ? Zh | Bh : t & ~al;
}
class th {
  constructor(e, t, i, a, o, r) {
    this.type = e, this.attrs = t, this.marks = i, this.solid = a, this.options = r, this.content = [], this.activeMarks = vt.none, this.match = o || (r & al ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(U.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let i = this.type.contentMatch, a;
        return (a = i.findWrapping(e.type)) ? (this.match = i, a) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Zh)) {
      let i = this.content[this.content.length - 1], a;
      if (i && i.isText && (a = /[ \t\r\n\u000c]+$/.exec(i.text))) {
        let o = i;
        i.text.length == a[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - a[0].length));
      }
    }
    let t = U.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(U.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !C_.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class H0 {
  constructor(e, t, i) {
    this.parser = e, this.options = t, this.isOpen = i, this.open = 0;
    let a = t.topNode, o, r = B0(null, t.preserveWhitespace, 0) | (i ? al : 0);
    a ? o = new th(a.type, a.attrs, vt.none, !0, t.topMatch || a.type.contentMatch, r) : i ? o = new th(null, null, vt.none, !0, null, r) : o = new th(e.schema.topNodeType, null, vt.none, !0, null, r), this.nodes = [o], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let i = e.nodeValue, a = this.top;
    if (a.options & Bh || a.inlineContext(e) || /[^ \t\r\n\u000c]/.test(i)) {
      if (a.options & Zh)
        a.options & Bh ? i = i.replace(/\r\n?/g, `
`) : i = i.replace(/\r?\n|\r/g, " ");
      else if (i = i.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(i) && this.open == this.nodes.length - 1) {
        let o = a.content[a.content.length - 1], r = e.previousSibling;
        (!o || r && r.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (i = i.slice(1));
      }
      i && this.insertNode(this.parser.schema.text(i), t), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, i) {
    let a = e.nodeName.toLowerCase(), o;
    S_.hasOwnProperty(a) && this.parser.normalizeLists && aX(e);
    let r = this.options.ruleFromNode && this.options.ruleFromNode(e) || (o = this.parser.matchTag(e, this, i));
    if (r ? r.ignore : iX.hasOwnProperty(a))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!r || r.skip || r.closeParent) {
      r && r.closeParent ? this.open = Math.max(0, this.open - 1) : r && r.skip.nodeType && (e = r.skip);
      let s, l = this.top, h = this.needsBlock;
      if (C_.hasOwnProperty(a))
        l.content.length && l.content[0].isInline && this.open && (this.open--, l = this.top), s = !0, l.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        return;
      }
      let d = r && r.skip ? t : this.readStyles(e, t);
      d && this.addAll(e, d), s && this.sync(l), this.needsBlock = h;
    } else {
      let s = this.readStyles(e, t);
      s && this.addElementByRule(e, r, s, r.consuming === !1 ? o : void 0);
    }
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let i = e.style;
    if (i && i.length)
      for (let a = 0; a < this.parser.matchedStyles.length; a++) {
        let o = this.parser.matchedStyles[a], r = i.getPropertyValue(o);
        if (r)
          for (let s = void 0; ; ) {
            let l = this.parser.matchStyle(o, r, this, s);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? t = t.filter((h) => !l.clearMark(h)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              s = l;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, i, a) {
    let o, r;
    if (t.node)
      if (r = this.parser.schema.nodes[t.node], r.isLeaf)
        this.insertNode(r.create(t.attrs), i) || this.leafFallback(e, i);
      else {
        let l = this.enter(r, t.attrs || null, i, t.preserveWhitespace);
        l && (o = !0, i = l);
      }
    else {
      let l = this.parser.schema.marks[t.mark];
      i = i.concat(l.create(t.attrs));
    }
    let s = this.top;
    if (r && r.isLeaf)
      this.findInside(e);
    else if (a)
      this.addElement(e, i, a);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, i));
    else {
      let l = e;
      typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, !0), this.addAll(l, i);
    }
    o && this.sync(s) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, i, a) {
    let o = i || 0;
    for (let r = i ? e.childNodes[i] : e.firstChild, s = a == null ? null : e.childNodes[a]; r != s; r = r.nextSibling, ++o)
      this.findAtPoint(e, o), this.addDOM(r, t);
    this.findAtPoint(e, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t) {
    let i, a;
    for (let o = this.open; o >= 0; o--) {
      let r = this.nodes[o], s = r.findWrapping(e);
      if (s && (!i || i.length > s.length) && (i = s, a = r, !s.length) || r.solid)
        break;
    }
    if (!i)
      return null;
    this.sync(a);
    for (let o = 0; o < i.length; o++)
      t = this.enterInner(i[o], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let a = this.textblockFromContext();
      a && (t = this.enterInner(a, null, t));
    }
    let i = this.findPlace(e, t);
    if (i) {
      this.closeExtra();
      let a = this.top;
      a.match && (a.match = a.match.matchType(e.type));
      let o = vt.none;
      for (let r of i.concat(e.marks))
        (a.type ? a.type.allowsMarkType(r.type) : G0(r.type, e.type)) && (o = r.addToSet(o));
      return a.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, i, a) {
    let o = this.findPlace(e.create(t), i);
    return o && (o = this.enterInner(e, t, i, !0, a)), o;
  }
  // Open a node of the given type
  enterInner(e, t, i, a = !1, o) {
    this.closeExtra();
    let r = this.top;
    r.match = r.match && r.match.matchType(e);
    let s = B0(e, o, r.options);
    r.options & al && r.content.length == 0 && (s |= al);
    let l = vt.none;
    return i = i.filter((h) => (r.type ? r.type.allowsMarkType(h.type) : G0(h.type, e)) ? (l = h.addToSet(l), !1) : !0), this.nodes.push(new th(e, t, l, a, null, s)), this.open++, i;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--)
      if (this.nodes[t] == e)
        return this.open = t, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let i = this.nodes[t].content;
      for (let a = i.length - 1; a >= 0; a--)
        e += i[a].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].node == e && this.find[i].offset == t && (this.find[i].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, i) {
    if (e != t && this.find)
      for (let a = 0; a < this.find.length; a++)
        this.find[a].pos == null && e.nodeType == 1 && e.contains(this.find[a].node) && t.compareDocumentPosition(this.find[a].node) & (i ? 2 : 4) && (this.find[a].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), i = this.options.context, a = !this.isOpen && (!i || i.parent.type == this.nodes[0].type), o = -(i ? i.depth + 1 : 0) + (a ? 0 : 1), r = (s, l) => {
      for (; s >= 0; s--) {
        let h = t[s];
        if (h == "") {
          if (s == t.length - 1 || s == 0)
            continue;
          for (; l >= o; l--)
            if (r(s - 1, l))
              return !0;
          return !1;
        } else {
          let d = l > 0 || l == 0 && a ? this.nodes[l].type : i && l >= o ? i.node(l - o).type : null;
          if (!d || d.name != h && d.groups.indexOf(h) == -1)
            return !1;
          l--;
        }
      }
      return !0;
    };
    return r(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let i = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (i && i.isTextblock && i.defaultAttrs)
          return i;
      }
    for (let t in this.parser.schema.nodes) {
      let i = this.parser.schema.nodes[t];
      if (i.isTextblock && i.defaultAttrs)
        return i;
    }
  }
}
function aX(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let i = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    i && S_.hasOwnProperty(i) && t ? (t.appendChild(e), e = t) : i == "li" ? t = e : i && (t = null);
  }
}
function oX(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function X0(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function G0(n, e) {
  let t = e.schema.nodes;
  for (let i in t) {
    let a = t[i];
    if (!a.allowsMarkType(n))
      continue;
    let o = [], r = (s) => {
      o.push(s);
      for (let l = 0; l < s.edgeCount; l++) {
        let { type: h, next: d } = s.edge(l);
        if (h == e || o.indexOf(d) < 0 && r(d))
          return !0;
      }
    };
    if (r(a.contentMatch))
      return !0;
  }
}
class Gr {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, i) {
    i || (i = Mf(t).createDocumentFragment());
    let a = i, o = [];
    return e.forEach((r) => {
      if (o.length || r.marks.length) {
        let s = 0, l = 0;
        for (; s < o.length && l < r.marks.length; ) {
          let h = r.marks[l];
          if (!this.marks[h.type.name]) {
            l++;
            continue;
          }
          if (!h.eq(o[s][0]) || h.type.spec.spanning === !1)
            break;
          s++, l++;
        }
        for (; s < o.length; )
          a = o.pop()[1];
        for (; l < r.marks.length; ) {
          let h = r.marks[l++], d = this.serializeMark(h, r.isInline, t);
          d && (o.push([h, a]), a.appendChild(d.dom), a = d.contentDOM || d.dom);
        }
      }
      a.appendChild(this.serializeNodeInner(r, t));
    }), i;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: i, contentDOM: a } = yh(Mf(t), this.nodes[e.type.name](e), null, e.attrs);
    if (a) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, a);
    }
    return i;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let i = this.serializeNodeInner(e, t);
    for (let a = e.marks.length - 1; a >= 0; a--) {
      let o = this.serializeMark(e.marks[a], e.isInline, t);
      o && ((o.contentDOM || o.dom).appendChild(i), i = o.dom);
    }
    return i;
  }
  /**
  @internal
  */
  serializeMark(e, t, i = {}) {
    let a = this.marks[e.type.name];
    return a && yh(Mf(i), a(e, t), null, e.attrs);
  }
  static renderSpec(e, t, i = null, a) {
    return yh(e, t, i, a);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Gr(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = W0(e.nodes);
    return t.text || (t.text = (i) => i.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return W0(e.marks);
  }
}
function W0(n) {
  let e = {};
  for (let t in n) {
    let i = n[t].spec.toDOM;
    i && (e[t] = i);
  }
  return e;
}
function Mf(n) {
  return n.document || window.document;
}
const Q0 = /* @__PURE__ */ new WeakMap();
function rX(n) {
  let e = Q0.get(n);
  return e === void 0 && Q0.set(n, e = sX(n)), e;
}
function sX(n) {
  let e = null;
  function t(i) {
    if (i && typeof i == "object")
      if (Array.isArray(i))
        if (typeof i[0] == "string")
          e || (e = []), e.push(i);
        else
          for (let a = 0; a < i.length; a++)
            t(i[a]);
      else
        for (let a in i)
          t(i[a]);
  }
  return t(n), e;
}
function yh(n, e, t, i) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let a = e[0], o;
  if (typeof a != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (i && (o = rX(i)) && o.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let r = a.indexOf(" ");
  r > 0 && (t = a.slice(0, r), a = a.slice(r + 1));
  let s, l = t ? n.createElementNS(t, a) : n.createElement(a), h = e[1], d = 1;
  if (h && typeof h == "object" && h.nodeType == null && !Array.isArray(h)) {
    d = 2;
    for (let f in h)
      if (h[f] != null) {
        let p = f.indexOf(" ");
        p > 0 ? l.setAttributeNS(f.slice(0, p), f.slice(p + 1), h[f]) : l.setAttribute(f, h[f]);
      }
  }
  for (let f = d; f < e.length; f++) {
    let p = e[f];
    if (p === 0) {
      if (f < e.length - 1 || f > d)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: y, contentDOM: m } = yh(n, p, t, i);
      if (l.appendChild(y), m) {
        if (s)
          throw new RangeError("Multiple content holes");
        s = m;
      }
    }
  }
  return { dom: l, contentDOM: s };
}
const k_ = 65535, __ = Math.pow(2, 16);
function uX(n, e) {
  return n + e * __;
}
function K0(n) {
  return n & k_;
}
function lX(n) {
  return (n - (n & k_)) / __;
}
const j_ = 1, T_ = 2, bh = 4, L_ = 8;
class Ip {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.pos = e, this.delInfo = t, this.recover = i;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & L_) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (j_ | bh)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (T_ | bh)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & bh) > 0;
  }
}
class fi {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && fi.empty)
      return fi.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, i = K0(e);
    if (!this.inverted)
      for (let a = 0; a < i; a++)
        t += this.ranges[a * 3 + 2] - this.ranges[a * 3 + 1];
    return this.ranges[i * 3] + t + lX(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, i) {
    let a = 0, o = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let s = 0; s < this.ranges.length; s += 3) {
      let l = this.ranges[s] - (this.inverted ? a : 0);
      if (l > e)
        break;
      let h = this.ranges[s + o], d = this.ranges[s + r], f = l + h;
      if (e <= f) {
        let p = h ? e == l ? -1 : e == f ? 1 : t : t, y = l + a + (p < 0 ? 0 : d);
        if (i)
          return y;
        let m = e == (t < 0 ? l : f) ? null : uX(s / 3, e - l), w = e == l ? T_ : e == f ? j_ : bh;
        return (t < 0 ? e != l : e != f) && (w |= L_), new Ip(y, w, m);
      }
      a += d - h;
    }
    return i ? e + a : new Ip(e + a, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let i = 0, a = K0(t), o = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let s = 0; s < this.ranges.length; s += 3) {
      let l = this.ranges[s] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let h = this.ranges[s + o], d = l + h;
      if (e <= d && s == a * 3)
        return !0;
      i += this.ranges[s + r] - h;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let a = 0, o = 0; a < this.ranges.length; a += 3) {
      let r = this.ranges[a], s = r - (this.inverted ? o : 0), l = r + (this.inverted ? 0 : o), h = this.ranges[a + t], d = this.ranges[a + i];
      e(s, s + h, l, l + d), o += d - h;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new fi(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? fi.empty : new fi(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
fi.empty = new fi([]);
class Os {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], t, i = 0, a = e.length) {
    this.maps = e, this.mirror = t, this.from = i, this.to = a;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new Os(this.maps, this.mirror, e, t);
  }
  /**
  @internal
  */
  copy() {
    return new Os(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.to = this.maps.push(e), t != null && this.setMirror(this.maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, i = this.maps.length; t < e.maps.length; t++) {
      let a = e.getMirror(t);
      this.appendMap(e.maps[t], a != null && a < t ? i + a : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, i = this.maps.length + e.maps.length; t >= 0; t--) {
      let a = e.getMirror(t);
      this.appendMap(e.maps[t].invert(), a != null && a > t ? i - a - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Os();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let i = this.from; i < this.to; i++)
      e = this.maps[i].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, i) {
    let a = 0;
    for (let o = this.from; o < this.to; o++) {
      let r = this.maps[o], s = r.mapResult(e, t);
      if (s.recover != null) {
        let l = this.getMirror(o);
        if (l != null && l > o && l < this.to) {
          o = l, e = this.maps[l].recover(s.recover);
          continue;
        }
      }
      a |= s.delInfo, e = s.pos;
    }
    return i ? e : new Ip(e, a, null);
  }
}
const Nf = /* @__PURE__ */ Object.create(null);
class Ln {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return fi.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let i = Nf[t.stepType];
    if (!i)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return i.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in Nf)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Nf[e] = t, t.prototype.jsonID = e, t;
  }
}
class Wt {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Wt(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Wt(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, i, a) {
    try {
      return Wt.ok(e.replace(t, i, a));
    } catch (o) {
      if (o instanceof Rh)
        return Wt.fail(o.message);
      throw o;
    }
  }
}
function ny(n, e, t) {
  let i = [];
  for (let a = 0; a < n.childCount; a++) {
    let o = n.child(a);
    o.content.size && (o = o.copy(ny(o.content, e, o))), o.isInline && (o = e(o, t, a)), i.push(o);
  }
  return U.fromArray(i);
}
class Mo extends Ln {
  /**
  Create a mark step.
  */
  constructor(e, t, i) {
    super(), this.from = e, this.to = t, this.mark = i;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), i = e.resolve(this.from), a = i.node(i.sharedDepth(this.to)), o = new ue(ny(t.content, (r, s) => !r.isAtom || !s.type.allowsMarkType(this.mark.type) ? r : r.mark(this.mark.addToSet(r.marks)), a), t.openStart, t.openEnd);
    return Wt.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new ba(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return t.deleted && i.deleted || t.pos >= i.pos ? null : new Mo(t.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof Mo && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Mo(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Mo(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Ln.jsonID("addMark", Mo);
class ba extends Ln {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, i) {
    super(), this.from = e, this.to = t, this.mark = i;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), i = new ue(ny(t.content, (a) => a.mark(this.mark.removeFromSet(a.marks)), e), t.openStart, t.openEnd);
    return Wt.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new Mo(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return t.deleted && i.deleted || t.pos >= i.pos ? null : new ba(t.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof ba && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ba(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new ba(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Ln.jsonID("removeMark", ba);
class No extends Ln {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Wt.fail("No node at mark step's position");
    let i = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return Wt.fromReplace(e, this.pos, this.pos + 1, new ue(U.from(i), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let i = this.mark.addToSet(t.marks);
      if (i.length == t.marks.length) {
        for (let a = 0; a < t.marks.length; a++)
          if (!t.marks[a].isInSet(i))
            return new No(this.pos, t.marks[a]);
        return new No(this.pos, this.mark);
      }
    }
    return new Is(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new No(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new No(t.pos, e.markFromJSON(t.mark));
  }
}
Ln.jsonID("addNodeMark", No);
class Is extends Ln {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Wt.fail("No node at mark step's position");
    let i = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return Wt.fromReplace(e, this.pos, this.pos + 1, new ue(U.from(i), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new No(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Is(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Is(t.pos, e.markFromJSON(t.mark));
  }
}
Ln.jsonID("removeNodeMark", Is);
class on extends Ln {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`â€”the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, i, a = !1) {
    super(), this.from = e, this.to = t, this.slice = i, this.structure = a;
  }
  apply(e) {
    return this.structure && Jp(e, this.from, this.to) ? Wt.fail("Structure replace would overwrite content") : Wt.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new fi([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new on(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return t.deletedAcross && i.deletedAcross ? null : new on(t.pos, Math.max(t.pos, i.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof on) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? ue.empty : new ue(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new on(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? ue.empty : new ue(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new on(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new on(t.from, t.to, ue.fromJSON(e, t.slice), !!t.structure);
  }
}
Ln.jsonID("replace", on);
class sn extends Ln {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, i, a, o, r, s = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = i, this.gapTo = a, this.slice = o, this.insert = r, this.structure = s;
  }
  apply(e) {
    if (this.structure && (Jp(e, this.from, this.gapFrom) || Jp(e, this.gapTo, this.to)))
      return Wt.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return Wt.fail("Gap is not a flat range");
    let i = this.slice.insertAt(this.insert, t.content);
    return i ? Wt.fromReplace(e, this.from, this.to, i) : Wt.fail("Content does not fit in gap");
  }
  getMap() {
    return new fi([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new sn(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1), a = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), o = this.to == this.gapTo ? i.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && i.deletedAcross || a < t.pos || o > i.pos ? null : new sn(t.pos, i.pos, a, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new sn(t.from, t.to, t.gapFrom, t.gapTo, ue.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
Ln.jsonID("replaceAround", sn);
function Jp(n, e, t) {
  let i = n.resolve(e), a = t - e, o = i.depth;
  for (; a > 0 && o > 0 && i.indexAfter(o) == i.node(o).childCount; )
    o--, a--;
  if (a > 0) {
    let r = i.node(o).maybeChild(i.indexAfter(o));
    for (; a > 0; ) {
      if (!r || r.isLeaf)
        return !0;
      r = r.firstChild, a--;
    }
  }
  return !1;
}
function cX(n, e, t, i) {
  let a = [], o = [], r, s;
  n.doc.nodesBetween(e, t, (l, h, d) => {
    if (!l.isInline)
      return;
    let f = l.marks;
    if (!i.isInSet(f) && d.type.allowsMarkType(i.type)) {
      let p = Math.max(h, e), y = Math.min(h + l.nodeSize, t), m = i.addToSet(f);
      for (let w = 0; w < f.length; w++)
        f[w].isInSet(m) || (r && r.to == p && r.mark.eq(f[w]) ? r.to = y : a.push(r = new ba(p, y, f[w])));
      s && s.to == p ? s.to = y : o.push(s = new Mo(p, y, i));
    }
  }), a.forEach((l) => n.step(l)), o.forEach((l) => n.step(l));
}
function hX(n, e, t, i) {
  let a = [], o = 0;
  n.doc.nodesBetween(e, t, (r, s) => {
    if (!r.isInline)
      return;
    o++;
    let l = null;
    if (i instanceof Cd) {
      let h = r.marks, d;
      for (; d = i.isInSet(h); )
        (l || (l = [])).push(d), h = d.removeFromSet(h);
    } else i ? i.isInSet(r.marks) && (l = [i]) : l = r.marks;
    if (l && l.length) {
      let h = Math.min(s + r.nodeSize, t);
      for (let d = 0; d < l.length; d++) {
        let f = l[d], p;
        for (let y = 0; y < a.length; y++) {
          let m = a[y];
          m.step == o - 1 && f.eq(a[y].style) && (p = m);
        }
        p ? (p.to = h, p.step = o) : a.push({ style: f, from: Math.max(s, e), to: h, step: o });
      }
    }
  }), a.forEach((r) => n.step(new ba(r.from, r.to, r.style)));
}
function x_(n, e, t, i = t.contentMatch, a = !0) {
  let o = n.doc.nodeAt(e), r = [], s = e + 1;
  for (let l = 0; l < o.childCount; l++) {
    let h = o.child(l), d = s + h.nodeSize, f = i.matchType(h.type);
    if (!f)
      r.push(new on(s, d, ue.empty));
    else {
      i = f;
      for (let p = 0; p < h.marks.length; p++)
        t.allowsMarkType(h.marks[p].type) || n.step(new ba(s, d, h.marks[p]));
      if (a && h.isText && t.whitespace != "pre") {
        let p, y = /\r?\n|\r/g, m;
        for (; p = y.exec(h.text); )
          m || (m = new ue(U.from(t.schema.text(" ", t.allowedMarks(h.marks))), 0, 0)), r.push(new on(s + p.index, s + p.index + p[0].length, m));
      }
    }
    s = d;
  }
  if (!i.validEnd) {
    let l = i.fillBefore(U.empty, !0);
    n.replace(s, s, new ue(l, 0, 0));
  }
  for (let l = r.length - 1; l >= 0; l--)
    n.step(r[l]);
}
function dX(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function iu(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let i = n.depth; ; --i) {
    let a = n.$from.node(i), o = n.$from.index(i), r = n.$to.indexAfter(i);
    if (i < n.depth && a.canReplace(o, r, t))
      return i;
    if (i == 0 || a.type.spec.isolating || !dX(a, o, r))
      break;
  }
  return null;
}
function gX(n, e, t) {
  let { $from: i, $to: a, depth: o } = e, r = i.before(o + 1), s = a.after(o + 1), l = r, h = s, d = U.empty, f = 0;
  for (let m = o, w = !1; m > t; m--)
    w || i.index(m) > 0 ? (w = !0, d = U.from(i.node(m).copy(d)), f++) : l--;
  let p = U.empty, y = 0;
  for (let m = o, w = !1; m > t; m--)
    w || a.after(m + 1) < a.end(m) ? (w = !0, p = U.from(a.node(m).copy(p)), y++) : h++;
  n.step(new sn(l, h, r, s, new ue(d.append(p), f, y), d.size - f, !0));
}
function iy(n, e, t = null, i = n) {
  let a = fX(n, e), o = a && pX(i, e);
  return o ? a.map(z0).concat({ type: e, attrs: t }).concat(o.map(z0)) : null;
}
function z0(n) {
  return { type: n, attrs: null };
}
function fX(n, e) {
  let { parent: t, startIndex: i, endIndex: a } = n, o = t.contentMatchAt(i).findWrapping(e);
  if (!o)
    return null;
  let r = o.length ? o[0] : e;
  return t.canReplaceWith(i, a, r) ? o : null;
}
function pX(n, e) {
  let { parent: t, startIndex: i, endIndex: a } = n, o = t.child(i), r = e.contentMatch.findWrapping(o.type);
  if (!r)
    return null;
  let l = (r.length ? r[r.length - 1] : e).contentMatch;
  for (let h = i; l && h < a; h++)
    l = l.matchType(t.child(h).type);
  return !l || !l.validEnd ? null : r;
}
function mX(n, e, t) {
  let i = U.empty;
  for (let r = t.length - 1; r >= 0; r--) {
    if (i.size) {
      let s = t[r].type.contentMatch.matchFragment(i);
      if (!s || !s.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    i = U.from(t[r].type.create(t[r].attrs, i));
  }
  let a = e.start, o = e.end;
  n.step(new sn(a, o, a, o, new ue(i, 0, 0), t.length, !0));
}
function yX(n, e, t, i, a) {
  if (!i.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = n.steps.length;
  n.doc.nodesBetween(e, t, (r, s) => {
    let l = typeof a == "function" ? a(r) : a;
    if (r.isTextblock && !r.hasMarkup(i, l) && vX(n.doc, n.mapping.slice(o).map(s), i)) {
      let h = null;
      if (i.schema.linebreakReplacement) {
        let y = i.whitespace == "pre", m = !!i.contentMatch.matchType(i.schema.linebreakReplacement);
        y && !m ? h = !1 : !y && m && (h = !0);
      }
      h === !1 && wX(n, r, s, o), x_(n, n.mapping.slice(o).map(s, 1), i, void 0, h === null);
      let d = n.mapping.slice(o), f = d.map(s, 1), p = d.map(s + r.nodeSize, 1);
      return n.step(new sn(f, p, f + 1, p - 1, new ue(U.from(i.create(l, null, r.marks)), 0, 0), 1, !0)), h === !0 && bX(n, r, s, o), !1;
    }
  });
}
function bX(n, e, t, i) {
  e.forEach((a, o) => {
    if (a.isText) {
      let r, s = /\r?\n|\r/g;
      for (; r = s.exec(a.text); ) {
        let l = n.mapping.slice(i).map(t + 1 + o + r.index);
        n.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function wX(n, e, t, i) {
  e.forEach((a, o) => {
    if (a.type == a.type.schema.linebreakReplacement) {
      let r = n.mapping.slice(i).map(t + 1 + o);
      n.replaceWith(r, r + 1, e.type.schema.text(`
`));
    }
  });
}
function vX(n, e, t) {
  let i = n.resolve(e), a = i.index();
  return i.parent.canReplaceWith(a, a + 1, t);
}
function CX(n, e, t, i, a) {
  let o = n.doc.nodeAt(e);
  if (!o)
    throw new RangeError("No node at given position");
  t || (t = o.type);
  let r = t.create(i, null, a || o.marks);
  if (o.isLeaf)
    return n.replaceWith(e, e + o.nodeSize, r);
  if (!t.validContent(o.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new sn(e, e + o.nodeSize, e + 1, e + o.nodeSize - 1, new ue(U.from(r), 0, 0), 1, !0));
}
function As(n, e, t = 1, i) {
  let a = n.resolve(e), o = a.depth - t, r = i && i[i.length - 1] || a.parent;
  if (o < 0 || a.parent.type.spec.isolating || !a.parent.canReplace(a.index(), a.parent.childCount) || !r.type.validContent(a.parent.content.cutByIndex(a.index(), a.parent.childCount)))
    return !1;
  for (let h = a.depth - 1, d = t - 2; h > o; h--, d--) {
    let f = a.node(h), p = a.index(h);
    if (f.type.spec.isolating)
      return !1;
    let y = f.content.cutByIndex(p, f.childCount), m = i && i[d + 1];
    m && (y = y.replaceChild(0, m.type.create(m.attrs)));
    let w = i && i[d] || f;
    if (!f.canReplace(p + 1, f.childCount) || !w.type.validContent(y))
      return !1;
  }
  let s = a.indexAfter(o), l = i && i[0];
  return a.node(o).canReplaceWith(s, s, l ? l.type : a.node(o + 1).type);
}
function SX(n, e, t = 1, i) {
  let a = n.doc.resolve(e), o = U.empty, r = U.empty;
  for (let s = a.depth, l = a.depth - t, h = t - 1; s > l; s--, h--) {
    o = U.from(a.node(s).copy(o));
    let d = i && i[h];
    r = U.from(d ? d.type.create(d.attrs, r) : a.node(s).copy(r));
  }
  n.step(new on(e, e, new ue(o.append(r), t, t), !0));
}
function zo(n, e) {
  let t = n.resolve(e), i = t.index();
  return E_(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(i, i + 1);
}
function E_(n, e) {
  return !!(n && e && !n.isLeaf && n.canAppend(e));
}
function Sd(n, e, t = -1) {
  let i = n.resolve(e);
  for (let a = i.depth; ; a--) {
    let o, r, s = i.index(a);
    if (a == i.depth ? (o = i.nodeBefore, r = i.nodeAfter) : t > 0 ? (o = i.node(a + 1), s++, r = i.node(a).maybeChild(s)) : (o = i.node(a).maybeChild(s - 1), r = i.node(a + 1)), o && !o.isTextblock && E_(o, r) && i.node(a).canReplace(s, s + 1))
      return e;
    if (a == 0)
      break;
    e = t < 0 ? i.before(a) : i.after(a);
  }
}
function kX(n, e, t) {
  let i = new on(e - t, e + t, ue.empty, !0);
  n.step(i);
}
function _X(n, e, t) {
  let i = n.resolve(e);
  if (i.parent.canReplaceWith(i.index(), i.index(), t))
    return e;
  if (i.parentOffset == 0)
    for (let a = i.depth - 1; a >= 0; a--) {
      let o = i.index(a);
      if (i.node(a).canReplaceWith(o, o, t))
        return i.before(a + 1);
      if (o > 0)
        return null;
    }
  if (i.parentOffset == i.parent.content.size)
    for (let a = i.depth - 1; a >= 0; a--) {
      let o = i.indexAfter(a);
      if (i.node(a).canReplaceWith(o, o, t))
        return i.after(a + 1);
      if (o < i.node(a).childCount)
        return null;
    }
  return null;
}
function D_(n, e, t) {
  let i = n.resolve(e);
  if (!t.content.size)
    return e;
  let a = t.content;
  for (let o = 0; o < t.openStart; o++)
    a = a.firstChild.content;
  for (let o = 1; o <= (t.openStart == 0 && t.size ? 2 : 1); o++)
    for (let r = i.depth; r >= 0; r--) {
      let s = r == i.depth ? 0 : i.pos <= (i.start(r + 1) + i.end(r + 1)) / 2 ? -1 : 1, l = i.index(r) + (s > 0 ? 1 : 0), h = i.node(r), d = !1;
      if (o == 1)
        d = h.canReplace(l, l, a);
      else {
        let f = h.contentMatchAt(l).findWrapping(a.firstChild.type);
        d = f && h.canReplaceWith(l, l, f[0]);
      }
      if (d)
        return s == 0 ? i.pos : s < 0 ? i.before(r + 1) : i.after(r + 1);
    }
  return null;
}
function kd(n, e, t = e, i = ue.empty) {
  if (e == t && !i.size)
    return null;
  let a = n.resolve(e), o = n.resolve(t);
  return M_(a, o, i) ? new on(e, t, i) : new jX(a, o, i).fit();
}
function M_(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class jX {
  constructor(e, t, i) {
    this.$from = e, this.$to = t, this.unplaced = i, this.frontier = [], this.placed = U.empty;
    for (let a = 0; a <= e.depth; a++) {
      let o = e.node(a);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(e.indexAfter(a))
      });
    }
    for (let a = e.depth; a > 0; a--)
      this.placed = U.from(e.node(a).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let h = this.findFittable();
      h ? this.placeNodes(h) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, i = this.$from, a = this.close(e < 0 ? this.$to : i.doc.resolve(e));
    if (!a)
      return null;
    let o = this.placed, r = i.depth, s = a.depth;
    for (; r && s && o.childCount == 1; )
      o = o.firstChild.content, r--, s--;
    let l = new ue(o, r, s);
    return e > -1 ? new sn(i.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || i.pos != this.$to.pos ? new on(i.pos, a.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, i = 0, a = this.unplaced.openEnd; i < e; i++) {
      let o = t.firstChild;
      if (t.childCount > 1 && (a = 0), o.type.spec.isolating && a <= i) {
        e = i;
        break;
      }
      t = o.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let i = t == 1 ? e : this.unplaced.openStart; i >= 0; i--) {
        let a, o = null;
        i ? (o = Of(this.unplaced.content, i - 1).firstChild, a = o.content) : a = this.unplaced.content;
        let r = a.firstChild;
        for (let s = this.depth; s >= 0; s--) {
          let { type: l, match: h } = this.frontier[s], d, f = null;
          if (t == 1 && (r ? h.matchType(r.type) || (f = h.fillBefore(U.from(r), !1)) : o && l.compatibleContent(o.type)))
            return { sliceDepth: i, frontierDepth: s, parent: o, inject: f };
          if (t == 2 && r && (d = h.findWrapping(r.type)))
            return { sliceDepth: i, frontierDepth: s, parent: o, wrap: d };
          if (o && h.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: i } = this.unplaced, a = Of(e, t);
    return !a.childCount || a.firstChild.isLeaf ? !1 : (this.unplaced = new ue(e, t + 1, Math.max(i, a.size + t >= e.size - i ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: i } = this.unplaced, a = Of(e, t);
    if (a.childCount <= 1 && t > 0) {
      let o = e.size - t <= t + a.size;
      this.unplaced = new ue(Gu(e, t - 1, 1), t - 1, o ? t - 1 : i);
    } else
      this.unplaced = new ue(Gu(e, t, 1), t, i);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: i, inject: a, wrap: o }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (o)
      for (let w = 0; w < o.length; w++)
        this.openFrontierNode(o[w]);
    let r = this.unplaced, s = i ? i.content : r.content, l = r.openStart - e, h = 0, d = [], { match: f, type: p } = this.frontier[t];
    if (a) {
      for (let w = 0; w < a.childCount; w++)
        d.push(a.child(w));
      f = f.matchFragment(a);
    }
    let y = s.size + e - (r.content.size - r.openEnd);
    for (; h < s.childCount; ) {
      let w = s.child(h), v = f.matchType(w.type);
      if (!v)
        break;
      h++, (h > 1 || l == 0 || w.content.size) && (f = v, d.push(N_(w.mark(p.allowedMarks(w.marks)), h == 1 ? l : 0, h == s.childCount ? y : -1)));
    }
    let m = h == s.childCount;
    m || (y = -1), this.placed = Wu(this.placed, t, U.from(d)), this.frontier[t].match = f, m && y < 0 && i && i.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let w = 0, v = s; w < y; w++) {
      let _ = v.lastChild;
      this.frontier.push({ type: _.type, match: _.contentMatchAt(_.childCount) }), v = _.content;
    }
    this.unplaced = m ? e == 0 ? ue.empty : new ue(Gu(r.content, e - 1, 1), e - 1, y < 0 ? r.openEnd : e - 1) : new ue(Gu(r.content, e, h), r.openStart, r.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !Af(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: i } = this.$to, a = this.$to.after(i);
    for (; i > 1 && a == this.$to.end(--i); )
      ++a;
    return a;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: i, type: a } = this.frontier[t], o = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), r = Af(e, t, a, i, o);
      if (r) {
        for (let s = t - 1; s >= 0; s--) {
          let { match: l, type: h } = this.frontier[s], d = Af(e, s, h, l, !0);
          if (!d || d.childCount)
            continue e;
        }
        return { depth: t, fit: r, move: o ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = Wu(this.placed, t.depth, t.fit)), e = t.move;
    for (let i = t.depth + 1; i <= e.depth; i++) {
      let a = e.node(i), o = a.type.contentMatch.fillBefore(a.content, !0, e.index(i));
      this.openFrontierNode(a.type, a.attrs, o);
    }
    return e;
  }
  openFrontierNode(e, t = null, i) {
    let a = this.frontier[this.depth];
    a.match = a.match.matchType(e), this.placed = Wu(this.placed, this.depth, U.from(e.create(t, i))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(U.empty, !0);
    t.childCount && (this.placed = Wu(this.placed, this.frontier.length, t));
  }
}
function Gu(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(Gu(n.firstChild.content, e - 1, t)));
}
function Wu(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(Wu(n.lastChild.content, e - 1, t)));
}
function Of(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function N_(n, e, t) {
  if (e <= 0)
    return n;
  let i = n.content;
  return e > 1 && (i = i.replaceChild(0, N_(i.firstChild, e - 1, i.childCount == 1 ? t - 1 : 0))), e > 0 && (i = n.type.contentMatch.fillBefore(i).append(i), t <= 0 && (i = i.append(n.type.contentMatch.matchFragment(i).fillBefore(U.empty, !0)))), n.copy(i);
}
function Af(n, e, t, i, a) {
  let o = n.node(e), r = a ? n.indexAfter(e) : n.index(e);
  if (r == o.childCount && !t.compatibleContent(o.type))
    return null;
  let s = i.fillBefore(o.content, !0, r);
  return s && !TX(t, o.content, r) ? s : null;
}
function TX(n, e, t) {
  for (let i = t; i < e.childCount; i++)
    if (!n.allowsMarks(e.child(i).marks))
      return !0;
  return !1;
}
function LX(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function xX(n, e, t, i) {
  if (!i.size)
    return n.deleteRange(e, t);
  let a = n.doc.resolve(e), o = n.doc.resolve(t);
  if (M_(a, o, i))
    return n.step(new on(e, t, i));
  let r = A_(a, n.doc.resolve(t));
  r[r.length - 1] == 0 && r.pop();
  let s = -(a.depth + 1);
  r.unshift(s);
  for (let p = a.depth, y = a.pos - 1; p > 0; p--, y--) {
    let m = a.node(p).type.spec;
    if (m.defining || m.definingAsContext || m.isolating)
      break;
    r.indexOf(p) > -1 ? s = p : a.before(p) == y && r.splice(1, 0, -p);
  }
  let l = r.indexOf(s), h = [], d = i.openStart;
  for (let p = i.content, y = 0; ; y++) {
    let m = p.firstChild;
    if (h.push(m), y == i.openStart)
      break;
    p = m.content;
  }
  for (let p = d - 1; p >= 0; p--) {
    let y = h[p], m = LX(y.type);
    if (m && !y.sameMarkup(a.node(Math.abs(s) - 1)))
      d = p;
    else if (m || !y.type.isTextblock)
      break;
  }
  for (let p = i.openStart; p >= 0; p--) {
    let y = (p + d + 1) % (i.openStart + 1), m = h[y];
    if (m)
      for (let w = 0; w < r.length; w++) {
        let v = r[(w + l) % r.length], _ = !0;
        v < 0 && (_ = !1, v = -v);
        let L = a.node(v - 1), T = a.index(v - 1);
        if (L.canReplaceWith(T, T, m.type, m.marks))
          return n.replace(a.before(v), _ ? o.after(v) : t, new ue(O_(i.content, 0, i.openStart, y), y, i.openEnd));
      }
  }
  let f = n.steps.length;
  for (let p = r.length - 1; p >= 0 && (n.replace(e, t, i), !(n.steps.length > f)); p--) {
    let y = r[p];
    y < 0 || (e = a.before(y), t = o.after(y));
  }
}
function O_(n, e, t, i, a) {
  if (e < t) {
    let o = n.firstChild;
    n = n.replaceChild(0, o.copy(O_(o.content, e + 1, t, i, o)));
  }
  if (e > i) {
    let o = a.contentMatchAt(0), r = o.fillBefore(n).append(n);
    n = r.append(o.matchFragment(r).fillBefore(U.empty, !0));
  }
  return n;
}
function EX(n, e, t, i) {
  if (!i.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let a = _X(n.doc, e, i.type);
    a != null && (e = t = a);
  }
  n.replaceRange(e, t, new ue(U.from(i), 0, 0));
}
function DX(n, e, t) {
  let i = n.doc.resolve(e), a = n.doc.resolve(t), o = A_(i, a);
  for (let r = 0; r < o.length; r++) {
    let s = o[r], l = r == o.length - 1;
    if (l && s == 0 || i.node(s).type.contentMatch.validEnd)
      return n.delete(i.start(s), a.end(s));
    if (s > 0 && (l || i.node(s - 1).canReplace(i.index(s - 1), a.indexAfter(s - 1))))
      return n.delete(i.before(s), a.after(s));
  }
  for (let r = 1; r <= i.depth && r <= a.depth; r++)
    if (e - i.start(r) == i.depth - r && t > i.end(r) && a.end(r) - t != a.depth - r)
      return n.delete(i.before(r), t);
  n.delete(e, t);
}
function A_(n, e) {
  let t = [], i = Math.min(n.depth, e.depth);
  for (let a = i; a >= 0; a--) {
    let o = n.start(a);
    if (o < n.pos - (n.depth - a) || e.end(a) > e.pos + (e.depth - a) || n.node(a).type.spec.isolating || e.node(a).type.spec.isolating)
      break;
    (o == e.start(a) || a == n.depth && a == e.depth && n.parent.inlineContent && e.parent.inlineContent && a && e.start(a - 1) == o - 1) && t.push(a);
  }
  return t;
}
class Ys extends Ln {
  /**
  Construct an attribute step.
  */
  constructor(e, t, i) {
    super(), this.pos = e, this.attr = t, this.value = i;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Wt.fail("No node at attribute step's position");
    let i = /* @__PURE__ */ Object.create(null);
    for (let o in t.attrs)
      i[o] = t.attrs[o];
    i[this.attr] = this.value;
    let a = t.type.create(i, null, t.marks);
    return Wt.fromReplace(e, this.pos, this.pos + 1, new ue(U.from(a), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return fi.empty;
  }
  invert(e) {
    return new Ys(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Ys(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Ys(t.pos, t.attr, t.value);
  }
}
Ln.jsonID("attr", Ys);
class wl extends Ln {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let a in e.attrs)
      t[a] = e.attrs[a];
    t[this.attr] = this.value;
    let i = e.type.create(t, e.content, e.marks);
    return Wt.ok(i);
  }
  getMap() {
    return fi.empty;
  }
  invert(e) {
    return new wl(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new wl(t.attr, t.value);
  }
}
Ln.jsonID("docAttr", wl);
let Js = class extends Error {
};
Js = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
Js.prototype = Object.create(Error.prototype);
Js.prototype.constructor = Js;
Js.prototype.name = "TransformError";
class MX {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Os();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new Js(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, i = ue.empty) {
    let a = kd(this.doc, e, t, i);
    return a && this.step(a), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, i) {
    return this.replace(e, t, new ue(U.from(i), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, ue.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, i) {
    return xX(this, e, t, i), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, i) {
    return EX(this, e, t, i), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return DX(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return gX(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return kX(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return mX(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, i, a = null) {
    return yX(this, e, t, i, a), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, i = null, a) {
    return CX(this, e, t, i, a), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, i) {
    return this.step(new Ys(e, t, i)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new wl(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new No(e, t)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    if (!(t instanceof vt)) {
      let i = this.doc.nodeAt(e);
      if (!i)
        throw new RangeError("No node at position " + e);
      if (t = t.isInSet(i.marks), !t)
        return this;
    }
    return this.step(new Is(e, t)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, t = 1, i) {
    return SX(this, e, t, i), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, i) {
    return cX(this, e, t, i), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, i) {
    return hX(this, e, t, i), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, i) {
    return x_(this, e, t, i), this;
  }
}
const Yf = /* @__PURE__ */ Object.create(null);
class Pe {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, i) {
    this.$anchor = e, this.$head = t, this.ranges = i || [new NX(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = ue.empty) {
    let i = t.content.lastChild, a = null;
    for (let s = 0; s < t.openEnd; s++)
      a = i, i = i.lastChild;
    let o = e.steps.length, r = this.ranges;
    for (let s = 0; s < r.length; s++) {
      let { $from: l, $to: h } = r[s], d = e.mapping.slice(o);
      e.replaceRange(d.map(l.pos), d.map(h.pos), s ? ue.empty : t), s == 0 && U0(e, o, (i ? i.isInline : a && a.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let i = e.steps.length, a = this.ranges;
    for (let o = 0; o < a.length; o++) {
      let { $from: r, $to: s } = a[o], l = e.mapping.slice(i), h = l.map(r.pos), d = l.map(s.pos);
      o ? e.deleteRange(h, d) : (e.replaceRangeWith(h, d, t), U0(e, i, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, i = !1) {
    let a = e.parent.inlineContent ? new Me(e) : ms(e.node(0), e.parent, e.pos, e.index(), t, i);
    if (a)
      return a;
    for (let o = e.depth - 1; o >= 0; o--) {
      let r = t < 0 ? ms(e.node(0), e.node(o), e.before(o + 1), e.index(o), t, i) : ms(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, t, i);
      if (r)
        return r;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new ta(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return ms(e, e, 0, 0, 1) || new ta(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return ms(e, e, e.content.size, e.childCount, -1) || new ta(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let i = Yf[t.type];
    if (!i)
      throw new RangeError(`No selection type ${t.type} defined`);
    return i.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in Yf)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Yf[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Me.between(this.$anchor, this.$head).getBookmark();
  }
}
Pe.prototype.visible = !0;
class NX {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let $0 = !1;
function V0(n) {
  !$0 && !n.parent.inlineContent && ($0 = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class Me extends Pe {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    V0(e), V0(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let i = e.resolve(t.map(this.head));
    if (!i.parent.inlineContent)
      return Pe.near(i);
    let a = e.resolve(t.map(this.anchor));
    return new Me(a.parent.inlineContent ? a : i, i);
  }
  replace(e, t = ue.empty) {
    if (super.replace(e, t), t == ue.empty) {
      let i = this.$from.marksAcross(this.$to);
      i && e.ensureMarks(i);
    }
  }
  eq(e) {
    return e instanceof Me && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new _d(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Me(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, i = t) {
    let a = e.resolve(t);
    return new this(a, i == t ? a : e.resolve(i));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, i) {
    let a = e.pos - t.pos;
    if ((!i || a) && (i = a >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let o = Pe.findFrom(t, i, !0) || Pe.findFrom(t, -i, !0);
      if (o)
        t = o.$head;
      else
        return Pe.near(t, i);
    }
    return e.parent.inlineContent || (a == 0 ? e = t : (e = (Pe.findFrom(e, -i, !0) || Pe.findFrom(e, i, !0)).$anchor, e.pos < t.pos != a < 0 && (e = t))), new Me(e, t);
  }
}
Pe.jsonID("text", Me);
class _d {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new _d(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Me.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class Ce extends Pe {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, i = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, i), this.node = t;
  }
  map(e, t) {
    let { deleted: i, pos: a } = t.mapResult(this.anchor), o = e.resolve(a);
    return i ? Pe.near(o) : new Ce(o);
  }
  content() {
    return new ue(U.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof Ce && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new ay(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Ce(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new Ce(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
Ce.prototype.visible = !1;
Pe.jsonID("node", Ce);
class ay {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: i } = e.mapResult(this.anchor);
    return t ? new _d(i, i) : new ay(i);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), i = t.nodeAfter;
    return i && Ce.isSelectable(i) ? new Ce(t) : Pe.near(t);
  }
}
class ta extends Pe {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = ue.empty) {
    if (t == ue.empty) {
      e.delete(0, e.doc.content.size);
      let i = Pe.atStart(e.doc);
      i.eq(e.selection) || e.setSelection(i);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new ta(e);
  }
  map(e) {
    return new ta(e);
  }
  eq(e) {
    return e instanceof ta;
  }
  getBookmark() {
    return OX;
  }
}
Pe.jsonID("all", ta);
const OX = {
  map() {
    return this;
  },
  resolve(n) {
    return new ta(n);
  }
};
function ms(n, e, t, i, a, o = !1) {
  if (e.inlineContent)
    return Me.create(n, t);
  for (let r = i - (a > 0 ? 0 : 1); a > 0 ? r < e.childCount : r >= 0; r += a) {
    let s = e.child(r);
    if (s.isAtom) {
      if (!o && Ce.isSelectable(s))
        return Ce.create(n, t - (a < 0 ? s.nodeSize : 0));
    } else {
      let l = ms(n, s, t + a, a < 0 ? s.childCount : 0, a, o);
      if (l)
        return l;
    }
    t += s.nodeSize * a;
  }
  return null;
}
function U0(n, e, t) {
  let i = n.steps.length - 1;
  if (i < e)
    return;
  let a = n.steps[i];
  if (!(a instanceof on || a instanceof sn))
    return;
  let o = n.mapping.maps[i], r;
  o.forEach((s, l, h, d) => {
    r == null && (r = d);
  }), n.setSelection(Pe.near(n.doc.resolve(r), t));
}
const q0 = 1, nh = 2, eC = 4;
class AX extends MX {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | q0) & ~nh, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & q0) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= nh, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return vt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & nh) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~nh, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let i = this.selection;
    return t && (e = e.mark(this.storedMarks || (i.empty ? i.$from.marks() : i.$from.marksAcross(i.$to) || vt.none))), i.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, i) {
    let a = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(a.text(e), !0) : this.deleteSelection();
    {
      if (i == null && (i = t), i = i ?? t, !e)
        return this.deleteRange(t, i);
      let o = this.storedMarks;
      if (!o) {
        let r = this.doc.resolve(t);
        o = i == t ? r.marks() : r.marksAcross(this.doc.resolve(i));
      }
      return this.replaceRangeWith(t, i, a.text(e, o)), this.selection.empty || this.setSelection(Pe.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= eC, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & eC) > 0;
  }
}
function tC(n, e) {
  return !e || !n ? n : n.bind(e);
}
class Qu {
  constructor(e, t, i) {
    this.name = e, this.init = tC(t.init, i), this.apply = tC(t.apply, i);
  }
}
const YX = [
  new Qu("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new Qu("selection", {
    init(n, e) {
      return n.selection || Pe.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new Qu("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, i) {
      return i.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new Qu("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class Pf {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = YX.slice(), t && t.forEach((i) => {
      if (this.pluginsByKey[i.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + i.key + ")");
      this.plugins.push(i), this.pluginsByKey[i.key] = i, i.spec.state && this.fields.push(new Qu(i.key, i.spec.state, i));
    });
  }
}
class js {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != t) {
        let a = this.config.plugins[i];
        if (a.spec.filterTransaction && !a.spec.filterTransaction.call(a, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], i = this.applyInner(e), a = null;
    for (; ; ) {
      let o = !1;
      for (let r = 0; r < this.config.plugins.length; r++) {
        let s = this.config.plugins[r];
        if (s.spec.appendTransaction) {
          let l = a ? a[r].n : 0, h = a ? a[r].state : this, d = l < t.length && s.spec.appendTransaction.call(s, l ? t.slice(l) : t, h, i);
          if (d && i.filterTransaction(d, r)) {
            if (d.setMeta("appendedTransaction", e), !a) {
              a = [];
              for (let f = 0; f < this.config.plugins.length; f++)
                a.push(f < r ? { state: i, n: t.length } : { state: this, n: 0 });
            }
            t.push(d), i = i.applyInner(d), o = !0;
          }
          a && (a[r] = { state: i, n: t.length });
        }
      }
      if (!o)
        return { state: i, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new js(this.config), i = this.config.fields;
    for (let a = 0; a < i.length; a++) {
      let o = i[a];
      t[o.name] = o.apply(e, this[o.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new AX(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new Pf(e.doc ? e.doc.type.schema : e.schema, e.plugins), i = new js(t);
    for (let a = 0; a < t.fields.length; a++)
      i[t.fields[a].name] = t.fields[a].init(e, i);
    return i;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new Pf(this.schema, e.plugins), i = t.fields, a = new js(t);
    for (let o = 0; o < i.length; o++) {
      let r = i[o].name;
      a[r] = this.hasOwnProperty(r) ? this[r] : i[o].init(e, a);
    }
    return a;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((i) => i.toJSON())), e && typeof e == "object")
      for (let i in e) {
        if (i == "doc" || i == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let a = e[i], o = a.spec.state;
        o && o.toJSON && (t[i] = o.toJSON.call(a, this[a.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, i) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let a = new Pf(e.schema, e.plugins), o = new js(a);
    return a.fields.forEach((r) => {
      if (r.name == "doc")
        o.doc = Tr.fromJSON(e.schema, t.doc);
      else if (r.name == "selection")
        o.selection = Pe.fromJSON(o.doc, t.selection);
      else if (r.name == "storedMarks")
        t.storedMarks && (o.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (i)
          for (let s in i) {
            let l = i[s], h = l.spec.state;
            if (l.key == r.name && h && h.fromJSON && Object.prototype.hasOwnProperty.call(t, s)) {
              o[r.name] = h.fromJSON.call(l, e, t[s], o);
              return;
            }
          }
        o[r.name] = r.init(e, o);
      }
    }), o;
  }
}
function Y_(n, e, t) {
  for (let i in n) {
    let a = n[i];
    a instanceof Function ? a = a.bind(e) : i == "handleDOMEvents" && (a = Y_(a, e, {})), t[i] = a;
  }
  return t;
}
class ii {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && Y_(e.props, this, this.props), this.key = e.key ? e.key.key : P_("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Rf = /* @__PURE__ */ Object.create(null);
function P_(n) {
  return n in Rf ? n + "$" + ++Rf[n] : (Rf[n] = 0, n + "$");
}
class La {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = P_(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const bn = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, vl = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Zp = null;
const Ga = function(n, e, t) {
  let i = Zp || (Zp = document.createRange());
  return i.setEnd(n, t ?? n.nodeValue.length), i.setStart(n, e || 0), i;
}, PX = function() {
  Zp = null;
}, Yr = function(n, e, t, i) {
  return t && (nC(n, e, t, i, -1) || nC(n, e, t, i, 1));
}, RX = /^(img|br|input|textarea|hr)$/i;
function nC(n, e, t, i, a) {
  for (; ; ) {
    if (n == t && e == i)
      return !0;
    if (e == (a < 0 ? 0 : fa(n))) {
      let o = n.parentNode;
      if (!o || o.nodeType != 1 || Jl(n) || RX.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = bn(n) + (a < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (a < 0 ? -1 : 0)], n.contentEditable == "false")
        return !1;
      e = a < 0 ? fa(n) : 0;
    } else
      return !1;
  }
}
function fa(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function FX(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = fa(n);
    } else if (n.parentNode && !Jl(n))
      e = bn(n), n = n.parentNode;
    else
      return null;
  }
}
function IX(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !Jl(n))
      e = bn(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function JX(n, e, t) {
  for (let i = e == 0, a = e == fa(n); i || a; ) {
    if (n == t)
      return !0;
    let o = bn(n);
    if (n = n.parentNode, !n)
      return !1;
    i = i && o == 0, a = a && o == fa(n);
  }
}
function Jl(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const jd = function(n) {
  return n.focusNode && Yr(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function pr(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function ZX(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function BX(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let i = n.caretPositionFromPoint(e, t);
      if (i)
        return { node: i.offsetNode, offset: i.offset };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let i = n.caretRangeFromPoint(e, t);
    if (i)
      return { node: i.startContainer, offset: i.startOffset };
  }
}
const ka = typeof navigator < "u" ? navigator : null, iC = typeof document < "u" ? document : null, $o = ka && ka.userAgent || "", Bp = /Edge\/(\d+)/.exec($o), R_ = /MSIE \d/.exec($o), Hp = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec($o), ei = !!(R_ || Hp || Bp), Po = R_ ? document.documentMode : Hp ? +Hp[1] : Bp ? +Bp[1] : 0, aa = !ei && /gecko\/(\d+)/i.test($o);
aa && +(/Firefox\/(\d+)/.exec($o) || [0, 0])[1];
const Xp = !ei && /Chrome\/(\d+)/.exec($o), jn = !!Xp, F_ = Xp ? +Xp[1] : 0, Rn = !ei && !!ka && /Apple Computer/.test(ka.vendor), Zs = Rn && (/Mobile\/\w+/.test($o) || !!ka && ka.maxTouchPoints > 2), Oi = Zs || (ka ? /Mac/.test(ka.platform) : !1), HX = ka ? /Win/.test(ka.platform) : !1, $i = /Android \d/.test($o), Zl = !!iC && "webkitFontSmoothing" in iC.documentElement.style, XX = Zl ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function GX(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function Ja(n, e) {
  return typeof n == "number" ? n : n[e];
}
function WX(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, i = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * i
  };
}
function aC(n, e, t) {
  let i = n.someProp("scrollThreshold") || 0, a = n.someProp("scrollMargin") || 5, o = n.dom.ownerDocument;
  for (let r = t || n.dom; r; r = vl(r)) {
    if (r.nodeType != 1)
      continue;
    let s = r, l = s == o.body, h = l ? GX(o) : WX(s), d = 0, f = 0;
    if (e.top < h.top + Ja(i, "top") ? f = -(h.top - e.top + Ja(a, "top")) : e.bottom > h.bottom - Ja(i, "bottom") && (f = e.bottom - e.top > h.bottom - h.top ? e.top + Ja(a, "top") - h.top : e.bottom - h.bottom + Ja(a, "bottom")), e.left < h.left + Ja(i, "left") ? d = -(h.left - e.left + Ja(a, "left")) : e.right > h.right - Ja(i, "right") && (d = e.right - h.right + Ja(a, "right")), d || f)
      if (l)
        o.defaultView.scrollBy(d, f);
      else {
        let p = s.scrollLeft, y = s.scrollTop;
        f && (s.scrollTop += f), d && (s.scrollLeft += d);
        let m = s.scrollLeft - p, w = s.scrollTop - y;
        e = { left: e.left - m, top: e.top - w, right: e.right - m, bottom: e.bottom - w };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(r).position))
      break;
  }
}
function QX(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), i, a;
  for (let o = (e.left + e.right) / 2, r = t + 1; r < Math.min(innerHeight, e.bottom); r += 5) {
    let s = n.root.elementFromPoint(o, r);
    if (!s || s == n.dom || !n.dom.contains(s))
      continue;
    let l = s.getBoundingClientRect();
    if (l.top >= t - 20) {
      i = s, a = l.top;
      break;
    }
  }
  return { refDOM: i, refTop: a, stack: I_(n.dom) };
}
function I_(n) {
  let e = [], t = n.ownerDocument;
  for (let i = n; i && (e.push({ dom: i, top: i.scrollTop, left: i.scrollLeft }), n != t); i = vl(i))
    ;
  return e;
}
function KX({ refDOM: n, refTop: e, stack: t }) {
  let i = n ? n.getBoundingClientRect().top : 0;
  J_(t, i == 0 ? 0 : i - e);
}
function J_(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: i, top: a, left: o } = n[t];
    i.scrollTop != a + e && (i.scrollTop = a + e), i.scrollLeft != o && (i.scrollLeft = o);
  }
}
let hs = null;
function zX(n) {
  if (n.setActive)
    return n.setActive();
  if (hs)
    return n.focus(hs);
  let e = I_(n);
  n.focus(hs == null ? {
    get preventScroll() {
      return hs = { preventScroll: !0 }, !0;
    }
  } : void 0), hs || (hs = !1, J_(e, 0));
}
function Z_(n, e) {
  let t, i = 2e8, a, o = 0, r = e.top, s = e.top, l, h;
  for (let d = n.firstChild, f = 0; d; d = d.nextSibling, f++) {
    let p;
    if (d.nodeType == 1)
      p = d.getClientRects();
    else if (d.nodeType == 3)
      p = Ga(d).getClientRects();
    else
      continue;
    for (let y = 0; y < p.length; y++) {
      let m = p[y];
      if (m.top <= r && m.bottom >= s) {
        r = Math.max(m.bottom, r), s = Math.min(m.top, s);
        let w = m.left > e.left ? m.left - e.left : m.right < e.left ? e.left - m.right : 0;
        if (w < i) {
          t = d, i = w, a = w && t.nodeType == 3 ? {
            left: m.right < e.left ? m.right : m.left,
            top: e.top
          } : e, d.nodeType == 1 && w && (o = f + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
          continue;
        }
      } else m.top > e.top && !l && m.left <= e.left && m.right >= e.left && (l = d, h = { left: Math.max(m.left, Math.min(m.right, e.left)), top: m.top });
      !t && (e.left >= m.right && e.top >= m.top || e.left >= m.left && e.top >= m.bottom) && (o = f + 1);
    }
  }
  return !t && l && (t = l, a = h, i = 0), t && t.nodeType == 3 ? $X(t, a) : !t || i && t.nodeType == 1 ? { node: n, offset: o } : Z_(t, a);
}
function $X(n, e) {
  let t = n.nodeValue.length, i = document.createRange();
  for (let a = 0; a < t; a++) {
    i.setEnd(n, a + 1), i.setStart(n, a);
    let o = ko(i, 1);
    if (o.top != o.bottom && oy(e, o))
      return { node: n, offset: a + (e.left >= (o.left + o.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function oy(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function VX(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function UX(n, e, t) {
  let { node: i, offset: a } = Z_(e, t), o = -1;
  if (i.nodeType == 1 && !i.firstChild) {
    let r = i.getBoundingClientRect();
    o = r.left != r.right && t.left > (r.left + r.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(i, a, o);
}
function qX(n, e, t, i) {
  let a = -1;
  for (let o = e, r = !1; o != n.dom; ) {
    let s = n.docView.nearestDesc(o, !0);
    if (!s)
      return null;
    if (s.dom.nodeType == 1 && (s.node.isBlock && s.parent || !s.contentDOM)) {
      let l = s.dom.getBoundingClientRect();
      if (s.node.isBlock && s.parent && (!r && l.left > i.left || l.top > i.top ? a = s.posBefore : (!r && l.right < i.left || l.bottom < i.top) && (a = s.posAfter), r = !0), !s.contentDOM && a < 0 && !s.node.isText)
        return (s.node.isBlock ? i.top < (l.top + l.bottom) / 2 : i.left < (l.left + l.right) / 2) ? s.posBefore : s.posAfter;
    }
    o = s.dom.parentNode;
  }
  return a > -1 ? a : n.docView.posFromDOM(e, t, -1);
}
function B_(n, e, t) {
  let i = n.childNodes.length;
  if (i && t.top < t.bottom)
    for (let a = Math.max(0, Math.min(i - 1, Math.floor(i * (e.top - t.top) / (t.bottom - t.top)) - 2)), o = a; ; ) {
      let r = n.childNodes[o];
      if (r.nodeType == 1) {
        let s = r.getClientRects();
        for (let l = 0; l < s.length; l++) {
          let h = s[l];
          if (oy(e, h))
            return B_(r, e, h);
        }
      }
      if ((o = (o + 1) % i) == a)
        break;
    }
  return n;
}
function e3(n, e) {
  let t = n.dom.ownerDocument, i, a = 0, o = BX(t, e.left, e.top);
  o && ({ node: i, offset: a } = o);
  let r = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), s;
  if (!r || !n.dom.contains(r.nodeType != 1 ? r.parentNode : r)) {
    let h = n.dom.getBoundingClientRect();
    if (!oy(e, h) || (r = B_(n.dom, e, h), !r))
      return null;
  }
  if (Rn)
    for (let h = r; i && h; h = vl(h))
      h.draggable && (i = void 0);
  if (r = VX(r, e), i) {
    if (aa && i.nodeType == 1 && (a = Math.min(a, i.childNodes.length), a < i.childNodes.length)) {
      let d = i.childNodes[a], f;
      d.nodeName == "IMG" && (f = d.getBoundingClientRect()).right <= e.left && f.bottom > e.top && a++;
    }
    let h;
    Zl && a && i.nodeType == 1 && (h = i.childNodes[a - 1]).nodeType == 1 && h.contentEditable == "false" && h.getBoundingClientRect().top >= e.top && a--, i == n.dom && a == i.childNodes.length - 1 && i.lastChild.nodeType == 1 && e.top > i.lastChild.getBoundingClientRect().bottom ? s = n.state.doc.content.size : (a == 0 || i.nodeType != 1 || i.childNodes[a - 1].nodeName != "BR") && (s = qX(n, i, a, e));
  }
  s == null && (s = UX(n, r, e));
  let l = n.docView.nearestDesc(r, !0);
  return { pos: s, inside: l ? l.posAtStart - l.border : -1 };
}
function oC(n) {
  return n.top < n.bottom || n.left < n.right;
}
function ko(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let i = t[e < 0 ? 0 : t.length - 1];
    if (oC(i))
      return i;
  }
  return Array.prototype.find.call(t, oC) || n.getBoundingClientRect();
}
const t3 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function H_(n, e, t) {
  let { node: i, offset: a, atom: o } = n.docView.domFromPos(e, t < 0 ? -1 : 1), r = Zl || aa;
  if (i.nodeType == 3)
    if (r && (t3.test(i.nodeValue) || (t < 0 ? !a : a == i.nodeValue.length))) {
      let l = ko(Ga(i, a, a), t);
      if (aa && a && /\s/.test(i.nodeValue[a - 1]) && a < i.nodeValue.length) {
        let h = ko(Ga(i, a - 1, a - 1), -1);
        if (h.top == l.top) {
          let d = ko(Ga(i, a, a + 1), -1);
          if (d.top != l.top)
            return Au(d, d.left < h.left);
        }
      }
      return l;
    } else {
      let l = a, h = a, d = t < 0 ? 1 : -1;
      return t < 0 && !a ? (h++, d = -1) : t >= 0 && a == i.nodeValue.length ? (l--, d = 1) : t < 0 ? l-- : h++, Au(ko(Ga(i, l, h), d), d < 0);
    }
  if (!n.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
    if (o == null && a && (t < 0 || a == fa(i))) {
      let l = i.childNodes[a - 1];
      if (l.nodeType == 1)
        return Ff(l.getBoundingClientRect(), !1);
    }
    if (o == null && a < fa(i)) {
      let l = i.childNodes[a];
      if (l.nodeType == 1)
        return Ff(l.getBoundingClientRect(), !0);
    }
    return Ff(i.getBoundingClientRect(), t >= 0);
  }
  if (o == null && a && (t < 0 || a == fa(i))) {
    let l = i.childNodes[a - 1], h = l.nodeType == 3 ? Ga(l, fa(l) - (r ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (h)
      return Au(ko(h, 1), !1);
  }
  if (o == null && a < fa(i)) {
    let l = i.childNodes[a];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let h = l ? l.nodeType == 3 ? Ga(l, 0, r ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (h)
      return Au(ko(h, -1), !0);
  }
  return Au(ko(i.nodeType == 3 ? Ga(i) : i, -t), t >= 0);
}
function Au(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function Ff(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function X_(n, e, t) {
  let i = n.state, a = n.root.activeElement;
  i != e && n.updateState(e), a != n.dom && n.focus();
  try {
    return t();
  } finally {
    i != e && n.updateState(i), a != n.dom && a && a.focus();
  }
}
function n3(n, e, t) {
  let i = e.selection, a = t == "up" ? i.$from : i.$to;
  return X_(n, e, () => {
    let { node: o } = n.docView.domFromPos(a.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let s = n.docView.nearestDesc(o, !0);
      if (!s)
        break;
      if (s.node.isBlock) {
        o = s.contentDOM || s.dom;
        break;
      }
      o = s.dom.parentNode;
    }
    let r = H_(n, a.pos, 1);
    for (let s = o.firstChild; s; s = s.nextSibling) {
      let l;
      if (s.nodeType == 1)
        l = s.getClientRects();
      else if (s.nodeType == 3)
        l = Ga(s, 0, s.nodeValue.length).getClientRects();
      else
        continue;
      for (let h = 0; h < l.length; h++) {
        let d = l[h];
        if (d.bottom > d.top + 1 && (t == "up" ? r.top - d.top > (d.bottom - r.top) * 2 : d.bottom - r.bottom > (r.bottom - d.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const i3 = /[\u0590-\u08ac]/;
function a3(n, e, t) {
  let { $head: i } = e.selection;
  if (!i.parent.isTextblock)
    return !1;
  let a = i.parentOffset, o = !a, r = a == i.parent.content.size, s = n.domSelection();
  return s ? !i3.test(i.parent.textContent) || !s.modify ? t == "left" || t == "backward" ? o : r : X_(n, e, () => {
    let { focusNode: l, focusOffset: h, anchorNode: d, anchorOffset: f } = n.domSelectionRange(), p = s.caretBidiLevel;
    s.modify("move", t, "character");
    let y = i.depth ? n.docView.domAfterPos(i.before()) : n.dom, { focusNode: m, focusOffset: w } = n.domSelectionRange(), v = m && !y.contains(m.nodeType == 1 ? m : m.parentNode) || l == m && h == w;
    try {
      s.collapse(d, f), l && (l != d || h != f) && s.extend && s.extend(l, h);
    } catch {
    }
    return p != null && (s.caretBidiLevel = p), v;
  }) : i.pos == i.start() || i.pos == i.end();
}
let rC = null, sC = null, uC = !1;
function o3(n, e, t) {
  return rC == e && sC == t ? uC : (rC = e, sC = t, uC = t == "up" || t == "down" ? n3(n, e, t) : a3(n, e, t));
}
const Fi = 0, lC = 1, yr = 2, _a = 3;
class Bl {
  constructor(e, t, i, a) {
    this.parent = e, this.children = t, this.dom = i, this.contentDOM = a, this.dirty = Fi, i.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, i) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, i = this.posAtStart; ; t++) {
      let a = this.children[t];
      if (a == e)
        return i;
      i += a.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, i) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (i < 0) {
        let o, r;
        if (e == this.contentDOM)
          o = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.previousSibling;
        }
        for (; o && !((r = o.pmViewDesc) && r.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(r) + r.size : this.posAtStart;
      } else {
        let o, r;
        if (e == this.contentDOM)
          o = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.nextSibling;
        }
        for (; o && !((r = o.pmViewDesc) && r.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(r) : this.posAtEnd;
      }
    let a;
    if (e == this.dom && this.contentDOM)
      a = t > bn(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      a = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            a = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (a == null && t == e.childNodes.length)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            a = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return a ?? i > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let i = !0, a = e; a; a = a.parentNode) {
      let o = this.getDesc(a), r;
      if (o && (!t || o.node))
        if (i && (r = o.nodeDOM) && !(r.nodeType == 1 ? r.contains(e.nodeType == 1 ? e : e.parentNode) : r == e))
          i = !1;
        else
          return o;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let i = t; i; i = i.parent)
      if (i == this)
        return t;
  }
  posFromDOM(e, t, i) {
    for (let a = e; a; a = a.parentNode) {
      let o = this.getDesc(a);
      if (o)
        return o.localPosFromDOM(e, t, i);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, i = 0; t < this.children.length; t++) {
      let a = this.children[t], o = i + a.size;
      if (i == e && o != i) {
        for (; !a.border && a.children.length; )
          a = a.children[0];
        return a;
      }
      if (e < o)
        return a.descAt(e - i - a.border);
      i = o;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let i = 0, a = 0;
    for (let o = 0; i < this.children.length; i++) {
      let r = this.children[i], s = o + r.size;
      if (s > e || r instanceof W_) {
        a = e - o;
        break;
      }
      o = s;
    }
    if (a)
      return this.children[i].domFromPos(a - this.children[i].border, t);
    for (let o; i && !(o = this.children[i - 1]).size && o instanceof G_ && o.side >= 0; i--)
      ;
    if (t <= 0) {
      let o, r = !0;
      for (; o = i ? this.children[i - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); i--, r = !1)
        ;
      return o && t && r && !o.border && !o.domAtom ? o.domFromPos(o.size, t) : { node: this.contentDOM, offset: o ? bn(o.dom) + 1 : 0 };
    } else {
      let o, r = !0;
      for (; o = i < this.children.length ? this.children[i] : null, !(!o || o.dom.parentNode == this.contentDOM); i++, r = !1)
        ;
      return o && r && !o.border && !o.domAtom ? o.domFromPos(0, t) : { node: this.contentDOM, offset: o ? bn(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, i = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let a = -1, o = -1;
    for (let r = i, s = 0; ; s++) {
      let l = this.children[s], h = r + l.size;
      if (a == -1 && e <= h) {
        let d = r + l.border;
        if (e >= d && t <= h - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, t, d);
        e = r;
        for (let f = s; f > 0; f--) {
          let p = this.children[f - 1];
          if (p.size && p.dom.parentNode == this.contentDOM && !p.emptyChildAt(1)) {
            a = bn(p.dom) + 1;
            break;
          }
          e -= p.size;
        }
        a == -1 && (a = 0);
      }
      if (a > -1 && (h > t || s == this.children.length - 1)) {
        t = h;
        for (let d = s + 1; d < this.children.length; d++) {
          let f = this.children[d];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(-1)) {
            o = bn(f.dom);
            break;
          }
          t += f.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      r = h;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: a, toOffset: o };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: i } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || i == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[i];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, i, a = !1) {
    let o = Math.min(e, t), r = Math.max(e, t);
    for (let p = 0, y = 0; p < this.children.length; p++) {
      let m = this.children[p], w = y + m.size;
      if (o > y && r < w)
        return m.setSelection(e - y - m.border, t - y - m.border, i, a);
      y = w;
    }
    let s = this.domFromPos(e, e ? -1 : 1), l = t == e ? s : this.domFromPos(t, t ? -1 : 1), h = i.getSelection(), d = !1;
    if ((aa || Rn) && e == t) {
      let { node: p, offset: y } = s;
      if (p.nodeType == 3) {
        if (d = !!(y && p.nodeValue[y - 1] == `
`), d && y == p.nodeValue.length)
          for (let m = p, w; m; m = m.parentNode) {
            if (w = m.nextSibling) {
              w.nodeName == "BR" && (s = l = { node: w.parentNode, offset: bn(w) + 1 });
              break;
            }
            let v = m.pmViewDesc;
            if (v && v.node && v.node.isBlock)
              break;
          }
      } else {
        let m = p.childNodes[y - 1];
        d = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (aa && h.focusNode && h.focusNode != l.node && h.focusNode.nodeType == 1) {
      let p = h.focusNode.childNodes[h.focusOffset];
      p && p.contentEditable == "false" && (a = !0);
    }
    if (!(a || d && Rn) && Yr(s.node, s.offset, h.anchorNode, h.anchorOffset) && Yr(l.node, l.offset, h.focusNode, h.focusOffset))
      return;
    let f = !1;
    if ((h.extend || e == t) && !d) {
      h.collapse(s.node, s.offset);
      try {
        e != t && h.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > t) {
        let y = s;
        s = l, l = y;
      }
      let p = document.createRange();
      p.setEnd(l.node, l.offset), p.setStart(s.node, s.offset), h.removeAllRanges(), h.addRange(p);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let i = 0, a = 0; a < this.children.length; a++) {
      let o = this.children[a], r = i + o.size;
      if (i == r ? e <= r && t >= i : e < r && t > i) {
        let s = i + o.border, l = r - o.border;
        if (e >= s && t <= l) {
          this.dirty = e == i || t == r ? yr : lC, e == s && t == l && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = _a : o.markDirty(e - s, t - s);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? yr : _a;
      }
      i = r;
    }
    this.dirty = yr;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let i = e == 1 ? yr : lC;
      t.dirty < i && (t.dirty = i);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class G_ extends Bl {
  constructor(e, t, i, a) {
    let o, r = t.type.toDOM;
    if (typeof r == "function" && (r = r(i, () => {
      if (!o)
        return a;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !t.type.spec.raw) {
      if (r.nodeType != 1) {
        let s = document.createElement("span");
        s.appendChild(r), r = s;
      }
      r.contentEditable = "false", r.classList.add("ProseMirror-widget");
    }
    super(e, [], r, null), this.widget = t, this.widget = t, o = this;
  }
  matchesWidget(e) {
    return this.dirty == Fi && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class r3 extends Bl {
  constructor(e, t, i, a) {
    super(e, [], t, null), this.textDOM = i, this.text = a;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Pr extends Bl {
  constructor(e, t, i, a) {
    super(e, [], i, a), this.mark = t;
  }
  static create(e, t, i, a) {
    let o = a.nodeViews[t.type.name], r = o && o(t, a, i);
    return (!r || !r.dom) && (r = Gr.renderSpec(document, t.type.spec.toDOM(t, i), null, t.attrs)), new Pr(e, t, r.dom, r.contentDOM || r.dom);
  }
  parseRule() {
    return this.dirty & _a || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != _a && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != Fi) {
      let i = this.parent;
      for (; !i.node; )
        i = i.parent;
      i.dirty < this.dirty && (i.dirty = this.dirty), this.dirty = Fi;
    }
  }
  slice(e, t, i) {
    let a = Pr.create(this.parent, this.mark, !0, i), o = this.children, r = this.size;
    t < r && (o = Qp(o, t, r, i)), e > 0 && (o = Qp(o, 0, e, i));
    for (let s = 0; s < o.length; s++)
      o[s].parent = a;
    return a.children = o, a;
  }
}
class Ro extends Bl {
  constructor(e, t, i, a, o, r, s, l, h) {
    super(e, [], o, r), this.node = t, this.outerDeco = i, this.innerDeco = a, this.nodeDOM = s;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, i, a, o, r) {
    let s = o.nodeViews[t.type.name], l, h = s && s(t, o, () => {
      if (!l)
        return r;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, i, a), d = h && h.dom, f = h && h.contentDOM;
    if (t.isText) {
      if (!d)
        d = document.createTextNode(t.text);
      else if (d.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else d || ({ dom: d, contentDOM: f } = Gr.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !f && !t.isText && d.nodeName != "BR" && (d.hasAttribute("contenteditable") || (d.contentEditable = "false"), t.type.spec.draggable && (d.draggable = !0));
    let p = d;
    return d = z_(d, i, t), h ? l = new s3(e, t, i, a, d, f || null, p, h, o, r + 1) : t.isText ? new Td(e, t, i, a, d, p, o) : new Ro(e, t, i, a, d, f || null, p, o, r + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let i = this.children[t];
        if (this.dom.contains(i.dom.parentNode)) {
          e.contentElement = i.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => U.empty);
    }
    return e;
  }
  matchesNode(e, t, i) {
    return this.dirty == Fi && e.eq(this.node) && Wp(t, this.outerDeco) && i.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let i = this.node.inlineContent, a = t, o = e.composing ? this.localCompositionInfo(e, t) : null, r = o && o.pos > -1 ? o : null, s = o && o.pos < 0, l = new l3(this, r && r.node, e);
    d3(this.node, this.innerDeco, (h, d, f) => {
      h.spec.marks ? l.syncToMarks(h.spec.marks, i, e) : h.type.side >= 0 && !f && l.syncToMarks(d == this.node.childCount ? vt.none : this.node.child(d).marks, i, e), l.placeWidget(h, e, a);
    }, (h, d, f, p) => {
      l.syncToMarks(h.marks, i, e);
      let y;
      l.findNodeMatch(h, d, f, p) || s && e.state.selection.from > a && e.state.selection.to < a + h.nodeSize && (y = l.findIndexWithChild(o.node)) > -1 && l.updateNodeAt(h, d, f, y, e) || l.updateNextNode(h, d, f, e, p, a) || l.addNode(h, d, f, e, a), a += h.nodeSize;
    }), l.syncToMarks([], i, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == yr) && (r && this.protectLocalComposition(e, r), Q_(this.contentDOM, this.children, e), Zs && g3(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: i, to: a } = e.state.selection;
    if (!(e.state.selection instanceof Me) || i < t || a > t + this.node.content.size)
      return null;
    let o = e.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let r = o.nodeValue, s = f3(this.node.content, r, i - t, a - t);
      return s < 0 ? null : { node: o, pos: s, text: r };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: i, text: a }) {
    if (this.getDesc(t))
      return;
    let o = t;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let r = new r3(this, o, t, a);
    e.input.compositionNodes.push(r), this.children = Qp(this.children, i, i + a.length, e, r);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, i, a) {
    return this.dirty == _a || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, i, a), !0);
  }
  updateInner(e, t, i, a) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = i, this.contentDOM && this.updateChildren(a, this.posAtStart), this.dirty = Fi;
  }
  updateOuterDeco(e) {
    if (Wp(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, i = this.dom;
    this.dom = K_(this.dom, this.nodeDOM, Gp(this.outerDeco, this.node, t), Gp(e, this.node, t)), this.dom != i && (i.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function cC(n, e, t, i, a) {
  z_(i, e, n);
  let o = new Ro(void 0, n, e, t, i, i, i, a, 0);
  return o.contentDOM && o.updateChildren(a, 0), o;
}
class Td extends Ro {
  constructor(e, t, i, a, o, r, s) {
    super(e, t, i, a, o, null, r, s, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, i, a) {
    return this.dirty == _a || this.dirty != Fi && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != Fi || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, a.trackWrites == this.nodeDOM && (a.trackWrites = null)), this.node = e, this.dirty = Fi, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, i) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, i);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, i) {
    let a = this.node.cut(e, t), o = document.createTextNode(a.text);
    return new Td(this.parent, a, this.outerDeco, this.innerDeco, o, o, i);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = _a);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class W_ extends Bl {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Fi && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class s3 extends Ro {
  constructor(e, t, i, a, o, r, s, l, h, d) {
    super(e, t, i, a, o, r, s, h, d), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, i, a) {
    if (this.dirty == _a)
      return !1;
    if (this.spec.update) {
      let o = this.spec.update(e, t, i);
      return o && this.updateInner(e, t, i, a), o;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, i, a);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, i, a) {
    this.spec.setSelection ? this.spec.setSelection(e, t, i) : super.setSelection(e, t, i, a);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function Q_(n, e, t) {
  let i = n.firstChild, a = !1;
  for (let o = 0; o < e.length; o++) {
    let r = e[o], s = r.dom;
    if (s.parentNode == n) {
      for (; s != i; )
        i = hC(i), a = !0;
      i = i.nextSibling;
    } else
      a = !0, n.insertBefore(s, i);
    if (r instanceof Pr) {
      let l = i ? i.previousSibling : n.lastChild;
      Q_(r.contentDOM, r.children, t), i = l ? l.nextSibling : n.firstChild;
    }
  }
  for (; i; )
    i = hC(i), a = !0;
  a && t.trackWrites == n && (t.trackWrites = null);
}
const ol = function(n) {
  n && (this.nodeName = n);
};
ol.prototype = /* @__PURE__ */ Object.create(null);
const br = [new ol()];
function Gp(n, e, t) {
  if (n.length == 0)
    return br;
  let i = t ? br[0] : new ol(), a = [i];
  for (let o = 0; o < n.length; o++) {
    let r = n[o].type.attrs;
    if (r) {
      r.nodeName && a.push(i = new ol(r.nodeName));
      for (let s in r) {
        let l = r[s];
        l != null && (t && a.length == 1 && a.push(i = new ol(e.isInline ? "span" : "div")), s == "class" ? i.class = (i.class ? i.class + " " : "") + l : s == "style" ? i.style = (i.style ? i.style + ";" : "") + l : s != "nodeName" && (i[s] = l));
      }
    }
  }
  return a;
}
function K_(n, e, t, i) {
  if (t == br && i == br)
    return e;
  let a = e;
  for (let o = 0; o < i.length; o++) {
    let r = i[o], s = t[o];
    if (o) {
      let l;
      s && s.nodeName == r.nodeName && a != n && (l = a.parentNode) && l.nodeName.toLowerCase() == r.nodeName || (l = document.createElement(r.nodeName), l.pmIsDeco = !0, l.appendChild(a), s = br[0]), a = l;
    }
    u3(a, s || br[0], r);
  }
  return a;
}
function u3(n, e, t) {
  for (let i in e)
    i != "class" && i != "style" && i != "nodeName" && !(i in t) && n.removeAttribute(i);
  for (let i in t)
    i != "class" && i != "style" && i != "nodeName" && t[i] != e[i] && n.setAttribute(i, t[i]);
  if (e.class != t.class) {
    let i = e.class ? e.class.split(" ").filter(Boolean) : [], a = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < i.length; o++)
      a.indexOf(i[o]) == -1 && n.classList.remove(i[o]);
    for (let o = 0; o < a.length; o++)
      i.indexOf(a[o]) == -1 && n.classList.add(a[o]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let i = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, a;
      for (; a = i.exec(e.style); )
        n.style.removeProperty(a[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function z_(n, e, t) {
  return K_(n, n, br, Gp(e, t, n.nodeType != 1));
}
function Wp(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function hC(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class l3 {
  constructor(e, t, i) {
    this.lock = t, this.view = i, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = c3(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let i = e; i < t; i++)
        this.top.children[i].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, i) {
    let a = 0, o = this.stack.length >> 1, r = Math.min(o, e.length);
    for (; a < r && (a == o - 1 ? this.top : this.stack[a + 1 << 1]).matchesMark(e[a]) && e[a].type.spec.spanning !== !1; )
      a++;
    for (; a < o; )
      this.destroyRest(), this.top.dirty = Fi, this.index = this.stack.pop(), this.top = this.stack.pop(), o--;
    for (; o < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let s = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let h = this.top.children[l];
        if (h.matchesMark(e[o]) && !this.isLocked(h.dom)) {
          s = l;
          break;
        }
      }
      if (s > -1)
        s > this.index && (this.changed = !0, this.destroyBetween(this.index, s)), this.top = this.top.children[this.index];
      else {
        let l = Pr.create(this.top, e[o], t, i);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, o++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, i, a) {
    let o = -1, r;
    if (a >= this.preMatch.index && (r = this.preMatch.matches[a - this.preMatch.index]).parent == this.top && r.matchesNode(e, t, i))
      o = this.top.children.indexOf(r, this.index);
    else
      for (let s = this.index, l = Math.min(this.top.children.length, s + 5); s < l; s++) {
        let h = this.top.children[s];
        if (h.matchesNode(e, t, i) && !this.preMatch.matched.has(h)) {
          o = s;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(e, t, i, a, o) {
    let r = this.top.children[a];
    return r.dirty == _a && r.dom == r.contentDOM && (r.dirty = yr), r.update(e, t, i, o) ? (this.destroyBetween(this.index, a), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let i = e.pmViewDesc;
        if (i) {
          for (let a = this.index; a < this.top.children.length; a++)
            if (this.top.children[a] == i)
              return a;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, i, a, o, r) {
    for (let s = this.index; s < this.top.children.length; s++) {
      let l = this.top.children[s];
      if (l instanceof Ro) {
        let h = this.preMatch.matched.get(l);
        if (h != null && h != o)
          return !1;
        let d = l.dom, f, p = this.isLocked(d) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != _a && Wp(t, l.outerDeco));
        if (!p && l.update(e, t, i, a))
          return this.destroyBetween(this.index, s), l.dom != d && (this.changed = !0), this.index++, !0;
        if (!p && (f = this.recreateWrapper(l, e, t, i, a, r)))
          return this.top.children[this.index] = f, f.contentDOM && (f.dirty = yr, f.updateChildren(a, r + 1), f.dirty = Fi), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, i, a, o, r) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content))
      return null;
    let s = Ro.create(this.top, t, i, a, o, r);
    if (s.contentDOM) {
      s.children = e.children, e.children = [];
      for (let l of s.children)
        l.parent = s;
    }
    return e.destroy(), s;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, i, a, o) {
    let r = Ro.create(this.top, e, t, i, a, o);
    r.contentDOM && r.updateChildren(a, o + 1), this.top.children.splice(this.index++, 0, r), this.changed = !0;
  }
  placeWidget(e, t, i) {
    let a = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (a && a.matchesWidget(e) && (e == a.widget || !a.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new G_(this.top, e, t, i);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof Pr; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof Td) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Rn || jn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let i = document.createElement(e);
      e == "IMG" && (i.className = "ProseMirror-separator", i.alt = ""), e == "BR" && (i.className = "ProseMirror-trailingBreak");
      let a = new W_(this.top, [], i, null);
      t != this.top ? t.children.push(a) : t.children.splice(this.index++, 0, a), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function c3(n, e) {
  let t = e, i = t.children.length, a = n.childCount, o = /* @__PURE__ */ new Map(), r = [];
  e: for (; a > 0; ) {
    let s;
    for (; ; )
      if (i) {
        let h = t.children[i - 1];
        if (h instanceof Pr)
          t = h, i = h.children.length;
        else {
          s = h, i--;
          break;
        }
      } else {
        if (t == e)
          break e;
        i = t.parent.children.indexOf(t), t = t.parent;
      }
    let l = s.node;
    if (l) {
      if (l != n.child(a - 1))
        break;
      --a, o.set(s, a), r.push(s);
    }
  }
  return { index: a, matched: o, matches: r.reverse() };
}
function h3(n, e) {
  return n.type.side - e.type.side;
}
function d3(n, e, t, i) {
  let a = e.locals(n), o = 0;
  if (a.length == 0) {
    for (let h = 0; h < n.childCount; h++) {
      let d = n.child(h);
      i(d, a, e.forChild(o, d), h), o += d.nodeSize;
    }
    return;
  }
  let r = 0, s = [], l = null;
  for (let h = 0; ; ) {
    let d, f;
    for (; r < a.length && a[r].to == o; ) {
      let v = a[r++];
      v.widget && (d ? (f || (f = [d])).push(v) : d = v);
    }
    if (d)
      if (f) {
        f.sort(h3);
        for (let v = 0; v < f.length; v++)
          t(f[v], h, !!l);
      } else
        t(d, h, !!l);
    let p, y;
    if (l)
      y = -1, p = l, l = null;
    else if (h < n.childCount)
      y = h, p = n.child(h++);
    else
      break;
    for (let v = 0; v < s.length; v++)
      s[v].to <= o && s.splice(v--, 1);
    for (; r < a.length && a[r].from <= o && a[r].to > o; )
      s.push(a[r++]);
    let m = o + p.nodeSize;
    if (p.isText) {
      let v = m;
      r < a.length && a[r].from < v && (v = a[r].from);
      for (let _ = 0; _ < s.length; _++)
        s[_].to < v && (v = s[_].to);
      v < m && (l = p.cut(v - o), p = p.cut(0, v - o), m = v, y = -1);
    } else
      for (; r < a.length && a[r].to < m; )
        r++;
    let w = p.isInline && !p.isLeaf ? s.filter((v) => !v.inline) : s.slice();
    i(p, w, e.forChild(o, p), y), o = m;
  }
}
function g3(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function f3(n, e, t, i) {
  for (let a = 0, o = 0; a < n.childCount && o <= i; ) {
    let r = n.child(a++), s = o;
    if (o += r.nodeSize, !r.isText)
      continue;
    let l = r.text;
    for (; a < n.childCount; ) {
      let h = n.child(a++);
      if (o += h.nodeSize, !h.isText)
        break;
      l += h.text;
    }
    if (o >= t) {
      if (o >= i && l.slice(i - e.length - s, i - s) == e)
        return i - e.length;
      let h = s < i ? l.lastIndexOf(e, i - s - 1) : -1;
      if (h >= 0 && h + e.length + s >= t)
        return s + h;
      if (t == i && l.length >= i + e.length - s && l.slice(i - s, i - s + e.length) == e)
        return i;
    }
  }
  return -1;
}
function Qp(n, e, t, i, a) {
  let o = [];
  for (let r = 0, s = 0; r < n.length; r++) {
    let l = n[r], h = s, d = s += l.size;
    h >= t || d <= e ? o.push(l) : (h < e && o.push(l.slice(0, e - h, i)), a && (o.push(a), a = void 0), d > t && o.push(l.slice(t - h, l.size, i)));
  }
  return o;
}
function ry(n, e = null) {
  let t = n.domSelectionRange(), i = n.state.doc;
  if (!t.focusNode)
    return null;
  let a = n.docView.nearestDesc(t.focusNode), o = a && a.size == 0, r = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (r < 0)
    return null;
  let s = i.resolve(r), l, h;
  if (jd(t)) {
    for (l = s; a && !a.node; )
      a = a.parent;
    let d = a.node;
    if (a && d.isAtom && Ce.isSelectable(d) && a.parent && !(d.isInline && JX(t.focusNode, t.focusOffset, a.dom))) {
      let f = a.posBefore;
      h = new Ce(r == f ? s : i.resolve(f));
    }
  } else {
    let d = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (d < 0)
      return null;
    l = i.resolve(d);
  }
  if (!h) {
    let d = e == "pointer" || n.state.selection.head < s.pos && !o ? 1 : -1;
    h = sy(n, l, s, d);
  }
  return h;
}
function $_(n) {
  return n.editable ? n.hasFocus() : U_(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function Va(n, e = !1) {
  let t = n.state.selection;
  if (V_(n, t), !!$_(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && jn) {
      let i = n.domSelectionRange(), a = n.domObserver.currentSelection;
      if (i.anchorNode && a.anchorNode && Yr(i.anchorNode, i.anchorOffset, a.anchorNode, a.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      m3(n);
    else {
      let { anchor: i, head: a } = t, o, r;
      dC && !(t instanceof Me) && (t.$from.parent.inlineContent || (o = gC(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (r = gC(n, t.to))), n.docView.setSelection(i, a, n.root, e), dC && (o && fC(o), r && fC(r)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && p3(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const dC = Rn || jn && F_ < 63;
function gC(n, e) {
  let { node: t, offset: i } = n.docView.domFromPos(e, 0), a = i < t.childNodes.length ? t.childNodes[i] : null, o = i ? t.childNodes[i - 1] : null;
  if (Rn && a && a.contentEditable == "false")
    return If(a);
  if ((!a || a.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (a)
      return If(a);
    if (o)
      return If(o);
  }
}
function If(n) {
  return n.contentEditable = "true", Rn && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function fC(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function p3(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), i = t.anchorNode, a = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != i || t.anchorOffset != a) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!$_(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function m3(n) {
  let e = n.domSelection(), t = document.createRange();
  if (!e)
    return;
  let i = n.cursorWrapper.dom, a = i.nodeName == "IMG";
  a ? t.setStart(i.parentNode, bn(i) + 1) : t.setStart(i, 0);
  let o = n.state.selection;
  if (o.empty)
    t.collapse(!0);
  else {
    let r = n.domAtPos(o.to);
    t.setEnd(r.node, r.offset);
  }
  e.removeAllRanges(), e.addRange(t), !a && !n.state.selection.visible && ei && Po <= 11 && (i.disabled = !0, i.disabled = !1);
}
function V_(n, e) {
  if (e instanceof Ce) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (pC(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    pC(n);
}
function pC(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function sy(n, e, t, i) {
  return n.someProp("createSelectionBetween", (a) => a(n, e, t)) || Me.between(e, t, i);
}
function mC(n) {
  return n.editable && !n.hasFocus() ? !1 : U_(n);
}
function U_(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function y3(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return Yr(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function Kp(n, e) {
  let { $anchor: t, $head: i } = n.selection, a = e > 0 ? t.max(i) : t.min(i), o = a.parent.inlineContent ? a.depth ? n.doc.resolve(e > 0 ? a.after() : a.before()) : null : a;
  return o && Pe.findFrom(o, e);
}
function jo(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function yC(n, e, t) {
  let i = n.state.selection;
  if (i instanceof Me)
    if (t.indexOf("s") > -1) {
      let { $head: a } = i, o = a.textOffset ? null : e < 0 ? a.nodeBefore : a.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let r = n.state.doc.resolve(a.pos + o.nodeSize * (e < 0 ? -1 : 1));
      return jo(n, new Me(i.$anchor, r));
    } else if (i.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let a = Kp(n.state, e);
        return a && a instanceof Ce ? jo(n, a) : !1;
      } else if (!(Oi && t.indexOf("m") > -1)) {
        let a = i.$head, o = a.textOffset ? null : e < 0 ? a.nodeBefore : a.nodeAfter, r;
        if (!o || o.isText)
          return !1;
        let s = e < 0 ? a.pos - o.nodeSize : a.pos;
        return o.isAtom || (r = n.docView.descAt(s)) && !r.contentDOM ? Ce.isSelectable(o) ? jo(n, new Ce(e < 0 ? n.state.doc.resolve(a.pos - o.nodeSize) : a)) : Zl ? jo(n, new Me(n.state.doc.resolve(e < 0 ? s : s + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (i instanceof Ce && i.node.isInline)
      return jo(n, new Me(e > 0 ? i.$to : i.$from));
    {
      let a = Kp(n.state, e);
      return a ? jo(n, a) : !1;
    }
  }
}
function Hh(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function rl(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function ds(n, e) {
  return e < 0 ? b3(n) : w3(n);
}
function b3(n) {
  let e = n.domSelectionRange(), t = e.focusNode, i = e.focusOffset;
  if (!t)
    return;
  let a, o, r = !1;
  for (aa && t.nodeType == 1 && i < Hh(t) && rl(t.childNodes[i], -1) && (r = !0); ; )
    if (i > 0) {
      if (t.nodeType != 1)
        break;
      {
        let s = t.childNodes[i - 1];
        if (rl(s, -1))
          a = t, o = --i;
        else if (s.nodeType == 3)
          t = s, i = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (q_(t))
        break;
      {
        let s = t.previousSibling;
        for (; s && rl(s, -1); )
          a = t.parentNode, o = bn(s), s = s.previousSibling;
        if (s)
          t = s, i = Hh(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          i = 0;
        }
      }
    }
  r ? zp(n, t, i) : a && zp(n, a, o);
}
function w3(n) {
  let e = n.domSelectionRange(), t = e.focusNode, i = e.focusOffset;
  if (!t)
    return;
  let a = Hh(t), o, r;
  for (; ; )
    if (i < a) {
      if (t.nodeType != 1)
        break;
      let s = t.childNodes[i];
      if (rl(s, 1))
        o = t, r = ++i;
      else
        break;
    } else {
      if (q_(t))
        break;
      {
        let s = t.nextSibling;
        for (; s && rl(s, 1); )
          o = s.parentNode, r = bn(s) + 1, s = s.nextSibling;
        if (s)
          t = s, i = 0, a = Hh(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          i = a = 0;
        }
      }
    }
  o && zp(n, o, r);
}
function q_(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function v3(n, e) {
  for (; n && e == n.childNodes.length && !Jl(n); )
    e = bn(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function C3(n, e) {
  for (; n && !e && !Jl(n); )
    e = bn(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function zp(n, e, t) {
  if (e.nodeType != 3) {
    let o, r;
    (r = v3(e, t)) ? (e = r, t = 0) : (o = C3(e, t)) && (e = o, t = o.nodeValue.length);
  }
  let i = n.domSelection();
  if (!i)
    return;
  if (jd(i)) {
    let o = document.createRange();
    o.setEnd(e, t), o.setStart(e, t), i.removeAllRanges(), i.addRange(o);
  } else i.extend && i.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: a } = n;
  setTimeout(() => {
    n.state == a && Va(n);
  }, 50);
}
function bC(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(jn || HX) && t.parent.inlineContent) {
    let a = n.coordsAtPos(e);
    if (e > t.start()) {
      let o = n.coordsAtPos(e - 1), r = (o.top + o.bottom) / 2;
      if (r > a.top && r < a.bottom && Math.abs(o.left - a.left) > 1)
        return o.left < a.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let o = n.coordsAtPos(e + 1), r = (o.top + o.bottom) / 2;
      if (r > a.top && r < a.bottom && Math.abs(o.left - a.left) > 1)
        return o.left > a.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function wC(n, e, t) {
  let i = n.state.selection;
  if (i instanceof Me && !i.empty || t.indexOf("s") > -1 || Oi && t.indexOf("m") > -1)
    return !1;
  let { $from: a, $to: o } = i;
  if (!a.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let r = Kp(n.state, e);
    if (r && r instanceof Ce)
      return jo(n, r);
  }
  if (!a.parent.inlineContent) {
    let r = e < 0 ? a : o, s = i instanceof ta ? Pe.near(r, e) : Pe.findFrom(r, e);
    return s ? jo(n, s) : !1;
  }
  return !1;
}
function vC(n, e) {
  if (!(n.state.selection instanceof Me))
    return !0;
  let { $head: t, $anchor: i, empty: a } = n.state.selection;
  if (!t.sameParent(i))
    return !0;
  if (!a)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let o = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (o && !o.isText) {
    let r = n.state.tr;
    return e < 0 ? r.delete(t.pos - o.nodeSize, t.pos) : r.delete(t.pos, t.pos + o.nodeSize), n.dispatch(r), !0;
  }
  return !1;
}
function CC(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function S3(n) {
  if (!Rn || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let i = e.firstChild;
    CC(n, i, "true"), setTimeout(() => CC(n, i, "false"), 20);
  }
  return !1;
}
function k3(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function _3(n, e) {
  let t = e.keyCode, i = k3(e);
  if (t == 8 || Oi && t == 72 && i == "c")
    return vC(n, -1) || ds(n, -1);
  if (t == 46 && !e.shiftKey || Oi && t == 68 && i == "c")
    return vC(n, 1) || ds(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || Oi && t == 66 && i == "c") {
    let a = t == 37 ? bC(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return yC(n, a, i) || ds(n, a);
  } else if (t == 39 || Oi && t == 70 && i == "c") {
    let a = t == 39 ? bC(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return yC(n, a, i) || ds(n, a);
  } else {
    if (t == 38 || Oi && t == 80 && i == "c")
      return wC(n, -1, i) || ds(n, -1);
    if (t == 40 || Oi && t == 78 && i == "c")
      return S3(n) || wC(n, 1, i) || ds(n, 1);
    if (i == (Oi ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function ej(n, e) {
  n.someProp("transformCopied", (y) => {
    e = y(e, n);
  });
  let t = [], { content: i, openStart: a, openEnd: o } = e;
  for (; a > 1 && o > 1 && i.childCount == 1 && i.firstChild.childCount == 1; ) {
    a--, o--;
    let y = i.firstChild;
    t.push(y.type.name, y.attrs != y.type.defaultAttrs ? y.attrs : null), i = y.content;
  }
  let r = n.someProp("clipboardSerializer") || Gr.fromSchema(n.state.schema), s = rj(), l = s.createElement("div");
  l.appendChild(r.serializeFragment(i, { document: s }));
  let h = l.firstChild, d, f = 0;
  for (; h && h.nodeType == 1 && (d = oj[h.nodeName.toLowerCase()]); ) {
    for (let y = d.length - 1; y >= 0; y--) {
      let m = s.createElement(d[y]);
      for (; l.firstChild; )
        m.appendChild(l.firstChild);
      l.appendChild(m), f++;
    }
    h = l.firstChild;
  }
  h && h.nodeType == 1 && h.setAttribute("data-pm-slice", `${a} ${o}${f ? ` -${f}` : ""} ${JSON.stringify(t)}`);
  let p = n.someProp("clipboardTextSerializer", (y) => y(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: p, slice: e };
}
function tj(n, e, t, i, a) {
  let o = a.parent.type.spec.code, r, s;
  if (!t && !e)
    return null;
  let l = e && (i || o || !t);
  if (l) {
    if (n.someProp("transformPastedText", (p) => {
      e = p(e, o || i, n);
    }), o)
      return e ? new ue(U.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : ue.empty;
    let f = n.someProp("clipboardTextParser", (p) => p(e, a, i, n));
    if (f)
      s = f;
    else {
      let p = a.marks(), { schema: y } = n.state, m = Gr.fromSchema(y);
      r = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((w) => {
        let v = r.appendChild(document.createElement("p"));
        w && v.appendChild(m.serializeNode(y.text(w, p)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (f) => {
      t = f(t, n);
    }), r = L3(t), Zl && x3(r);
  let h = r && r.querySelector("[data-pm-slice]"), d = h && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(h.getAttribute("data-pm-slice") || "");
  if (d && d[3])
    for (let f = +d[3]; f > 0; f--) {
      let p = r.firstChild;
      for (; p && p.nodeType != 1; )
        p = p.nextSibling;
      if (!p)
        break;
      r = p;
    }
  if (s || (s = (n.someProp("clipboardParser") || n.someProp("domParser") || Yo.fromSchema(n.state.schema)).parseSlice(r, {
    preserveWhitespace: !!(l || d),
    context: a,
    ruleFromNode(p) {
      return p.nodeName == "BR" && !p.nextSibling && p.parentNode && !j3.test(p.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), d)
    s = E3(SC(s, +d[1], +d[2]), d[4]);
  else if (s = ue.maxOpen(T3(s.content, a), !0), s.openStart || s.openEnd) {
    let f = 0, p = 0;
    for (let y = s.content.firstChild; f < s.openStart && !y.type.spec.isolating; f++, y = y.firstChild)
      ;
    for (let y = s.content.lastChild; p < s.openEnd && !y.type.spec.isolating; p++, y = y.lastChild)
      ;
    s = SC(s, f, p);
  }
  return n.someProp("transformPasted", (f) => {
    s = f(s, n);
  }), s;
}
const j3 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function T3(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let a = e.node(t).contentMatchAt(e.index(t)), o, r = [];
    if (n.forEach((s) => {
      if (!r)
        return;
      let l = a.findWrapping(s.type), h;
      if (!l)
        return r = null;
      if (h = r.length && o.length && ij(l, o, s, r[r.length - 1], 0))
        r[r.length - 1] = h;
      else {
        r.length && (r[r.length - 1] = aj(r[r.length - 1], o.length));
        let d = nj(s, l);
        r.push(d), a = a.matchType(d.type), o = l;
      }
    }), r)
      return U.from(r);
  }
  return n;
}
function nj(n, e, t = 0) {
  for (let i = e.length - 1; i >= t; i--)
    n = e[i].create(null, U.from(n));
  return n;
}
function ij(n, e, t, i, a) {
  if (a < n.length && a < e.length && n[a] == e[a]) {
    let o = ij(n, e, t, i.lastChild, a + 1);
    if (o)
      return i.copy(i.content.replaceChild(i.childCount - 1, o));
    if (i.contentMatchAt(i.childCount).matchType(a == n.length - 1 ? t.type : n[a + 1]))
      return i.copy(i.content.append(U.from(nj(t, n, a + 1))));
  }
}
function aj(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, aj(n.lastChild, e - 1)), i = n.contentMatchAt(n.childCount).fillBefore(U.empty, !0);
  return n.copy(t.append(i));
}
function $p(n, e, t, i, a, o) {
  let r = e < 0 ? n.firstChild : n.lastChild, s = r.content;
  return n.childCount > 1 && (o = 0), a < i - 1 && (s = $p(s, e, t, i, a + 1, o)), a >= t && (s = e < 0 ? r.contentMatchAt(0).fillBefore(s, o <= a).append(s) : s.append(r.contentMatchAt(r.childCount).fillBefore(U.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, r.copy(s));
}
function SC(n, e, t) {
  return e < n.openStart && (n = new ue($p(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new ue($p(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const oj = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let kC = null;
function rj() {
  return kC || (kC = document.implementation.createHTMLDocument("title"));
}
function L3(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = rj().createElement("div"), i = /<([a-z][^>\s]+)/i.exec(n), a;
  if ((a = i && oj[i[1].toLowerCase()]) && (n = a.map((o) => "<" + o + ">").join("") + n + a.map((o) => "</" + o + ">").reverse().join("")), t.innerHTML = n, a)
    for (let o = 0; o < a.length; o++)
      t = t.querySelector(a[o]) || t;
  return t;
}
function x3(n) {
  let e = n.querySelectorAll(jn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    i.childNodes.length == 1 && i.textContent == "Â " && i.parentNode && i.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), i);
  }
}
function E3(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, i;
  try {
    i = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: a, openStart: o, openEnd: r } = n;
  for (let s = i.length - 2; s >= 0; s -= 2) {
    let l = t.nodes[i[s]];
    if (!l || l.hasRequiredAttrs())
      break;
    a = U.from(l.create(i[s + 1], a)), o++, r++;
  }
  return new ue(a, o, r);
}
const Fn = {}, In = {}, D3 = { touchstart: !0, touchmove: !0 };
class M3 {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function N3(n) {
  for (let e in Fn) {
    let t = Fn[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (i) => {
      A3(n, i) && !uy(n, i) && (n.editable || !(i.type in In)) && t(n, i);
    }, D3[e] ? { passive: !0 } : void 0);
  }
  Rn && n.dom.addEventListener("input", () => null), Vp(n);
}
function Oo(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function O3(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function Vp(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (i) => uy(n, i));
  });
}
function uy(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let i = t[e.type];
    return i ? i(n, e) || e.defaultPrevented : !1;
  });
}
function A3(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function Y3(n, e) {
  !uy(n, e) && Fn[e.type] && (n.editable || !(e.type in In)) && Fn[e.type](n, e);
}
In.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !uj(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !($i && jn && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), Zs && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let i = Date.now();
      n.input.lastIOSEnter = i, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == i && (n.someProp("handleKeyDown", (a) => a(n, pr(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (i) => i(n, t)) || _3(n, t) ? t.preventDefault() : Oo(n, "key");
};
In.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
In.keypress = (n, e) => {
  let t = e;
  if (uj(n, t) || !t.charCode || t.ctrlKey && !t.altKey || Oi && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (a) => a(n, t))) {
    t.preventDefault();
    return;
  }
  let i = n.state.selection;
  if (!(i instanceof Me) || !i.$from.sameParent(i.$to)) {
    let a = String.fromCharCode(t.charCode);
    !/[\r\n]/.test(a) && !n.someProp("handleTextInput", (o) => o(n, i.$from.pos, i.$to.pos, a)) && n.dispatch(n.state.tr.insertText(a).scrollIntoView()), t.preventDefault();
  }
};
function Ld(n) {
  return { left: n.clientX, top: n.clientY };
}
function P3(n, e) {
  let t = e.x - n.clientX, i = e.y - n.clientY;
  return t * t + i * i < 100;
}
function ly(n, e, t, i, a) {
  if (i == -1)
    return !1;
  let o = n.state.doc.resolve(i);
  for (let r = o.depth + 1; r > 0; r--)
    if (n.someProp(e, (s) => r > o.depth ? s(n, t, o.nodeAfter, o.before(r), a, !0) : s(n, t, o.node(r), o.before(r), a, !1)))
      return !0;
  return !1;
}
function Ps(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let i = n.state.tr.setSelection(e);
  i.setMeta("pointer", !0), n.dispatch(i);
}
function R3(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), i = t.nodeAfter;
  return i && i.isAtom && Ce.isSelectable(i) ? (Ps(n, new Ce(t)), !0) : !1;
}
function F3(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, i, a;
  t instanceof Ce && (i = t.node);
  let o = n.state.doc.resolve(e);
  for (let r = o.depth + 1; r > 0; r--) {
    let s = r > o.depth ? o.nodeAfter : o.node(r);
    if (Ce.isSelectable(s)) {
      i && t.$from.depth > 0 && r >= t.$from.depth && o.before(t.$from.depth + 1) == t.$from.pos ? a = o.before(t.$from.depth) : a = o.before(r);
      break;
    }
  }
  return a != null ? (Ps(n, Ce.create(n.state.doc, a)), !0) : !1;
}
function I3(n, e, t, i, a) {
  return ly(n, "handleClickOn", e, t, i) || n.someProp("handleClick", (o) => o(n, e, i)) || (a ? F3(n, t) : R3(n, t));
}
function J3(n, e, t, i) {
  return ly(n, "handleDoubleClickOn", e, t, i) || n.someProp("handleDoubleClick", (a) => a(n, e, i));
}
function Z3(n, e, t, i) {
  return ly(n, "handleTripleClickOn", e, t, i) || n.someProp("handleTripleClick", (a) => a(n, e, i)) || B3(n, t, i);
}
function B3(n, e, t) {
  if (t.button != 0)
    return !1;
  let i = n.state.doc;
  if (e == -1)
    return i.inlineContent ? (Ps(n, Me.create(i, 0, i.content.size)), !0) : !1;
  let a = i.resolve(e);
  for (let o = a.depth + 1; o > 0; o--) {
    let r = o > a.depth ? a.nodeAfter : a.node(o), s = a.before(o);
    if (r.inlineContent)
      Ps(n, Me.create(i, s + 1, s + 1 + r.content.size));
    else if (Ce.isSelectable(r))
      Ps(n, Ce.create(i, s));
    else
      continue;
    return !0;
  }
}
function cy(n) {
  return Xh(n);
}
const sj = Oi ? "metaKey" : "ctrlKey";
Fn.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let i = cy(n), a = Date.now(), o = "singleClick";
  a - n.input.lastClick.time < 500 && P3(t, n.input.lastClick) && !t[sj] && (n.input.lastClick.type == "singleClick" ? o = "doubleClick" : n.input.lastClick.type == "doubleClick" && (o = "tripleClick")), n.input.lastClick = { time: a, x: t.clientX, y: t.clientY, type: o };
  let r = n.posAtCoords(Ld(t));
  r && (o == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new H3(n, r, t, !!i)) : (o == "doubleClick" ? J3 : Z3)(n, r.pos, r.inside, t) ? t.preventDefault() : Oo(n, "pointer"));
};
class H3 {
  constructor(e, t, i, a) {
    this.view = e, this.pos = t, this.event = i, this.flushed = a, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!i[sj], this.allowDefault = i.shiftKey;
    let o, r;
    if (t.inside > -1)
      o = e.state.doc.nodeAt(t.inside), r = t.inside;
    else {
      let d = e.state.doc.resolve(t.pos);
      o = d.parent, r = d.depth ? d.before() : 0;
    }
    const s = a ? null : i.target, l = s ? e.docView.nearestDesc(s, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: h } = e.state;
    (i.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || h instanceof Ce && h.from <= r && h.to > r) && (this.mightDrag = {
      node: o,
      pos: r,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && aa && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Oo(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Va(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(Ld(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Oo(this.view, "pointer") : I3(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Rn && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    jn && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (Ps(this.view, Pe.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : Oo(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Oo(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Fn.touchstart = (n) => {
  n.input.lastTouch = Date.now(), cy(n), Oo(n, "pointer");
};
Fn.touchmove = (n) => {
  n.input.lastTouch = Date.now(), Oo(n, "pointer");
};
Fn.contextmenu = (n) => cy(n);
function uj(n, e) {
  return n.composing ? !0 : Rn && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const X3 = $i ? 5e3 : -1;
In.compositionstart = In.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof Me && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((i) => i.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), Xh(n, !0), n.markCursor = null;
    else if (Xh(n), aa && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let i = n.domSelectionRange();
      for (let a = i.focusNode, o = i.focusOffset; a && a.nodeType == 1 && o != 0; ) {
        let r = o < 0 ? a.lastChild : a.childNodes[o - 1];
        if (!r)
          break;
        if (r.nodeType == 3) {
          let s = n.domSelection();
          s && s.collapse(r, r.nodeValue.length);
          break;
        } else
          a = r, o = -1;
      }
    }
    n.input.composing = !0;
  }
  lj(n, X3);
};
In.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, lj(n, 20));
};
function lj(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => Xh(n), e));
}
function cj(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = W3()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function G3(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = FX(e.focusNode, e.focusOffset), i = IX(e.focusNode, e.focusOffset);
  if (t && i && t != i) {
    let a = i.pmViewDesc, o = n.domObserver.lastChangedTextNode;
    if (t == o || i == o)
      return o;
    if (!a || !a.isText(i.nodeValue))
      return i;
    if (n.input.compositionNode == i) {
      let r = t.pmViewDesc;
      if (!(!r || !r.isText(t.nodeValue)))
        return i;
    }
  }
  return t || i;
}
function W3() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function Xh(n, e = !1) {
  if (!($i && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), cj(n), e || n.docView && n.docView.dirty) {
      let t = ry(n);
      return t && !t.eq(n.state.selection) ? n.dispatch(n.state.tr.setSelection(t)) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function Q3(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let i = getSelection(), a = document.createRange();
  a.selectNodeContents(e), n.dom.blur(), i.removeAllRanges(), i.addRange(a), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const Cl = ei && Po < 15 || Zs && XX < 604;
Fn.copy = In.cut = (n, e) => {
  let t = e, i = n.state.selection, a = t.type == "cut";
  if (i.empty)
    return;
  let o = Cl ? null : t.clipboardData, r = i.content(), { dom: s, text: l } = ej(n, r);
  o ? (t.preventDefault(), o.clearData(), o.setData("text/html", s.innerHTML), o.setData("text/plain", l)) : Q3(n, s), a && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function K3(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function z3(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, i = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (i.contentEditable = "true"), i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.focus();
  let a = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), i.parentNode && i.parentNode.removeChild(i), t ? Sl(n, i.value, null, a, e) : Sl(n, i.textContent, i.innerHTML, a, e);
  }, 50);
}
function Sl(n, e, t, i, a) {
  let o = tj(n, e, t, i, n.state.selection.$from);
  if (n.someProp("handlePaste", (l) => l(n, a, o || ue.empty)))
    return !0;
  if (!o)
    return !1;
  let r = K3(o), s = r ? n.state.tr.replaceSelectionWith(r, i) : n.state.tr.replaceSelection(o);
  return n.dispatch(s.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function hj(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
In.paste = (n, e) => {
  let t = e;
  if (n.composing && !$i)
    return;
  let i = Cl ? null : t.clipboardData, a = n.input.shiftKey && n.input.lastKeyCode != 45;
  i && Sl(n, hj(i), i.getData("text/html"), a, t) ? t.preventDefault() : z3(n, t);
};
class dj {
  constructor(e, t, i) {
    this.slice = e, this.move = t, this.node = i;
  }
}
const gj = Oi ? "altKey" : "ctrlKey";
Fn.dragstart = (n, e) => {
  let t = e, i = n.input.mouseDown;
  if (i && i.done(), !t.dataTransfer)
    return;
  let a = n.state.selection, o = a.empty ? null : n.posAtCoords(Ld(t)), r;
  if (!(o && o.pos >= a.from && o.pos <= (a instanceof Ce ? a.to - 1 : a.to))) {
    if (i && i.mightDrag)
      r = Ce.create(n.state.doc, i.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let f = n.docView.nearestDesc(t.target, !0);
      f && f.node.type.spec.draggable && f != n.docView && (r = Ce.create(n.state.doc, f.posBefore));
    }
  }
  let s = (r || n.state.selection).content(), { dom: l, text: h, slice: d } = ej(n, s);
  (!t.dataTransfer.files.length || !jn || F_ > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Cl ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Cl || t.dataTransfer.setData("text/plain", h), n.dragging = new dj(d, !t[gj], r);
};
Fn.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
In.dragover = In.dragenter = (n, e) => e.preventDefault();
In.drop = (n, e) => {
  let t = e, i = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let a = n.posAtCoords(Ld(t));
  if (!a)
    return;
  let o = n.state.doc.resolve(a.pos), r = i && i.slice;
  r ? n.someProp("transformPasted", (m) => {
    r = m(r, n);
  }) : r = tj(n, hj(t.dataTransfer), Cl ? null : t.dataTransfer.getData("text/html"), !1, o);
  let s = !!(i && !t[gj]);
  if (n.someProp("handleDrop", (m) => m(n, t, r || ue.empty, s))) {
    t.preventDefault();
    return;
  }
  if (!r)
    return;
  t.preventDefault();
  let l = r ? D_(n.state.doc, o.pos, r) : o.pos;
  l == null && (l = o.pos);
  let h = n.state.tr;
  if (s) {
    let { node: m } = i;
    m ? m.replace(h) : h.deleteSelection();
  }
  let d = h.mapping.map(l), f = r.openStart == 0 && r.openEnd == 0 && r.content.childCount == 1, p = h.doc;
  if (f ? h.replaceRangeWith(d, d, r.content.firstChild) : h.replaceRange(d, d, r), h.doc.eq(p))
    return;
  let y = h.doc.resolve(d);
  if (f && Ce.isSelectable(r.content.firstChild) && y.nodeAfter && y.nodeAfter.sameMarkup(r.content.firstChild))
    h.setSelection(new Ce(y));
  else {
    let m = h.mapping.map(l);
    h.mapping.maps[h.mapping.maps.length - 1].forEach((w, v, _, L) => m = L), h.setSelection(sy(n, y, h.doc.resolve(m)));
  }
  n.focus(), n.dispatch(h.setMeta("uiEvent", "drop"));
};
Fn.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && Va(n);
  }, 20));
};
Fn.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
Fn.beforeinput = (n, e) => {
  if (jn && $i && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: i } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != i || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (o) => o(n, pr(8, "Backspace")))))
        return;
      let { $cursor: a } = n.state.selection;
      a && a.pos > 0 && n.dispatch(n.state.tr.delete(a.pos - 1, a.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in In)
  Fn[n] = In[n];
function kl(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class Gh {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || Lr, this.side = this.spec.side || 0;
  }
  map(e, t, i, a) {
    let { pos: o, deleted: r } = e.mapResult(t.from + a, this.side < 0 ? -1 : 1);
    return r ? null : new Pi(o - i, o - i, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Gh && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && kl(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Fo {
  constructor(e, t) {
    this.attrs = e, this.spec = t || Lr;
  }
  map(e, t, i, a) {
    let o = e.map(t.from + a, this.spec.inclusiveStart ? -1 : 1) - i, r = e.map(t.to + a, this.spec.inclusiveEnd ? 1 : -1) - i;
    return o >= r ? null : new Pi(o, r, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof Fo && kl(this.attrs, e.attrs) && kl(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Fo;
  }
  destroy() {
  }
}
class hy {
  constructor(e, t) {
    this.attrs = e, this.spec = t || Lr;
  }
  map(e, t, i, a) {
    let o = e.mapResult(t.from + a, 1);
    if (o.deleted)
      return null;
    let r = e.mapResult(t.to + a, -1);
    return r.deleted || r.pos <= o.pos ? null : new Pi(o.pos - i, r.pos - i, this);
  }
  valid(e, t) {
    let { index: i, offset: a } = e.content.findIndex(t.from), o;
    return a == t.from && !(o = e.child(i)).isText && a + o.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof hy && kl(this.attrs, e.attrs) && kl(this.spec, e.spec);
  }
  destroy() {
  }
}
class Pi {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.type = i;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new Pi(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, i) {
    return this.type.map(e, this, t, i);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, i) {
    return new Pi(e, e, new Gh(t, i));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, i, a) {
    return new Pi(e, t, new Fo(i, a));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, i, a) {
    return new Pi(e, t, new hy(i, a));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Fo;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Gh;
  }
}
const ys = [], Lr = {};
class Vt {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : ys, this.children = t.length ? t : ys;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? Wh(t, e, 0, Lr) : kn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, i) {
    let a = [];
    return this.findInner(e ?? 0, t ?? 1e9, a, 0, i), a;
  }
  findInner(e, t, i, a, o) {
    for (let r = 0; r < this.local.length; r++) {
      let s = this.local[r];
      s.from <= t && s.to >= e && (!o || o(s.spec)) && i.push(s.copy(s.from + a, s.to + a));
    }
    for (let r = 0; r < this.children.length; r += 3)
      if (this.children[r] < t && this.children[r + 1] > e) {
        let s = this.children[r] + 1;
        this.children[r + 2].findInner(e - s, t - s, i, a + s, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, i) {
    return this == kn || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, i || Lr);
  }
  /**
  @internal
  */
  mapInner(e, t, i, a, o) {
    let r;
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s].map(e, i, a);
      l && l.type.valid(t, l) ? (r || (r = [])).push(l) : o.onRemove && o.onRemove(this.local[s].spec);
    }
    return this.children.length ? $3(this.children, r || [], e, t, i, a, o) : r ? new Vt(r.sort(xr), ys) : kn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == kn ? Vt.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, i) {
    let a, o = 0;
    e.forEach((s, l) => {
      let h = l + i, d;
      if (d = pj(t, s, h)) {
        for (a || (a = this.children.slice()); o < a.length && a[o] < l; )
          o += 3;
        a[o] == l ? a[o + 2] = a[o + 2].addInner(s, d, h + 1) : a.splice(o, 0, l, l + s.nodeSize, Wh(d, s, h + 1, Lr)), o += 3;
      }
    });
    let r = fj(o ? mj(t) : t, -i);
    for (let s = 0; s < r.length; s++)
      r[s].type.valid(e, r[s]) || r.splice(s--, 1);
    return new Vt(r.length ? this.local.concat(r).sort(xr) : this.local, a || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == kn ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let i = this.children, a = this.local;
    for (let o = 0; o < i.length; o += 3) {
      let r, s = i[o] + t, l = i[o + 1] + t;
      for (let d = 0, f; d < e.length; d++)
        (f = e[d]) && f.from > s && f.to < l && (e[d] = null, (r || (r = [])).push(f));
      if (!r)
        continue;
      i == this.children && (i = this.children.slice());
      let h = i[o + 2].removeInner(r, s + 1);
      h != kn ? i[o + 2] = h : (i.splice(o, 3), o -= 3);
    }
    if (a.length) {
      for (let o = 0, r; o < e.length; o++)
        if (r = e[o])
          for (let s = 0; s < a.length; s++)
            a[s].eq(r, t) && (a == this.local && (a = this.local.slice()), a.splice(s--, 1));
    }
    return i == this.children && a == this.local ? this : a.length || i.length ? new Vt(a, i) : kn;
  }
  forChild(e, t) {
    if (this == kn)
      return this;
    if (t.isLeaf)
      return Vt.empty;
    let i, a;
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] >= e) {
        this.children[s] == e && (i = this.children[s + 2]);
        break;
      }
    let o = e + 1, r = o + t.content.size;
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s];
      if (l.from < r && l.to > o && l.type instanceof Fo) {
        let h = Math.max(o, l.from) - o, d = Math.min(r, l.to) - o;
        h < d && (a || (a = [])).push(l.copy(h, d));
      }
    }
    if (a) {
      let s = new Vt(a.sort(xr), ys);
      return i ? new Eo([s, i]) : s;
    }
    return i || kn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Vt) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return dy(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == kn)
      return ys;
    if (e.inlineContent || !this.local.some(Fo.is))
      return this.local;
    let t = [];
    for (let i = 0; i < this.local.length; i++)
      this.local[i].type instanceof Fo || t.push(this.local[i]);
    return t;
  }
}
Vt.empty = new Vt([], []);
Vt.removeOverlap = dy;
const kn = Vt.empty;
class Eo {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const i = this.members.map((a) => a.map(e, t, Lr));
    return Eo.from(i);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return Vt.empty;
    let i = [];
    for (let a = 0; a < this.members.length; a++) {
      let o = this.members[a].forChild(e, t);
      o != kn && (o instanceof Eo ? i = i.concat(o.members) : i.push(o));
    }
    return Eo.from(i);
  }
  eq(e) {
    if (!(e instanceof Eo) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, i = !0;
    for (let a = 0; a < this.members.length; a++) {
      let o = this.members[a].localsInner(e);
      if (o.length)
        if (!t)
          t = o;
        else {
          i && (t = t.slice(), i = !1);
          for (let r = 0; r < o.length; r++)
            t.push(o[r]);
        }
    }
    return t ? dy(i ? t : t.sort(xr)) : ys;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return kn;
      case 1:
        return e[0];
      default:
        return new Eo(e.every((t) => t instanceof Vt) ? e : e.reduce((t, i) => t.concat(i instanceof Vt ? i : i.members), []));
    }
  }
}
function $3(n, e, t, i, a, o, r) {
  let s = n.slice();
  for (let h = 0, d = o; h < t.maps.length; h++) {
    let f = 0;
    t.maps[h].forEach((p, y, m, w) => {
      let v = w - m - (y - p);
      for (let _ = 0; _ < s.length; _ += 3) {
        let L = s[_ + 1];
        if (L < 0 || p > L + d - f)
          continue;
        let T = s[_] + d - f;
        y >= T ? s[_ + 1] = p <= T ? -2 : -1 : p >= d && v && (s[_] += v, s[_ + 1] += v);
      }
      f += v;
    }), d = t.maps[h].map(d, -1);
  }
  let l = !1;
  for (let h = 0; h < s.length; h += 3)
    if (s[h + 1] < 0) {
      if (s[h + 1] == -2) {
        l = !0, s[h + 1] = -1;
        continue;
      }
      let d = t.map(n[h] + o), f = d - a;
      if (f < 0 || f >= i.content.size) {
        l = !0;
        continue;
      }
      let p = t.map(n[h + 1] + o, -1), y = p - a, { index: m, offset: w } = i.content.findIndex(f), v = i.maybeChild(m);
      if (v && w == f && w + v.nodeSize == y) {
        let _ = s[h + 2].mapInner(t, v, d + 1, n[h] + o + 1, r);
        _ != kn ? (s[h] = f, s[h + 1] = y, s[h + 2] = _) : (s[h + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let h = V3(s, n, e, t, a, o, r), d = Wh(h, i, 0, r);
    e = d.local;
    for (let f = 0; f < s.length; f += 3)
      s[f + 1] < 0 && (s.splice(f, 3), f -= 3);
    for (let f = 0, p = 0; f < d.children.length; f += 3) {
      let y = d.children[f];
      for (; p < s.length && s[p] < y; )
        p += 3;
      s.splice(p, 0, d.children[f], d.children[f + 1], d.children[f + 2]);
    }
  }
  return new Vt(e.sort(xr), s);
}
function fj(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let i = 0; i < n.length; i++) {
    let a = n[i];
    t.push(new Pi(a.from + e, a.to + e, a.type));
  }
  return t;
}
function V3(n, e, t, i, a, o, r) {
  function s(l, h) {
    for (let d = 0; d < l.local.length; d++) {
      let f = l.local[d].map(i, a, h);
      f ? t.push(f) : r.onRemove && r.onRemove(l.local[d].spec);
    }
    for (let d = 0; d < l.children.length; d += 3)
      s(l.children[d + 2], l.children[d] + h + 1);
  }
  for (let l = 0; l < n.length; l += 3)
    n[l + 1] == -1 && s(n[l + 2], e[l] + o + 1);
  return t;
}
function pj(n, e, t) {
  if (e.isLeaf)
    return null;
  let i = t + e.nodeSize, a = null;
  for (let o = 0, r; o < n.length; o++)
    (r = n[o]) && r.from > t && r.to < i && ((a || (a = [])).push(r), n[o] = null);
  return a;
}
function mj(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function Wh(n, e, t, i) {
  let a = [], o = !1;
  e.forEach((s, l) => {
    let h = pj(n, s, l + t);
    if (h) {
      o = !0;
      let d = Wh(h, s, t + l + 1, i);
      d != kn && a.push(l, l + s.nodeSize, d);
    }
  });
  let r = fj(o ? mj(n) : n, -t).sort(xr);
  for (let s = 0; s < r.length; s++)
    r[s].type.valid(e, r[s]) || (i.onRemove && i.onRemove(r[s].spec), r.splice(s--, 1));
  return r.length || a.length ? new Vt(r, a) : kn;
}
function xr(n, e) {
  return n.from - e.from || n.to - e.to;
}
function dy(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let i = e[t];
    if (i.from != i.to)
      for (let a = t + 1; a < e.length; a++) {
        let o = e[a];
        if (o.from == i.from) {
          o.to != i.to && (e == n && (e = n.slice()), e[a] = o.copy(o.from, i.to), _C(e, a + 1, o.copy(i.to, o.to)));
          continue;
        } else {
          o.from < i.to && (e == n && (e = n.slice()), e[t] = i.copy(i.from, o.from), _C(e, a, i.copy(o.from, i.to)));
          break;
        }
      }
  }
  return e;
}
function _C(n, e, t) {
  for (; e < n.length && xr(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function Jf(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let i = t(n.state);
    i && i != kn && e.push(i);
  }), n.cursorWrapper && e.push(Vt.create(n.state.doc, [n.cursorWrapper.deco])), Eo.from(e);
}
const U3 = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, q3 = ei && Po <= 11;
class eG {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class tG {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new eG(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((i) => {
      for (let a = 0; a < i.length; a++)
        this.queue.push(i[a]);
      ei && Po <= 11 && i.some((a) => a.type == "childList" && a.removedNodes.length || a.type == "characterData" && a.oldValue.length > a.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), q3 && (this.onCharData = (i) => {
      this.queue.push({ target: i.target, type: "characterData", oldValue: i.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, U3)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (mC(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Va(this.view);
      if (ei && Po <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Yr(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), i;
    for (let o = e.focusNode; o; o = vl(o))
      t.add(o);
    for (let o = e.anchorNode; o; o = vl(o))
      if (t.has(o)) {
        i = o;
        break;
      }
    let a = i && this.view.docView.nearestDesc(i);
    if (a && a.ignoreMutation({
      type: "selection",
      target: i.nodeType == 3 ? i.parentNode : i
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let i = e.domSelectionRange(), a = !this.suppressingSelectionUpdates && !this.currentSelection.eq(i) && mC(e) && !this.ignoreSelectionChange(i), o = -1, r = -1, s = !1, l = [];
    if (e.editable)
      for (let d = 0; d < t.length; d++) {
        let f = this.registerMutation(t[d], l);
        f && (o = o < 0 ? f.from : Math.min(f.from, o), r = r < 0 ? f.to : Math.max(f.to, r), f.typeOver && (s = !0));
      }
    if (aa && l.length) {
      let d = l.filter((f) => f.nodeName == "BR");
      if (d.length == 2) {
        let [f, p] = d;
        f.parentNode && f.parentNode.parentNode == p.parentNode ? p.remove() : f.remove();
      } else {
        let { focusNode: f } = this.currentSelection;
        for (let p of d) {
          let y = p.parentNode;
          y && y.nodeName == "LI" && (!f || aG(e, f) != y) && p.remove();
        }
      }
    }
    let h = null;
    o < 0 && a && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && jd(i) && (h = ry(e)) && h.eq(Pe.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Va(e), this.currentSelection.set(i), e.scrollToSelection()) : (o > -1 || a) && (o > -1 && (e.docView.markDirty(o, r), nG(e)), this.handleDOMChange(o, r, s, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(i) || Va(e), this.currentSelection.set(i));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let i = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (i == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !i || i.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let d = 0; d < e.addedNodes.length; d++) {
        let f = e.addedNodes[d];
        t.push(f), f.nodeType == 3 && (this.lastChangedTextNode = f);
      }
      if (i.contentDOM && i.contentDOM != i.dom && !i.contentDOM.contains(e.target))
        return { from: i.posBefore, to: i.posAfter };
      let a = e.previousSibling, o = e.nextSibling;
      if (ei && Po <= 11 && e.addedNodes.length)
        for (let d = 0; d < e.addedNodes.length; d++) {
          let { previousSibling: f, nextSibling: p } = e.addedNodes[d];
          (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (a = f), (!p || Array.prototype.indexOf.call(e.addedNodes, p) < 0) && (o = p);
        }
      let r = a && a.parentNode == e.target ? bn(a) + 1 : 0, s = i.localPosFromDOM(e.target, r, -1), l = o && o.parentNode == e.target ? bn(o) : e.target.childNodes.length, h = i.localPosFromDOM(e.target, l, 1);
      return { from: s, to: h };
    } else return e.type == "attributes" ? { from: i.posAtStart - i.border, to: i.posAtEnd + i.border } : (this.lastChangedTextNode = e.target, {
      from: i.posAtStart,
      to: i.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let jC = /* @__PURE__ */ new WeakMap(), TC = !1;
function nG(n) {
  if (!jC.has(n) && (jC.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = aa, TC)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), TC = !0;
  }
}
function LC(n, e) {
  let t = e.startContainer, i = e.startOffset, a = e.endContainer, o = e.endOffset, r = n.domAtPos(n.state.selection.anchor);
  return Yr(r.node, r.offset, a, o) && ([t, i, a, o] = [a, o, t, i]), { anchorNode: t, anchorOffset: i, focusNode: a, focusOffset: o };
}
function iG(n, e) {
  if (e.getComposedRanges) {
    let a = e.getComposedRanges(n.root)[0];
    if (a)
      return LC(n, a);
  }
  let t;
  function i(a) {
    a.preventDefault(), a.stopImmediatePropagation(), t = a.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", i, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", i, !0), t ? LC(n, t) : null;
}
function aG(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let i = n.docView.nearestDesc(t, !0);
    if (i && i.node.isBlock)
      return t;
  }
  return null;
}
function oG(n, e, t) {
  let { node: i, fromOffset: a, toOffset: o, from: r, to: s } = n.docView.parseRange(e, t), l = n.domSelectionRange(), h, d = l.anchorNode;
  if (d && n.dom.contains(d.nodeType == 1 ? d : d.parentNode) && (h = [{ node: d, offset: l.anchorOffset }], jd(l) || h.push({ node: l.focusNode, offset: l.focusOffset })), jn && n.input.lastKeyCode === 8)
    for (let v = o; v > a; v--) {
      let _ = i.childNodes[v - 1], L = _.pmViewDesc;
      if (_.nodeName == "BR" && !L) {
        o = v;
        break;
      }
      if (!L || L.size)
        break;
    }
  let f = n.state.doc, p = n.someProp("domParser") || Yo.fromSchema(n.state.schema), y = f.resolve(r), m = null, w = p.parse(i, {
    topNode: y.parent,
    topMatch: y.parent.contentMatchAt(y.index()),
    topOpen: !0,
    from: a,
    to: o,
    preserveWhitespace: y.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: h,
    ruleFromNode: rG,
    context: y
  });
  if (h && h[0].pos != null) {
    let v = h[0].pos, _ = h[1] && h[1].pos;
    _ == null && (_ = v), m = { anchor: v + r, head: _ + r };
  }
  return { doc: w, sel: m, from: r, to: s };
}
function rG(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (Rn && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || Rn && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const sG = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function uG(n, e, t, i, a) {
  let o = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let Y = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, te = ry(n, Y);
    if (te && !n.state.selection.eq(te)) {
      if (jn && $i && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (re) => re(n, pr(13, "Enter"))))
        return;
      let ge = n.state.tr.setSelection(te);
      Y == "pointer" ? ge.setMeta("pointer", !0) : Y == "key" && ge.scrollIntoView(), o && ge.setMeta("composition", o), n.dispatch(ge);
    }
    return;
  }
  let r = n.state.doc.resolve(e), s = r.sharedDepth(t);
  e = r.before(s + 1), t = n.state.doc.resolve(t).after(s + 1);
  let l = n.state.selection, h = oG(n, e, t), d = n.state.doc, f = d.slice(h.from, h.to), p, y;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (p = n.state.selection.to, y = "end") : (p = n.state.selection.from, y = "start"), n.input.lastKeyCode = null;
  let m = hG(f.content, h.doc.content, h.from, p, y);
  if ((Zs && n.input.lastIOSEnter > Date.now() - 225 || $i) && a.some((Y) => Y.nodeType == 1 && !sG.test(Y.nodeName)) && (!m || m.endA >= m.endB) && n.someProp("handleKeyDown", (Y) => Y(n, pr(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!m)
    if (i && l instanceof Me && !l.empty && l.$head.sameParent(l.$anchor) && !n.composing && !(h.sel && h.sel.anchor != h.sel.head))
      m = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (h.sel) {
        let Y = xC(n, n.state.doc, h.sel);
        if (Y && !Y.eq(n.state.selection)) {
          let te = n.state.tr.setSelection(Y);
          o && te.setMeta("composition", o), n.dispatch(te);
        }
      }
      return;
    }
  n.input.domChangeCount++, n.state.selection.from < n.state.selection.to && m.start == m.endB && n.state.selection instanceof Me && (m.start > n.state.selection.from && m.start <= n.state.selection.from + 2 && n.state.selection.from >= h.from ? m.start = n.state.selection.from : m.endA < n.state.selection.to && m.endA >= n.state.selection.to - 2 && n.state.selection.to <= h.to && (m.endB += n.state.selection.to - m.endA, m.endA = n.state.selection.to)), ei && Po <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > h.from && h.doc.textBetween(m.start - h.from - 1, m.start - h.from + 1) == " Â " && (m.start--, m.endA--, m.endB--);
  let w = h.doc.resolveNoCache(m.start - h.from), v = h.doc.resolveNoCache(m.endB - h.from), _ = d.resolve(m.start), L = w.sameParent(v) && w.parent.inlineContent && _.end() >= m.endA, T;
  if ((Zs && n.input.lastIOSEnter > Date.now() - 225 && (!L || a.some((Y) => Y.nodeName == "DIV" || Y.nodeName == "P")) || !L && w.pos < h.doc.content.size && !w.sameParent(v) && (T = Pe.findFrom(h.doc.resolve(w.pos + 1), 1, !0)) && T.head == v.pos) && n.someProp("handleKeyDown", (Y) => Y(n, pr(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > m.start && cG(d, m.start, m.endA, w, v) && n.someProp("handleKeyDown", (Y) => Y(n, pr(8, "Backspace")))) {
    $i && jn && n.domObserver.suppressSelectionUpdates();
    return;
  }
  jn && $i && m.endB == m.start && (n.input.lastAndroidDelete = Date.now()), $i && !L && w.start() != v.start() && v.parentOffset == 0 && w.depth == v.depth && h.sel && h.sel.anchor == h.sel.head && h.sel.head == m.endA && (m.endB -= 2, v = h.doc.resolveNoCache(m.endB - h.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(Y) {
      return Y(n, pr(13, "Enter"));
    });
  }, 20));
  let S = m.start, A = m.endA, x, M, P;
  if (L) {
    if (w.pos == v.pos)
      ei && Po <= 11 && w.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => Va(n), 20)), x = n.state.tr.delete(S, A), M = d.resolve(m.start).marksAcross(d.resolve(m.endA));
    else if (
      // Adding or removing a mark
      m.endA == m.endB && (P = lG(w.parent.content.cut(w.parentOffset, v.parentOffset), _.parent.content.cut(_.parentOffset, m.endA - _.start())))
    )
      x = n.state.tr, P.type == "add" ? x.addMark(S, A, P.mark) : x.removeMark(S, A, P.mark);
    else if (w.parent.child(w.index()).isText && w.index() == v.index() - (v.textOffset ? 0 : 1)) {
      let Y = w.parent.textBetween(w.parentOffset, v.parentOffset);
      if (n.someProp("handleTextInput", (te) => te(n, S, A, Y)))
        return;
      x = n.state.tr.insertText(Y, S, A);
    }
  }
  if (x || (x = n.state.tr.replace(S, A, h.doc.slice(m.start - h.from, m.endB - h.from))), h.sel) {
    let Y = xC(n, x.doc, h.sel);
    Y && !(jn && $i && n.composing && Y.empty && (m.start != m.endB || n.input.lastAndroidDelete < Date.now() - 100) && (Y.head == S || Y.head == x.mapping.map(A) - 1) || ei && Y.empty && Y.head == S) && x.setSelection(Y);
  }
  M && x.ensureMarks(M), o && x.setMeta("composition", o), n.dispatch(x.scrollIntoView());
}
function xC(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : sy(n, e.resolve(t.anchor), e.resolve(t.head));
}
function lG(n, e) {
  let t = n.firstChild.marks, i = e.firstChild.marks, a = t, o = i, r, s, l;
  for (let d = 0; d < i.length; d++)
    a = i[d].removeFromSet(a);
  for (let d = 0; d < t.length; d++)
    o = t[d].removeFromSet(o);
  if (a.length == 1 && o.length == 0)
    s = a[0], r = "add", l = (d) => d.mark(s.addToSet(d.marks));
  else if (a.length == 0 && o.length == 1)
    s = o[0], r = "remove", l = (d) => d.mark(s.removeFromSet(d.marks));
  else
    return null;
  let h = [];
  for (let d = 0; d < e.childCount; d++)
    h.push(l(e.child(d)));
  if (U.from(h).eq(n))
    return { mark: s, type: r };
}
function cG(n, e, t, i, a) {
  if (
    // The content must have shrunk
    t - e <= a.pos - i.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Zf(i, !0, !1) < a.pos
  )
    return !1;
  let o = n.resolve(e);
  if (!i.parent.isTextblock) {
    let s = o.nodeAfter;
    return s != null && t == e + s.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let r = n.resolve(Zf(o, !0, !0));
  return !r.parent.isTextblock || r.pos > t || Zf(r, !0, !1) < t ? !1 : i.parent.content.cut(i.parentOffset).eq(r.parent.content);
}
function Zf(n, e, t) {
  let i = n.depth, a = e ? n.end() : n.pos;
  for (; i > 0 && (e || n.indexAfter(i) == n.node(i).childCount); )
    i--, a++, e = !1;
  if (t) {
    let o = n.node(i).maybeChild(n.indexAfter(i));
    for (; o && !o.isLeaf; )
      o = o.firstChild, a++;
  }
  return a;
}
function hG(n, e, t, i, a) {
  let o = n.findDiffStart(e, t);
  if (o == null)
    return null;
  let { a: r, b: s } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (a == "end") {
    let l = Math.max(0, o - Math.min(r, s));
    i -= r + l - o;
  }
  if (r < o && n.size < e.size) {
    let l = i <= o && i >= r ? o - i : 0;
    o -= l, o && o < e.size && EC(e.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), s = o + (s - r), r = o;
  } else if (s < o) {
    let l = i <= o && i >= s ? o - i : 0;
    o -= l, o && o < n.size && EC(n.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), r = o + (r - s), s = o;
  }
  return { start: o, endA: r, endB: s };
}
function EC(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class dG {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new M3(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(AC), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = NC(this), MC(this), this.nodeViews = OC(this), this.docView = cC(this.state.doc, DC(this), Jf(this), this.dom, this), this.domObserver = new tG(this, (i, a, o, r) => uG(this, i, a, o, r)), this.domObserver.start(), N3(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Vp(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(AC), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let i in this._props)
      t[i] = this._props[i];
    t.state = this.state;
    for (let i in e)
      t[i] = e[i];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var i;
    let a = this.state, o = !1, r = !1;
    e.storedMarks && this.composing && (cj(this), r = !0), this.state = e;
    let s = a.plugins != e.plugins || this._props.plugins != t.plugins;
    if (s || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let y = OC(this);
      fG(y, this.nodeViews) && (this.nodeViews = y, o = !0);
    }
    (s || t.handleDOMEvents != this._props.handleDOMEvents) && Vp(this), this.editable = NC(this), MC(this);
    let l = Jf(this), h = DC(this), d = a.plugins != e.plugins && !a.doc.eq(e.doc) ? "reset" : e.scrollToSelection > a.scrollToSelection ? "to selection" : "preserve", f = o || !this.docView.matchesNode(e.doc, h, l);
    (f || !e.selection.eq(a.selection)) && (r = !0);
    let p = d == "preserve" && r && this.dom.style.overflowAnchor == null && QX(this);
    if (r) {
      this.domObserver.stop();
      let y = f && (ei || jn) && !this.composing && !a.selection.empty && !e.selection.empty && gG(a.selection, e.selection);
      if (f) {
        let m = jn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = G3(this)), (o || !this.docView.update(e.doc, h, l, this)) && (this.docView.updateOuterDeco(h), this.docView.destroy(), this.docView = cC(e.doc, h, l, this.dom, this)), m && !this.trackWrites && (y = !0);
      }
      y || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && y3(this)) ? Va(this, y) : (V_(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(a), !((i = this.dragging) === null || i === void 0) && i.node && !a.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, a), d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : p && KX(p);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof Ce) {
      let t = this.docView.domAfterPos(this.state.selection.from);
      t.nodeType == 1 && aC(this, t.getBoundingClientRect(), e);
    } else
      aC(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let i = this.directPlugins[t];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let i = this.state.plugins[t];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let i = this.pluginViews[t];
        i.update && i.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let i = e.node, a = -1;
    if (this.state.doc.nodeAt(i.from) == i.node)
      a = i.from;
    else {
      let o = i.from + (this.state.doc.content.size - t.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == i.node && (a = o);
    }
    this.dragging = new dj(e.slice, e.move, a < 0 ? void 0 : Ce.create(this.state.doc, a));
  }
  someProp(e, t) {
    let i = this._props && this._props[e], a;
    if (i != null && (a = t ? t(i) : i))
      return a;
    for (let r = 0; r < this.directPlugins.length; r++) {
      let s = this.directPlugins[r].props[e];
      if (s != null && (a = t ? t(s) : s))
        return a;
    }
    let o = this.state.plugins;
    if (o)
      for (let r = 0; r < o.length; r++) {
        let s = o[r].props[e];
        if (s != null && (a = t ? t(s) : s))
          return a;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ei) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && zX(this.dom), Va(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return e3(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return H_(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesâ€”for example when interpreting an event
  targetâ€”you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, i = -1) {
    let a = this.docView.posFromDOM(e, t, i);
    if (a == null)
      throw new RangeError("DOM position not inside the editor");
    return a;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return o3(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return Sl(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return Sl(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (O3(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Jf(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, PX());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return Y3(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let t = this._props.dispatchTransaction;
    t ? t.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Rn && this.root.nodeType === 11 && ZX(this.dom.ownerDocument) == this.dom && iG(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function DC(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let i in t)
        i == "class" ? e.class += " " + t[i] : i == "style" ? e.style = (e.style ? e.style + ";" : "") + t[i] : !e[i] && i != "contenteditable" && i != "nodeName" && (e[i] = String(t[i]));
  }), e.translate || (e.translate = "no"), [Pi.node(0, n.state.doc.content.size, e)];
}
function MC(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: Pi.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function NC(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function gG(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function OC(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(i) {
    for (let a in i)
      Object.prototype.hasOwnProperty.call(e, a) || (e[a] = i[a]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function fG(n, e) {
  let t = 0, i = 0;
  for (let a in n) {
    if (n[a] != e[a])
      return !0;
    t++;
  }
  for (let a in e)
    i++;
  return t != i;
}
function AC(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Xo = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Qh = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, pG = typeof navigator < "u" && /Mac/.test(navigator.platform), mG = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var wn = 0; wn < 10; wn++) Xo[48 + wn] = Xo[96 + wn] = String(wn);
for (var wn = 1; wn <= 24; wn++) Xo[wn + 111] = "F" + wn;
for (var wn = 65; wn <= 90; wn++)
  Xo[wn] = String.fromCharCode(wn + 32), Qh[wn] = String.fromCharCode(wn);
for (var Bf in Xo) Qh.hasOwnProperty(Bf) || (Qh[Bf] = Xo[Bf]);
function yG(n) {
  var e = pG && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || mG && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? Qh : Xo)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
const bG = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function wG(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let i, a, o, r;
  for (let s = 0; s < e.length - 1; s++) {
    let l = e[s];
    if (/^(cmd|meta|m)$/i.test(l))
      r = !0;
    else if (/^a(lt)?$/i.test(l))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      a = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      bG ? r = !0 : a = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return i && (t = "Alt-" + t), a && (t = "Ctrl-" + t), r && (t = "Meta-" + t), o && (t = "Shift-" + t), t;
}
function vG(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[wG(t)] = n[t];
  return e;
}
function Hf(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function CG(n) {
  return new ii({ props: { handleKeyDown: yj(n) } });
}
function yj(n) {
  let e = vG(n);
  return function(t, i) {
    let a = yG(i), o, r = e[Hf(a, i)];
    if (r && r(t.state, t.dispatch, t))
      return !0;
    if (a.length == 1 && a != " ") {
      if (i.shiftKey) {
        let s = e[Hf(a, i, !1)];
        if (s && s(t.state, t.dispatch, t))
          return !0;
      }
      if ((i.shiftKey || i.altKey || i.metaKey || a.charCodeAt(0) > 127) && (o = Xo[i.keyCode]) && o != a) {
        let s = e[Hf(o, i)];
        if (s && s(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const SG = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function bj(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const kG = (n, e, t) => {
  let i = bj(n, t);
  if (!i)
    return !1;
  let a = gy(i);
  if (!a) {
    let r = i.blockRange(), s = r && iu(r);
    return s == null ? !1 : (e && e(n.tr.lift(r, s).scrollIntoView()), !0);
  }
  let o = a.nodeBefore;
  if (Sj(n, a, e, -1))
    return !0;
  if (i.parent.content.size == 0 && (Bs(o, "end") || Ce.isSelectable(o)))
    for (let r = i.depth; ; r--) {
      let s = kd(n.doc, i.before(r), i.after(r), ue.empty);
      if (s && s.slice.size < s.to - s.from) {
        if (e) {
          let l = n.tr.step(s);
          l.setSelection(Bs(o, "end") ? Pe.findFrom(l.doc.resolve(l.mapping.map(a.pos, -1)), -1) : Ce.create(l.doc, a.pos - o.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (r == 1 || i.node(r - 1).childCount > 1)
        break;
    }
  return o.isAtom && a.depth == i.depth - 1 ? (e && e(n.tr.delete(a.pos - o.nodeSize, a.pos).scrollIntoView()), !0) : !1;
}, _G = (n, e, t) => {
  let i = bj(n, t);
  if (!i)
    return !1;
  let a = gy(i);
  return a ? wj(n, a, e) : !1;
}, jG = (n, e, t) => {
  let i = vj(n, t);
  if (!i)
    return !1;
  let a = fy(i);
  return a ? wj(n, a, e) : !1;
};
function wj(n, e, t) {
  let i = e.nodeBefore, a = i, o = e.pos - 1;
  for (; !a.isTextblock; o--) {
    if (a.type.spec.isolating)
      return !1;
    let d = a.lastChild;
    if (!d)
      return !1;
    a = d;
  }
  let r = e.nodeAfter, s = r, l = e.pos + 1;
  for (; !s.isTextblock; l++) {
    if (s.type.spec.isolating)
      return !1;
    let d = s.firstChild;
    if (!d)
      return !1;
    s = d;
  }
  let h = kd(n.doc, o, l, ue.empty);
  if (!h || h.from != o || h instanceof on && h.slice.size >= l - o)
    return !1;
  if (t) {
    let d = n.tr.step(h);
    d.setSelection(Me.create(d.doc, o)), t(d.scrollIntoView());
  }
  return !0;
}
function Bs(n, e, t = !1) {
  for (let i = n; i; i = e == "start" ? i.firstChild : i.lastChild) {
    if (i.isTextblock)
      return !0;
    if (t && i.childCount != 1)
      return !1;
  }
  return !1;
}
const TG = (n, e, t) => {
  let { $head: i, empty: a } = n.selection, o = i;
  if (!a)
    return !1;
  if (i.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : i.parentOffset > 0)
      return !1;
    o = gy(i);
  }
  let r = o && o.nodeBefore;
  return !r || !Ce.isSelectable(r) ? !1 : (e && e(n.tr.setSelection(Ce.create(n.doc, o.pos - r.nodeSize)).scrollIntoView()), !0);
};
function gy(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function vj(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const LG = (n, e, t) => {
  let i = vj(n, t);
  if (!i)
    return !1;
  let a = fy(i);
  if (!a)
    return !1;
  let o = a.nodeAfter;
  if (Sj(n, a, e, 1))
    return !0;
  if (i.parent.content.size == 0 && (Bs(o, "start") || Ce.isSelectable(o))) {
    let r = kd(n.doc, i.before(), i.after(), ue.empty);
    if (r && r.slice.size < r.to - r.from) {
      if (e) {
        let s = n.tr.step(r);
        s.setSelection(Bs(o, "start") ? Pe.findFrom(s.doc.resolve(s.mapping.map(a.pos)), 1) : Ce.create(s.doc, s.mapping.map(a.pos))), e(s.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && a.depth == i.depth - 1 ? (e && e(n.tr.delete(a.pos, a.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, xG = (n, e, t) => {
  let { $head: i, empty: a } = n.selection, o = i;
  if (!a)
    return !1;
  if (i.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : i.parentOffset < i.parent.content.size)
      return !1;
    o = fy(i);
  }
  let r = o && o.nodeAfter;
  return !r || !Ce.isSelectable(r) ? !1 : (e && e(n.tr.setSelection(Ce.create(n.doc, o.pos)).scrollIntoView()), !0);
};
function fy(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const EG = (n, e) => {
  let t = n.selection, i = t instanceof Ce, a;
  if (i) {
    if (t.node.isTextblock || !zo(n.doc, t.from))
      return !1;
    a = t.from;
  } else if (a = Sd(n.doc, t.from, -1), a == null)
    return !1;
  if (e) {
    let o = n.tr.join(a);
    i && o.setSelection(Ce.create(o.doc, a - n.doc.resolve(a).nodeBefore.nodeSize)), e(o.scrollIntoView());
  }
  return !0;
}, DG = (n, e) => {
  let t = n.selection, i;
  if (t instanceof Ce) {
    if (t.node.isTextblock || !zo(n.doc, t.to))
      return !1;
    i = t.to;
  } else if (i = Sd(n.doc, t.to, 1), i == null)
    return !1;
  return e && e(n.tr.join(i).scrollIntoView()), !0;
}, MG = (n, e) => {
  let { $from: t, $to: i } = n.selection, a = t.blockRange(i), o = a && iu(a);
  return o == null ? !1 : (e && e(n.tr.lift(a, o).scrollIntoView()), !0);
}, NG = (n, e) => {
  let { $head: t, $anchor: i } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(i) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function Cj(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const OG = (n, e) => {
  let { $head: t, $anchor: i } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(i))
    return !1;
  let a = t.node(-1), o = t.indexAfter(-1), r = Cj(a.contentMatchAt(o));
  if (!r || !a.canReplaceWith(o, o, r))
    return !1;
  if (e) {
    let s = t.after(), l = n.tr.replaceWith(s, s, r.createAndFill());
    l.setSelection(Pe.near(l.doc.resolve(s), 1)), e(l.scrollIntoView());
  }
  return !0;
}, AG = (n, e) => {
  let t = n.selection, { $from: i, $to: a } = t;
  if (t instanceof ta || i.parent.inlineContent || a.parent.inlineContent)
    return !1;
  let o = Cj(a.parent.contentMatchAt(a.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (e) {
    let r = (!i.parentOffset && a.index() < a.parent.childCount ? i : a).pos, s = n.tr.insert(r, o.createAndFill());
    s.setSelection(Me.create(s.doc, r + 1)), e(s.scrollIntoView());
  }
  return !0;
}, YG = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let o = t.before();
    if (As(n.doc, o))
      return e && e(n.tr.split(o).scrollIntoView()), !0;
  }
  let i = t.blockRange(), a = i && iu(i);
  return a == null ? !1 : (e && e(n.tr.lift(i, a).scrollIntoView()), !0);
}, PG = (n, e) => {
  let { $from: t, to: i } = n.selection, a, o = t.sharedDepth(i);
  return o == 0 ? !1 : (a = t.before(o), e && e(n.tr.setSelection(Ce.create(n.doc, a))), !0);
};
function RG(n, e, t) {
  let i = e.nodeBefore, a = e.nodeAfter, o = e.index();
  return !i || !a || !i.type.compatibleContent(a.type) ? !1 : !i.content.size && e.parent.canReplace(o - 1, o) ? (t && t(n.tr.delete(e.pos - i.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(o, o + 1) || !(a.isTextblock || zo(n.doc, e.pos)) ? !1 : (t && t(n.tr.clearIncompatible(e.pos, i.type, i.contentMatchAt(i.childCount)).join(e.pos).scrollIntoView()), !0);
}
function Sj(n, e, t, i) {
  let a = e.nodeBefore, o = e.nodeAfter, r, s, l = a.type.spec.isolating || o.type.spec.isolating;
  if (!l && RG(n, e, t))
    return !0;
  let h = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (h && (r = (s = a.contentMatchAt(a.childCount)).findWrapping(o.type)) && s.matchType(r[0] || o.type).validEnd) {
    if (t) {
      let y = e.pos + o.nodeSize, m = U.empty;
      for (let _ = r.length - 1; _ >= 0; _--)
        m = U.from(r[_].create(null, m));
      m = U.from(a.copy(m));
      let w = n.tr.step(new sn(e.pos - 1, y, e.pos, y, new ue(m, 1, 0), r.length, !0)), v = y + 2 * r.length;
      zo(w.doc, v) && w.join(v), t(w.scrollIntoView());
    }
    return !0;
  }
  let d = o.type.spec.isolating || i > 0 && l ? null : Pe.findFrom(e, 1), f = d && d.$from.blockRange(d.$to), p = f && iu(f);
  if (p != null && p >= e.depth)
    return t && t(n.tr.lift(f, p).scrollIntoView()), !0;
  if (h && Bs(o, "start", !0) && Bs(a, "end")) {
    let y = a, m = [];
    for (; m.push(y), !y.isTextblock; )
      y = y.lastChild;
    let w = o, v = 1;
    for (; !w.isTextblock; w = w.firstChild)
      v++;
    if (y.canReplace(y.childCount, y.childCount, w.content)) {
      if (t) {
        let _ = U.empty;
        for (let T = m.length - 1; T >= 0; T--)
          _ = U.from(m[T].copy(_));
        let L = n.tr.step(new sn(e.pos - m.length, e.pos + o.nodeSize, e.pos + v, e.pos + o.nodeSize - v, new ue(_, m.length, 0), 0, !0));
        t(L.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function kj(n) {
  return function(e, t) {
    let i = e.selection, a = n < 0 ? i.$from : i.$to, o = a.depth;
    for (; a.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return a.node(o).isTextblock ? (t && t(e.tr.setSelection(Me.create(e.doc, n < 0 ? a.start(o) : a.end(o)))), !0) : !1;
  };
}
const FG = kj(-1), IG = kj(1);
function JG(n, e = null) {
  return function(t, i) {
    let { $from: a, $to: o } = t.selection, r = a.blockRange(o), s = r && iy(r, n, e);
    return s ? (i && i(t.tr.wrap(r, s).scrollIntoView()), !0) : !1;
  };
}
function YC(n, e = null) {
  return function(t, i) {
    let a = !1;
    for (let o = 0; o < t.selection.ranges.length && !a; o++) {
      let { $from: { pos: r }, $to: { pos: s } } = t.selection.ranges[o];
      t.doc.nodesBetween(r, s, (l, h) => {
        if (a)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(n, e)))
          if (l.type == n)
            a = !0;
          else {
            let d = t.doc.resolve(h), f = d.index();
            a = d.parent.canReplaceWith(f, f + 1, n);
          }
      });
    }
    if (!a)
      return !1;
    if (i) {
      let o = t.tr;
      for (let r = 0; r < t.selection.ranges.length; r++) {
        let { $from: { pos: s }, $to: { pos: l } } = t.selection.ranges[r];
        o.setBlockType(s, l, n, e);
      }
      i(o.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function ZG(n, e = null) {
  return function(t, i) {
    let { $from: a, $to: o } = t.selection, r = a.blockRange(o), s = !1, l = r;
    if (!r)
      return !1;
    if (r.depth >= 2 && a.node(r.depth - 1).type.compatibleContent(n) && r.startIndex == 0) {
      if (a.index(r.depth - 1) == 0)
        return !1;
      let d = t.doc.resolve(r.start - 2);
      l = new Ih(d, d, r.depth), r.endIndex < r.parent.childCount && (r = new Ih(a, t.doc.resolve(o.end(r.depth)), r.depth)), s = !0;
    }
    let h = iy(l, n, e, r);
    return h ? (i && i(BG(t.tr, r, h, s, n).scrollIntoView()), !0) : !1;
  };
}
function BG(n, e, t, i, a) {
  let o = U.empty;
  for (let d = t.length - 1; d >= 0; d--)
    o = U.from(t[d].type.create(t[d].attrs, o));
  n.step(new sn(e.start - (i ? 2 : 0), e.end, e.start, e.end, new ue(o, 0, 0), t.length, !0));
  let r = 0;
  for (let d = 0; d < t.length; d++)
    t[d].type == a && (r = d + 1);
  let s = t.length - r, l = e.start + t.length - (i ? 2 : 0), h = e.parent;
  for (let d = e.startIndex, f = e.endIndex, p = !0; d < f; d++, p = !1)
    !p && As(n.doc, l, s) && (n.split(l, s), l += 2 * s), l += h.child(d).nodeSize;
  return n;
}
function HG(n) {
  return function(e, t) {
    let { $from: i, $to: a } = e.selection, o = i.blockRange(a, (r) => r.childCount > 0 && r.firstChild.type == n);
    return o ? t ? i.node(o.depth - 1).type == n ? XG(e, t, n, o) : GG(e, t, o) : !0 : !1;
  };
}
function XG(n, e, t, i) {
  let a = n.tr, o = i.end, r = i.$to.end(i.depth);
  o < r && (a.step(new sn(o - 1, r, o, r, new ue(U.from(t.create(null, i.parent.copy())), 1, 0), 1, !0)), i = new Ih(a.doc.resolve(i.$from.pos), a.doc.resolve(r), i.depth));
  const s = iu(i);
  if (s == null)
    return !1;
  a.lift(i, s);
  let l = a.mapping.map(o, -1) - 1;
  return zo(a.doc, l) && a.join(l), e(a.scrollIntoView()), !0;
}
function GG(n, e, t) {
  let i = n.tr, a = t.parent;
  for (let y = t.end, m = t.endIndex - 1, w = t.startIndex; m > w; m--)
    y -= a.child(m).nodeSize, i.delete(y - 1, y + 1);
  let o = i.doc.resolve(t.start), r = o.nodeAfter;
  if (i.mapping.map(t.end) != t.start + o.nodeAfter.nodeSize)
    return !1;
  let s = t.startIndex == 0, l = t.endIndex == a.childCount, h = o.node(-1), d = o.index(-1);
  if (!h.canReplace(d + (s ? 0 : 1), d + 1, r.content.append(l ? U.empty : U.from(a))))
    return !1;
  let f = o.pos, p = f + r.nodeSize;
  return i.step(new sn(f - (s ? 1 : 0), p + (l ? 1 : 0), f + 1, p - 1, new ue((s ? U.empty : U.from(a.copy(U.empty))).append(l ? U.empty : U.from(a.copy(U.empty))), s ? 0 : 1, l ? 0 : 1), s ? 0 : 1)), e(i.scrollIntoView()), !0;
}
function WG(n) {
  return function(e, t) {
    let { $from: i, $to: a } = e.selection, o = i.blockRange(a, (h) => h.childCount > 0 && h.firstChild.type == n);
    if (!o)
      return !1;
    let r = o.startIndex;
    if (r == 0)
      return !1;
    let s = o.parent, l = s.child(r - 1);
    if (l.type != n)
      return !1;
    if (t) {
      let h = l.lastChild && l.lastChild.type == s.type, d = U.from(h ? n.create() : null), f = new ue(U.from(n.create(null, U.from(s.type.create(null, d)))), h ? 3 : 1, 0), p = o.start, y = o.end;
      t(e.tr.step(new sn(p - (h ? 3 : 1), y, p, y, f, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function xd(n) {
  const { state: e, transaction: t } = n;
  let { selection: i } = t, { doc: a } = t, { storedMarks: o } = t;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return o;
    },
    get selection() {
      return i;
    },
    get doc() {
      return a;
    },
    get tr() {
      return i = t.selection, a = t.doc, o = t.storedMarks, t;
    }
  };
}
class Ed {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: t, state: i } = this, { view: a } = t, { tr: o } = i, r = this.buildProps(o);
    return Object.fromEntries(Object.entries(e).map(([s, l]) => [s, (...d) => {
      const f = l(...d)(r);
      return !o.getMeta("preventDispatch") && !this.hasCustomState && a.dispatch(o), f;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, t = !0) {
    const { rawCommands: i, editor: a, state: o } = this, { view: r } = a, s = [], l = !!e, h = e || o.tr, d = () => (!l && t && !h.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(h), s.every((p) => p === !0)), f = {
      ...Object.fromEntries(Object.entries(i).map(([p, y]) => [p, (...w) => {
        const v = this.buildProps(h, t), _ = y(...w)(v);
        return s.push(_), f;
      }])),
      run: d
    };
    return f;
  }
  createCan(e) {
    const { rawCommands: t, state: i } = this, a = !1, o = e || i.tr, r = this.buildProps(o, a);
    return {
      ...Object.fromEntries(Object.entries(t).map(([l, h]) => [l, (...d) => h(...d)({ ...r, dispatch: void 0 })])),
      chain: () => this.createChain(o, a)
    };
  }
  buildProps(e, t = !0) {
    const { rawCommands: i, editor: a, state: o } = this, { view: r } = a, s = {
      tr: e,
      editor: a,
      view: r,
      state: xd({
        state: o,
        transaction: e
      }),
      dispatch: t ? () => {
      } : void 0,
      chain: () => this.createChain(e, t),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(i).map(([l, h]) => [l, (...d) => h(...d)(s)]));
      }
    };
    return s;
  }
}
class QG {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const i = this.callbacks[e];
    return i && i.forEach((a) => a.apply(this, t)), this;
  }
  off(e, t) {
    const i = this.callbacks[e];
    return i && (t ? this.callbacks[e] = i.filter((a) => a !== t) : delete this.callbacks[e]), this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function fe(n, e, t) {
  return n.config[e] === void 0 && n.parent ? fe(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({
    ...t,
    parent: n.parent ? fe(n.parent, e, t) : null
  }) : n.config[e];
}
function Dd(n) {
  const e = n.filter((a) => a.type === "extension"), t = n.filter((a) => a.type === "node"), i = n.filter((a) => a.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: t,
    markExtensions: i
  };
}
function _j(n) {
  const e = [], { nodeExtensions: t, markExtensions: i } = Dd(n), a = [...t, ...i], o = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return n.forEach((r) => {
    const s = {
      name: r.name,
      options: r.options,
      storage: r.storage,
      extensions: a
    }, l = fe(r, "addGlobalAttributes", s);
    if (!l)
      return;
    l().forEach((d) => {
      d.types.forEach((f) => {
        Object.entries(d.attributes).forEach(([p, y]) => {
          e.push({
            type: f,
            name: p,
            attribute: {
              ...o,
              ...y
            }
          });
        });
      });
    });
  }), a.forEach((r) => {
    const s = {
      name: r.name,
      options: r.options,
      storage: r.storage
    }, l = fe(r, "addAttributes", s);
    if (!l)
      return;
    const h = l();
    Object.entries(h).forEach(([d, f]) => {
      const p = {
        ...o,
        ...f
      };
      typeof (p == null ? void 0 : p.default) == "function" && (p.default = p.default()), p != null && p.isRequired && (p == null ? void 0 : p.default) === void 0 && delete p.default, e.push({
        type: r.name,
        name: d,
        attribute: p
      });
    });
  }), e;
}
function cn(n, e) {
  if (typeof n == "string") {
    if (!e.nodes[n])
      throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`);
    return e.nodes[n];
  }
  return n;
}
function Ut(...n) {
  return n.filter((e) => !!e).reduce((e, t) => {
    const i = { ...e };
    return Object.entries(t).forEach(([a, o]) => {
      if (!i[a]) {
        i[a] = o;
        return;
      }
      if (a === "class") {
        const s = o ? o.split(" ") : [], l = i[a] ? i[a].split(" ") : [], h = s.filter((d) => !l.includes(d));
        i[a] = [...l, ...h].join(" ");
      } else a === "style" ? i[a] = [i[a], o].join("; ") : i[a] = o;
    }), i;
  }, {});
}
function Up(n, e) {
  return e.filter((t) => t.attribute.rendered).map((t) => t.attribute.renderHTML ? t.attribute.renderHTML(n.attrs) || {} : {
    [t.name]: n.attrs[t.name]
  }).reduce((t, i) => Ut(t, i), {});
}
function jj(n) {
  return typeof n == "function";
}
function Ze(n, e = void 0, ...t) {
  return jj(n) ? e ? n.bind(e)(...t) : n(...t) : n;
}
function KG(n = {}) {
  return Object.keys(n).length === 0 && n.constructor === Object;
}
function zG(n) {
  return typeof n != "string" ? n : n.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n) : n === "true" ? !0 : n === "false" ? !1 : n;
}
function PC(n, e) {
  return "style" in n ? n : {
    ...n,
    getAttrs: (t) => {
      const i = n.getAttrs ? n.getAttrs(t) : n.attrs;
      if (i === !1)
        return !1;
      const a = e.reduce((o, r) => {
        const s = r.attribute.parseHTML ? r.attribute.parseHTML(t) : zG(t.getAttribute(r.name));
        return s == null ? o : {
          ...o,
          [r.name]: s
        };
      }, {});
      return { ...i, ...a };
    }
  };
}
function RC(n) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(n).filter(([e, t]) => e === "attrs" && KG(t) ? !1 : t != null)
  );
}
function $G(n, e) {
  var t;
  const i = _j(n), { nodeExtensions: a, markExtensions: o } = Dd(n), r = (t = a.find((h) => fe(h, "topNode"))) === null || t === void 0 ? void 0 : t.name, s = Object.fromEntries(a.map((h) => {
    const d = i.filter((_) => _.type === h.name), f = {
      name: h.name,
      options: h.options,
      storage: h.storage,
      editor: e
    }, p = n.reduce((_, L) => {
      const T = fe(L, "extendNodeSchema", f);
      return {
        ..._,
        ...T ? T(h) : {}
      };
    }, {}), y = RC({
      ...p,
      content: Ze(fe(h, "content", f)),
      marks: Ze(fe(h, "marks", f)),
      group: Ze(fe(h, "group", f)),
      inline: Ze(fe(h, "inline", f)),
      atom: Ze(fe(h, "atom", f)),
      selectable: Ze(fe(h, "selectable", f)),
      draggable: Ze(fe(h, "draggable", f)),
      code: Ze(fe(h, "code", f)),
      whitespace: Ze(fe(h, "whitespace", f)),
      defining: Ze(fe(h, "defining", f)),
      isolating: Ze(fe(h, "isolating", f)),
      attrs: Object.fromEntries(d.map((_) => {
        var L;
        return [_.name, { default: (L = _ == null ? void 0 : _.attribute) === null || L === void 0 ? void 0 : L.default }];
      }))
    }), m = Ze(fe(h, "parseHTML", f));
    m && (y.parseDOM = m.map((_) => PC(_, d)));
    const w = fe(h, "renderHTML", f);
    w && (y.toDOM = (_) => w({
      node: _,
      HTMLAttributes: Up(_, d)
    }));
    const v = fe(h, "renderText", f);
    return v && (y.toText = v), [h.name, y];
  })), l = Object.fromEntries(o.map((h) => {
    const d = i.filter((v) => v.type === h.name), f = {
      name: h.name,
      options: h.options,
      storage: h.storage,
      editor: e
    }, p = n.reduce((v, _) => {
      const L = fe(_, "extendMarkSchema", f);
      return {
        ...v,
        ...L ? L(h) : {}
      };
    }, {}), y = RC({
      ...p,
      inclusive: Ze(fe(h, "inclusive", f)),
      excludes: Ze(fe(h, "excludes", f)),
      group: Ze(fe(h, "group", f)),
      spanning: Ze(fe(h, "spanning", f)),
      code: Ze(fe(h, "code", f)),
      attrs: Object.fromEntries(d.map((v) => {
        var _;
        return [v.name, { default: (_ = v == null ? void 0 : v.attribute) === null || _ === void 0 ? void 0 : _.default }];
      }))
    }), m = Ze(fe(h, "parseHTML", f));
    m && (y.parseDOM = m.map((v) => PC(v, d)));
    const w = fe(h, "renderHTML", f);
    return w && (y.toDOM = (v) => w({
      mark: v,
      HTMLAttributes: Up(v, d)
    })), [h.name, y];
  }));
  return new v_({
    topNode: r,
    nodes: s,
    marks: l
  });
}
function Xf(n, e) {
  return e.nodes[n] || e.marks[n] || null;
}
function FC(n, e) {
  return Array.isArray(e) ? e.some((t) => (typeof t == "string" ? t : t.name) === n.name) : e;
}
const VG = (n, e = 500) => {
  let t = "";
  const i = n.parentOffset;
  return n.parent.nodesBetween(Math.max(0, i - e), i, (a, o, r, s) => {
    var l, h;
    const d = ((h = (l = a.type.spec).toText) === null || h === void 0 ? void 0 : h.call(l, {
      node: a,
      pos: o,
      parent: r,
      index: s
    })) || a.textContent || "%leaf%";
    t += a.isAtom && !a.isText ? d : d.slice(0, Math.max(0, i - o));
  }), t;
};
function py(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
class Md {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const UG = (n, e) => {
  if (py(e))
    return e.exec(n);
  const t = e(n);
  if (!t)
    return null;
  const i = [t.text];
  return i.index = t.index, i.input = n, i.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), i.push(t.replaceWith)), i;
};
function ih(n) {
  var e;
  const { editor: t, from: i, to: a, text: o, rules: r, plugin: s } = n, { view: l } = t;
  if (l.composing)
    return !1;
  const h = l.state.doc.resolve(i);
  if (
    // check for code node
    h.parent.type.spec.code || !((e = h.nodeBefore || h.nodeAfter) === null || e === void 0) && e.marks.find((p) => p.type.spec.code)
  )
    return !1;
  let d = !1;
  const f = VG(h) + o;
  return r.forEach((p) => {
    if (d)
      return;
    const y = UG(f, p.find);
    if (!y)
      return;
    const m = l.state.tr, w = xd({
      state: l.state,
      transaction: m
    }), v = {
      from: i - (y[0].length - o.length),
      to: a
    }, { commands: _, chain: L, can: T } = new Ed({
      editor: t,
      state: w
    });
    p.handler({
      state: w,
      range: v,
      match: y,
      commands: _,
      chain: L,
      can: T
    }) === null || !m.steps.length || (m.setMeta(s, {
      transform: m,
      from: i,
      to: a,
      text: o
    }), l.dispatch(m), d = !0);
  }), d;
}
function qG(n) {
  const { editor: e, rules: t } = n, i = new ii({
    state: {
      init() {
        return null;
      },
      apply(a, o) {
        const r = a.getMeta(i);
        if (r)
          return r;
        const s = a.getMeta("applyInputRules");
        return !!s && setTimeout(() => {
          const { from: h, text: d } = s, f = h + d.length;
          ih({
            editor: e,
            from: h,
            to: f,
            text: d,
            rules: t,
            plugin: i
          });
        }), a.selectionSet || a.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(a, o, r, s) {
        return ih({
          editor: e,
          from: o,
          to: r,
          text: s,
          rules: t,
          plugin: i
        });
      },
      handleDOMEvents: {
        compositionend: (a) => (setTimeout(() => {
          const { $cursor: o } = a.state.selection;
          o && ih({
            editor: e,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: t,
            plugin: i
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(a, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: r } = a.state.selection;
        return r ? ih({
          editor: e,
          from: r.pos,
          to: r.pos,
          text: `
`,
          rules: t,
          plugin: i
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return i;
}
function eW(n) {
  return typeof n == "number";
}
class tW {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const nW = (n, e, t) => {
  if (py(e))
    return [...n.matchAll(e)];
  const i = e(n, t);
  return i ? i.map((a) => {
    const o = [a.text];
    return o.index = a.index, o.input = n, o.data = a.data, a.replaceWith && (a.text.includes(a.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(a.replaceWith)), o;
  }) : [];
};
function iW(n) {
  const { editor: e, state: t, from: i, to: a, rule: o, pasteEvent: r, dropEvent: s } = n, { commands: l, chain: h, can: d } = new Ed({
    editor: e,
    state: t
  }), f = [];
  return t.doc.nodesBetween(i, a, (y, m) => {
    if (!y.isTextblock || y.type.spec.code)
      return;
    const w = Math.max(i, m), v = Math.min(a, m + y.content.size), _ = y.textBetween(w - m, v - m, void 0, "ï¿¼");
    nW(_, o.find, r).forEach((T) => {
      if (T.index === void 0)
        return;
      const S = w + T.index + 1, A = S + T[0].length, x = {
        from: t.tr.mapping.map(S),
        to: t.tr.mapping.map(A)
      }, M = o.handler({
        state: t,
        range: x,
        match: T,
        commands: l,
        chain: h,
        can: d,
        pasteEvent: r,
        dropEvent: s
      });
      f.push(M);
    });
  }), f.every((y) => y !== null);
}
const aW = (n) => {
  var e;
  const t = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = t.clipboardData) === null || e === void 0 || e.setData("text/html", n), t;
};
function oW(n) {
  const { editor: e, rules: t } = n;
  let i = null, a = !1, o = !1, r = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, s = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  const l = ({ state: d, from: f, to: p, rule: y, pasteEvt: m }) => {
    const w = d.tr, v = xd({
      state: d,
      transaction: w
    });
    if (!(!iW({
      editor: e,
      state: v,
      from: Math.max(f - 1, 0),
      to: p.b - 1,
      rule: y,
      pasteEvent: m,
      dropEvent: s
    }) || !w.steps.length))
      return s = typeof DragEvent < "u" ? new DragEvent("drop") : null, r = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, w;
  };
  return t.map((d) => new ii({
    // we register a global drag handler to track the current drag source element
    view(f) {
      const p = (y) => {
        var m;
        i = !((m = f.dom.parentElement) === null || m === void 0) && m.contains(y.target) ? f.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", p), {
        destroy() {
          window.removeEventListener("dragstart", p);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (f, p) => (o = i === f.dom.parentElement, s = p, !1),
        paste: (f, p) => {
          var y;
          const m = (y = p.clipboardData) === null || y === void 0 ? void 0 : y.getData("text/html");
          return r = p, a = !!(m != null && m.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (f, p, y) => {
      const m = f[0], w = m.getMeta("uiEvent") === "paste" && !a, v = m.getMeta("uiEvent") === "drop" && !o, _ = m.getMeta("applyPasteRules"), L = !!_;
      if (!w && !v && !L)
        return;
      if (L) {
        const { from: A, text: x } = _, M = A + x.length, P = aW(x);
        return l({
          rule: d,
          state: y,
          from: A,
          to: { b: M },
          pasteEvt: P
        });
      }
      const T = p.doc.content.findDiffStart(y.doc.content), S = p.doc.content.findDiffEnd(y.doc.content);
      if (!(!eW(T) || !S || T === S.b))
        return l({
          rule: d,
          state: y,
          from: T,
          to: S,
          pasteEvt: r
        });
    }
  }));
}
function rW(n) {
  const e = n.filter((t, i) => n.indexOf(t) !== i);
  return Array.from(new Set(e));
}
class Ts {
  constructor(e, t) {
    this.splittableMarks = [], this.editor = t, this.extensions = Ts.resolve(e), this.schema = $G(this.extensions, t), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const t = Ts.sort(Ts.flatten(e)), i = rW(t.map((a) => a.name));
    return i.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${i.map((a) => `'${a}'`).join(", ")}]. This can lead to issues.`), t;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((t) => {
      const i = {
        name: t.name,
        options: t.options,
        storage: t.storage
      }, a = fe(t, "addExtensions", i);
      return a ? [t, ...this.flatten(a())] : t;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((i, a) => {
      const o = fe(i, "priority") || 100, r = fe(a, "priority") || 100;
      return o > r ? -1 : o < r ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, t) => {
      const i = {
        name: t.name,
        options: t.options,
        storage: t.storage,
        editor: this.editor,
        type: Xf(t.name, this.schema)
      }, a = fe(t, "addCommands", i);
      return a ? {
        ...e,
        ...a()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, t = Ts.sort([...this.extensions].reverse()), i = [], a = [], o = t.map((r) => {
      const s = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: Xf(r.name, this.schema)
      }, l = [], h = fe(r, "addKeyboardShortcuts", s);
      let d = {};
      if (r.type === "mark" && fe(r, "exitable", s) && (d.ArrowRight = () => ja.handleExit({ editor: e, mark: r })), h) {
        const w = Object.fromEntries(Object.entries(h()).map(([v, _]) => [v, () => _({ editor: e })]));
        d = { ...d, ...w };
      }
      const f = CG(d);
      l.push(f);
      const p = fe(r, "addInputRules", s);
      FC(r, e.options.enableInputRules) && p && i.push(...p());
      const y = fe(r, "addPasteRules", s);
      FC(r, e.options.enablePasteRules) && y && a.push(...y());
      const m = fe(r, "addProseMirrorPlugins", s);
      if (m) {
        const w = m();
        l.push(...w);
      }
      return l;
    }).flat();
    return [
      qG({
        editor: e,
        rules: i
      }),
      ...oW({
        editor: e,
        rules: a
      }),
      ...o
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return _j(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: t } = Dd(this.extensions);
    return Object.fromEntries(t.filter((i) => !!fe(i, "addNodeView")).map((i) => {
      const a = this.attributes.filter((l) => l.type === i.name), o = {
        name: i.name,
        options: i.options,
        storage: i.storage,
        editor: e,
        type: cn(i.name, this.schema)
      }, r = fe(i, "addNodeView", o);
      if (!r)
        return [];
      const s = (l, h, d, f) => {
        const p = Up(l, a);
        return r()({
          editor: e,
          node: l,
          getPos: d,
          decorations: f,
          HTMLAttributes: p,
          extension: i
        });
      };
      return [i.name, s];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var t;
      this.editor.extensionStorage[e.name] = e.storage;
      const i = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: Xf(e.name, this.schema)
      };
      e.type === "mark" && (!((t = Ze(fe(e, "keepOnSplit", i))) !== null && t !== void 0) || t) && this.splittableMarks.push(e.name);
      const a = fe(e, "onBeforeCreate", i), o = fe(e, "onCreate", i), r = fe(e, "onUpdate", i), s = fe(e, "onSelectionUpdate", i), l = fe(e, "onTransaction", i), h = fe(e, "onFocus", i), d = fe(e, "onBlur", i), f = fe(e, "onDestroy", i);
      a && this.editor.on("beforeCreate", a), o && this.editor.on("create", o), r && this.editor.on("update", r), s && this.editor.on("selectionUpdate", s), l && this.editor.on("transaction", l), h && this.editor.on("focus", h), d && this.editor.on("blur", d), f && this.editor.on("destroy", f);
    });
  }
}
function sW(n) {
  return Object.prototype.toString.call(n).slice(8, -1);
}
function ah(n) {
  return sW(n) !== "Object" ? !1 : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype;
}
function Nd(n, e) {
  const t = { ...n };
  return ah(n) && ah(e) && Object.keys(e).forEach((i) => {
    ah(e[i]) && ah(n[i]) ? t[i] = Nd(n[i], e[i]) : t[i] = e[i];
  }), t;
}
class Jn {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ze(fe(this, "addOptions", {
      name: this.name
    }))), this.storage = Ze(fe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Jn(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => Nd(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new Jn({ ...this.config, ...e });
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Ze(fe(t, "addOptions", {
      name: t.name
    })), t.storage = Ze(fe(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
}
function Tj(n, e, t) {
  const { from: i, to: a } = e, { blockSeparator: o = `

`, textSerializers: r = {} } = t || {};
  let s = "";
  return n.nodesBetween(i, a, (l, h, d, f) => {
    var p;
    l.isBlock && h > i && (s += o);
    const y = r == null ? void 0 : r[l.type.name];
    if (y)
      return d && (s += y({
        node: l,
        pos: h,
        parent: d,
        index: f,
        range: e
      })), !1;
    l.isText && (s += (p = l == null ? void 0 : l.text) === null || p === void 0 ? void 0 : p.slice(Math.max(i, h) - h, a - h));
  }), s;
}
function Lj(n) {
  return Object.fromEntries(Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText]));
}
const uW = Jn.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new ii({
        key: new La("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: n } = this, { state: e, schema: t } = n, { doc: i, selection: a } = e, { ranges: o } = a, r = Math.min(...o.map((d) => d.$from.pos)), s = Math.max(...o.map((d) => d.$to.pos)), l = Lj(t);
            return Tj(i, { from: r, to: s }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), lW = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => {
  var t;
  n.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) === null || t === void 0 || t.removeAllRanges());
}), !0), cW = (n = !1) => ({ commands: e }) => e.setContent("", n), hW = () => ({ state: n, tr: e, dispatch: t }) => {
  const { selection: i } = e, { ranges: a } = i;
  return t && a.forEach(({ $from: o, $to: r }) => {
    n.doc.nodesBetween(o.pos, r.pos, (s, l) => {
      if (s.type.isText)
        return;
      const { doc: h, mapping: d } = e, f = h.resolve(d.map(l)), p = h.resolve(d.map(l + s.nodeSize)), y = f.blockRange(p);
      if (!y)
        return;
      const m = iu(y);
      if (s.type.isTextblock) {
        const { defaultType: w } = f.parent.contentMatchAt(f.index());
        e.setNodeMarkup(y.start, w);
      }
      (m || m === 0) && e.lift(y, m);
    });
  }), !0;
}, dW = (n) => (e) => n(e), gW = () => ({ state: n, dispatch: e }) => AG(n, e), fW = (n, e) => ({ editor: t, tr: i }) => {
  const { state: a } = t, o = a.doc.slice(n.from, n.to);
  i.deleteRange(n.from, n.to);
  const r = i.mapping.map(e);
  return i.insert(r, o.content), i.setSelection(new Me(i.doc.resolve(r - 1))), !0;
}, pW = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, i = t.$anchor.node();
  if (i.content.size > 0)
    return !1;
  const a = n.selection.$anchor;
  for (let o = a.depth; o > 0; o -= 1)
    if (a.node(o).type === i.type) {
      if (e) {
        const s = a.before(o), l = a.after(o);
        n.delete(s, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, mW = (n) => ({ tr: e, state: t, dispatch: i }) => {
  const a = cn(n, t.schema), o = e.selection.$anchor;
  for (let r = o.depth; r > 0; r -= 1)
    if (o.node(r).type === a) {
      if (i) {
        const l = o.before(r), h = o.after(r);
        e.delete(l, h).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, yW = (n) => ({ tr: e, dispatch: t }) => {
  const { from: i, to: a } = n;
  return t && e.delete(i, a), !0;
}, bW = () => ({ state: n, dispatch: e }) => SG(n, e), wW = () => ({ commands: n }) => n.keyboardShortcut("Enter"), vW = () => ({ state: n, dispatch: e }) => OG(n, e);
function Kh(n, e, t = { strict: !0 }) {
  const i = Object.keys(e);
  return i.length ? i.every((a) => t.strict ? e[a] === n[a] : py(e[a]) ? e[a].test(n[a]) : e[a] === n[a]) : !0;
}
function qp(n, e, t = {}) {
  return n.find((i) => i.type === e && Kh(i.attrs, t));
}
function CW(n, e, t = {}) {
  return !!qp(n, e, t);
}
function my(n, e, t = {}) {
  if (!n || !e)
    return;
  let i = n.parent.childAfter(n.parentOffset);
  if (n.parentOffset === i.offset && i.offset !== 0 && (i = n.parent.childBefore(n.parentOffset)), !i.node)
    return;
  const a = qp([...i.node.marks], e, t);
  if (!a)
    return;
  let o = i.index, r = n.start() + i.offset, s = o + 1, l = r + i.node.nodeSize;
  for (qp([...i.node.marks], e, t); o > 0 && a.isInSet(n.parent.child(o - 1).marks); )
    o -= 1, r -= n.parent.child(o).nodeSize;
  for (; s < n.parent.childCount && CW([...n.parent.child(s).marks], e, t); )
    l += n.parent.child(s).nodeSize, s += 1;
  return {
    from: r,
    to: l
  };
}
function Vo(n, e) {
  if (typeof n == "string") {
    if (!e.marks[n])
      throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`);
    return e.marks[n];
  }
  return n;
}
const SW = (n, e = {}) => ({ tr: t, state: i, dispatch: a }) => {
  const o = Vo(n, i.schema), { doc: r, selection: s } = t, { $from: l, from: h, to: d } = s;
  if (a) {
    const f = my(l, o, e);
    if (f && f.from <= h && f.to >= d) {
      const p = Me.create(r, f.from, f.to);
      t.setSelection(p);
    }
  }
  return !0;
}, kW = (n) => (e) => {
  const t = typeof n == "function" ? n(e) : n;
  for (let i = 0; i < t.length; i += 1)
    if (t[i](e))
      return !0;
  return !1;
};
function yy(n) {
  return n instanceof Me;
}
function $a(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function xj(n, e = null) {
  if (!e)
    return null;
  const t = Pe.atStart(n), i = Pe.atEnd(n);
  if (e === "start" || e === !0)
    return t;
  if (e === "end")
    return i;
  const a = t.from, o = i.to;
  return e === "all" ? Me.create(n, $a(0, a, o), $a(n.content.size, a, o)) : Me.create(n, $a(e, a, o), $a(e, a, o));
}
function by() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const _W = (n = null, e = {}) => ({ editor: t, view: i, tr: a, dispatch: o }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const r = () => {
    by() && i.dom.focus(), requestAnimationFrame(() => {
      t.isDestroyed || (i.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView());
    });
  };
  if (i.hasFocus() && n === null || n === !1)
    return !0;
  if (o && n === null && !yy(t.state.selection))
    return r(), !0;
  const s = xj(a.doc, n) || t.state.selection, l = t.state.selection.eq(s);
  return o && (l || a.setSelection(s), l && a.storedMarks && a.setStoredMarks(a.storedMarks), r()), !0;
}, jW = (n, e) => (t) => n.every((i, a) => e(i, { ...t, index: a })), TW = (n, e) => ({ tr: t, commands: i }) => i.insertContentAt({ from: t.selection.from, to: t.selection.to }, n, e), Ej = (n) => {
  const e = n.childNodes;
  for (let t = e.length - 1; t >= 0; t -= 1) {
    const i = e[t];
    i.nodeType === 3 && i.nodeValue && /^(\n\s\s|\n)$/.test(i.nodeValue) ? n.removeChild(i) : i.nodeType === 1 && Ej(i);
  }
  return n;
};
function oh(n) {
  const e = `<body>${n}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body;
  return Ej(t);
}
function zh(n, e, t) {
  t = {
    slice: !0,
    parseOptions: {},
    ...t
  };
  const i = typeof n == "object" && n !== null, a = typeof n == "string";
  if (i)
    try {
      return Array.isArray(n) && n.length > 0 ? U.fromArray(n.map((r) => e.nodeFromJSON(r))) : e.nodeFromJSON(n);
    } catch (o) {
      if (t.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", o), zh("", e, t);
    }
  if (a) {
    if (t.errorOnInvalidContent) {
      let r = !1, s = "";
      const l = new v_({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (h) => (r = !0, s = typeof h == "string" ? h : h.outerHTML, null)
              }
            ]
          }
        })
      });
      if (t.slice ? Yo.fromSchema(l).parseSlice(oh(n), t.parseOptions) : Yo.fromSchema(l).parse(oh(n), t.parseOptions), t.errorOnInvalidContent && r)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${s}`) });
    }
    const o = Yo.fromSchema(e);
    return t.slice ? o.parseSlice(oh(n), t.parseOptions).content : o.parse(oh(n), t.parseOptions);
  }
  return zh("", e, t);
}
function LW(n, e, t) {
  const i = n.steps.length - 1;
  if (i < e)
    return;
  const a = n.steps[i];
  if (!(a instanceof on || a instanceof sn))
    return;
  const o = n.mapping.maps[i];
  let r = 0;
  o.forEach((s, l, h, d) => {
    r === 0 && (r = d);
  }), n.setSelection(Pe.near(n.doc.resolve(r), t));
}
const xW = (n) => !("type" in n), EW = (n, e, t) => ({ tr: i, dispatch: a, editor: o }) => {
  var r;
  if (a) {
    t = {
      parseOptions: {},
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...t
    };
    let s;
    try {
      s = zh(e, o.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...t.parseOptions
        },
        errorOnInvalidContent: (r = t.errorOnInvalidContent) !== null && r !== void 0 ? r : o.options.enableContentCheck
      });
    } catch (m) {
      return o.emit("contentError", {
        editor: o,
        error: m,
        disableCollaboration: () => {
          console.error("[tiptap error]: Unable to disable collaboration at this point in time");
        }
      }), !1;
    }
    let { from: l, to: h } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, d = !0, f = !0;
    if ((xW(s) ? s : [s]).forEach((m) => {
      m.check(), d = d ? m.isText && m.marks.length === 0 : !1, f = f ? m.isBlock : !1;
    }), l === h && f) {
      const { parent: m } = i.doc.resolve(l);
      m.isTextblock && !m.type.spec.code && !m.childCount && (l -= 1, h += 1);
    }
    let y;
    d ? (Array.isArray(e) ? y = e.map((m) => m.text || "").join("") : typeof e == "object" && e && e.text ? y = e.text : y = e, i.insertText(y, l, h)) : (y = s, i.replaceWith(l, h, y)), t.updateSelection && LW(i, i.steps.length - 1, -1), t.applyInputRules && i.setMeta("applyInputRules", { from: l, text: y }), t.applyPasteRules && i.setMeta("applyPasteRules", { from: l, text: y });
  }
  return !0;
}, DW = () => ({ state: n, dispatch: e }) => EG(n, e), MW = () => ({ state: n, dispatch: e }) => DG(n, e), NW = () => ({ state: n, dispatch: e }) => kG(n, e), OW = () => ({ state: n, dispatch: e }) => LG(n, e), AW = () => ({ state: n, dispatch: e, tr: t }) => {
  try {
    const i = Sd(n.doc, n.selection.$from.pos, -1);
    return i == null ? !1 : (t.join(i, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, YW = () => ({ state: n, dispatch: e, tr: t }) => {
  try {
    const i = Sd(n.doc, n.selection.$from.pos, 1);
    return i == null ? !1 : (t.join(i, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, PW = () => ({ state: n, dispatch: e }) => _G(n, e), RW = () => ({ state: n, dispatch: e }) => jG(n, e);
function Dj() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function FW(n) {
  const e = n.split(/-(?!$)/);
  let t = e[e.length - 1];
  t === "Space" && (t = " ");
  let i, a, o, r;
  for (let s = 0; s < e.length - 1; s += 1) {
    const l = e[s];
    if (/^(cmd|meta|m)$/i.test(l))
      r = !0;
    else if (/^a(lt)?$/i.test(l))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      a = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      by() || Dj() ? r = !0 : a = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return i && (t = `Alt-${t}`), a && (t = `Ctrl-${t}`), r && (t = `Meta-${t}`), o && (t = `Shift-${t}`), t;
}
const IW = (n) => ({ editor: e, view: t, tr: i, dispatch: a }) => {
  const o = FW(n).split(/-(?!$)/), r = o.find((h) => !["Alt", "Ctrl", "Meta", "Shift"].includes(h)), s = new KeyboardEvent("keydown", {
    key: r === "Space" ? " " : r,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    t.someProp("handleKeyDown", (h) => h(t, s));
  });
  return l == null || l.steps.forEach((h) => {
    const d = h.map(i.mapping);
    d && a && i.maybeStep(d);
  }), !0;
};
function _l(n, e, t = {}) {
  const { from: i, to: a, empty: o } = n.selection, r = e ? cn(e, n.schema) : null, s = [];
  n.doc.nodesBetween(i, a, (f, p) => {
    if (f.isText)
      return;
    const y = Math.max(i, p), m = Math.min(a, p + f.nodeSize);
    s.push({
      node: f,
      from: y,
      to: m
    });
  });
  const l = a - i, h = s.filter((f) => r ? r.name === f.node.type.name : !0).filter((f) => Kh(f.node.attrs, t, { strict: !1 }));
  return o ? !!h.length : h.reduce((f, p) => f + p.to - p.from, 0) >= l;
}
const JW = (n, e = {}) => ({ state: t, dispatch: i }) => {
  const a = cn(n, t.schema);
  return _l(t, a, e) ? MG(t, i) : !1;
}, ZW = () => ({ state: n, dispatch: e }) => YG(n, e), BW = (n) => ({ state: e, dispatch: t }) => {
  const i = cn(n, e.schema);
  return HG(i)(e, t);
}, HW = () => ({ state: n, dispatch: e }) => NG(n, e);
function Od(n, e) {
  return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null;
}
function IC(n, e) {
  const t = typeof e == "string" ? [e] : e;
  return Object.keys(n).reduce((i, a) => (t.includes(a) || (i[a] = n[a]), i), {});
}
const XW = (n, e) => ({ tr: t, state: i, dispatch: a }) => {
  let o = null, r = null;
  const s = Od(typeof n == "string" ? n : n.name, i.schema);
  return s ? (s === "node" && (o = cn(n, i.schema)), s === "mark" && (r = Vo(n, i.schema)), a && t.selection.ranges.forEach((l) => {
    i.doc.nodesBetween(l.$from.pos, l.$to.pos, (h, d) => {
      o && o === h.type && t.setNodeMarkup(d, void 0, IC(h.attrs, e)), r && h.marks.length && h.marks.forEach((f) => {
        r === f.type && t.addMark(d, d + h.nodeSize, r.create(IC(f.attrs, e)));
      });
    });
  }), !0) : !1;
}, GW = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0), WW = () => ({ tr: n, commands: e }) => e.setTextSelection({
  from: 0,
  to: n.doc.content.size
}), QW = () => ({ state: n, dispatch: e }) => TG(n, e), KW = () => ({ state: n, dispatch: e }) => xG(n, e), zW = () => ({ state: n, dispatch: e }) => PG(n, e), $W = () => ({ state: n, dispatch: e }) => IG(n, e), VW = () => ({ state: n, dispatch: e }) => FG(n, e);
function em(n, e, t = {}, i = {}) {
  return zh(n, e, {
    slice: !1,
    parseOptions: t,
    errorOnInvalidContent: i.errorOnInvalidContent
  });
}
const UW = (n, e = !1, t = {}, i = {}) => ({ editor: a, tr: o, dispatch: r, commands: s }) => {
  var l, h;
  const { doc: d } = o;
  if (t.preserveWhitespace !== "full") {
    const f = em(n, a.schema, t, {
      errorOnInvalidContent: (l = i.errorOnInvalidContent) !== null && l !== void 0 ? l : a.options.enableContentCheck
    });
    return r && o.replaceWith(0, d.content.size, f).setMeta("preventUpdate", !e), !0;
  }
  return r && o.setMeta("preventUpdate", !e), s.insertContentAt({ from: 0, to: d.content.size }, n, {
    parseOptions: t,
    errorOnInvalidContent: (h = i.errorOnInvalidContent) !== null && h !== void 0 ? h : a.options.enableContentCheck
  });
};
function Ad(n, e) {
  const t = Vo(e, n.schema), { from: i, to: a, empty: o } = n.selection, r = [];
  o ? (n.storedMarks && r.push(...n.storedMarks), r.push(...n.selection.$head.marks())) : n.doc.nodesBetween(i, a, (l) => {
    r.push(...l.marks);
  });
  const s = r.find((l) => l.type.name === t.name);
  return s ? { ...s.attrs } : {};
}
function qW(n) {
  for (let e = 0; e < n.edgeCount; e += 1) {
    const { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
function e5(n, e) {
  for (let t = n.depth; t > 0; t -= 1) {
    const i = n.node(t);
    if (e(i))
      return {
        pos: t > 0 ? n.before(t) : 0,
        start: n.start(t),
        depth: t,
        node: i
      };
  }
}
function wy(n) {
  return (e) => e5(e.$from, n);
}
function t5(n, e) {
  const t = Gr.fromSchema(e).serializeFragment(n), a = document.implementation.createHTMLDocument().createElement("div");
  return a.appendChild(t), a.innerHTML;
}
function n5(n, e) {
  const t = {
    from: 0,
    to: n.content.size
  };
  return Tj(n, t, e);
}
function i5(n, e) {
  const t = cn(e, n.schema), { from: i, to: a } = n.selection, o = [];
  n.doc.nodesBetween(i, a, (s) => {
    o.push(s);
  });
  const r = o.reverse().find((s) => s.type.name === t.name);
  return r ? { ...r.attrs } : {};
}
function a5(n, e) {
  const t = Od(typeof e == "string" ? e : e.name, n.schema);
  return t === "node" ? i5(n, e) : t === "mark" ? Ad(n, e) : {};
}
function Mj(n, e, t) {
  const i = [];
  return n === e ? t.resolve(n).marks().forEach((a) => {
    const o = t.resolve(n), r = my(o, a.type);
    r && i.push({
      mark: a,
      ...r
    });
  }) : t.nodesBetween(n, e, (a, o) => {
    !a || (a == null ? void 0 : a.nodeSize) === void 0 || i.push(...a.marks.map((r) => ({
      from: o,
      to: o + a.nodeSize,
      mark: r
    })));
  }), i;
}
function wh(n, e, t) {
  return Object.fromEntries(Object.entries(t).filter(([i]) => {
    const a = n.find((o) => o.type === e && o.name === i);
    return a ? a.attribute.keepOnSplit : !1;
  }));
}
function tm(n, e, t = {}) {
  const { empty: i, ranges: a } = n.selection, o = e ? Vo(e, n.schema) : null;
  if (i)
    return !!(n.storedMarks || n.selection.$from.marks()).filter((f) => o ? o.name === f.type.name : !0).find((f) => Kh(f.attrs, t, { strict: !1 }));
  let r = 0;
  const s = [];
  if (a.forEach(({ $from: f, $to: p }) => {
    const y = f.pos, m = p.pos;
    n.doc.nodesBetween(y, m, (w, v) => {
      if (!w.isText && !w.marks.length)
        return;
      const _ = Math.max(y, v), L = Math.min(m, v + w.nodeSize), T = L - _;
      r += T, s.push(...w.marks.map((S) => ({
        mark: S,
        from: _,
        to: L
      })));
    });
  }), r === 0)
    return !1;
  const l = s.filter((f) => o ? o.name === f.mark.type.name : !0).filter((f) => Kh(f.mark.attrs, t, { strict: !1 })).reduce((f, p) => f + p.to - p.from, 0), h = s.filter((f) => o ? f.mark.type !== o && f.mark.type.excludes(o) : !0).reduce((f, p) => f + p.to - p.from, 0);
  return (l > 0 ? l + h : l) >= r;
}
function o5(n, e, t = {}) {
  if (!e)
    return _l(n, null, t) || tm(n, null, t);
  const i = Od(e, n.schema);
  return i === "node" ? _l(n, e, t) : i === "mark" ? tm(n, e, t) : !1;
}
function JC(n, e) {
  const { nodeExtensions: t } = Dd(e), i = t.find((r) => r.name === n);
  if (!i)
    return !1;
  const a = {
    name: i.name,
    options: i.options,
    storage: i.storage
  }, o = Ze(fe(i, "group", a));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function Nj(n, { checkChildren: e = !0, ignoreWhitespace: t = !1 } = {}) {
  var i;
  if (t) {
    if (n.type.name === "hardBreak")
      return !0;
    if (n.isText)
      return /^\s*$/m.test((i = n.text) !== null && i !== void 0 ? i : "");
  }
  if (n.isText)
    return !n.text;
  if (n.isAtom || n.isLeaf)
    return !1;
  if (n.content.childCount === 0)
    return !0;
  if (e) {
    let a = !0;
    return n.content.forEach((o) => {
      a !== !1 && (Nj(o, { ignoreWhitespace: t, checkChildren: e }) || (a = !1));
    }), a;
  }
  return !1;
}
function Oj(n) {
  return n instanceof Ce;
}
function Aj(n, e, t) {
  const a = n.state.doc.content.size, o = $a(e, 0, a), r = $a(t, 0, a), s = n.coordsAtPos(o), l = n.coordsAtPos(r, -1), h = Math.min(s.top, l.top), d = Math.max(s.bottom, l.bottom), f = Math.min(s.left, l.left), p = Math.max(s.right, l.right), y = p - f, m = d - h, _ = {
    top: h,
    bottom: d,
    left: f,
    right: p,
    width: y,
    height: m,
    x: f,
    y: h
  };
  return {
    ..._,
    toJSON: () => _
  };
}
function r5(n, e, t) {
  var i;
  const { selection: a } = e;
  let o = null;
  if (yy(a) && (o = a.$cursor), o) {
    const s = (i = n.storedMarks) !== null && i !== void 0 ? i : o.marks();
    return !!t.isInSet(s) || !s.some((l) => l.type.excludes(t));
  }
  const { ranges: r } = a;
  return r.some(({ $from: s, $to: l }) => {
    let h = s.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : !1;
    return n.doc.nodesBetween(s.pos, l.pos, (d, f, p) => {
      if (h)
        return !1;
      if (d.isInline) {
        const y = !p || p.type.allowsMarkType(t), m = !!t.isInSet(d.marks) || !d.marks.some((w) => w.type.excludes(t));
        h = y && m;
      }
      return !h;
    }), h;
  });
}
const s5 = (n, e = {}) => ({ tr: t, state: i, dispatch: a }) => {
  const { selection: o } = t, { empty: r, ranges: s } = o, l = Vo(n, i.schema);
  if (a)
    if (r) {
      const h = Ad(i, l);
      t.addStoredMark(l.create({
        ...h,
        ...e
      }));
    } else
      s.forEach((h) => {
        const d = h.$from.pos, f = h.$to.pos;
        i.doc.nodesBetween(d, f, (p, y) => {
          const m = Math.max(y, d), w = Math.min(y + p.nodeSize, f);
          p.marks.find((_) => _.type === l) ? p.marks.forEach((_) => {
            l === _.type && t.addMark(m, w, l.create({
              ..._.attrs,
              ...e
            }));
          }) : t.addMark(m, w, l.create(e));
        });
      });
  return r5(i, t, l);
}, u5 = (n, e) => ({ tr: t }) => (t.setMeta(n, e), !0), l5 = (n, e = {}) => ({ state: t, dispatch: i, chain: a }) => {
  const o = cn(n, t.schema);
  return o.isTextblock ? a().command(({ commands: r }) => YC(o, e)(t) ? !0 : r.clearNodes()).command(({ state: r }) => YC(o, e)(r, i)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, c5 = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: i } = e, a = $a(n, 0, i.content.size), o = Ce.create(i, a);
    e.setSelection(o);
  }
  return !0;
}, h5 = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: i } = e, { from: a, to: o } = typeof n == "number" ? { from: n, to: n } : n, r = Me.atStart(i).from, s = Me.atEnd(i).to, l = $a(a, r, s), h = $a(o, r, s), d = Me.create(i, l, h);
    e.setSelection(d);
  }
  return !0;
}, d5 = (n) => ({ state: e, dispatch: t }) => {
  const i = cn(n, e.schema);
  return WG(i)(e, t);
};
function ZC(n, e) {
  const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks();
  if (t) {
    const i = t.filter((a) => e == null ? void 0 : e.includes(a.type.name));
    n.tr.ensureMarks(i);
  }
}
const g5 = ({ keepMarks: n = !0 } = {}) => ({ tr: e, state: t, dispatch: i, editor: a }) => {
  const { selection: o, doc: r } = e, { $from: s, $to: l } = o, h = a.extensionManager.attributes, d = wh(h, s.node().type.name, s.node().attrs);
  if (o instanceof Ce && o.node.isBlock)
    return !s.parentOffset || !As(r, s.pos) ? !1 : (i && (n && ZC(t, a.extensionManager.splittableMarks), e.split(s.pos).scrollIntoView()), !0);
  if (!s.parent.isBlock)
    return !1;
  const f = l.parentOffset === l.parent.content.size, p = s.depth === 0 ? void 0 : qW(s.node(-1).contentMatchAt(s.indexAfter(-1)));
  let y = f && p ? [
    {
      type: p,
      attrs: d
    }
  ] : void 0, m = As(e.doc, e.mapping.map(s.pos), 1, y);
  if (!y && !m && As(e.doc, e.mapping.map(s.pos), 1, p ? [{ type: p }] : void 0) && (m = !0, y = p ? [
    {
      type: p,
      attrs: d
    }
  ] : void 0), i) {
    if (m && (o instanceof Me && e.deleteSelection(), e.split(e.mapping.map(s.pos), 1, y), p && !f && !s.parentOffset && s.parent.type !== p)) {
      const w = e.mapping.map(s.before()), v = e.doc.resolve(w);
      s.node(-1).canReplaceWith(v.index(), v.index() + 1, p) && e.setNodeMarkup(e.mapping.map(s.before()), p);
    }
    n && ZC(t, a.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return m;
}, f5 = (n, e = {}) => ({ tr: t, state: i, dispatch: a, editor: o }) => {
  var r;
  const s = cn(n, i.schema), { $from: l, $to: h } = i.selection, d = i.selection.node;
  if (d && d.isBlock || l.depth < 2 || !l.sameParent(h))
    return !1;
  const f = l.node(-1);
  if (f.type !== s)
    return !1;
  const p = o.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== s || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (a) {
      let _ = U.empty;
      const L = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let P = l.depth - L; P >= l.depth - 3; P -= 1)
        _ = U.from(l.node(P).copy(_));
      const T = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, S = {
        ...wh(p, l.node().type.name, l.node().attrs),
        ...e
      }, A = ((r = s.contentMatch.defaultType) === null || r === void 0 ? void 0 : r.createAndFill(S)) || void 0;
      _ = _.append(U.from(s.createAndFill(null, A) || void 0));
      const x = l.before(l.depth - (L - 1));
      t.replace(x, l.after(-T), new ue(_, 4 - L, 0));
      let M = -1;
      t.doc.nodesBetween(x, t.doc.content.size, (P, Y) => {
        if (M > -1)
          return !1;
        P.isTextblock && P.content.size === 0 && (M = Y + 1);
      }), M > -1 && t.setSelection(Me.near(t.doc.resolve(M))), t.scrollIntoView();
    }
    return !0;
  }
  const y = h.pos === l.end() ? f.contentMatchAt(0).defaultType : null, m = {
    ...wh(p, f.type.name, f.attrs),
    ...e
  }, w = {
    ...wh(p, l.node().type.name, l.node().attrs),
    ...e
  };
  t.delete(l.pos, h.pos);
  const v = y ? [
    { type: s, attrs: m },
    { type: y, attrs: w }
  ] : [{ type: s, attrs: m }];
  if (!As(t.doc, l.pos, 2))
    return !1;
  if (a) {
    const { selection: _, storedMarks: L } = i, { splittableMarks: T } = o.extensionManager, S = L || _.$to.parentOffset && _.$from.marks();
    if (t.split(l.pos, 2, v).scrollIntoView(), !S || !a)
      return !0;
    const A = S.filter((x) => T.includes(x.type.name));
    t.ensureMarks(A);
  }
  return !0;
}, Gf = (n, e) => {
  const t = wy((r) => r.type === e)(n.selection);
  if (!t)
    return !0;
  const i = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
  if (i === void 0)
    return !0;
  const a = n.doc.nodeAt(i);
  return t.node.type === (a == null ? void 0 : a.type) && zo(n.doc, t.pos) && n.join(t.pos), !0;
}, Wf = (n, e) => {
  const t = wy((r) => r.type === e)(n.selection);
  if (!t)
    return !0;
  const i = n.doc.resolve(t.start).after(t.depth);
  if (i === void 0)
    return !0;
  const a = n.doc.nodeAt(i);
  return t.node.type === (a == null ? void 0 : a.type) && zo(n.doc, i) && n.join(i), !0;
}, p5 = (n, e, t, i = {}) => ({ editor: a, tr: o, state: r, dispatch: s, chain: l, commands: h, can: d }) => {
  const { extensions: f, splittableMarks: p } = a.extensionManager, y = cn(n, r.schema), m = cn(e, r.schema), { selection: w, storedMarks: v } = r, { $from: _, $to: L } = w, T = _.blockRange(L), S = v || w.$to.parentOffset && w.$from.marks();
  if (!T)
    return !1;
  const A = wy((x) => JC(x.type.name, f))(w);
  if (T.depth >= 1 && A && T.depth - A.depth <= 1) {
    if (A.node.type === y)
      return h.liftListItem(m);
    if (JC(A.node.type.name, f) && y.validContent(A.node.content) && s)
      return l().command(() => (o.setNodeMarkup(A.pos, y), !0)).command(() => Gf(o, y)).command(() => Wf(o, y)).run();
  }
  return !t || !S || !s ? l().command(() => d().wrapInList(y, i) ? !0 : h.clearNodes()).wrapInList(y, i).command(() => Gf(o, y)).command(() => Wf(o, y)).run() : l().command(() => {
    const x = d().wrapInList(y, i), M = S.filter((P) => p.includes(P.type.name));
    return o.ensureMarks(M), x ? !0 : h.clearNodes();
  }).wrapInList(y, i).command(() => Gf(o, y)).command(() => Wf(o, y)).run();
}, m5 = (n, e = {}, t = {}) => ({ state: i, commands: a }) => {
  const { extendEmptyMarkRange: o = !1 } = t, r = Vo(n, i.schema);
  return tm(i, r, e) ? a.unsetMark(r, { extendEmptyMarkRange: o }) : a.setMark(r, e);
}, y5 = (n, e, t = {}) => ({ state: i, commands: a }) => {
  const o = cn(n, i.schema), r = cn(e, i.schema);
  return _l(i, o, t) ? a.setNode(r) : a.setNode(o, t);
}, b5 = (n, e = {}) => ({ state: t, commands: i }) => {
  const a = cn(n, t.schema);
  return _l(t, a, e) ? i.lift(a) : i.wrapIn(a, e);
}, w5 = () => ({ state: n, dispatch: e }) => {
  const t = n.plugins;
  for (let i = 0; i < t.length; i += 1) {
    const a = t[i];
    let o;
    if (a.spec.isInputRules && (o = a.getState(n))) {
      if (e) {
        const r = n.tr, s = o.transform;
        for (let l = s.steps.length - 1; l >= 0; l -= 1)
          r.step(s.steps[l].invert(s.docs[l]));
        if (o.text) {
          const l = r.doc.resolve(o.from).marks();
          r.replaceWith(o.from, o.to, n.schema.text(o.text, l));
        } else
          r.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, v5 = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, { empty: i, ranges: a } = t;
  return i || e && a.forEach((o) => {
    n.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, C5 = (n, e = {}) => ({ tr: t, state: i, dispatch: a }) => {
  var o;
  const { extendEmptyMarkRange: r = !1 } = e, { selection: s } = t, l = Vo(n, i.schema), { $from: h, empty: d, ranges: f } = s;
  if (!a)
    return !0;
  if (d && r) {
    let { from: p, to: y } = s;
    const m = (o = h.marks().find((v) => v.type === l)) === null || o === void 0 ? void 0 : o.attrs, w = my(h, l, m);
    w && (p = w.from, y = w.to), t.removeMark(p, y, l);
  } else
    f.forEach((p) => {
      t.removeMark(p.$from.pos, p.$to.pos, l);
    });
  return t.removeStoredMark(l), !0;
}, S5 = (n, e = {}) => ({ tr: t, state: i, dispatch: a }) => {
  let o = null, r = null;
  const s = Od(typeof n == "string" ? n : n.name, i.schema);
  return s ? (s === "node" && (o = cn(n, i.schema)), s === "mark" && (r = Vo(n, i.schema)), a && t.selection.ranges.forEach((l) => {
    const h = l.$from.pos, d = l.$to.pos;
    i.doc.nodesBetween(h, d, (f, p) => {
      o && o === f.type && t.setNodeMarkup(p, void 0, {
        ...f.attrs,
        ...e
      }), r && f.marks.length && f.marks.forEach((y) => {
        if (r === y.type) {
          const m = Math.max(p, h), w = Math.min(p + f.nodeSize, d);
          t.addMark(m, w, r.create({
            ...y.attrs,
            ...e
          }));
        }
      });
    });
  }), !0) : !1;
}, k5 = (n, e = {}) => ({ state: t, dispatch: i }) => {
  const a = cn(n, t.schema);
  return JG(a, e)(t, i);
}, _5 = (n, e = {}) => ({ state: t, dispatch: i }) => {
  const a = cn(n, t.schema);
  return ZG(a, e)(t, i);
};
var j5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: lW,
  clearContent: cW,
  clearNodes: hW,
  command: dW,
  createParagraphNear: gW,
  cut: fW,
  deleteCurrentNode: pW,
  deleteNode: mW,
  deleteRange: yW,
  deleteSelection: bW,
  enter: wW,
  exitCode: vW,
  extendMarkRange: SW,
  first: kW,
  focus: _W,
  forEach: jW,
  insertContent: TW,
  insertContentAt: EW,
  joinBackward: NW,
  joinDown: MW,
  joinForward: OW,
  joinItemBackward: AW,
  joinItemForward: YW,
  joinTextblockBackward: PW,
  joinTextblockForward: RW,
  joinUp: DW,
  keyboardShortcut: IW,
  lift: JW,
  liftEmptyBlock: ZW,
  liftListItem: BW,
  newlineInCode: HW,
  resetAttributes: XW,
  scrollIntoView: GW,
  selectAll: WW,
  selectNodeBackward: QW,
  selectNodeForward: KW,
  selectParentNode: zW,
  selectTextblockEnd: $W,
  selectTextblockStart: VW,
  setContent: UW,
  setMark: s5,
  setMeta: u5,
  setNode: l5,
  setNodeSelection: c5,
  setTextSelection: h5,
  sinkListItem: d5,
  splitBlock: g5,
  splitListItem: f5,
  toggleList: p5,
  toggleMark: m5,
  toggleNode: y5,
  toggleWrap: b5,
  undoInputRule: w5,
  unsetAllMarks: v5,
  unsetMark: C5,
  updateAttributes: S5,
  wrapIn: k5,
  wrapInList: _5
});
const T5 = Jn.create({
  name: "commands",
  addCommands() {
    return {
      ...j5
    };
  }
}), L5 = Jn.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new ii({
        key: new La("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), x5 = Jn.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: n } = this;
    return [
      new ii({
        key: new La("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, t) => {
              n.isFocused = !0;
              const i = n.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(i), !1;
            },
            blur: (e, t) => {
              n.isFocused = !1;
              const i = n.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(i), !1;
            }
          }
        }
      })
    ];
  }
}), E5 = Jn.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const n = () => this.editor.commands.first(({ commands: r }) => [
      () => r.undoInputRule(),
      // maybe convert first text block node to default node
      () => r.command(({ tr: s }) => {
        const { selection: l, doc: h } = s, { empty: d, $anchor: f } = l, { pos: p, parent: y } = f, m = f.parent.isTextblock && p > 0 ? s.doc.resolve(p - 1) : f, w = m.parent.type.spec.isolating, v = f.pos - f.parentOffset, _ = w && m.parent.childCount === 1 ? v === f.pos : Pe.atStart(h).from === p;
        return !d || !y.type.isTextblock || y.textContent.length || !_ || _ && f.parent.type.name === "paragraph" ? !1 : r.clearNodes();
      }),
      () => r.deleteSelection(),
      () => r.joinBackward(),
      () => r.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: r }) => [
      () => r.deleteSelection(),
      () => r.deleteCurrentNode(),
      () => r.joinForward(),
      () => r.selectNodeForward()
    ]), i = {
      Enter: () => this.editor.commands.first(({ commands: r }) => [
        () => r.newlineInCode(),
        () => r.createParagraphNear(),
        () => r.liftEmptyBlock(),
        () => r.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: n,
      "Mod-Backspace": n,
      "Shift-Backspace": n,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, a = {
      ...i
    }, o = {
      ...i,
      "Ctrl-h": n,
      "Alt-Backspace": n,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return by() || Dj() ? o : a;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnâ€™t work well
      // with many other commands.
      new ii({
        key: new La("clearDocument"),
        appendTransaction: (n, e, t) => {
          if (!(n.some((m) => m.docChanged) && !e.doc.eq(t.doc)))
            return;
          const { empty: a, from: o, to: r } = e.selection, s = Pe.atStart(e.doc).from, l = Pe.atEnd(e.doc).to;
          if (a || !(o === s && r === l) || !(t.doc.textBetween(0, t.doc.content.size, " ", " ").length === 0))
            return;
          const f = t.tr, p = xd({
            state: t,
            transaction: f
          }), { commands: y } = new Ed({
            editor: this.editor,
            state: p
          });
          if (y.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), D5 = Jn.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new ii({
        key: new La("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class mr {
  get name() {
    return this.node.type.name;
  }
  constructor(e, t, i = !1, a = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = i, this.resolvedPos = e, this.editor = t, this.currentNode = a;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let t = this.from, i = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You canâ€™t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      t = this.from + 1, i = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: t, to: i }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e);
    return new mr(t, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new mr(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new mr(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((t, i) => {
      const a = t.isBlock && !t.isTextblock, o = this.pos + i + 1, r = this.resolvedPos.doc.resolve(o);
      if (!a && r.depth <= this.depth)
        return;
      const s = new mr(r, this.editor, a, a ? t : null);
      a && (s.actualDepth = this.depth + 1), e.push(new mr(r, this.editor, a, a ? t : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, t = {}) {
    let i = null, a = this.parent;
    for (; a && !i; ) {
      if (a.node.type.name === e)
        if (Object.keys(t).length > 0) {
          const o = a.node.attrs, r = Object.keys(t);
          for (let s = 0; s < r.length; s += 1) {
            const l = r[s];
            if (o[l] !== t[l])
              break;
          }
        } else
          i = a;
      a = a.parent;
    }
    return i;
  }
  querySelector(e, t = {}) {
    return this.querySelectorAll(e, t, !0)[0] || null;
  }
  querySelectorAll(e, t = {}, i = !1) {
    let a = [];
    if (!this.children || this.children.length === 0)
      return a;
    const o = Object.keys(t);
    return this.children.forEach((r) => {
      i && a.length > 0 || (r.node.type.name === e && o.every((l) => t[l] === r.node.attrs[l]) && a.push(r), !(i && a.length > 0) && (a = a.concat(r.querySelectorAll(e, t, i))));
    }), a;
  }
  setAttribute(e) {
    const t = this.editor.state.selection;
    this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, e).setTextSelection(t.from).run();
  }
}
const M5 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function N5(n, e, t) {
  const i = document.querySelector("style[data-tiptap-style]");
  if (i !== null)
    return i;
  const a = document.createElement("style");
  return e && a.setAttribute("nonce", e), a.setAttribute("data-tiptap-style", ""), a.innerHTML = n, document.getElementsByTagName("head")[0].appendChild(a), a;
}
let O5 = class extends QG {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: t }) => {
        throw t;
      }
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = N5(M5, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, t = !0) {
    this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   */
  registerPlugin(e, t) {
    const i = jj(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], a = this.state.reconfigure({ plugins: i });
    this.view.updateState(a);
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKey The plugins name
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const t = typeof e == "string" ? `${e}$` : e.key, i = this.state.reconfigure({
      // @ts-ignore
      plugins: this.state.plugins.filter((a) => !a.key.startsWith(t))
    });
    this.view.updateState(i);
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, t;
    const a = [...this.options.enableCoreExtensions ? [
      L5,
      uW.configure({
        blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || t === void 0 ? void 0 : t.blockSeparator
      }),
      T5,
      x5,
      E5,
      D5
    ] : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o == null ? void 0 : o.type));
    this.extensionManager = new Ts(a, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Ed({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    let e;
    try {
      e = em(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (o) {
      if (!(o instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(o.message))
        throw o;
      this.emit("contentError", {
        editor: this,
        error: o,
        disableCollaboration: () => {
          this.options.extensions = this.options.extensions.filter((r) => r.name !== "collaboration"), this.createExtensionManager();
        }
      }), e = em(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const t = xj(e, this.options.autofocus);
    this.view = new dG(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: js.create({
        doc: e,
        selection: t || void 0
      })
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.createNodeViews(), this.prependClass();
    const a = this.view.dom;
    a.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const t = this.capturedTransaction;
    return this.capturedTransaction = null, t;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((r) => {
        var s;
        return (s = this.capturedTransaction) === null || s === void 0 ? void 0 : s.step(r);
      });
      return;
    }
    const t = this.state.apply(e), i = !this.state.selection.eq(t.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: t
    }), this.view.updateState(t), this.emit("transaction", {
      editor: this,
      transaction: e
    }), i && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const a = e.getMeta("focus"), o = e.getMeta("blur");
    a && this.emit("focus", {
      editor: this,
      event: a.event,
      transaction: e
    }), o && this.emit("blur", {
      editor: this,
      event: o.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return a5(this.state, e);
  }
  isActive(e, t) {
    const i = typeof e == "string" ? e : null, a = typeof e == "string" ? t : e;
    return o5(this.state, i, a);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return t5(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: t = `

`, textSerializers: i = {} } = e || {};
    return n5(this.state.doc, {
      blockSeparator: t,
      textSerializers: {
        ...Lj(this.schema),
        ...i
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return Nj(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.view && this.view.destroy(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, t) {
    var i;
    return ((i = this.$doc) === null || i === void 0 ? void 0 : i.querySelector(e, t)) || null;
  }
  $nodes(e, t) {
    var i;
    return ((i = this.$doc) === null || i === void 0 ? void 0 : i.querySelectorAll(e, t)) || null;
  }
  $pos(e) {
    const t = this.state.doc.resolve(e);
    return new mr(t, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Hs(n) {
  return new Md({
    find: n.find,
    handler: ({ state: e, range: t, match: i }) => {
      const a = Ze(n.getAttributes, void 0, i);
      if (a === !1 || a === null)
        return null;
      const { tr: o } = e, r = i[i.length - 1], s = i[0];
      if (r) {
        const l = s.search(/\S/), h = t.from + s.indexOf(r), d = h + r.length;
        if (Mj(t.from, t.to, e.doc).filter((y) => y.mark.type.excluded.find((w) => w === n.type && w !== y.mark.type)).filter((y) => y.to > h).length)
          return null;
        d < t.to && o.delete(d, t.to), h > t.from && o.delete(t.from + l, h);
        const p = t.from + l + r.length;
        o.addMark(t.from + l, p, n.type.create(a || {})), o.removeStoredMark(n.type);
      }
    }
  });
}
function A5(n) {
  return new Md({
    find: n.find,
    handler: ({ state: e, range: t, match: i }) => {
      const a = Ze(n.getAttributes, void 0, i) || {}, { tr: o } = e, r = t.from;
      let s = t.to;
      const l = n.type.create(a);
      if (i[1]) {
        const h = i[0].lastIndexOf(i[1]);
        let d = r + h;
        d > s ? d = s : s = d + i[1].length;
        const f = i[0][i[0].length - 1];
        o.insertText(f, r + i[0].length - 1), o.replaceWith(d, s, l);
      } else if (i[0]) {
        const h = n.type.isInline ? r : r - 1;
        o.insert(h, n.type.create(a)).delete(o.mapping.map(r), o.mapping.map(s));
      }
      o.scrollIntoView();
    }
  });
}
function nm(n) {
  return new Md({
    find: n.find,
    handler: ({ state: e, range: t, match: i }) => {
      const a = e.doc.resolve(t.from), o = Ze(n.getAttributes, void 0, i) || {};
      if (!a.node(-1).canReplaceWith(a.index(-1), a.indexAfter(-1), n.type))
        return null;
      e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, o);
    }
  });
}
function jl(n) {
  return new Md({
    find: n.find,
    handler: ({ state: e, range: t, match: i, chain: a }) => {
      const o = Ze(n.getAttributes, void 0, i) || {}, r = e.tr.delete(t.from, t.to), l = r.doc.resolve(t.from).blockRange(), h = l && iy(l, n.type, o);
      if (!h)
        return null;
      if (r.wrap(l, h), n.keepMarks && n.editor) {
        const { selection: f, storedMarks: p } = e, { splittableMarks: y } = n.editor.extensionManager, m = p || f.$to.parentOffset && f.$from.marks();
        if (m) {
          const w = m.filter((v) => y.includes(v.type.name));
          r.ensureMarks(w);
        }
      }
      if (n.keepAttributes) {
        const f = n.type.name === "bulletList" || n.type.name === "orderedList" ? "listItem" : "taskList";
        a().updateAttributes(f, o).run();
      }
      const d = r.doc.resolve(t.from - 1).nodeBefore;
      d && d.type === n.type && zo(r.doc, t.from - 1) && (!n.joinPredicate || n.joinPredicate(i, d)) && r.join(t.from - 1);
    }
  });
}
class ja {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ze(fe(this, "addOptions", {
      name: this.name
    }))), this.storage = Ze(fe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new ja(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => Nd(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new ja(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Ze(fe(t, "addOptions", {
      name: t.name
    })), t.storage = Ze(fe(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
  static handleExit({ editor: e, mark: t }) {
    const { tr: i } = e.state, a = e.state.selection.$from;
    if (a.pos === a.end()) {
      const r = a.marks();
      if (!!!r.find((h) => (h == null ? void 0 : h.type.name) === t.name))
        return !1;
      const l = r.find((h) => (h == null ? void 0 : h.type.name) === t.name);
      return l && i.removeStoredMark(l), i.insertText(" ", a.pos), e.view.dispatch(i), !0;
    }
    return !1;
  }
}
let Si = class im {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ze(fe(this, "addOptions", {
      name: this.name
    }))), this.storage = Ze(fe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new im(e);
  }
  configure(e = {}) {
    const t = this.extend({
      ...this.config,
      addOptions: () => Nd(this.options, e)
    });
    return t.name = this.name, t.parent = this.parent, t;
  }
  extend(e = {}) {
    const t = new im(e);
    return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = Ze(fe(t, "addOptions", {
      name: t.name
    })), t.storage = Ze(fe(t, "addStorage", {
      name: t.name,
      options: t.options
    })), t;
  }
};
function Xs(n) {
  return new tW({
    find: n.find,
    handler: ({ state: e, range: t, match: i, pasteEvent: a }) => {
      const o = Ze(n.getAttributes, void 0, i, a);
      if (o === !1 || o === null)
        return null;
      const { tr: r } = e, s = i[i.length - 1], l = i[0];
      let h = t.to;
      if (s) {
        const d = l.search(/\S/), f = t.from + l.indexOf(s), p = f + s.length;
        if (Mj(t.from, t.to, e.doc).filter((m) => m.mark.type.excluded.find((v) => v === n.type && v !== m.mark.type)).filter((m) => m.to > f).length)
          return null;
        p < t.to && r.delete(p, t.to), f > t.from && r.delete(t.from + d, f), h = t.from + d + s.length, r.addMark(t.from + d, h, n.type.create(o || {})), r.removeStoredMark(n.type);
      }
    }
  });
}
var ti = "top", Zi = "bottom", Bi = "right", ni = "left", vy = "auto", Hl = [ti, Zi, Bi, ni], Gs = "start", Tl = "end", Y5 = "clippingParents", Yj = "viewport", Yu = "popper", P5 = "reference", BC = /* @__PURE__ */ Hl.reduce(function(n, e) {
  return n.concat([e + "-" + Gs, e + "-" + Tl]);
}, []), Pj = /* @__PURE__ */ [].concat(Hl, [vy]).reduce(function(n, e) {
  return n.concat([e, e + "-" + Gs, e + "-" + Tl]);
}, []), R5 = "beforeRead", F5 = "read", I5 = "afterRead", J5 = "beforeMain", Z5 = "main", B5 = "afterMain", H5 = "beforeWrite", X5 = "write", G5 = "afterWrite", W5 = [R5, F5, I5, J5, Z5, B5, H5, X5, G5];
function Ta(n) {
  return n ? (n.nodeName || "").toLowerCase() : null;
}
function wi(n) {
  if (n == null)
    return window;
  if (n.toString() !== "[object Window]") {
    var e = n.ownerDocument;
    return e && e.defaultView || window;
  }
  return n;
}
function Rr(n) {
  var e = wi(n).Element;
  return n instanceof e || n instanceof Element;
}
function Ii(n) {
  var e = wi(n).HTMLElement;
  return n instanceof e || n instanceof HTMLElement;
}
function Cy(n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = wi(n).ShadowRoot;
  return n instanceof e || n instanceof ShadowRoot;
}
function Q5(n) {
  var e = n.state;
  Object.keys(e.elements).forEach(function(t) {
    var i = e.styles[t] || {}, a = e.attributes[t] || {}, o = e.elements[t];
    !Ii(o) || !Ta(o) || (Object.assign(o.style, i), Object.keys(a).forEach(function(r) {
      var s = a[r];
      s === !1 ? o.removeAttribute(r) : o.setAttribute(r, s === !0 ? "" : s);
    }));
  });
}
function K5(n) {
  var e = n.state, t = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function() {
    Object.keys(e.elements).forEach(function(i) {
      var a = e.elements[i], o = e.attributes[i] || {}, r = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]), s = r.reduce(function(l, h) {
        return l[h] = "", l;
      }, {});
      !Ii(a) || !Ta(a) || (Object.assign(a.style, s), Object.keys(o).forEach(function(l) {
        a.removeAttribute(l);
      }));
    });
  };
}
const Rj = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Q5,
  effect: K5,
  requires: ["computeStyles"]
};
function Ca(n) {
  return n.split("-")[0];
}
var Er = Math.max, $h = Math.min, Ws = Math.round;
function am() {
  var n = navigator.userAgentData;
  return n != null && n.brands && Array.isArray(n.brands) ? n.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function Fj() {
  return !/^((?!chrome|android).)*safari/i.test(am());
}
function Qs(n, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var i = n.getBoundingClientRect(), a = 1, o = 1;
  e && Ii(n) && (a = n.offsetWidth > 0 && Ws(i.width) / n.offsetWidth || 1, o = n.offsetHeight > 0 && Ws(i.height) / n.offsetHeight || 1);
  var r = Rr(n) ? wi(n) : window, s = r.visualViewport, l = !Fj() && t, h = (i.left + (l && s ? s.offsetLeft : 0)) / a, d = (i.top + (l && s ? s.offsetTop : 0)) / o, f = i.width / a, p = i.height / o;
  return {
    width: f,
    height: p,
    top: d,
    right: h + f,
    bottom: d + p,
    left: h,
    x: h,
    y: d
  };
}
function Sy(n) {
  var e = Qs(n), t = n.offsetWidth, i = n.offsetHeight;
  return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), {
    x: n.offsetLeft,
    y: n.offsetTop,
    width: t,
    height: i
  };
}
function Ij(n, e) {
  var t = e.getRootNode && e.getRootNode();
  if (n.contains(e))
    return !0;
  if (t && Cy(t)) {
    var i = e;
    do {
      if (i && n.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function no(n) {
  return wi(n).getComputedStyle(n);
}
function z5(n) {
  return ["table", "td", "th"].indexOf(Ta(n)) >= 0;
}
function Uo(n) {
  return ((Rr(n) ? n.ownerDocument : (
    // $FlowFixMe[prop-missing]
    n.document
  )) || window.document).documentElement;
}
function Yd(n) {
  return Ta(n) === "html" ? n : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    n.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    n.parentNode || // DOM Element detected
    (Cy(n) ? n.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Uo(n)
  );
}
function HC(n) {
  return !Ii(n) || // https://github.com/popperjs/popper-core/issues/837
  no(n).position === "fixed" ? null : n.offsetParent;
}
function $5(n) {
  var e = /firefox/i.test(am()), t = /Trident/i.test(am());
  if (t && Ii(n)) {
    var i = no(n);
    if (i.position === "fixed")
      return null;
  }
  var a = Yd(n);
  for (Cy(a) && (a = a.host); Ii(a) && ["html", "body"].indexOf(Ta(a)) < 0; ) {
    var o = no(a);
    if (o.transform !== "none" || o.perspective !== "none" || o.contain === "paint" || ["transform", "perspective"].indexOf(o.willChange) !== -1 || e && o.willChange === "filter" || e && o.filter && o.filter !== "none")
      return a;
    a = a.parentNode;
  }
  return null;
}
function Xl(n) {
  for (var e = wi(n), t = HC(n); t && z5(t) && no(t).position === "static"; )
    t = HC(t);
  return t && (Ta(t) === "html" || Ta(t) === "body" && no(t).position === "static") ? e : t || $5(n) || e;
}
function ky(n) {
  return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
}
function sl(n, e, t) {
  return Er(n, $h(e, t));
}
function V5(n, e, t) {
  var i = sl(n, e, t);
  return i > t ? t : i;
}
function Jj() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Zj(n) {
  return Object.assign({}, Jj(), n);
}
function Bj(n, e) {
  return e.reduce(function(t, i) {
    return t[i] = n, t;
  }, {});
}
var U5 = function(e, t) {
  return e = typeof e == "function" ? e(Object.assign({}, t.rects, {
    placement: t.placement
  })) : e, Zj(typeof e != "number" ? e : Bj(e, Hl));
};
function q5(n) {
  var e, t = n.state, i = n.name, a = n.options, o = t.elements.arrow, r = t.modifiersData.popperOffsets, s = Ca(t.placement), l = ky(s), h = [ni, Bi].indexOf(s) >= 0, d = h ? "height" : "width";
  if (!(!o || !r)) {
    var f = U5(a.padding, t), p = Sy(o), y = l === "y" ? ti : ni, m = l === "y" ? Zi : Bi, w = t.rects.reference[d] + t.rects.reference[l] - r[l] - t.rects.popper[d], v = r[l] - t.rects.reference[l], _ = Xl(o), L = _ ? l === "y" ? _.clientHeight || 0 : _.clientWidth || 0 : 0, T = w / 2 - v / 2, S = f[y], A = L - p[d] - f[m], x = L / 2 - p[d] / 2 + T, M = sl(S, x, A), P = l;
    t.modifiersData[i] = (e = {}, e[P] = M, e.centerOffset = M - x, e);
  }
}
function e4(n) {
  var e = n.state, t = n.options, i = t.element, a = i === void 0 ? "[data-popper-arrow]" : i;
  a != null && (typeof a == "string" && (a = e.elements.popper.querySelector(a), !a) || Ij(e.elements.popper, a) && (e.elements.arrow = a));
}
const t4 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: q5,
  effect: e4,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Ks(n) {
  return n.split("-")[1];
}
var n4 = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function i4(n, e) {
  var t = n.x, i = n.y, a = e.devicePixelRatio || 1;
  return {
    x: Ws(t * a) / a || 0,
    y: Ws(i * a) / a || 0
  };
}
function XC(n) {
  var e, t = n.popper, i = n.popperRect, a = n.placement, o = n.variation, r = n.offsets, s = n.position, l = n.gpuAcceleration, h = n.adaptive, d = n.roundOffsets, f = n.isFixed, p = r.x, y = p === void 0 ? 0 : p, m = r.y, w = m === void 0 ? 0 : m, v = typeof d == "function" ? d({
    x: y,
    y: w
  }) : {
    x: y,
    y: w
  };
  y = v.x, w = v.y;
  var _ = r.hasOwnProperty("x"), L = r.hasOwnProperty("y"), T = ni, S = ti, A = window;
  if (h) {
    var x = Xl(t), M = "clientHeight", P = "clientWidth";
    if (x === wi(t) && (x = Uo(t), no(x).position !== "static" && s === "absolute" && (M = "scrollHeight", P = "scrollWidth")), x = x, a === ti || (a === ni || a === Bi) && o === Tl) {
      S = Zi;
      var Y = f && x === A && A.visualViewport ? A.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        x[M]
      );
      w -= Y - i.height, w *= l ? 1 : -1;
    }
    if (a === ni || (a === ti || a === Zi) && o === Tl) {
      T = Bi;
      var te = f && x === A && A.visualViewport ? A.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        x[P]
      );
      y -= te - i.width, y *= l ? 1 : -1;
    }
  }
  var ge = Object.assign({
    position: s
  }, h && n4), re = d === !0 ? i4({
    x: y,
    y: w
  }, wi(t)) : {
    x: y,
    y: w
  };
  if (y = re.x, w = re.y, l) {
    var me;
    return Object.assign({}, ge, (me = {}, me[S] = L ? "0" : "", me[T] = _ ? "0" : "", me.transform = (A.devicePixelRatio || 1) <= 1 ? "translate(" + y + "px, " + w + "px)" : "translate3d(" + y + "px, " + w + "px, 0)", me));
  }
  return Object.assign({}, ge, (e = {}, e[S] = L ? w + "px" : "", e[T] = _ ? y + "px" : "", e.transform = "", e));
}
function a4(n) {
  var e = n.state, t = n.options, i = t.gpuAcceleration, a = i === void 0 ? !0 : i, o = t.adaptive, r = o === void 0 ? !0 : o, s = t.roundOffsets, l = s === void 0 ? !0 : s, h = {
    placement: Ca(e.placement),
    variation: Ks(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: a,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, XC(Object.assign({}, h, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: r,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, XC(Object.assign({}, h, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const o4 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: a4,
  data: {}
};
var rh = {
  passive: !0
};
function r4(n) {
  var e = n.state, t = n.instance, i = n.options, a = i.scroll, o = a === void 0 ? !0 : a, r = i.resize, s = r === void 0 ? !0 : r, l = wi(e.elements.popper), h = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return o && h.forEach(function(d) {
    d.addEventListener("scroll", t.update, rh);
  }), s && l.addEventListener("resize", t.update, rh), function() {
    o && h.forEach(function(d) {
      d.removeEventListener("scroll", t.update, rh);
    }), s && l.removeEventListener("resize", t.update, rh);
  };
}
const s4 = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: r4,
  data: {}
};
var u4 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function vh(n) {
  return n.replace(/left|right|bottom|top/g, function(e) {
    return u4[e];
  });
}
var l4 = {
  start: "end",
  end: "start"
};
function GC(n) {
  return n.replace(/start|end/g, function(e) {
    return l4[e];
  });
}
function _y(n) {
  var e = wi(n), t = e.pageXOffset, i = e.pageYOffset;
  return {
    scrollLeft: t,
    scrollTop: i
  };
}
function jy(n) {
  return Qs(Uo(n)).left + _y(n).scrollLeft;
}
function c4(n, e) {
  var t = wi(n), i = Uo(n), a = t.visualViewport, o = i.clientWidth, r = i.clientHeight, s = 0, l = 0;
  if (a) {
    o = a.width, r = a.height;
    var h = Fj();
    (h || !h && e === "fixed") && (s = a.offsetLeft, l = a.offsetTop);
  }
  return {
    width: o,
    height: r,
    x: s + jy(n),
    y: l
  };
}
function h4(n) {
  var e, t = Uo(n), i = _y(n), a = (e = n.ownerDocument) == null ? void 0 : e.body, o = Er(t.scrollWidth, t.clientWidth, a ? a.scrollWidth : 0, a ? a.clientWidth : 0), r = Er(t.scrollHeight, t.clientHeight, a ? a.scrollHeight : 0, a ? a.clientHeight : 0), s = -i.scrollLeft + jy(n), l = -i.scrollTop;
  return no(a || t).direction === "rtl" && (s += Er(t.clientWidth, a ? a.clientWidth : 0) - o), {
    width: o,
    height: r,
    x: s,
    y: l
  };
}
function Ty(n) {
  var e = no(n), t = e.overflow, i = e.overflowX, a = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(t + a + i);
}
function Hj(n) {
  return ["html", "body", "#document"].indexOf(Ta(n)) >= 0 ? n.ownerDocument.body : Ii(n) && Ty(n) ? n : Hj(Yd(n));
}
function ul(n, e) {
  var t;
  e === void 0 && (e = []);
  var i = Hj(n), a = i === ((t = n.ownerDocument) == null ? void 0 : t.body), o = wi(i), r = a ? [o].concat(o.visualViewport || [], Ty(i) ? i : []) : i, s = e.concat(r);
  return a ? s : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    s.concat(ul(Yd(r)))
  );
}
function om(n) {
  return Object.assign({}, n, {
    left: n.x,
    top: n.y,
    right: n.x + n.width,
    bottom: n.y + n.height
  });
}
function d4(n, e) {
  var t = Qs(n, !1, e === "fixed");
  return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t;
}
function WC(n, e, t) {
  return e === Yj ? om(c4(n, t)) : Rr(e) ? d4(e, t) : om(h4(Uo(n)));
}
function g4(n) {
  var e = ul(Yd(n)), t = ["absolute", "fixed"].indexOf(no(n).position) >= 0, i = t && Ii(n) ? Xl(n) : n;
  return Rr(i) ? e.filter(function(a) {
    return Rr(a) && Ij(a, i) && Ta(a) !== "body";
  }) : [];
}
function f4(n, e, t, i) {
  var a = e === "clippingParents" ? g4(n) : [].concat(e), o = [].concat(a, [t]), r = o[0], s = o.reduce(function(l, h) {
    var d = WC(n, h, i);
    return l.top = Er(d.top, l.top), l.right = $h(d.right, l.right), l.bottom = $h(d.bottom, l.bottom), l.left = Er(d.left, l.left), l;
  }, WC(n, r, i));
  return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s;
}
function Xj(n) {
  var e = n.reference, t = n.element, i = n.placement, a = i ? Ca(i) : null, o = i ? Ks(i) : null, r = e.x + e.width / 2 - t.width / 2, s = e.y + e.height / 2 - t.height / 2, l;
  switch (a) {
    case ti:
      l = {
        x: r,
        y: e.y - t.height
      };
      break;
    case Zi:
      l = {
        x: r,
        y: e.y + e.height
      };
      break;
    case Bi:
      l = {
        x: e.x + e.width,
        y: s
      };
      break;
    case ni:
      l = {
        x: e.x - t.width,
        y: s
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var h = a ? ky(a) : null;
  if (h != null) {
    var d = h === "y" ? "height" : "width";
    switch (o) {
      case Gs:
        l[h] = l[h] - (e[d] / 2 - t[d] / 2);
        break;
      case Tl:
        l[h] = l[h] + (e[d] / 2 - t[d] / 2);
        break;
    }
  }
  return l;
}
function Ll(n, e) {
  e === void 0 && (e = {});
  var t = e, i = t.placement, a = i === void 0 ? n.placement : i, o = t.strategy, r = o === void 0 ? n.strategy : o, s = t.boundary, l = s === void 0 ? Y5 : s, h = t.rootBoundary, d = h === void 0 ? Yj : h, f = t.elementContext, p = f === void 0 ? Yu : f, y = t.altBoundary, m = y === void 0 ? !1 : y, w = t.padding, v = w === void 0 ? 0 : w, _ = Zj(typeof v != "number" ? v : Bj(v, Hl)), L = p === Yu ? P5 : Yu, T = n.rects.popper, S = n.elements[m ? L : p], A = f4(Rr(S) ? S : S.contextElement || Uo(n.elements.popper), l, d, r), x = Qs(n.elements.reference), M = Xj({
    reference: x,
    element: T,
    strategy: "absolute",
    placement: a
  }), P = om(Object.assign({}, T, M)), Y = p === Yu ? P : x, te = {
    top: A.top - Y.top + _.top,
    bottom: Y.bottom - A.bottom + _.bottom,
    left: A.left - Y.left + _.left,
    right: Y.right - A.right + _.right
  }, ge = n.modifiersData.offset;
  if (p === Yu && ge) {
    var re = ge[a];
    Object.keys(te).forEach(function(me) {
      var ut = [Bi, Zi].indexOf(me) >= 0 ? 1 : -1, ht = [ti, Zi].indexOf(me) >= 0 ? "y" : "x";
      te[me] += re[ht] * ut;
    });
  }
  return te;
}
function p4(n, e) {
  e === void 0 && (e = {});
  var t = e, i = t.placement, a = t.boundary, o = t.rootBoundary, r = t.padding, s = t.flipVariations, l = t.allowedAutoPlacements, h = l === void 0 ? Pj : l, d = Ks(i), f = d ? s ? BC : BC.filter(function(m) {
    return Ks(m) === d;
  }) : Hl, p = f.filter(function(m) {
    return h.indexOf(m) >= 0;
  });
  p.length === 0 && (p = f);
  var y = p.reduce(function(m, w) {
    return m[w] = Ll(n, {
      placement: w,
      boundary: a,
      rootBoundary: o,
      padding: r
    })[Ca(w)], m;
  }, {});
  return Object.keys(y).sort(function(m, w) {
    return y[m] - y[w];
  });
}
function m4(n) {
  if (Ca(n) === vy)
    return [];
  var e = vh(n);
  return [GC(n), e, GC(e)];
}
function y4(n) {
  var e = n.state, t = n.options, i = n.name;
  if (!e.modifiersData[i]._skip) {
    for (var a = t.mainAxis, o = a === void 0 ? !0 : a, r = t.altAxis, s = r === void 0 ? !0 : r, l = t.fallbackPlacements, h = t.padding, d = t.boundary, f = t.rootBoundary, p = t.altBoundary, y = t.flipVariations, m = y === void 0 ? !0 : y, w = t.allowedAutoPlacements, v = e.options.placement, _ = Ca(v), L = _ === v, T = l || (L || !m ? [vh(v)] : m4(v)), S = [v].concat(T).reduce(function(Jt, pt) {
      return Jt.concat(Ca(pt) === vy ? p4(e, {
        placement: pt,
        boundary: d,
        rootBoundary: f,
        padding: h,
        flipVariations: m,
        allowedAutoPlacements: w
      }) : pt);
    }, []), A = e.rects.reference, x = e.rects.popper, M = /* @__PURE__ */ new Map(), P = !0, Y = S[0], te = 0; te < S.length; te++) {
      var ge = S[te], re = Ca(ge), me = Ks(ge) === Gs, ut = [ti, Zi].indexOf(re) >= 0, ht = ut ? "width" : "height", ze = Ll(e, {
        placement: ge,
        boundary: d,
        rootBoundary: f,
        altBoundary: p,
        padding: h
      }), Ge = ut ? me ? Bi : ni : me ? Zi : ti;
      A[ht] > x[ht] && (Ge = vh(Ge));
      var Ae = vh(Ge), It = [];
      if (o && It.push(ze[re] <= 0), s && It.push(ze[Ge] <= 0, ze[Ae] <= 0), It.every(function(Jt) {
        return Jt;
      })) {
        Y = ge, P = !1;
        break;
      }
      M.set(ge, It);
    }
    if (P)
      for (var xt = m ? 3 : 1, ft = function(pt) {
        var Ee = S.find(function(xn) {
          var Xt = M.get(xn);
          if (Xt)
            return Xt.slice(0, pt).every(function(en) {
              return en;
            });
        });
        if (Ee)
          return Y = Ee, "break";
      }, gt = xt; gt > 0; gt--) {
        var Kt = ft(gt);
        if (Kt === "break") break;
      }
    e.placement !== Y && (e.modifiersData[i]._skip = !0, e.placement = Y, e.reset = !0);
  }
}
const b4 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: y4,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function QC(n, e, t) {
  return t === void 0 && (t = {
    x: 0,
    y: 0
  }), {
    top: n.top - e.height - t.y,
    right: n.right - e.width + t.x,
    bottom: n.bottom - e.height + t.y,
    left: n.left - e.width - t.x
  };
}
function KC(n) {
  return [ti, Bi, Zi, ni].some(function(e) {
    return n[e] >= 0;
  });
}
function w4(n) {
  var e = n.state, t = n.name, i = e.rects.reference, a = e.rects.popper, o = e.modifiersData.preventOverflow, r = Ll(e, {
    elementContext: "reference"
  }), s = Ll(e, {
    altBoundary: !0
  }), l = QC(r, i), h = QC(s, a, o), d = KC(l), f = KC(h);
  e.modifiersData[t] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: h,
    isReferenceHidden: d,
    hasPopperEscaped: f
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": f
  });
}
const v4 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: w4
};
function C4(n, e, t) {
  var i = Ca(n), a = [ni, ti].indexOf(i) >= 0 ? -1 : 1, o = typeof t == "function" ? t(Object.assign({}, e, {
    placement: n
  })) : t, r = o[0], s = o[1];
  return r = r || 0, s = (s || 0) * a, [ni, Bi].indexOf(i) >= 0 ? {
    x: s,
    y: r
  } : {
    x: r,
    y: s
  };
}
function S4(n) {
  var e = n.state, t = n.options, i = n.name, a = t.offset, o = a === void 0 ? [0, 0] : a, r = Pj.reduce(function(d, f) {
    return d[f] = C4(f, e.rects, o), d;
  }, {}), s = r[e.placement], l = s.x, h = s.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += h), e.modifiersData[i] = r;
}
const k4 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: S4
};
function _4(n) {
  var e = n.state, t = n.name;
  e.modifiersData[t] = Xj({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const j4 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: _4,
  data: {}
};
function T4(n) {
  return n === "x" ? "y" : "x";
}
function L4(n) {
  var e = n.state, t = n.options, i = n.name, a = t.mainAxis, o = a === void 0 ? !0 : a, r = t.altAxis, s = r === void 0 ? !1 : r, l = t.boundary, h = t.rootBoundary, d = t.altBoundary, f = t.padding, p = t.tether, y = p === void 0 ? !0 : p, m = t.tetherOffset, w = m === void 0 ? 0 : m, v = Ll(e, {
    boundary: l,
    rootBoundary: h,
    padding: f,
    altBoundary: d
  }), _ = Ca(e.placement), L = Ks(e.placement), T = !L, S = ky(_), A = T4(S), x = e.modifiersData.popperOffsets, M = e.rects.reference, P = e.rects.popper, Y = typeof w == "function" ? w(Object.assign({}, e.rects, {
    placement: e.placement
  })) : w, te = typeof Y == "number" ? {
    mainAxis: Y,
    altAxis: Y
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, Y), ge = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, re = {
    x: 0,
    y: 0
  };
  if (x) {
    if (o) {
      var me, ut = S === "y" ? ti : ni, ht = S === "y" ? Zi : Bi, ze = S === "y" ? "height" : "width", Ge = x[S], Ae = Ge + v[ut], It = Ge - v[ht], xt = y ? -P[ze] / 2 : 0, ft = L === Gs ? M[ze] : P[ze], gt = L === Gs ? -P[ze] : -M[ze], Kt = e.elements.arrow, Jt = y && Kt ? Sy(Kt) : {
        width: 0,
        height: 0
      }, pt = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Jj(), Ee = pt[ut], xn = pt[ht], Xt = sl(0, M[ze], Jt[ze]), en = T ? M[ze] / 2 - xt - Xt - Ee - te.mainAxis : ft - Xt - Ee - te.mainAxis, hn = T ? -M[ze] / 2 + xt + Xt + xn + te.mainAxis : gt + Xt + xn + te.mainAxis, dn = e.elements.arrow && Xl(e.elements.arrow), En = dn ? S === "y" ? dn.clientTop || 0 : dn.clientLeft || 0 : 0, Zn = (me = ge == null ? void 0 : ge[S]) != null ? me : 0, $ = Ge + en - Zn - En, Oe = Ge + hn - Zn, ai = sl(y ? $h(Ae, $) : Ae, Ge, y ? Er(It, Oe) : It);
      x[S] = ai, re[S] = ai - Ge;
    }
    if (s) {
      var Mt, oi = S === "x" ? ti : ni, oa = S === "x" ? Zi : Bi, D = x[A], N = A === "y" ? "height" : "width", X = D + v[oi], le = D - v[oa], it = [ti, ni].indexOf(_) !== -1, Je = (Mt = ge == null ? void 0 : ge[A]) != null ? Mt : 0, We = it ? X : D - M[N] - P[N] - Je + te.altAxis, Z = it ? D + M[N] + P[N] - Je - te.altAxis : le, z = y && it ? V5(We, D, Z) : sl(y ? We : X, D, y ? Z : le);
      x[A] = z, re[A] = z - D;
    }
    e.modifiersData[i] = re;
  }
}
const x4 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: L4,
  requiresIfExists: ["offset"]
};
function E4(n) {
  return {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  };
}
function D4(n) {
  return n === wi(n) || !Ii(n) ? _y(n) : E4(n);
}
function M4(n) {
  var e = n.getBoundingClientRect(), t = Ws(e.width) / n.offsetWidth || 1, i = Ws(e.height) / n.offsetHeight || 1;
  return t !== 1 || i !== 1;
}
function N4(n, e, t) {
  t === void 0 && (t = !1);
  var i = Ii(e), a = Ii(e) && M4(e), o = Uo(e), r = Qs(n, a, t), s = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !t) && ((Ta(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Ty(o)) && (s = D4(e)), Ii(e) ? (l = Qs(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : o && (l.x = jy(o))), {
    x: r.left + s.scrollLeft - l.x,
    y: r.top + s.scrollTop - l.y,
    width: r.width,
    height: r.height
  };
}
function O4(n) {
  var e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set(), i = [];
  n.forEach(function(o) {
    e.set(o.name, o);
  });
  function a(o) {
    t.add(o.name);
    var r = [].concat(o.requires || [], o.requiresIfExists || []);
    r.forEach(function(s) {
      if (!t.has(s)) {
        var l = e.get(s);
        l && a(l);
      }
    }), i.push(o);
  }
  return n.forEach(function(o) {
    t.has(o.name) || a(o);
  }), i;
}
function A4(n) {
  var e = O4(n);
  return W5.reduce(function(t, i) {
    return t.concat(e.filter(function(a) {
      return a.phase === i;
    }));
  }, []);
}
function Y4(n) {
  var e;
  return function() {
    return e || (e = new Promise(function(t) {
      Promise.resolve().then(function() {
        e = void 0, t(n());
      });
    })), e;
  };
}
function P4(n) {
  var e = n.reduce(function(t, i) {
    var a = t[i.name];
    return t[i.name] = a ? Object.assign({}, a, i, {
      options: Object.assign({}, a.options, i.options),
      data: Object.assign({}, a.data, i.data)
    }) : i, t;
  }, {});
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}
var zC = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function $C() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return !e.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function R4(n) {
  n === void 0 && (n = {});
  var e = n, t = e.defaultModifiers, i = t === void 0 ? [] : t, a = e.defaultOptions, o = a === void 0 ? zC : a;
  return function(s, l, h) {
    h === void 0 && (h = o);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, zC, o),
      modifiersData: {},
      elements: {
        reference: s,
        popper: l
      },
      attributes: {},
      styles: {}
    }, f = [], p = !1, y = {
      state: d,
      setOptions: function(_) {
        var L = typeof _ == "function" ? _(d.options) : _;
        w(), d.options = Object.assign({}, o, d.options, L), d.scrollParents = {
          reference: Rr(s) ? ul(s) : s.contextElement ? ul(s.contextElement) : [],
          popper: ul(l)
        };
        var T = A4(P4([].concat(i, d.options.modifiers)));
        return d.orderedModifiers = T.filter(function(S) {
          return S.enabled;
        }), m(), y.update();
      },
      // Sync update â€“ it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!p) {
          var _ = d.elements, L = _.reference, T = _.popper;
          if ($C(L, T)) {
            d.rects = {
              reference: N4(L, Xl(T), d.options.strategy === "fixed"),
              popper: Sy(T)
            }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(te) {
              return d.modifiersData[te.name] = Object.assign({}, te.data);
            });
            for (var S = 0; S < d.orderedModifiers.length; S++) {
              if (d.reset === !0) {
                d.reset = !1, S = -1;
                continue;
              }
              var A = d.orderedModifiers[S], x = A.fn, M = A.options, P = M === void 0 ? {} : M, Y = A.name;
              typeof x == "function" && (d = x({
                state: d,
                options: P,
                name: Y,
                instance: y
              }) || d);
            }
          }
        }
      },
      // Async and optimistically optimized update â€“ it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: Y4(function() {
        return new Promise(function(v) {
          y.forceUpdate(), v(d);
        });
      }),
      destroy: function() {
        w(), p = !0;
      }
    };
    if (!$C(s, l))
      return y;
    y.setOptions(h).then(function(v) {
      !p && h.onFirstUpdate && h.onFirstUpdate(v);
    });
    function m() {
      d.orderedModifiers.forEach(function(v) {
        var _ = v.name, L = v.options, T = L === void 0 ? {} : L, S = v.effect;
        if (typeof S == "function") {
          var A = S({
            state: d,
            name: _,
            instance: y,
            options: T
          }), x = function() {
          };
          f.push(A || x);
        }
      });
    }
    function w() {
      f.forEach(function(v) {
        return v();
      }), f = [];
    }
    return y;
  };
}
var F4 = [s4, j4, o4, Rj, k4, b4, x4, t4, v4], I4 = /* @__PURE__ */ R4({
  defaultModifiers: F4
}), J4 = "tippy-box", Gj = "tippy-content", Z4 = "tippy-backdrop", Wj = "tippy-arrow", Qj = "tippy-svg-arrow", gr = {
  passive: !0,
  capture: !0
}, Kj = function() {
  return document.body;
};
function B4(n, e) {
  return {}.hasOwnProperty.call(n, e);
}
function Qf(n, e, t) {
  if (Array.isArray(n)) {
    var i = n[e];
    return i ?? (Array.isArray(t) ? t[e] : t);
  }
  return n;
}
function Ly(n, e) {
  var t = {}.toString.call(n);
  return t.indexOf("[object") === 0 && t.indexOf(e + "]") > -1;
}
function zj(n, e) {
  return typeof n == "function" ? n.apply(void 0, e) : n;
}
function VC(n, e) {
  if (e === 0)
    return n;
  var t;
  return function(i) {
    clearTimeout(t), t = setTimeout(function() {
      n(i);
    }, e);
  };
}
function H4(n, e) {
  var t = Object.assign({}, n);
  return e.forEach(function(i) {
    delete t[i];
  }), t;
}
function X4(n) {
  return n.split(/\s+/).filter(Boolean);
}
function bs(n) {
  return [].concat(n);
}
function UC(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function G4(n) {
  return n.filter(function(e, t) {
    return n.indexOf(e) === t;
  });
}
function W4(n) {
  return n.split("-")[0];
}
function Vh(n) {
  return [].slice.call(n);
}
function qC(n) {
  return Object.keys(n).reduce(function(e, t) {
    return n[t] !== void 0 && (e[t] = n[t]), e;
  }, {});
}
function ll() {
  return document.createElement("div");
}
function xl(n) {
  return ["Element", "Fragment"].some(function(e) {
    return Ly(n, e);
  });
}
function Q4(n) {
  return Ly(n, "NodeList");
}
function K4(n) {
  return Ly(n, "MouseEvent");
}
function z4(n) {
  return !!(n && n._tippy && n._tippy.reference === n);
}
function $4(n) {
  return xl(n) ? [n] : Q4(n) ? Vh(n) : Array.isArray(n) ? n : Vh(document.querySelectorAll(n));
}
function Kf(n, e) {
  n.forEach(function(t) {
    t && (t.style.transitionDuration = e + "ms");
  });
}
function e1(n, e) {
  n.forEach(function(t) {
    t && t.setAttribute("data-state", e);
  });
}
function V4(n) {
  var e, t = bs(n), i = t[0];
  return i != null && (e = i.ownerDocument) != null && e.body ? i.ownerDocument : document;
}
function U4(n, e) {
  var t = e.clientX, i = e.clientY;
  return n.every(function(a) {
    var o = a.popperRect, r = a.popperState, s = a.props, l = s.interactiveBorder, h = W4(r.placement), d = r.modifiersData.offset;
    if (!d)
      return !0;
    var f = h === "bottom" ? d.top.y : 0, p = h === "top" ? d.bottom.y : 0, y = h === "right" ? d.left.x : 0, m = h === "left" ? d.right.x : 0, w = o.top - i + f > l, v = i - o.bottom - p > l, _ = o.left - t + y > l, L = t - o.right - m > l;
    return w || v || _ || L;
  });
}
function zf(n, e, t) {
  var i = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(a) {
    n[i](a, t);
  });
}
function t1(n, e) {
  for (var t = e; t; ) {
    var i;
    if (n.contains(t))
      return !0;
    t = t.getRootNode == null || (i = t.getRootNode()) == null ? void 0 : i.host;
  }
  return !1;
}
var da = {
  isTouch: !1
}, n1 = 0;
function q4() {
  da.isTouch || (da.isTouch = !0, window.performance && document.addEventListener("mousemove", $j));
}
function $j() {
  var n = performance.now();
  n - n1 < 20 && (da.isTouch = !1, document.removeEventListener("mousemove", $j)), n1 = n;
}
function eQ() {
  var n = document.activeElement;
  if (z4(n)) {
    var e = n._tippy;
    n.blur && !e.state.isVisible && n.blur();
  }
}
function tQ() {
  document.addEventListener("touchstart", q4, gr), window.addEventListener("blur", eQ);
}
var nQ = typeof window < "u" && typeof document < "u", iQ = nQ ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function gs(n) {
  var e = n === "destroy" ? "n already-" : " ";
  return [n + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function i1(n) {
  var e = /[ \t]{2,}/g, t = /^[ \t]*/gm;
  return n.replace(e, " ").replace(t, "").trim();
}
function aQ(n) {
  return i1(`
  %ctippy.js

  %c` + i1(n) + `

  %cðŸ‘·â€ This is a development-only message. It will be removed in production.
  `);
}
function Vj(n) {
  return [
    aQ(n),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var El;
process.env.NODE_ENV !== "production" && oQ();
function oQ() {
  El = /* @__PURE__ */ new Set();
}
function Wa(n, e) {
  if (n && !El.has(e)) {
    var t;
    El.add(e), (t = console).warn.apply(t, Vj(e));
  }
}
function rm(n, e) {
  if (n && !El.has(e)) {
    var t;
    El.add(e), (t = console).error.apply(t, Vj(e));
  }
}
function rQ(n) {
  var e = !n, t = Object.prototype.toString.call(n) === "[object Object]" && !n.addEventListener;
  rm(e, ["tippy() was passed", "`" + String(n) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), rm(t, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var Uj = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, sQ = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, pi = Object.assign({
  appendTo: Kj,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, Uj, sQ), uQ = Object.keys(pi), lQ = function(e) {
  process.env.NODE_ENV !== "production" && eT(e, []);
  var t = Object.keys(e);
  t.forEach(function(i) {
    pi[i] = e[i];
  });
};
function qj(n) {
  var e = n.plugins || [], t = e.reduce(function(i, a) {
    var o = a.name, r = a.defaultValue;
    if (o) {
      var s;
      i[o] = n[o] !== void 0 ? n[o] : (s = pi[o]) != null ? s : r;
    }
    return i;
  }, {});
  return Object.assign({}, n, t);
}
function cQ(n, e) {
  var t = e ? Object.keys(qj(Object.assign({}, pi, {
    plugins: e
  }))) : uQ, i = t.reduce(function(a, o) {
    var r = (n.getAttribute("data-tippy-" + o) || "").trim();
    if (!r)
      return a;
    if (o === "content")
      a[o] = r;
    else
      try {
        a[o] = JSON.parse(r);
      } catch {
        a[o] = r;
      }
    return a;
  }, {});
  return i;
}
function a1(n, e) {
  var t = Object.assign({}, e, {
    content: zj(e.content, [n])
  }, e.ignoreAttributes ? {} : cQ(n, e.plugins));
  return t.aria = Object.assign({}, pi.aria, t.aria), t.aria = {
    expanded: t.aria.expanded === "auto" ? e.interactive : t.aria.expanded,
    content: t.aria.content === "auto" ? e.interactive ? null : "describedby" : t.aria.content
  }, t;
}
function eT(n, e) {
  n === void 0 && (n = {}), e === void 0 && (e = []);
  var t = Object.keys(n);
  t.forEach(function(i) {
    var a = H4(pi, Object.keys(Uj)), o = !B4(a, i);
    o && (o = e.filter(function(r) {
      return r.name === i;
    }).length === 0), Wa(o, ["`" + i + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var hQ = function() {
  return "innerHTML";
};
function sm(n, e) {
  n[hQ()] = e;
}
function o1(n) {
  var e = ll();
  return n === !0 ? e.className = Wj : (e.className = Qj, xl(n) ? e.appendChild(n) : sm(e, n)), e;
}
function r1(n, e) {
  xl(e.content) ? (sm(n, ""), n.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? sm(n, e.content) : n.textContent = e.content);
}
function um(n) {
  var e = n.firstElementChild, t = Vh(e.children);
  return {
    box: e,
    content: t.find(function(i) {
      return i.classList.contains(Gj);
    }),
    arrow: t.find(function(i) {
      return i.classList.contains(Wj) || i.classList.contains(Qj);
    }),
    backdrop: t.find(function(i) {
      return i.classList.contains(Z4);
    })
  };
}
function tT(n) {
  var e = ll(), t = ll();
  t.className = J4, t.setAttribute("data-state", "hidden"), t.setAttribute("tabindex", "-1");
  var i = ll();
  i.className = Gj, i.setAttribute("data-state", "hidden"), r1(i, n.props), e.appendChild(t), t.appendChild(i), a(n.props, n.props);
  function a(o, r) {
    var s = um(e), l = s.box, h = s.content, d = s.arrow;
    r.theme ? l.setAttribute("data-theme", r.theme) : l.removeAttribute("data-theme"), typeof r.animation == "string" ? l.setAttribute("data-animation", r.animation) : l.removeAttribute("data-animation"), r.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof r.maxWidth == "number" ? r.maxWidth + "px" : r.maxWidth, r.role ? l.setAttribute("role", r.role) : l.removeAttribute("role"), (o.content !== r.content || o.allowHTML !== r.allowHTML) && r1(h, n.props), r.arrow ? d ? o.arrow !== r.arrow && (l.removeChild(d), l.appendChild(o1(r.arrow))) : l.appendChild(o1(r.arrow)) : d && l.removeChild(d);
  }
  return {
    popper: e,
    onUpdate: a
  };
}
tT.$$tippy = !0;
var dQ = 1, sh = [], $f = [];
function gQ(n, e) {
  var t = a1(n, Object.assign({}, pi, qj(qC(e)))), i, a, o, r = !1, s = !1, l = !1, h = !1, d, f, p, y = [], m = VC($, t.interactiveDebounce), w, v = dQ++, _ = null, L = G4(t.plugins), T = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, S = {
    // properties
    id: v,
    reference: n,
    popper: ll(),
    popperInstance: _,
    props: t,
    state: T,
    plugins: L,
    // methods
    clearDelayTimeouts: We,
    setProps: Z,
    setContent: z,
    show: Be,
    hide: mt,
    hideWithInteractivity: Bn,
    enable: it,
    disable: Je,
    unmount: ra,
    destroy: ki
  };
  if (!t.render)
    return process.env.NODE_ENV !== "production" && rm(!0, "render() function has not been supplied."), S;
  var A = t.render(S), x = A.popper, M = A.onUpdate;
  x.setAttribute("data-tippy-root", ""), x.id = "tippy-" + S.id, S.popper = x, n._tippy = S, x._tippy = S;
  var P = L.map(function(B) {
    return B.fn(S);
  }), Y = n.hasAttribute("aria-expanded");
  return dn(), xt(), Ge(), Ae("onCreate", [S]), t.showOnCreate && X(), x.addEventListener("mouseenter", function() {
    S.props.interactive && S.state.isVisible && S.clearDelayTimeouts();
  }), x.addEventListener("mouseleave", function() {
    S.props.interactive && S.props.trigger.indexOf("mouseenter") >= 0 && ut().addEventListener("mousemove", m);
  }), S;
  function te() {
    var B = S.props.touch;
    return Array.isArray(B) ? B : [B, 0];
  }
  function ge() {
    return te()[0] === "hold";
  }
  function re() {
    var B;
    return !!((B = S.props.render) != null && B.$$tippy);
  }
  function me() {
    return w || n;
  }
  function ut() {
    var B = me().parentNode;
    return B ? V4(B) : document;
  }
  function ht() {
    return um(x);
  }
  function ze(B) {
    return S.state.isMounted && !S.state.isVisible || da.isTouch || d && d.type === "focus" ? 0 : Qf(S.props.delay, B ? 0 : 1, pi.delay);
  }
  function Ge(B) {
    B === void 0 && (B = !1), x.style.pointerEvents = S.props.interactive && !B ? "" : "none", x.style.zIndex = "" + S.props.zIndex;
  }
  function Ae(B, he, ve) {
    if (ve === void 0 && (ve = !0), P.forEach(function($e) {
      $e[B] && $e[B].apply($e, he);
    }), ve) {
      var et;
      (et = S.props)[B].apply(et, he);
    }
  }
  function It() {
    var B = S.props.aria;
    if (B.content) {
      var he = "aria-" + B.content, ve = x.id, et = bs(S.props.triggerTarget || n);
      et.forEach(function($e) {
        var gn = $e.getAttribute(he);
        if (S.state.isVisible)
          $e.setAttribute(he, gn ? gn + " " + ve : ve);
        else {
          var Hn = gn && gn.replace(ve, "").trim();
          Hn ? $e.setAttribute(he, Hn) : $e.removeAttribute(he);
        }
      });
    }
  }
  function xt() {
    if (!(Y || !S.props.aria.expanded)) {
      var B = bs(S.props.triggerTarget || n);
      B.forEach(function(he) {
        S.props.interactive ? he.setAttribute("aria-expanded", S.state.isVisible && he === me() ? "true" : "false") : he.removeAttribute("aria-expanded");
      });
    }
  }
  function ft() {
    ut().removeEventListener("mousemove", m), sh = sh.filter(function(B) {
      return B !== m;
    });
  }
  function gt(B) {
    if (!(da.isTouch && (l || B.type === "mousedown"))) {
      var he = B.composedPath && B.composedPath()[0] || B.target;
      if (!(S.props.interactive && t1(x, he))) {
        if (bs(S.props.triggerTarget || n).some(function(ve) {
          return t1(ve, he);
        })) {
          if (da.isTouch || S.state.isVisible && S.props.trigger.indexOf("click") >= 0)
            return;
        } else
          Ae("onClickOutside", [S, B]);
        S.props.hideOnClick === !0 && (S.clearDelayTimeouts(), S.hide(), s = !0, setTimeout(function() {
          s = !1;
        }), S.state.isMounted || Ee());
      }
    }
  }
  function Kt() {
    l = !0;
  }
  function Jt() {
    l = !1;
  }
  function pt() {
    var B = ut();
    B.addEventListener("mousedown", gt, !0), B.addEventListener("touchend", gt, gr), B.addEventListener("touchstart", Jt, gr), B.addEventListener("touchmove", Kt, gr);
  }
  function Ee() {
    var B = ut();
    B.removeEventListener("mousedown", gt, !0), B.removeEventListener("touchend", gt, gr), B.removeEventListener("touchstart", Jt, gr), B.removeEventListener("touchmove", Kt, gr);
  }
  function xn(B, he) {
    en(B, function() {
      !S.state.isVisible && x.parentNode && x.parentNode.contains(x) && he();
    });
  }
  function Xt(B, he) {
    en(B, he);
  }
  function en(B, he) {
    var ve = ht().box;
    function et($e) {
      $e.target === ve && (zf(ve, "remove", et), he());
    }
    if (B === 0)
      return he();
    zf(ve, "remove", f), zf(ve, "add", et), f = et;
  }
  function hn(B, he, ve) {
    ve === void 0 && (ve = !1);
    var et = bs(S.props.triggerTarget || n);
    et.forEach(function($e) {
      $e.addEventListener(B, he, ve), y.push({
        node: $e,
        eventType: B,
        handler: he,
        options: ve
      });
    });
  }
  function dn() {
    ge() && (hn("touchstart", Zn, {
      passive: !0
    }), hn("touchend", Oe, {
      passive: !0
    })), X4(S.props.trigger).forEach(function(B) {
      if (B !== "manual")
        switch (hn(B, Zn), B) {
          case "mouseenter":
            hn("mouseleave", Oe);
            break;
          case "focus":
            hn(iQ ? "focusout" : "blur", ai);
            break;
          case "focusin":
            hn("focusout", ai);
            break;
        }
    });
  }
  function En() {
    y.forEach(function(B) {
      var he = B.node, ve = B.eventType, et = B.handler, $e = B.options;
      he.removeEventListener(ve, et, $e);
    }), y = [];
  }
  function Zn(B) {
    var he, ve = !1;
    if (!(!S.state.isEnabled || Mt(B) || s)) {
      var et = ((he = d) == null ? void 0 : he.type) === "focus";
      d = B, w = B.currentTarget, xt(), !S.state.isVisible && K4(B) && sh.forEach(function($e) {
        return $e(B);
      }), B.type === "click" && (S.props.trigger.indexOf("mouseenter") < 0 || r) && S.props.hideOnClick !== !1 && S.state.isVisible ? ve = !0 : X(B), B.type === "click" && (r = !ve), ve && !et && le(B);
    }
  }
  function $(B) {
    var he = B.target, ve = me().contains(he) || x.contains(he);
    if (!(B.type === "mousemove" && ve)) {
      var et = N().concat(x).map(function($e) {
        var gn, Hn = $e._tippy, xa = (gn = Hn.popperInstance) == null ? void 0 : gn.state;
        return xa ? {
          popperRect: $e.getBoundingClientRect(),
          popperState: xa,
          props: t
        } : null;
      }).filter(Boolean);
      U4(et, B) && (ft(), le(B));
    }
  }
  function Oe(B) {
    var he = Mt(B) || S.props.trigger.indexOf("click") >= 0 && r;
    if (!he) {
      if (S.props.interactive) {
        S.hideWithInteractivity(B);
        return;
      }
      le(B);
    }
  }
  function ai(B) {
    S.props.trigger.indexOf("focusin") < 0 && B.target !== me() || S.props.interactive && B.relatedTarget && x.contains(B.relatedTarget) || le(B);
  }
  function Mt(B) {
    return da.isTouch ? ge() !== B.type.indexOf("touch") >= 0 : !1;
  }
  function oi() {
    oa();
    var B = S.props, he = B.popperOptions, ve = B.placement, et = B.offset, $e = B.getReferenceClientRect, gn = B.moveTransition, Hn = re() ? um(x).arrow : null, xa = $e ? {
      getBoundingClientRect: $e,
      contextElement: $e.contextElement || me()
    } : n, su = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Wr) {
        var lo = Wr.state;
        if (re()) {
          var Gl = ht(), lu = Gl.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Qr) {
            Qr === "placement" ? lu.setAttribute("data-placement", lo.placement) : lo.attributes.popper["data-popper-" + Qr] ? lu.setAttribute("data-" + Qr, "") : lu.removeAttribute("data-" + Qr);
          }), lo.attributes.popper = {};
        }
      }
    }, Ea = [{
      name: "offset",
      options: {
        offset: et
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !gn
      }
    }, su];
    re() && Hn && Ea.push({
      name: "arrow",
      options: {
        element: Hn,
        padding: 3
      }
    }), Ea.push.apply(Ea, (he == null ? void 0 : he.modifiers) || []), S.popperInstance = I4(xa, x, Object.assign({}, he, {
      placement: ve,
      onFirstUpdate: p,
      modifiers: Ea
    }));
  }
  function oa() {
    S.popperInstance && (S.popperInstance.destroy(), S.popperInstance = null);
  }
  function D() {
    var B = S.props.appendTo, he, ve = me();
    S.props.interactive && B === Kj || B === "parent" ? he = ve.parentNode : he = zj(B, [ve]), he.contains(x) || he.appendChild(x), S.state.isMounted = !0, oi(), process.env.NODE_ENV !== "production" && Wa(S.props.interactive && B === pi.appendTo && ve.nextElementSibling !== x, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function N() {
    return Vh(x.querySelectorAll("[data-tippy-root]"));
  }
  function X(B) {
    S.clearDelayTimeouts(), B && Ae("onTrigger", [S, B]), pt();
    var he = ze(!0), ve = te(), et = ve[0], $e = ve[1];
    da.isTouch && et === "hold" && $e && (he = $e), he ? i = setTimeout(function() {
      S.show();
    }, he) : S.show();
  }
  function le(B) {
    if (S.clearDelayTimeouts(), Ae("onUntrigger", [S, B]), !S.state.isVisible) {
      Ee();
      return;
    }
    if (!(S.props.trigger.indexOf("mouseenter") >= 0 && S.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(B.type) >= 0 && r)) {
      var he = ze(!1);
      he ? a = setTimeout(function() {
        S.state.isVisible && S.hide();
      }, he) : o = requestAnimationFrame(function() {
        S.hide();
      });
    }
  }
  function it() {
    S.state.isEnabled = !0;
  }
  function Je() {
    S.hide(), S.state.isEnabled = !1;
  }
  function We() {
    clearTimeout(i), clearTimeout(a), cancelAnimationFrame(o);
  }
  function Z(B) {
    if (process.env.NODE_ENV !== "production" && Wa(S.state.isDestroyed, gs("setProps")), !S.state.isDestroyed) {
      Ae("onBeforeUpdate", [S, B]), En();
      var he = S.props, ve = a1(n, Object.assign({}, he, qC(B), {
        ignoreAttributes: !0
      }));
      S.props = ve, dn(), he.interactiveDebounce !== ve.interactiveDebounce && (ft(), m = VC($, ve.interactiveDebounce)), he.triggerTarget && !ve.triggerTarget ? bs(he.triggerTarget).forEach(function(et) {
        et.removeAttribute("aria-expanded");
      }) : ve.triggerTarget && n.removeAttribute("aria-expanded"), xt(), Ge(), M && M(he, ve), S.popperInstance && (oi(), N().forEach(function(et) {
        requestAnimationFrame(et._tippy.popperInstance.forceUpdate);
      })), Ae("onAfterUpdate", [S, B]);
    }
  }
  function z(B) {
    S.setProps({
      content: B
    });
  }
  function Be() {
    process.env.NODE_ENV !== "production" && Wa(S.state.isDestroyed, gs("show"));
    var B = S.state.isVisible, he = S.state.isDestroyed, ve = !S.state.isEnabled, et = da.isTouch && !S.props.touch, $e = Qf(S.props.duration, 0, pi.duration);
    if (!(B || he || ve || et) && !me().hasAttribute("disabled") && (Ae("onShow", [S], !1), S.props.onShow(S) !== !1)) {
      if (S.state.isVisible = !0, re() && (x.style.visibility = "visible"), Ge(), pt(), S.state.isMounted || (x.style.transition = "none"), re()) {
        var gn = ht(), Hn = gn.box, xa = gn.content;
        Kf([Hn, xa], 0);
      }
      p = function() {
        var Ea;
        if (!(!S.state.isVisible || h)) {
          if (h = !0, x.offsetHeight, x.style.transition = S.props.moveTransition, re() && S.props.animation) {
            var uu = ht(), Wr = uu.box, lo = uu.content;
            Kf([Wr, lo], $e), e1([Wr, lo], "visible");
          }
          It(), xt(), UC($f, S), (Ea = S.popperInstance) == null || Ea.forceUpdate(), Ae("onMount", [S]), S.props.animation && re() && Xt($e, function() {
            S.state.isShown = !0, Ae("onShown", [S]);
          });
        }
      }, D();
    }
  }
  function mt() {
    process.env.NODE_ENV !== "production" && Wa(S.state.isDestroyed, gs("hide"));
    var B = !S.state.isVisible, he = S.state.isDestroyed, ve = !S.state.isEnabled, et = Qf(S.props.duration, 1, pi.duration);
    if (!(B || he || ve) && (Ae("onHide", [S], !1), S.props.onHide(S) !== !1)) {
      if (S.state.isVisible = !1, S.state.isShown = !1, h = !1, r = !1, re() && (x.style.visibility = "hidden"), ft(), Ee(), Ge(!0), re()) {
        var $e = ht(), gn = $e.box, Hn = $e.content;
        S.props.animation && (Kf([gn, Hn], et), e1([gn, Hn], "hidden"));
      }
      It(), xt(), S.props.animation ? re() && xn(et, S.unmount) : S.unmount();
    }
  }
  function Bn(B) {
    process.env.NODE_ENV !== "production" && Wa(S.state.isDestroyed, gs("hideWithInteractivity")), ut().addEventListener("mousemove", m), UC(sh, m), m(B);
  }
  function ra() {
    process.env.NODE_ENV !== "production" && Wa(S.state.isDestroyed, gs("unmount")), S.state.isVisible && S.hide(), S.state.isMounted && (oa(), N().forEach(function(B) {
      B._tippy.unmount();
    }), x.parentNode && x.parentNode.removeChild(x), $f = $f.filter(function(B) {
      return B !== S;
    }), S.state.isMounted = !1, Ae("onHidden", [S]));
  }
  function ki() {
    process.env.NODE_ENV !== "production" && Wa(S.state.isDestroyed, gs("destroy")), !S.state.isDestroyed && (S.clearDelayTimeouts(), S.unmount(), En(), delete n._tippy, S.state.isDestroyed = !0, Ae("onDestroy", [S]));
  }
}
function au(n, e) {
  e === void 0 && (e = {});
  var t = pi.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (rQ(n), eT(e, t)), tQ();
  var i = Object.assign({}, e, {
    plugins: t
  }), a = $4(n);
  if (process.env.NODE_ENV !== "production") {
    var o = xl(i.content), r = a.length > 1;
    Wa(o && r, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var s = a.reduce(function(l, h) {
    var d = h && gQ(h, i);
    return d && l.push(d), l;
  }, []);
  return xl(n) ? s[0] : s;
}
au.defaultProps = pi;
au.setDefaultProps = lQ;
au.currentInput = da;
Object.assign({}, Rj, {
  effect: function(e) {
    var t = e.state, i = {
      popper: {
        position: t.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(t.elements.popper.style, i.popper), t.styles = i, t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow);
  }
});
au.setDefaultProps({
  render: tT
});
class fQ {
  constructor({ editor: e, element: t, view: i, tippyOptions: a = {}, updateDelay: o = 250, shouldShow: r }) {
    this.preventHide = !1, this.shouldShow = ({ view: s, state: l, from: h, to: d }) => {
      const { doc: f, selection: p } = l, { empty: y } = p, m = !f.textBetween(h, d).length && yy(l.selection), w = this.element.contains(document.activeElement);
      return !(!(s.hasFocus() || w) || y || m || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: s }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      s != null && s.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(s.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s });
    }, this.handleDebouncedUpdate = (s, l) => {
      const h = !(l != null && l.selection.eq(s.state.selection)), d = !(l != null && l.doc.eq(s.state.doc));
      !h && !d || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(s, h, d, l);
      }, this.updateDelay));
    }, this.updateHandler = (s, l, h, d) => {
      var f, p, y;
      const { state: m, composing: w } = s, { selection: v } = m;
      if (w || !l && !h)
        return;
      this.createTooltip();
      const { ranges: L } = v, T = Math.min(...L.map((x) => x.$from.pos)), S = Math.max(...L.map((x) => x.$to.pos));
      if (!((f = this.shouldShow) === null || f === void 0 ? void 0 : f.call(this, {
        editor: this.editor,
        view: s,
        state: m,
        oldState: d,
        from: T,
        to: S
      }))) {
        this.hide();
        return;
      }
      (p = this.tippy) === null || p === void 0 || p.setProps({
        getReferenceClientRect: ((y = this.tippyOptions) === null || y === void 0 ? void 0 : y.getReferenceClientRect) || (() => {
          if (Oj(m.selection)) {
            let x = s.nodeDOM(T);
            const M = x.dataset.nodeViewWrapper ? x : x.querySelector("[data-node-view-wrapper]");
            if (M && (x = M.firstChild), x)
              return x.getBoundingClientRect();
          }
          return Aj(s, T, S);
        })
      }), this.show();
    }, this.editor = e, this.element = t, this.view = i, this.updateDelay = o, r && (this.shouldShow = r), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = a, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, t = !!e.parentElement;
    this.tippy || !t || (this.tippy = au(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, t) {
    const { state: i } = e, a = i.selection.from !== i.selection.to;
    if (this.updateDelay > 0 && a) {
      this.handleDebouncedUpdate(e, t);
      return;
    }
    const o = !(t != null && t.selection.eq(e.state.selection)), r = !(t != null && t.doc.eq(e.state.doc));
    this.updateHandler(e, o, r, t);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, t;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const nT = (n) => new ii({
  key: typeof n.pluginKey == "string" ? new La(n.pluginKey) : n.pluginKey,
  view: (e) => new fQ({ view: e, ...n })
});
Jn.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      nT({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class pQ {
  constructor({ editor: e, element: t, view: i, tippyOptions: a = {}, shouldShow: o }) {
    this.preventHide = !1, this.shouldShow = ({ view: r, state: s }) => {
      const { selection: l } = s, { $anchor: h, empty: d } = l, f = h.depth === 1, p = h.parent.isTextblock && !h.parent.type.spec.code && !h.parent.textContent;
      return !(!r.hasFocus() || !d || !f || !p || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: r }) => {
      var s;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      r != null && r.relatedTarget && (!((s = this.element.parentNode) === null || s === void 0) && s.contains(r.relatedTarget)) || this.hide();
    }, this.tippyBlurHandler = (r) => {
      this.blurHandler({ event: r });
    }, this.editor = e, this.element = t, this.view = i, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = a, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, t = !!e.parentElement;
    this.tippy || !t || (this.tippy = au(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, t) {
    var i, a, o;
    const { state: r } = e, { doc: s, selection: l } = r, { from: h, to: d } = l;
    if (t && t.doc.eq(s) && t.selection.eq(l))
      return;
    if (this.createTooltip(), !((i = this.shouldShow) === null || i === void 0 ? void 0 : i.call(this, {
      editor: this.editor,
      view: e,
      state: r,
      oldState: t
    }))) {
      this.hide();
      return;
    }
    (a = this.tippy) === null || a === void 0 || a.setProps({
      getReferenceClientRect: ((o = this.tippyOptions) === null || o === void 0 ? void 0 : o.getReferenceClientRect) || (() => Aj(e, h, d))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, t;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const iT = (n) => new ii({
  key: typeof n.pluginKey == "string" ? new La(n.pluginKey) : n.pluginKey,
  view: (e) => new pQ({ view: e, ...n })
});
Jn.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      iT({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const mQ = Xe({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(n, { slots: e }) {
    const t = vn(null);
    return Vs(() => {
      const { updateDelay: i, editor: a, pluginKey: o, shouldShow: r, tippyOptions: s } = n;
      a.registerPlugin(nT({
        updateDelay: i,
        editor: a,
        element: t.value,
        pluginKey: o,
        shouldShow: r,
        tippyOptions: s
      }));
    }), Al(() => {
      const { pluginKey: i, editor: a } = n;
      a.unregisterPlugin(i);
    }), () => {
      var i;
      return ao("div", { ref: t }, (i = e.default) === null || i === void 0 ? void 0 : i.call(e));
    };
  }
});
function s1(n) {
  return yA((e, t) => ({
    get() {
      return e(), n;
    },
    set(i) {
      n = i, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          t();
        });
      });
    }
  }));
}
class yQ extends O5 {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = s1(this.view.state), this.reactiveExtensionStorage = s1(this.extensionStorage), this.on("beforeTransaction", ({ nextState: t }) => {
      this.reactiveState.value = t, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), mA(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, t) {
    super.registerPlugin(e, t), this.reactiveState.value = this.view.state;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    super.unregisterPlugin(e), this.reactiveState.value = this.view.state;
  }
}
const bQ = Xe({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(n) {
    const e = vn(), t = Zr();
    return pA(() => {
      const i = n.editor;
      i && i.options.element && e.value && W1(() => {
        if (!e.value || !i.options.element.firstChild)
          return;
        const a = I(e.value);
        e.value.append(...i.options.element.childNodes), i.contentComponent = t.ctx._, t && (i.appContext = {
          ...t.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: t.provides
        }), i.setOptions({
          element: a
        }), i.createNodeViews();
      });
    }), Al(() => {
      const i = n.editor;
      if (!i || (i.isDestroyed || i.view.setProps({
        nodeViews: {}
      }), i.contentComponent = null, i.appContext = null, !i.options.element.firstChild))
        return;
      const a = document.createElement("div");
      a.append(...i.options.element.childNodes), i.setOptions({
        element: a
      });
    }), { rootEl: e };
  },
  render() {
    return ao("div", {
      ref: (n) => {
        this.rootEl = n;
      }
    });
  }
});
Xe({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(n, { slots: e }) {
    const t = vn(null);
    return Vs(() => {
      const { pluginKey: i, editor: a, tippyOptions: o, shouldShow: r } = n;
      a.registerPlugin(iT({
        pluginKey: i,
        editor: a,
        element: t.value,
        tippyOptions: o,
        shouldShow: r
      }));
    }), Al(() => {
      const { pluginKey: i, editor: a } = n;
      a.unregisterPlugin(i);
    }), () => {
      var i;
      return ao("div", { ref: t }, (i = e.default) === null || i === void 0 ? void 0 : i.call(e));
    };
  }
});
Xe({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return ao(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
Xe({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var n, e;
    return ao(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (n = this.$slots).default) === null || e === void 0 ? void 0 : e.call(n));
  }
});
const wQ = (n = {}) => {
  const e = wm();
  return Vs(() => {
    e.value = new yQ(n);
  }), Al(() => {
    var t;
    (t = e.value) === null || t === void 0 || t.destroy();
  }), e;
}, vQ = /^\s*>\s$/, CQ = Si.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["blockquote", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: n }) => n.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: n }) => n.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: n }) => n.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      jl({
        find: vQ,
        type: this.type
      })
    ];
  }
}), SQ = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, kQ = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, _Q = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, jQ = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, TQ = ja.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (n) => n.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (n) => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["strong", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: n }) => n.setMark(this.name),
      toggleBold: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetBold: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Hs({
        find: SQ,
        type: this.type
      }),
      Hs({
        find: _Q,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Xs({
        find: kQ,
        type: this.type
      }),
      Xs({
        find: jQ,
        type: this.type
      })
    ];
  }
}), LQ = Si.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["li", Ut(this.options.HTMLAttributes, n), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), u1 = ja.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (n) => n.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: n, commands: e }) => {
        const t = Ad(n, this.type);
        return Object.entries(t).some(([, a]) => !!a) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), l1 = /^\s*([-+*])\s$/, xQ = Si.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["ul", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(LQ.name, this.editor.getAttributes(u1.name)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let n = jl({
      find: l1,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (n = jl({
      find: l1,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(u1.name),
      editor: this.editor
    })), [
      n
    ];
  }
}), EQ = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/, DQ = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g, MQ = ja.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["code", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: n }) => n.setMark(this.name),
      toggleCode: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetCode: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Hs({
        find: EQ,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Xs({
        find: DQ,
        type: this.type
      })
    ];
  }
}), NQ = /^```([a-z]+)?[\s\n]$/, OQ = /^~~~([a-z]+)?[\s\n]$/, AQ = Si.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (n) => {
          var e;
          const { languageClassPrefix: t } = this.options, o = [...((e = n.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((r) => r.startsWith(t)).map((r) => r.replace(t, ""))[0];
          return o || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [
      "pre",
      Ut(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: n.attrs.language ? this.options.languageClassPrefix + n.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (n) => ({ commands: e }) => e.setNode(this.name, n),
      toggleCodeBlock: (n) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: n, $anchor: e } = this.editor.state.selection, t = e.pos === 1;
        return !n || e.parent.type.name !== this.name ? !1 : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: n }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = n, { selection: t } = e, { $from: i, empty: a } = t;
        if (!a || i.parent.type !== this.type)
          return !1;
        const o = i.parentOffset === i.parent.nodeSize - 2, r = i.parent.textContent.endsWith(`

`);
        return !o || !r ? !1 : n.chain().command(({ tr: s }) => (s.delete(i.pos - 2, i.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: n }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = n, { selection: t, doc: i } = e, { $from: a, empty: o } = t;
        if (!o || a.parent.type !== this.type || !(a.parentOffset === a.parent.nodeSize - 2))
          return !1;
        const s = a.after();
        return s === void 0 ? !1 : i.nodeAt(s) ? n.commands.command(({ tr: h }) => (h.setSelection(Pe.near(i.resolve(s))), !0)) : n.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      nm({
        find: NQ,
        type: this.type,
        getAttributes: (n) => ({
          language: n[1]
        })
      }),
      nm({
        find: OQ,
        type: this.type,
        getAttributes: (n) => ({
          language: n[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new ii({
        key: new La("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (n, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const t = e.clipboardData.getData("text/plain"), i = e.clipboardData.getData("vscode-editor-data"), a = i ? JSON.parse(i) : void 0, o = a == null ? void 0 : a.mode;
            if (!t || !o)
              return !1;
            const { tr: r, schema: s } = n.state, l = s.text(t.replace(/\r\n?/g, `
`));
            return r.replaceSelectionWith(this.type.create({ language: o }, l)), r.selection.$from.parent.type !== this.type && r.setSelection(Me.near(r.doc.resolve(Math.max(0, r.selection.from - 2)))), r.setMeta("paste", !0), n.dispatch(r), !0;
          }
        }
      })
    ];
  }
}), YQ = Si.create({
  name: "doc",
  topNode: !0,
  content: "block+"
});
function PQ(n = {}) {
  return new ii({
    view(e) {
      return new RQ(e, n);
    }
  });
}
class RQ {
  constructor(e, t) {
    var i;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (i = t.width) !== null && i !== void 0 ? i : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((a) => {
      let o = (r) => {
        this[a](r);
      };
      return e.dom.addEventListener(a, o), { name: a, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, i;
    if (t) {
      let s = e.nodeBefore, l = e.nodeAfter;
      if (s || l) {
        let h = this.editorView.nodeDOM(this.cursorPos - (s ? s.nodeSize : 0));
        if (h) {
          let d = h.getBoundingClientRect(), f = s ? d.bottom : d.top;
          s && l && (f = (f + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), i = { left: d.left, right: d.right, top: f - this.width / 2, bottom: f + this.width / 2 };
        }
      }
    }
    if (!i) {
      let s = this.editorView.coordsAtPos(this.cursorPos);
      i = { left: s.left - this.width / 2, right: s.left + this.width / 2, top: s.top, bottom: s.bottom };
    }
    let a = this.editorView.dom.offsetParent;
    this.element || (this.element = a.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let o, r;
    if (!a || a == document.body && getComputedStyle(a).position == "static")
      o = -pageXOffset, r = -pageYOffset;
    else {
      let s = a.getBoundingClientRect();
      o = s.left - a.scrollLeft, r = s.top - a.scrollTop;
    }
    this.element.style.left = i.left - o + "px", this.element.style.top = i.top - r + "px", this.element.style.width = i.right - i.left + "px", this.element.style.height = i.bottom - i.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), i = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), a = i && i.type.spec.disableDropCursor, o = typeof a == "function" ? a(this.editorView, t, e) : a;
    if (t && !o) {
      let r = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let s = D_(this.editorView.state.doc, r, this.editorView.dragging.slice);
        s != null && (r = s);
      }
      this.setCursor(r), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
const FQ = Jn.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      PQ(this.options)
    ];
  }
});
class Rt extends Pe {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let i = e.resolve(t.map(this.head));
    return Rt.valid(i) ? new Rt(i) : Pe.near(i);
  }
  content() {
    return ue.empty;
  }
  eq(e) {
    return e instanceof Rt && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Rt(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new xy(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !IQ(e) || !JQ(e))
      return !1;
    let i = t.type.spec.allowGapCursor;
    if (i != null)
      return i;
    let a = t.contentMatchAt(e.index()).defaultType;
    return a && a.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, i = !1) {
    e: for (; ; ) {
      if (!i && Rt.valid(e))
        return e;
      let a = e.pos, o = null;
      for (let r = e.depth; ; r--) {
        let s = e.node(r);
        if (t > 0 ? e.indexAfter(r) < s.childCount : e.index(r) > 0) {
          o = s.child(t > 0 ? e.indexAfter(r) : e.index(r) - 1);
          break;
        } else if (r == 0)
          return null;
        a += t;
        let l = e.doc.resolve(a);
        if (Rt.valid(l))
          return l;
      }
      for (; ; ) {
        let r = t > 0 ? o.firstChild : o.lastChild;
        if (!r) {
          if (o.isAtom && !o.isText && !Ce.isSelectable(o)) {
            e = e.doc.resolve(a + o.nodeSize * t), i = !1;
            continue e;
          }
          break;
        }
        o = r, a += t;
        let s = e.doc.resolve(a);
        if (Rt.valid(s))
          return s;
      }
      return null;
    }
  }
}
Rt.prototype.visible = !1;
Rt.findFrom = Rt.findGapCursorFrom;
Pe.jsonID("gapcursor", Rt);
class xy {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new xy(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return Rt.valid(t) ? new Rt(t) : Pe.near(t);
  }
}
function IQ(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), i = n.node(e);
    if (t == 0) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    for (let a = i.child(t - 1); ; a = a.lastChild) {
      if (a.childCount == 0 && !a.inlineContent || a.isAtom || a.type.spec.isolating)
        return !0;
      if (a.inlineContent)
        return !1;
    }
  }
  return !0;
}
function JQ(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), i = n.node(e);
    if (t == i.childCount) {
      if (i.type.spec.isolating)
        return !0;
      continue;
    }
    for (let a = i.child(t); ; a = a.firstChild) {
      if (a.childCount == 0 && !a.inlineContent || a.isAtom || a.type.spec.isolating)
        return !0;
      if (a.inlineContent)
        return !1;
    }
  }
  return !0;
}
function ZQ() {
  return new ii({
    props: {
      decorations: GQ,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && Rt.valid(t) ? new Rt(t) : null;
      },
      handleClick: HQ,
      handleKeyDown: BQ,
      handleDOMEvents: { beforeinput: XQ }
    }
  });
}
const BQ = yj({
  ArrowLeft: uh("horiz", -1),
  ArrowRight: uh("horiz", 1),
  ArrowUp: uh("vert", -1),
  ArrowDown: uh("vert", 1)
});
function uh(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(i, a, o) {
    let r = i.selection, s = e > 0 ? r.$to : r.$from, l = r.empty;
    if (r instanceof Me) {
      if (!o.endOfTextblock(t) || s.depth == 0)
        return !1;
      l = !1, s = i.doc.resolve(e > 0 ? s.after() : s.before());
    }
    let h = Rt.findGapCursorFrom(s, e, l);
    return h ? (a && a(i.tr.setSelection(new Rt(h))), !0) : !1;
  };
}
function HQ(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let i = n.state.doc.resolve(e);
  if (!Rt.valid(i))
    return !1;
  let a = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return a && a.inside > -1 && Ce.isSelectable(n.state.doc.nodeAt(a.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new Rt(i))), !0);
}
function XQ(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof Rt))
    return !1;
  let { $from: t } = n.state.selection, i = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!i)
    return !1;
  let a = U.empty;
  for (let r = i.length - 1; r >= 0; r--)
    a = U.from(i[r].createAndFill(null, a));
  let o = n.state.tr.replace(t.pos, t.pos, new ue(a, 0, 0));
  return o.setSelection(Me.near(o.doc.resolve(t.pos + 1))), n.dispatch(o), !1;
}
function GQ(n) {
  if (!(n.selection instanceof Rt))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Vt.create(n.doc, [Pi.widget(n.selection.head, e, { key: "gapcursor" })]);
}
const WQ = Jn.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      ZQ()
    ];
  },
  extendNodeSchema(n) {
    var e;
    const t = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      allowGapCursor: (e = Ze(fe(n, "allowGapCursor", t))) !== null && e !== void 0 ? e : null
    };
  }
}), QQ = Si.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["br", Ut(this.options.HTMLAttributes, n)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: n, chain: e, state: t, editor: i }) => n.first([
        () => n.exitCode(),
        () => n.command(() => {
          const { selection: a, storedMarks: o } = t;
          if (a.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: r } = this.options, { splittableMarks: s } = i.extensionManager, l = o || a.$to.parentOffset && a.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: h, dispatch: d }) => {
            if (d && l && r) {
              const f = l.filter((p) => s.includes(p.type.name));
              h.ensureMarks(f);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), KQ = Si.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((n) => ({
      tag: `h${n}`,
      attrs: { level: n }
    }));
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(n.attrs.level) ? n.attrs.level : this.options.levels[0]}`, Ut(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.setNode(this.name, n) : !1,
      toggleHeading: (n) => ({ commands: e }) => this.options.levels.includes(n.level) ? e.toggleNode(this.name, "paragraph", n) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((n, e) => ({
      ...n,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((n) => nm({
      find: new RegExp(`^(#{1,${n}})\\s$`),
      type: this.type,
      getAttributes: {
        level: n
      }
    }));
  }
});
var Uh = 200, un = function() {
};
un.prototype.append = function(e) {
  return e.length ? (e = un.from(e), !this.length && e || e.length < Uh && this.leafAppend(e) || this.length < Uh && e.leafPrepend(this) || this.appendInner(e)) : this;
};
un.prototype.prepend = function(e) {
  return e.length ? un.from(e).append(this) : this;
};
un.prototype.appendInner = function(e) {
  return new zQ(this, e);
};
un.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? un.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
un.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
un.prototype.forEach = function(e, t, i) {
  t === void 0 && (t = 0), i === void 0 && (i = this.length), t <= i ? this.forEachInner(e, t, i, 0) : this.forEachInvertedInner(e, t, i, 0);
};
un.prototype.map = function(e, t, i) {
  t === void 0 && (t = 0), i === void 0 && (i = this.length);
  var a = [];
  return this.forEach(function(o, r) {
    return a.push(e(o, r));
  }, t, i), a;
};
un.from = function(e) {
  return e instanceof un ? e : e && e.length ? new aT(e) : un.empty;
};
var aT = /* @__PURE__ */ function(n) {
  function e(i) {
    n.call(this), this.values = i;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(a, o) {
    return a == 0 && o == this.length ? this : new e(this.values.slice(a, o));
  }, e.prototype.getInner = function(a) {
    return this.values[a];
  }, e.prototype.forEachInner = function(a, o, r, s) {
    for (var l = o; l < r; l++)
      if (a(this.values[l], s + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(a, o, r, s) {
    for (var l = o - 1; l >= r; l--)
      if (a(this.values[l], s + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(a) {
    if (this.length + a.length <= Uh)
      return new e(this.values.concat(a.flatten()));
  }, e.prototype.leafPrepend = function(a) {
    if (this.length + a.length <= Uh)
      return new e(a.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(un);
un.empty = new aT([]);
var zQ = /* @__PURE__ */ function(n) {
  function e(t, i) {
    n.call(this), this.left = t, this.right = i, this.length = t.length + i.length, this.depth = Math.max(t.depth, i.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  }, e.prototype.forEachInner = function(i, a, o, r) {
    var s = this.left.length;
    if (a < s && this.left.forEachInner(i, a, Math.min(o, s), r) === !1 || o > s && this.right.forEachInner(i, Math.max(a - s, 0), Math.min(this.length, o) - s, r + s) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(i, a, o, r) {
    var s = this.left.length;
    if (a > s && this.right.forEachInvertedInner(i, a - s, Math.max(o, s) - s, r + s) === !1 || o < s && this.left.forEachInvertedInner(i, Math.min(a, s), o, r) === !1)
      return !1;
  }, e.prototype.sliceInner = function(i, a) {
    if (i == 0 && a == this.length)
      return this;
    var o = this.left.length;
    return a <= o ? this.left.slice(i, a) : i >= o ? this.right.slice(i - o, a - o) : this.left.slice(i, o).append(this.right.slice(0, a - o));
  }, e.prototype.leafAppend = function(i) {
    var a = this.right.leafAppend(i);
    if (a)
      return new e(this.left, a);
  }, e.prototype.leafPrepend = function(i) {
    var a = this.left.leafPrepend(i);
    if (a)
      return new e(a, this.right);
  }, e.prototype.appendInner = function(i) {
    return this.left.depth >= Math.max(this.right.depth, i.depth) + 1 ? new e(this.left, new e(this.right, i)) : new e(this, i);
  }, e;
}(un);
const $Q = 500;
class Ui {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let i = this.items.length;
    for (; ; i--)
      if (this.items.get(i - 1).selection) {
        --i;
        break;
      }
    let a, o;
    t && (a = this.remapping(i, this.items.length), o = a.maps.length);
    let r = e.tr, s, l, h = [], d = [];
    return this.items.forEach((f, p) => {
      if (!f.step) {
        a || (a = this.remapping(i, p + 1), o = a.maps.length), o--, d.push(f);
        return;
      }
      if (a) {
        d.push(new ca(f.map));
        let y = f.step.map(a.slice(o)), m;
        y && r.maybeStep(y).doc && (m = r.mapping.maps[r.mapping.maps.length - 1], h.push(new ca(m, void 0, void 0, h.length + d.length))), o--, m && a.appendMap(m, o);
      } else
        r.maybeStep(f.step);
      if (f.selection)
        return s = a ? f.selection.map(a.slice(o)) : f.selection, l = new Ui(this.items.slice(0, i).append(d.reverse().concat(h)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: r, selection: s };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, i, a) {
    let o = [], r = this.eventCount, s = this.items, l = !a && s.length ? s.get(s.length - 1) : null;
    for (let d = 0; d < e.steps.length; d++) {
      let f = e.steps[d].invert(e.docs[d]), p = new ca(e.mapping.maps[d], f, t), y;
      (y = l && l.merge(p)) && (p = y, d ? o.pop() : s = s.slice(0, s.length - 1)), o.push(p), t && (r++, t = void 0), a || (l = p);
    }
    let h = r - i.depth;
    return h > UQ && (s = VQ(s, h), r -= h), new Ui(s.append(o), r);
  }
  remapping(e, t) {
    let i = new Os();
    return this.items.forEach((a, o) => {
      let r = a.mirrorOffset != null && o - a.mirrorOffset >= e ? i.maps.length - a.mirrorOffset : void 0;
      i.appendMap(a.map, r);
    }, e, t), i;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Ui(this.items.append(e.map((t) => new ca(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let i = [], a = Math.max(0, this.items.length - t), o = e.mapping, r = e.steps.length, s = this.eventCount;
    this.items.forEach((p) => {
      p.selection && s--;
    }, a);
    let l = t;
    this.items.forEach((p) => {
      let y = o.getMirror(--l);
      if (y == null)
        return;
      r = Math.min(r, y);
      let m = o.maps[y];
      if (p.step) {
        let w = e.steps[y].invert(e.docs[y]), v = p.selection && p.selection.map(o.slice(l + 1, y));
        v && s++, i.push(new ca(m, w, v));
      } else
        i.push(new ca(m));
    }, a);
    let h = [];
    for (let p = t; p < r; p++)
      h.push(new ca(o.maps[p]));
    let d = this.items.slice(0, a).append(h).append(i), f = new Ui(d, s);
    return f.emptyItemCount() > $Q && (f = f.compress(this.items.length - i.length)), f;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), i = t.maps.length, a = [], o = 0;
    return this.items.forEach((r, s) => {
      if (s >= e)
        a.push(r), r.selection && o++;
      else if (r.step) {
        let l = r.step.map(t.slice(i)), h = l && l.getMap();
        if (i--, h && t.appendMap(h, i), l) {
          let d = r.selection && r.selection.map(t.slice(i));
          d && o++;
          let f = new ca(h.invert(), l, d), p, y = a.length - 1;
          (p = a.length && a[y].merge(f)) ? a[y] = p : a.push(f);
        }
      } else r.map && i--;
    }, this.items.length, 0), new Ui(un.from(a.reverse()), o);
  }
}
Ui.empty = new Ui(un.empty, 0);
function VQ(n, e) {
  let t;
  return n.forEach((i, a) => {
    if (i.selection && e-- == 0)
      return t = a, !1;
  }), n.slice(t);
}
class ca {
  constructor(e, t, i, a) {
    this.map = e, this.step = t, this.selection = i, this.mirrorOffset = a;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new ca(t.getMap().invert(), t, this.selection);
    }
  }
}
class To {
  constructor(e, t, i, a, o) {
    this.done = e, this.undone = t, this.prevRanges = i, this.prevTime = a, this.prevComposition = o;
  }
}
const UQ = 20;
function qQ(n, e, t, i) {
  let a = t.getMeta(Dr), o;
  if (a)
    return a.historyState;
  t.getMeta(nK) && (n = new To(n.done, n.undone, null, 0, -1));
  let r = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (r && r.getMeta(Dr))
    return r.getMeta(Dr).redo ? new To(n.done.addTransform(t, void 0, i, Ch(e)), n.undone, c1(t.mapping.maps), n.prevTime, n.prevComposition) : new To(n.done, n.undone.addTransform(t, void 0, i, Ch(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(r && r.getMeta("addToHistory") === !1)) {
    let s = t.getMeta("composition"), l = n.prevTime == 0 || !r && n.prevComposition != s && (n.prevTime < (t.time || 0) - i.newGroupDelay || !eK(t, n.prevRanges)), h = r ? Vf(n.prevRanges, t.mapping) : c1(t.mapping.maps);
    return new To(n.done.addTransform(t, l ? e.selection.getBookmark() : void 0, i, Ch(e)), Ui.empty, h, t.time, s ?? n.prevComposition);
  } else return (o = t.getMeta("rebased")) ? new To(n.done.rebased(t, o), n.undone.rebased(t, o), Vf(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new To(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), Vf(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function eK(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((i, a) => {
    for (let o = 0; o < e.length; o += 2)
      i <= e[o + 1] && a >= e[o] && (t = !0);
  }), t;
}
function c1(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((i, a, o, r) => e.push(o, r));
  return e;
}
function Vf(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let i = 0; i < n.length; i += 2) {
    let a = e.map(n[i], 1), o = e.map(n[i + 1], -1);
    a <= o && t.push(a, o);
  }
  return t;
}
function tK(n, e, t) {
  let i = Ch(e), a = Dr.get(e).spec.config, o = (t ? n.undone : n.done).popEvent(e, i);
  if (!o)
    return null;
  let r = o.selection.resolve(o.transform.doc), s = (t ? n.done : n.undone).addTransform(o.transform, e.selection.getBookmark(), a, i), l = new To(t ? s : o.remaining, t ? o.remaining : s, null, 0, -1);
  return o.transform.setSelection(r).setMeta(Dr, { redo: t, historyState: l });
}
let Uf = !1, h1 = null;
function Ch(n) {
  let e = n.plugins;
  if (h1 != e) {
    Uf = !1, h1 = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        Uf = !0;
        break;
      }
  }
  return Uf;
}
const Dr = new La("history"), nK = new La("closeHistory");
function iK(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new ii({
    key: Dr,
    state: {
      init() {
        return new To(Ui.empty, Ui.empty, null, 0, -1);
      },
      apply(e, t, i) {
        return qQ(t, i, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let i = t.inputType, a = i == "historyUndo" ? rT : i == "historyRedo" ? sT : null;
          return a ? (t.preventDefault(), a(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function oT(n, e) {
  return (t, i) => {
    let a = Dr.getState(t);
    if (!a || (n ? a.undone : a.done).eventCount == 0)
      return !1;
    if (i) {
      let o = tK(a, t, n);
      o && i(e ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const rT = oT(!1, !0), sT = oT(!0, !0), aK = Jn.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: n, dispatch: e }) => rT(n, e),
      redo: () => ({ state: n, dispatch: e }) => sT(n, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      iK(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-Ñ": () => this.editor.commands.undo(),
      "Shift-Mod-Ñ": () => this.editor.commands.redo()
    };
  }
}), oK = Si.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["hr", Ut(this.options.HTMLAttributes, n)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: n, state: e }) => {
        const { selection: t } = e, { $from: i, $to: a } = t, o = n();
        return i.parentOffset === 0 ? o.insertContentAt({
          from: Math.max(i.pos - 1, 0),
          to: a.pos
        }, {
          type: this.name
        }) : Oj(t) ? o.insertContentAt(a.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ tr: r, dispatch: s }) => {
          var l;
          if (s) {
            const { $to: h } = r.selection, d = h.end();
            if (h.nodeAfter)
              h.nodeAfter.isTextblock ? r.setSelection(Me.create(r.doc, h.pos + 1)) : h.nodeAfter.isBlock ? r.setSelection(Ce.create(r.doc, h.pos)) : r.setSelection(Me.create(r.doc, h.pos));
            else {
              const f = (l = h.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              f && (r.insert(d, f), r.setSelection(Me.create(r.doc, d + 1)));
            }
            r.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      A5({
        find: /^(?:---|â€”-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), rK = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, sK = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, uK = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, lK = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, cK = ja.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (n) => n.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["em", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: n }) => n.setMark(this.name),
      toggleItalic: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetItalic: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Hs({
        find: rK,
        type: this.type
      }),
      Hs({
        find: uK,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Xs({
        find: sK,
        type: this.type
      }),
      Xs({
        find: lK,
        type: this.type
      })
    ];
  }
}), hK = Si.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["li", Ut(this.options.HTMLAttributes, n), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), dK = Si.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["li", Ut(this.options.HTMLAttributes, n), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), d1 = ja.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (n) => n.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["span", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: n, commands: e }) => {
        const t = Ad(n, this.type);
        return Object.entries(t).some(([, a]) => !!a) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), g1 = /^(\d+)\.\s$/, gK = Si.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (n) => n.hasAttribute("start") ? parseInt(n.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: void 0,
        parseHTML: (n) => n.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    const { start: e, ...t } = n;
    return e === 1 ? ["ol", Ut(this.options.HTMLAttributes, t), 0] : ["ol", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(dK.name, this.editor.getAttributes(d1.name)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let n = jl({
      find: g1,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (n = jl({
      find: g1,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(d1.name) }),
      joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1],
      editor: this.editor
    })), [
      n
    ];
  }
}), fK = Si.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["p", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: n }) => n.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), pK = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, mK = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, yK = ja.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (n) => n.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["s", Ut(this.options.HTMLAttributes, n), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: n }) => n.setMark(this.name),
      toggleStrike: () => ({ commands: n }) => n.toggleMark(this.name),
      unsetStrike: () => ({ commands: n }) => n.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Hs({
        find: pK,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Xs({
        find: mK,
        type: this.type
      })
    ];
  }
}), bK = Si.create({
  name: "text",
  group: "inline"
}), wK = Jn.create({
  name: "starterKit",
  addExtensions() {
    var n, e, t, i, a, o, r, s, l, h, d, f, p, y, m, w, v, _;
    const L = [];
    return this.options.bold !== !1 && L.push(TQ.configure((n = this.options) === null || n === void 0 ? void 0 : n.bold)), this.options.blockquote !== !1 && L.push(CQ.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== !1 && L.push(xQ.configure((t = this.options) === null || t === void 0 ? void 0 : t.bulletList)), this.options.code !== !1 && L.push(MQ.configure((i = this.options) === null || i === void 0 ? void 0 : i.code)), this.options.codeBlock !== !1 && L.push(AQ.configure((a = this.options) === null || a === void 0 ? void 0 : a.codeBlock)), this.options.document !== !1 && L.push(YQ.configure((o = this.options) === null || o === void 0 ? void 0 : o.document)), this.options.dropcursor !== !1 && L.push(FQ.configure((r = this.options) === null || r === void 0 ? void 0 : r.dropcursor)), this.options.gapcursor !== !1 && L.push(WQ.configure((s = this.options) === null || s === void 0 ? void 0 : s.gapcursor)), this.options.hardBreak !== !1 && L.push(QQ.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== !1 && L.push(KQ.configure((h = this.options) === null || h === void 0 ? void 0 : h.heading)), this.options.history !== !1 && L.push(aK.configure((d = this.options) === null || d === void 0 ? void 0 : d.history)), this.options.horizontalRule !== !1 && L.push(oK.configure((f = this.options) === null || f === void 0 ? void 0 : f.horizontalRule)), this.options.italic !== !1 && L.push(cK.configure((p = this.options) === null || p === void 0 ? void 0 : p.italic)), this.options.listItem !== !1 && L.push(hK.configure((y = this.options) === null || y === void 0 ? void 0 : y.listItem)), this.options.orderedList !== !1 && L.push(gK.configure((m = this.options) === null || m === void 0 ? void 0 : m.orderedList)), this.options.paragraph !== !1 && L.push(fK.configure((w = this.options) === null || w === void 0 ? void 0 : w.paragraph)), this.options.strike !== !1 && L.push(yK.configure((v = this.options) === null || v === void 0 ? void 0 : v.strike)), this.options.text !== !1 && L.push(bK.configure((_ = this.options) === null || _ === void 0 ? void 0 : _.text)), L;
  }
}), vK = { class: "rounded-main p-2 border border-solid border-body-dark" }, CK = { class: "flex gap-2 p-2 bg-white border border-solid border-body-dark rounded-main" }, lh = /* @__PURE__ */ Xe({
  __name: "BaseEditor",
  props: {
    modelValue: {
      type: String,
      default: ""
    }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, i = e, a = wQ({
      content: t.modelValue,
      extensions: [
        wK
      ],
      onUpdate: () => {
        a.value && i("update:modelValue", a.value.getHTML());
      }
    });
    return Al(() => {
      var o;
      (o = a.value) == null || o.destroy();
    }), Ua(() => t.modelValue, (o) => {
      !a.value || a.value.getHTML() === o || a.value.commands.setContent(o, !1);
    }), (o, r) => (q(), ie("div", vK, [
      V(I(bQ), { editor: I(a) }, null, 8, ["editor"]),
      I(a) ? (q(), ln(I(mQ), {
        key: 0,
        editor: I(a),
        "tippy-options": { duration: 100 }
      }, {
        default: se(() => [
          ae("div", CK, [
            ae("button", {
              onClick: r[0] || (r[0] = (s) => I(a).chain().focus().toggleBold().run()),
              class: va({ "font-bold": I(a).isActive("bold") })
            }, " bold ", 2),
            ae("button", {
              onClick: r[1] || (r[1] = (s) => I(a).chain().focus().toggleItalic().run()),
              class: va({ "font-bold": I(a).isActive("italic") })
            }, " italic ", 2),
            ae("button", {
              onClick: r[2] || (r[2] = (s) => I(a).chain().focus().toggleStrike().run()),
              class: va({ "font-bold": I(a).isActive("strike") })
            }, " strike ", 2)
          ])
        ]),
        _: 1
      }, 8, ["editor"])) : tt("", !0)
    ]));
  }
}), SK = ["value"], kK = /* @__PURE__ */ Xe({
  __name: "BaseSelect",
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    items: {
      type: Array,
      required: !0
    },
    optionId: {
      type: String,
      required: !0
    },
    optionLabel: {
      type: String,
      required: !0
    }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, a = od(t, "modelValue", e);
    return (o, r) => id((q(), ie("select", {
      label: "select",
      "onUpdate:modelValue": r[0] || (r[0] = (s) => Ol(a) ? a.value = s : null),
      class: "block bg-white rounded-main w-full p-2 border border-solid border-body-dark"
    }, [
      (q(!0), ie(Ht, null, Un(t.items, (s) => (q(), ie("option", {
        key: s[t.optionId],
        value: s[t.optionId]
      }, we(s[t.optionLabel]), 9, SK))), 128))
    ], 512)), [
      [bA, I(a)]
    ]);
  }
}), _K = { class: "text-lg font-bold" }, jK = {
  key: 0,
  class: "flex gap-2 items-center"
}, TK = {
  key: 1,
  class: "flex gap-2 mt-2"
}, LK = { key: 0 }, xK = { key: 1 }, EK = {
  key: 0,
  class: "flex flex-col gap-2"
}, DK = { class: "FormObject-Inner" }, MK = { class: "FormObject-Row" }, NK = { class: "FormObject-Row" }, OK = { class: "FormObject-Row" }, AK = { class: "my-2" }, YK = { class: "FormObject-Title" }, PK = { class: "FormObject-Row" }, RK = { class: "FormObject-Title" }, FK = { class: "FormObject-Row" }, IK = {
  key: 0,
  class: "FormObject-ArrowName"
}, JK = { class: "py-3 flex gap-1" }, ZK = /* @__PURE__ */ Xe({
  __name: "FormObject",
  setup(n) {
    const e = aS("FormObject"), {
      mapObjectCurrent: t,
      mapFile: i,
      mapObject: a,
      mapCurrent: o,
      drawer: r,
      mapObjectRemoved: s,
      mapObjectRelationRemoved: l,
      mapObjectUrl: h,
      controlCombo: d
    } = qt(), {
      patron: f,
      chain: p,
      guest: y
    } = vi(), m = new Ik(() => {
      const M = p.create();
      t.objectId(f.create(M.receiveKey("objectId"))), t.objectId(f.create((P) => {
        e("sep obj", P);
      })), i.currentMap(f.create(M.receiveKey("map"))), i.currentMap(f.create((P) => {
        e("sep map", P);
      })), M.result(f.create(
        y.create(({ map: P, objectId: Y }) => {
          e("object opened", Y), m.value = P.objects[Y];
        })
      ));
    }).ref(), w = o.types(new qe()).ref(), v = i.currentMap(new qe()).ref(), _ = new Zm(m), L = h.url(_, new qe()).ref(), T = () => {
      t.give(""), r.give("");
    }, S = () => {
      s.give(m.value), T();
    }, A = () => {
      a.give({
        ...m.value,
        outlink: m.value.outlink || L.value
      }), T();
    }, x = (M) => {
      l.give({
        index: M,
        object: m.value
      });
    };
    return d.happenedConditional(
      "KeyS",
      r.openedByName("object"),
      f.create(y.create(A))
    ), (M, P) => (q(), ln(Um, {
      name: "object",
      onClose: T
    }, {
      header: se(() => [
        ae("h2", _K, we(M.$t("general.mapObject")), 1),
        I(m) ? (q(), ie("small", jK, [
          ae("span", null, " ID #" + we(I(m).id), 1)
        ])) : tt("", !0),
        I(m) ? (q(), ie("div", TK, [
          I(m).createTimestamp ? (q(), ie("div", LK, " Ð¡Ð¾Ð·Ð´Ð°Ð½: " + we(new Date(I(m).createTimestamp).toLocaleString()), 1)) : tt("", !0),
          I(m).changeTimestamp ? (q(), ie("div", xK, " Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½: " + we(new Date(I(m).changeTimestamp).toLocaleString()), 1)) : tt("", !0)
        ])) : tt("", !0)
      ]),
      footer: se(() => [
        ae("div", JK, [
          V(kt, {
            type: "success",
            onClick: A
          }, {
            default: se(() => [
              Ue(we(M.$t("general.save")), 1)
            ]),
            _: 1
          }),
          V(kt, {
            type: "danger",
            onClick: S
          }, {
            default: se(() => [
              Ue(we(M.$t("general.delete")), 1)
            ]),
            _: 1
          }),
          V(kt, { onClick: T }, {
            default: se(() => [
              Ue(we(M.$t("general.cancel")), 1)
            ]),
            _: 1
          })
        ])
      ]),
      default: se(() => [
        I(m) ? (q(), ie("div", EK, [
          ae("div", DK, [
            ae("div", MK, [
              V(jf, {
                modelValue: I(m).linked,
                "onUpdate:modelValue": P[0] || (P[0] = (Y) => I(m).linked = Y),
                label: M.$t("general.nameAsLink")
              }, null, 8, ["modelValue", "label"])
            ]),
            I(m).linked ? (q(), ie(Ht, { key: 0 }, [
              V(di, null, {
                default: se(() => [
                  Ue(we(M.$t("general.outerLink")), 1)
                ]),
                _: 1
              }),
              ae("div", NK, [
                V(ga, {
                  "model-value": I(m).outlink || I(L),
                  "onUpdate:modelValue": P[1] || (P[1] = (Y) => I(m).outlink = Y)
                }, null, 8, ["model-value"])
              ]),
              ae("div", OK, [
                V(jf, {
                  modelValue: I(m).targetBlank,
                  "onUpdate:modelValue": P[2] || (P[2] = (Y) => I(m).targetBlank = Y),
                  label: M.$t("general.inNewTab")
                }, null, 8, ["modelValue", "label"])
              ])
            ], 64)) : tt("", !0),
            (q(!0), ie(Ht, null, Un(I(m).additionalFields, (Y, te) => (q(), ln(Ni, {
              class: "mb-2",
              key: te
            }, {
              default: se(() => [
                V(di, { class: "mb-1" }, {
                  default: se(() => [
                    Ue(we(te), 1)
                  ]),
                  _: 2
                }, 1024),
                V(lh, {
                  modelValue: I(m).additionalFields[te],
                  "onUpdate:modelValue": (ge) => I(m).additionalFields[te] = ge
                }, null, 8, ["modelValue", "onUpdate:modelValue"])
              ]),
              _: 2
            }, 1024))), 128)),
            V(Ni, null, {
              default: se(() => [
                V(di, null, {
                  default: se(() => [
                    Ue(we(M.$t("general.topName")), 1)
                  ]),
                  _: 1
                }),
                V(lh, {
                  modelValue: I(m).additionalName,
                  "onUpdate:modelValue": P[3] || (P[3] = (Y) => I(m).additionalName = Y)
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            V(Ni, null, {
              default: se(() => [
                V(di, null, {
                  default: se(() => [
                    Ue(we(M.$t("general.bottomName")), 1)
                  ]),
                  _: 1
                }),
                V(lh, {
                  modelValue: I(m).name,
                  "onUpdate:modelValue": P[4] || (P[4] = (Y) => I(m).name = Y)
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            V(Ni, null, {
              default: se(() => [
                V(di, null, {
                  default: se(() => [
                    Ue(we(M.$t("general.description")), 1)
                  ]),
                  _: 1
                }),
                V(lh, {
                  modelValue: I(m).description,
                  "onUpdate:modelValue": P[5] || (P[5] = (Y) => I(m).description = Y)
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            V(Ni, null, {
              default: se(() => [
                V(di, null, {
                  default: se(() => P[12] || (P[12] = [
                    Ue(" Z-Index ")
                  ])),
                  _: 1
                }),
                V(ga, {
                  modelValue: I(m).zindex,
                  "onUpdate:modelValue": P[6] || (P[6] = (Y) => I(m).zindex = Y),
                  type: "number"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            V(Ni, null, {
              default: se(() => [
                V(di, null, {
                  default: se(() => P[13] || (P[13] = [
                    Ue(" Width ")
                  ])),
                  _: 1
                }),
                V(ga, {
                  modelValue: I(m).width,
                  "onUpdate:modelValue": P[7] || (P[7] = (Y) => I(m).width = Y),
                  step: "20",
                  type: "number"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            V(Ni, null, {
              default: se(() => [
                V(di, null, {
                  default: se(() => P[14] || (P[14] = [
                    Ue(" Height ")
                  ])),
                  _: 1
                }),
                V(ga, {
                  modelValue: I(m).height,
                  "onUpdate:modelValue": P[8] || (P[8] = (Y) => I(m).height = Y),
                  step: "20",
                  type: "number"
                }, null, 8, ["modelValue"])
              ]),
              _: 1
            }),
            V(Ni, null, {
              default: se(() => [
                V(di, null, {
                  default: se(() => [
                    Ue(we(M.$t("general.objectType")), 1)
                  ]),
                  _: 1
                }),
                V(kK, {
                  modelValue: I(m).type,
                  "onUpdate:modelValue": P[9] || (P[9] = (Y) => I(m).type = Y),
                  items: I(w),
                  "option-id": "id",
                  "option-label": "name"
                }, null, 8, ["modelValue", "items"])
              ]),
              _: 1
            }),
            ae("div", AK, [
              V(jf, {
                modelValue: I(m).inMenu,
                "onUpdate:modelValue": P[10] || (P[10] = (Y) => I(m).inMenu = Y),
                label: M.$t("general.useInMenu")
              }, null, 8, ["modelValue", "label"])
            ]),
            I(m).inMenu ? (q(), ie(Ht, { key: 1 }, [
              ae("div", YK, we(M.$t("general.menuOrder")), 1),
              ae("div", PK, [
                V(ga, {
                  modelValue: I(m).menuOrder,
                  "onUpdate:modelValue": P[11] || (P[11] = (Y) => I(m).menuOrder = Y),
                  type: "number"
                }, null, 8, ["modelValue"])
              ])
            ], 64)) : tt("", !0),
            I(m).arrows && I(m).arrows.length ? (q(), ie(Ht, { key: 2 }, [
              ae("div", RK, we(M.$t("general.relations")), 1),
              ae("div", FK, [
                (q(!0), ie(Ht, null, Un(I(m).arrows, (Y, te) => {
                  var ge;
                  return q(), ie("div", {
                    key: Y.id,
                    class: "FormObject-Arrow"
                  }, [
                    (ge = I(v)) != null && ge.objects[Y.id] ? (q(), ie("span", IK, " #" + we(te + 1) + " " + we(I(v).objects[Y.id].name), 1)) : tt("", !0),
                    V(kt, {
                      class: "FormObject-ArrowButton",
                      type: "danger",
                      size: "sm",
                      onClick: (re) => x(te)
                    }, {
                      default: se(() => [
                        Ue(we(M.$t("general.delete")), 1)
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ]);
                }), 128))
              ])
            ], 64)) : tt("", !0)
          ])
        ])) : tt("", !0)
      ]),
      _: 1
    }));
  }
}), BK = {
  key: 0,
  title: "ÐÐ°Ð·Ð°Ð´",
  class: "absolute text-white left-0 top-0 -ml-5 flex justify-center items-center bg-primary/70 hover:bg-primary-second/70 cursor-pointer w-5"
}, HK = {
  key: 1,
  class: "BaseModal-Header"
}, XK = { class: "overflow-y-auto flex-grow" }, GK = {
  key: 2,
  class: "BaseModal-Footer"
}, ou = /* @__PURE__ */ Xe({
  __name: "BaseModal",
  props: {
    name: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const { modal: e } = qt(), t = n, i = e.isOpenedByName(t.name, new qe()).ref(), a = [], o = () => {
      e.give("");
    };
    return (r, s) => (q(), ln(K1, { name: "fade" }, {
      default: se(() => [
        I(i) ? (q(), ie("div", {
          key: 0,
          class: "absolute rounded-main overflow-y-auto flex justify-center items-center top-0 left-0 bg-black/10 z-20 h-full w-full",
          onClick: o
        }, [
          ae("div", {
            class: "w-full relative flex flex-col max-w-[800px] max-h-[90%] bg-white p-3",
            onClick: s[0] || (s[0] = Us(() => {
            }, ["stop"]))
          }, [
            a.length > 1 ? (q(), ie("div", BK, " < ")) : tt("", !0),
            ae("div", {
              title: "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ",
              class: "e2e-modal-close absolute text-white right-0 top-0 -mr-5 flex justify-center items-center bg-danger/70 hover:bg-danger-second/70 cursor-pointer w-5",
              onClick: o
            }, " Ã— "),
            r.$slots.header ? (q(), ie("div", HK, [
              Ri(r.$slots, "header")
            ])) : tt("", !0),
            ae("div", XK, [
              Ri(r.$slots, "default")
            ]),
            r.$slots.footer ? (q(), ie("div", GK, [
              Ri(r.$slots, "footer")
            ])) : tt("", !0)
          ])
        ])) : tt("", !0)
      ]),
      _: 3
    }));
  }
}), WK = { class: "BaseTextarea" }, QK = /* @__PURE__ */ Xe({
  __name: "BaseTextarea",
  props: {
    modelValue: {
      type: String,
      default: ""
    }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const a = od(n, "modelValue", e);
    return (o, r) => (q(), ie("div", WK, [
      id(ae("textarea", {
        ref: "textarea",
        "onUpdate:modelValue": r[0] || (r[0] = (s) => Ol(a) ? a.value = s : null),
        class: "rounded-main block w-full p-2 border min-h-[200px] border-solid border-body-dark"
      }, null, 512), [
        [z1, I(a)]
      ])
    ]));
  }
}), KK = { class: "text-lg font-bold" }, zK = {
  key: 0,
  class: "flex flex-col"
}, $K = { class: "flex justify-end pt-4 gap-2" }, VK = /* @__PURE__ */ Xe({
  __name: "FormType",
  setup(n) {
    const {
      mapTypeCurrent: e,
      mapFile: t,
      mapType: i,
      modal: a,
      controlCombo: o
    } = qt(), { patron: r, chain: s, guest: l } = vi();
    e.typeId(
      r.create(l.create((m) => {
        m && a.give("type");
      }))
    );
    const h = vn(""), d = s.create(), f = new Ik(() => {
      e.typeId(r.create(d.receiveKey("typeId"))), t.currentMap(r.create(d.receiveKey("map"))), d.result(r.create(
        l.create(({ map: m, typeId: w }) => {
          var v;
          f.value = m.types[w], h.value = (v = f.value) == null ? void 0 : v.name;
        })
      ));
    }).ref(), p = () => {
      e.give(""), a.give(""), d.receiveKey("typeId").give("");
    }, y = () => {
      i.give({
        name: h.value,
        type: f.value
      }), p();
    };
    return o.happenedConditional(
      "KeyS",
      a.openedByName("type"),
      r.create(l.create(y))
    ), (m, w) => (q(), ln(ou, { name: "type" }, {
      header: se(() => [
        ae("h2", KK, we(m.$t("general.mapType")), 1)
      ]),
      footer: se(() => [
        ae("div", $K, [
          V(kt, {
            type: "success",
            onClick: y
          }, {
            default: se(() => [
              Ue(we(m.$t("general.save")), 1)
            ]),
            _: 1
          }),
          V(kt, { onClick: p }, {
            default: se(() => [
              Ue(we(m.$t("general.cancel")), 1)
            ]),
            _: 1
          })
        ])
      ]),
      default: se(() => [
        I(f) ? (q(), ie("div", zK, [
          V(Ni, null, {
            default: se(() => [
              V(di, null, {
                default: se(() => w[4] || (w[4] = [
                  Ue(" ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ñ‚Ð¸Ð¿Ð° ")
                ])),
                _: 1
              }),
              V(ga, {
                modelValue: I(f).name,
                "onUpdate:modelValue": w[0] || (w[0] = (v) => I(f).name = v)
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }),
          V(Ni, null, {
            default: se(() => [
              V(di, null, {
                default: se(() => w[5] || (w[5] = [
                  Ue(" SVG ")
                ])),
                _: 1
              }),
              V(QK, {
                modelValue: I(f).svg,
                "onUpdate:modelValue": w[1] || (w[1] = (v) => I(f).svg = v)
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }),
          V(Ni, null, {
            default: se(() => [
              V(di, null, {
                default: se(() => w[6] || (w[6] = [
                  Ue(" Ð¨Ð¸Ñ€Ð¸Ð½Ð° ")
                ])),
                _: 1
              }),
              V(ga, {
                modelValue: I(f).width,
                "onUpdate:modelValue": w[2] || (w[2] = (v) => I(f).width = v)
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          }),
          V(Ni, null, {
            default: se(() => [
              V(di, null, {
                default: se(() => w[7] || (w[7] = [
                  Ue(" Ð’Ñ‹ÑÐ¾Ñ‚Ð° ")
                ])),
                _: 1
              }),
              V(ga, {
                modelValue: I(f).height,
                "onUpdate:modelValue": w[3] || (w[3] = (v) => I(f).height = v)
              }, null, 8, ["modelValue"])
            ]),
            _: 1
          })
        ])) : tt("", !0)
      ]),
      _: 1
    }));
  }
}), UK = { class: "text-lg font-bold" }, qK = {
  key: 0,
  class: "TheSettings"
}, e6 = { class: "mb-2" }, t6 = { class: "TheSettings-Row" }, n6 = { class: "flex gap-2 mb-2" }, i6 = { class: "mb-2" }, a6 = { class: "mb-2" }, o6 = {
  href: "https://github.com/kosukhin/mind-map-creator",
  target: "_blank"
}, r6 = { class: "flex gap-2" }, s6 = /* @__PURE__ */ Xe({
  __name: "FormSettings",
  setup(n) {
    const {
      modal: e,
      mapFile: t,
      mapRemoved: i,
      mapSettings: a,
      controlCombo: o,
      parentNames: r,
      mapCurrentID: s
    } = qt(), { patron: l, guest: h } = vi(), d = r.names(new qe()).ref(), f = t.currentMap(new qe()).ref(), p = s.id(new qe()).ref(), y = () => {
      e.give("");
    }, m = () => {
      a.give(f.value.settings), y();
    };
    return o.happenedConditional(
      "KeyS",
      e.openedByName("settings"),
      l.create(h.create(m))
    ), (w, v) => (q(), ln(ou, { name: "settings" }, {
      header: se(() => [
        ae("h2", UK, we(w.$t("general.mapSettings")), 1)
      ]),
      default: se(() => {
        var _;
        return [
          (_ = I(f)) != null && _.settings ? (q(), ie("div", qK, [
            ae("div", e6, [
              ae("div", t6, [
                ae("div", n6, [
                  I(d).length > 1 ? (q(), ln(kt, {
                    key: 0,
                    type: "primary",
                    class: "text-white",
                    onClick: v[0] || (v[0] = (L) => I(e).give("parentTypes"))
                  }, {
                    default: se(() => [
                      Ue(we(w.$t("general.parentTypes")), 1)
                    ]),
                    _: 1
                  })) : tt("", !0),
                  V(kt, {
                    type: "primary",
                    class: "text-white e2e-open-presets",
                    onClick: v[1] || (v[1] = (L) => I(e).give("presets"))
                  }, {
                    default: se(() => v[5] || (v[5] = [
                      Ue(" ÐŸÑ€ÐµÑÐµÑ‚Ñ‹ ")
                    ])),
                    _: 1
                  })
                ])
              ]),
              ae("div", i6, [
                ae("label", null, [
                  ae("b", null, we(w.$t("general.mapName")), 1),
                  V(ga, {
                    modelValue: I(f).settings.title,
                    "onUpdate:modelValue": v[2] || (v[2] = (L) => I(f).settings.title = L)
                  }, null, 8, ["modelValue"])
                ])
              ]),
              ae("div", a6, [
                ae("a", o6, we(w.$t("general.githubRepo")), 1)
              ])
            ]),
            ae("div", r6, [
              V(kt, {
                class: "TheSettings-Button",
                type: "success",
                onClick: v[3] || (v[3] = (L) => m())
              }, {
                default: se(() => [
                  Ue(we(w.$t("general.save")), 1)
                ]),
                _: 1
              }),
              V(kt, {
                class: "TheSettings-Button",
                onClick: y
              }, {
                default: se(() => [
                  Ue(we(w.$t("general.cancel")), 1)
                ]),
                _: 1
              }),
              V(kt, {
                class: "TheSettings-Button",
                type: "danger",
                onClick: v[4] || (v[4] = (L) => {
                  I(i).give(I(p)), y();
                })
              }, {
                default: se(() => [
                  Ue(we(w.$t("general.removeMap")), 1)
                ]),
                _: 1
              })
            ])
          ])) : tt("", !0)
        ];
      }),
      _: 1
    }));
  }
}), u6 = { class: "AppPresets" }, l6 = { class: "flex gap-2 items-end" }, c6 = { class: "AppTypesParent-ItemTitle" }, h6 = ["innerHTML"], d6 = /* @__PURE__ */ Xe({
  __name: "AppPresets",
  setup(n) {
    const {
      jsonp: e,
      svgMapTypeImage: t
    } = vi(), { mapType: i } = qt(), a = e.create("onPresets", "/data/presets.js", []).content(new qe([])).ref(), o = wt(() => a.value.map((r) => ({
      preset: r,
      image: t.create(r).markup()
    })));
    return (r, s) => (q(), ln(ou, { name: "presets" }, {
      default: se(() => [
        ae("div", u6, [
          s[0] || (s[0] = ae("div", { class: "text-md font-bold mb-2" }, "ÐžÐ±Ñ‰Ð¸Ðµ", -1)),
          ae("div", l6, [
            (q(!0), ie(Ht, null, Un(o.value, (l) => (q(), ie("div", {
              key: l.preset.name,
              class: "flex flex-col gap-2"
            }, [
              ae("div", c6, we(l.preset.name), 1),
              ae("div", {
                class: "AppTypesParent-ItemImage",
                innerHTML: l.image,
                style: pa(`width:${l.preset.width}px;height:${l.preset.height}px`)
              }, null, 12, h6),
              V(kt, {
                class: "AppTypesParent-ItemButton e2e-add-preset-type",
                type: "success",
                size: "sm",
                onClick: (h) => I(i).give({ name: l.preset.name, type: l.preset })
              }, {
                default: se(() => [
                  Ue(we(r.$t("general.addToMap")), 1)
                ]),
                _: 2
              }, 1032, ["onClick"])
            ]))), 128))
          ])
        ])
      ]),
      _: 1
    }));
  }
}), g6 = { class: "AppTypes" }, f6 = { class: "flex gap-2 items-end" }, p6 = { class: "AppTypesParent-ItemTitle" }, m6 = ["innerHTML"], y6 = /* @__PURE__ */ Xe({
  __name: "AppTypesParent",
  setup(n) {
    const { parentTypes: e, mapType: t } = qt(), { svgMapTypeImage: i } = vi(), a = e.types(new qe()).ref(), o = wt(() => {
      var r;
      return (r = a.value) == null ? void 0 : r.map((s) => ({
        type: s,
        image: i.create(s).markup()
      })).sort((s, l) => +(s.type.name >= l.type.name));
    });
    return (r, s) => (q(), ln(ou, { name: "parentTypes" }, {
      default: se(() => [
        ae("div", g6, [
          s[0] || (s[0] = ae("div", { class: "text-md font-bold mb-2" }, "Ð Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÑÐºÐ¸Ðµ Ñ‚Ð¸Ð¿Ñ‹", -1)),
          ae("div", f6, [
            (q(!0), ie(Ht, null, Un(o.value, (l) => (q(), ie("div", {
              key: l.type.name,
              class: "flex flex-col gap-2"
            }, [
              ae("div", p6, we(l.type.name), 1),
              ae("div", {
                class: "AppTypesParent-ItemImage",
                innerHTML: l.image,
                style: pa(`width:${l.type.width}px;height:${l.type.height}px`)
              }, null, 12, m6),
              V(kt, {
                class: "AppTypesParent-ItemButton e2e-add-preset-type",
                type: "success",
                size: "sm",
                onClick: (h) => I(t).give({ name: l.type.name, type: l.type })
              }, {
                default: se(() => [
                  Ue(we(r.$t("general.addToMap")), 1)
                ]),
                _: 2
              }, 1032, ["onClick"])
            ]))), 128))
          ])
        ])
      ]),
      _: 1
    }));
  }
}), b6 = { class: "AppMenuObject" }, w6 = {
  key: 0,
  class: "AppMenuObject-Empty"
}, v6 = {
  key: 1,
  class: "flex flex-col gap-1"
}, C6 = ["onClick"], S6 = ["innerHTML"], k6 = /* @__PURE__ */ Xe({
  __name: "AppMenuObject",
  setup(n) {
    const {
      controlCombo: e,
      drawer: t,
      menu: i,
      stagePosition: a
    } = qt(), { guest: o, patron: r } = vi(), s = i.menuObjects(new qe()).ref();
    return e.happened(
      "KeyM",
      r.create(o.create(() => {
        t.give("menu");
      }))
    ), (l, h) => (q(), ln(Um, {
      direction: "rtl",
      name: "menu"
    }, {
      default: se(() => [
        ae("div", b6, [
          I(s).length ? (q(), ie("div", v6, [
            (q(!0), ie(Ht, null, Un(I(s), (d) => (q(), ie("a", {
              key: d.id,
              class: "AppMenuObject-Item",
              href: "#",
              onClick: Us((f) => {
                I(a).give(d), I(t).give("");
              }, ["prevent"])
            }, [
              ae("span", {
                innerHTML: d.additionalName ? d.additionalName : d.name
              }, null, 8, S6)
            ], 8, C6))), 128))
          ])) : (q(), ie("div", w6, we(l.$t("appMenuObject.noItems")), 1))
        ])
      ]),
      _: 1
    }));
  }
});
/*!
  * shared v9.14.0
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const io = typeof window < "u";
let mi, Fr;
if (process.env.NODE_ENV !== "production") {
  const n = io && window.performance;
  n && n.mark && n.measure && n.clearMarks && // @ts-ignore browser compat
  n.clearMeasures && (mi = (e) => {
    n.mark(e);
  }, Fr = (e, t, i) => {
    n.measure(e, t, i), n.clearMarks(t), n.clearMarks(i);
  });
}
const _6 = /\{([0-9a-zA-Z]+)\}/g;
function Ey(n, ...e) {
  return e.length === 1 && st(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), n.replace(_6, (t, i) => e.hasOwnProperty(i) ? e[i] : "");
}
const so = (n, e = !1) => e ? Symbol.for(n) : Symbol(n), j6 = (n, e, t) => T6({ l: n, k: e, s: t }), T6 = (n) => JSON.stringify(n).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), _n = (n) => typeof n == "number" && isFinite(n), L6 = (n) => lT(n) === "[object Date]", zs = (n) => lT(n) === "[object RegExp]", Pd = (n) => Ke(n) && Object.keys(n).length === 0, Tn = Object.assign;
let f1;
const Ka = () => f1 || (f1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function p1(n) {
  return n.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const x6 = Object.prototype.hasOwnProperty;
function qh(n, e) {
  return x6.call(n, e);
}
const Qt = Array.isArray, jt = (n) => typeof n == "function", de = (n) => typeof n == "string", bt = (n) => typeof n == "boolean", st = (n) => n !== null && typeof n == "object", E6 = (n) => st(n) && jt(n.then) && jt(n.catch), uT = Object.prototype.toString, lT = (n) => uT.call(n), Ke = (n) => {
  if (!st(n))
    return !1;
  const e = Object.getPrototypeOf(n);
  return e === null || e.constructor === Object;
}, D6 = (n) => n == null ? "" : Qt(n) || Ke(n) && n.toString === uT ? JSON.stringify(n, null, 2) : String(n);
function M6(n, e = "") {
  return n.reduce((t, i, a) => a === 0 ? t + i : t + e + i, "");
}
const m1 = 2;
function N6(n, e = 0, t = n.length) {
  const i = n.split(/\r?\n/);
  let a = 0;
  const o = [];
  for (let r = 0; r < i.length; r++)
    if (a += i[r].length + 1, a >= e) {
      for (let s = r - m1; s <= r + m1 || t > a; s++) {
        if (s < 0 || s >= i.length)
          continue;
        const l = s + 1;
        o.push(`${l}${" ".repeat(3 - String(l).length)}|  ${i[s]}`);
        const h = i[s].length;
        if (s === r) {
          const d = e - (a - h) + 1, f = Math.max(1, t > a ? h - d : t - e);
          o.push("   |  " + " ".repeat(d) + "^".repeat(f));
        } else if (s > r) {
          if (t > a) {
            const d = Math.max(Math.min(t - a, h), 1);
            o.push("   |  " + "^".repeat(d));
          }
          a += h + 1;
        }
      }
      break;
    }
  return o.join(`
`);
}
function Rd(n) {
  let e = n;
  return () => ++e;
}
function uo(n, e) {
  typeof console < "u" && (console.warn("[intlify] " + n), e && console.warn(e.stack));
}
const y1 = {};
function cT(n) {
  y1[n] || (y1[n] = !0, uo(n));
}
function O6() {
  const n = /* @__PURE__ */ new Map();
  return {
    events: n,
    on(t, i) {
      const a = n.get(t);
      a && a.push(i) || n.set(t, [i]);
    },
    off(t, i) {
      const a = n.get(t);
      a && a.splice(a.indexOf(i) >>> 0, 1);
    },
    emit(t, i) {
      (n.get(t) || []).slice().map((a) => a(i)), (n.get("*") || []).slice().map((a) => a(t, i));
    }
  };
}
const ch = (n) => !st(n) || Qt(n);
function Sh(n, e) {
  if (ch(n) || ch(e))
    throw new Error("Invalid value");
  const t = [{ src: n, des: e }];
  for (; t.length; ) {
    const { src: i, des: a } = t.pop();
    Object.keys(i).forEach((o) => {
      ch(i[o]) || ch(a[o]) ? a[o] = i[o] : t.push({ src: i[o], des: a[o] });
    });
  }
}
/*!
  * message-compiler v9.14.0
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function A6(n, e, t) {
  return { line: n, column: e, offset: t };
}
function ed(n, e, t) {
  return { start: n, end: e };
}
const Y6 = /\{([0-9a-zA-Z]+)\}/g;
function hT(n, ...e) {
  return e.length === 1 && P6(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), n.replace(Y6, (t, i) => e.hasOwnProperty(i) ? e[i] : "");
}
const dT = Object.assign, b1 = (n) => typeof n == "string", P6 = (n) => n !== null && typeof n == "object";
function gT(n, e = "") {
  return n.reduce((t, i, a) => a === 0 ? t + i : t + e + i, "");
}
const Fd = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
}, R6 = {
  [Fd.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
};
function F6(n, e, ...t) {
  const i = hT(R6[n], ...t || []), a = { message: String(i), code: n };
  return e && (a.location = e), a;
}
const je = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
}, I6 = {
  // tokenizer error messages
  [je.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [je.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [je.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [je.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [je.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [je.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [je.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [je.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [je.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [je.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [je.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [je.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [je.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [je.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [je.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [je.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function ru(n, e, t = {}) {
  const { domain: i, messages: a, args: o } = t, r = hT((a || I6)[n] || "", ...o || []), s = new SyntaxError(String(r));
  return s.code = n, e && (s.location = e), s.domain = i, s;
}
function J6(n) {
  throw n;
}
const Z6 = /<\/?[\w\s="/.':;#-\/]+>/, B6 = (n) => Z6.test(n), Za = " ", H6 = "\r", An = `
`, X6 = "\u2028", G6 = "\u2029";
function W6(n) {
  const e = n;
  let t = 0, i = 1, a = 1, o = 0;
  const r = (M) => e[M] === H6 && e[M + 1] === An, s = (M) => e[M] === An, l = (M) => e[M] === G6, h = (M) => e[M] === X6, d = (M) => r(M) || s(M) || l(M) || h(M), f = () => t, p = () => i, y = () => a, m = () => o, w = (M) => r(M) || l(M) || h(M) ? An : e[M], v = () => w(t), _ = () => w(t + o);
  function L() {
    return o = 0, d(t) && (i++, a = 0), r(t) && t++, t++, a++, e[t];
  }
  function T() {
    return r(t + o) && o++, o++, e[t + o];
  }
  function S() {
    t = 0, i = 1, a = 1, o = 0;
  }
  function A(M = 0) {
    o = M;
  }
  function x() {
    const M = t + o;
    for (; M !== t; )
      L();
    o = 0;
  }
  return {
    index: f,
    line: p,
    column: y,
    peekOffset: m,
    charAt: w,
    currentChar: v,
    currentPeek: _,
    next: L,
    peek: T,
    reset: S,
    resetPeek: A,
    skipToPeek: x
  };
}
const Co = void 0, Q6 = ".", w1 = "'", K6 = "tokenizer";
function z6(n, e = {}) {
  const t = e.location !== !1, i = W6(n), a = () => i.index(), o = () => A6(i.line(), i.column(), i.index()), r = o(), s = a(), l = {
    currentType: 14,
    offset: s,
    startLoc: r,
    endLoc: r,
    lastType: 14,
    lastOffset: s,
    lastStartLoc: r,
    lastEndLoc: r,
    braceNest: 0,
    inLinked: !1,
    text: ""
  }, h = () => l, { onError: d } = e;
  function f(D, N, X, ...le) {
    const it = h();
    if (N.column += X, N.offset += X, d) {
      const Je = t ? ed(it.startLoc, N) : null, We = ru(D, Je, {
        domain: K6,
        args: le
      });
      d(We);
    }
  }
  function p(D, N, X) {
    D.endLoc = o(), D.currentType = N;
    const le = { type: N };
    return t && (le.loc = ed(D.startLoc, D.endLoc)), X != null && (le.value = X), le;
  }
  const y = (D) => p(
    D,
    14
    /* TokenTypes.EOF */
  );
  function m(D, N) {
    return D.currentChar() === N ? (D.next(), N) : (f(je.EXPECTED_TOKEN, o(), 0, N), "");
  }
  function w(D) {
    let N = "";
    for (; D.currentPeek() === Za || D.currentPeek() === An; )
      N += D.currentPeek(), D.peek();
    return N;
  }
  function v(D) {
    const N = w(D);
    return D.skipToPeek(), N;
  }
  function _(D) {
    if (D === Co)
      return !1;
    const N = D.charCodeAt(0);
    return N >= 97 && N <= 122 || // a-z
    N >= 65 && N <= 90 || // A-Z
    N === 95;
  }
  function L(D) {
    if (D === Co)
      return !1;
    const N = D.charCodeAt(0);
    return N >= 48 && N <= 57;
  }
  function T(D, N) {
    const { currentType: X } = N;
    if (X !== 2)
      return !1;
    w(D);
    const le = _(D.currentPeek());
    return D.resetPeek(), le;
  }
  function S(D, N) {
    const { currentType: X } = N;
    if (X !== 2)
      return !1;
    w(D);
    const le = D.currentPeek() === "-" ? D.peek() : D.currentPeek(), it = L(le);
    return D.resetPeek(), it;
  }
  function A(D, N) {
    const { currentType: X } = N;
    if (X !== 2)
      return !1;
    w(D);
    const le = D.currentPeek() === w1;
    return D.resetPeek(), le;
  }
  function x(D, N) {
    const { currentType: X } = N;
    if (X !== 8)
      return !1;
    w(D);
    const le = D.currentPeek() === ".";
    return D.resetPeek(), le;
  }
  function M(D, N) {
    const { currentType: X } = N;
    if (X !== 9)
      return !1;
    w(D);
    const le = _(D.currentPeek());
    return D.resetPeek(), le;
  }
  function P(D, N) {
    const { currentType: X } = N;
    if (!(X === 8 || X === 12))
      return !1;
    w(D);
    const le = D.currentPeek() === ":";
    return D.resetPeek(), le;
  }
  function Y(D, N) {
    const { currentType: X } = N;
    if (X !== 10)
      return !1;
    const le = () => {
      const Je = D.currentPeek();
      return Je === "{" ? _(D.peek()) : Je === "@" || Je === "%" || Je === "|" || Je === ":" || Je === "." || Je === Za || !Je ? !1 : Je === An ? (D.peek(), le()) : re(D, !1);
    }, it = le();
    return D.resetPeek(), it;
  }
  function te(D) {
    w(D);
    const N = D.currentPeek() === "|";
    return D.resetPeek(), N;
  }
  function ge(D) {
    const N = w(D), X = D.currentPeek() === "%" && D.peek() === "{";
    return D.resetPeek(), {
      isModulo: X,
      hasSpace: N.length > 0
    };
  }
  function re(D, N = !0) {
    const X = (it = !1, Je = "", We = !1) => {
      const Z = D.currentPeek();
      return Z === "{" ? Je === "%" ? !1 : it : Z === "@" || !Z ? Je === "%" ? !0 : it : Z === "%" ? (D.peek(), X(it, "%", !0)) : Z === "|" ? Je === "%" || We ? !0 : !(Je === Za || Je === An) : Z === Za ? (D.peek(), X(!0, Za, We)) : Z === An ? (D.peek(), X(!0, An, We)) : !0;
    }, le = X();
    return N && D.resetPeek(), le;
  }
  function me(D, N) {
    const X = D.currentChar();
    return X === Co ? Co : N(X) ? (D.next(), X) : null;
  }
  function ut(D) {
    const N = D.charCodeAt(0);
    return N >= 97 && N <= 122 || // a-z
    N >= 65 && N <= 90 || // A-Z
    N >= 48 && N <= 57 || // 0-9
    N === 95 || // _
    N === 36;
  }
  function ht(D) {
    return me(D, ut);
  }
  function ze(D) {
    const N = D.charCodeAt(0);
    return N >= 97 && N <= 122 || // a-z
    N >= 65 && N <= 90 || // A-Z
    N >= 48 && N <= 57 || // 0-9
    N === 95 || // _
    N === 36 || // $
    N === 45;
  }
  function Ge(D) {
    return me(D, ze);
  }
  function Ae(D) {
    const N = D.charCodeAt(0);
    return N >= 48 && N <= 57;
  }
  function It(D) {
    return me(D, Ae);
  }
  function xt(D) {
    const N = D.charCodeAt(0);
    return N >= 48 && N <= 57 || // 0-9
    N >= 65 && N <= 70 || // A-F
    N >= 97 && N <= 102;
  }
  function ft(D) {
    return me(D, xt);
  }
  function gt(D) {
    let N = "", X = "";
    for (; N = It(D); )
      X += N;
    return X;
  }
  function Kt(D) {
    v(D);
    const N = D.currentChar();
    return N !== "%" && f(je.EXPECTED_TOKEN, o(), 0, N), D.next(), "%";
  }
  function Jt(D) {
    let N = "";
    for (; ; ) {
      const X = D.currentChar();
      if (X === "{" || X === "}" || X === "@" || X === "|" || !X)
        break;
      if (X === "%")
        if (re(D))
          N += X, D.next();
        else
          break;
      else if (X === Za || X === An)
        if (re(D))
          N += X, D.next();
        else {
          if (te(D))
            break;
          N += X, D.next();
        }
      else
        N += X, D.next();
    }
    return N;
  }
  function pt(D) {
    v(D);
    let N = "", X = "";
    for (; N = Ge(D); )
      X += N;
    return D.currentChar() === Co && f(je.UNTERMINATED_CLOSING_BRACE, o(), 0), X;
  }
  function Ee(D) {
    v(D);
    let N = "";
    return D.currentChar() === "-" ? (D.next(), N += `-${gt(D)}`) : N += gt(D), D.currentChar() === Co && f(je.UNTERMINATED_CLOSING_BRACE, o(), 0), N;
  }
  function xn(D) {
    return D !== w1 && D !== An;
  }
  function Xt(D) {
    v(D), m(D, "'");
    let N = "", X = "";
    for (; N = me(D, xn); )
      N === "\\" ? X += en(D) : X += N;
    const le = D.currentChar();
    return le === An || le === Co ? (f(je.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, o(), 0), le === An && (D.next(), m(D, "'")), X) : (m(D, "'"), X);
  }
  function en(D) {
    const N = D.currentChar();
    switch (N) {
      case "\\":
      case "'":
        return D.next(), `\\${N}`;
      case "u":
        return hn(D, N, 4);
      case "U":
        return hn(D, N, 6);
      default:
        return f(je.UNKNOWN_ESCAPE_SEQUENCE, o(), 0, N), "";
    }
  }
  function hn(D, N, X) {
    m(D, N);
    let le = "";
    for (let it = 0; it < X; it++) {
      const Je = ft(D);
      if (!Je) {
        f(je.INVALID_UNICODE_ESCAPE_SEQUENCE, o(), 0, `\\${N}${le}${D.currentChar()}`);
        break;
      }
      le += Je;
    }
    return `\\${N}${le}`;
  }
  function dn(D) {
    return D !== "{" && D !== "}" && D !== Za && D !== An;
  }
  function En(D) {
    v(D);
    let N = "", X = "";
    for (; N = me(D, dn); )
      X += N;
    return X;
  }
  function Zn(D) {
    let N = "", X = "";
    for (; N = ht(D); )
      X += N;
    return X;
  }
  function $(D) {
    const N = (X) => {
      const le = D.currentChar();
      return le === "{" || le === "%" || le === "@" || le === "|" || le === "(" || le === ")" || !le || le === Za ? X : (X += le, D.next(), N(X));
    };
    return N("");
  }
  function Oe(D) {
    v(D);
    const N = m(
      D,
      "|"
      /* TokenChars.Pipe */
    );
    return v(D), N;
  }
  function ai(D, N) {
    let X = null;
    switch (D.currentChar()) {
      case "{":
        return N.braceNest >= 1 && f(je.NOT_ALLOW_NEST_PLACEHOLDER, o(), 0), D.next(), X = p(
          N,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), v(D), N.braceNest++, X;
      case "}":
        return N.braceNest > 0 && N.currentType === 2 && f(je.EMPTY_PLACEHOLDER, o(), 0), D.next(), X = p(
          N,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), N.braceNest--, N.braceNest > 0 && v(D), N.inLinked && N.braceNest === 0 && (N.inLinked = !1), X;
      case "@":
        return N.braceNest > 0 && f(je.UNTERMINATED_CLOSING_BRACE, o(), 0), X = Mt(D, N) || y(N), N.braceNest = 0, X;
      default: {
        let it = !0, Je = !0, We = !0;
        if (te(D))
          return N.braceNest > 0 && f(je.UNTERMINATED_CLOSING_BRACE, o(), 0), X = p(N, 1, Oe(D)), N.braceNest = 0, N.inLinked = !1, X;
        if (N.braceNest > 0 && (N.currentType === 5 || N.currentType === 6 || N.currentType === 7))
          return f(je.UNTERMINATED_CLOSING_BRACE, o(), 0), N.braceNest = 0, oi(D, N);
        if (it = T(D, N))
          return X = p(N, 5, pt(D)), v(D), X;
        if (Je = S(D, N))
          return X = p(N, 6, Ee(D)), v(D), X;
        if (We = A(D, N))
          return X = p(N, 7, Xt(D)), v(D), X;
        if (!it && !Je && !We)
          return X = p(N, 13, En(D)), f(je.INVALID_TOKEN_IN_PLACEHOLDER, o(), 0, X.value), v(D), X;
        break;
      }
    }
    return X;
  }
  function Mt(D, N) {
    const { currentType: X } = N;
    let le = null;
    const it = D.currentChar();
    switch ((X === 8 || X === 9 || X === 12 || X === 10) && (it === An || it === Za) && f(je.INVALID_LINKED_FORMAT, o(), 0), it) {
      case "@":
        return D.next(), le = p(
          N,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        ), N.inLinked = !0, le;
      case ".":
        return v(D), D.next(), p(
          N,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return v(D), D.next(), p(
          N,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return te(D) ? (le = p(N, 1, Oe(D)), N.braceNest = 0, N.inLinked = !1, le) : x(D, N) || P(D, N) ? (v(D), Mt(D, N)) : M(D, N) ? (v(D), p(N, 12, Zn(D))) : Y(D, N) ? (v(D), it === "{" ? ai(D, N) || le : p(N, 11, $(D))) : (X === 8 && f(je.INVALID_LINKED_FORMAT, o(), 0), N.braceNest = 0, N.inLinked = !1, oi(D, N));
    }
  }
  function oi(D, N) {
    let X = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (N.braceNest > 0)
      return ai(D, N) || y(N);
    if (N.inLinked)
      return Mt(D, N) || y(N);
    switch (D.currentChar()) {
      case "{":
        return ai(D, N) || y(N);
      case "}":
        return f(je.UNBALANCED_CLOSING_BRACE, o(), 0), D.next(), p(
          N,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return Mt(D, N) || y(N);
      default: {
        if (te(D))
          return X = p(N, 1, Oe(D)), N.braceNest = 0, N.inLinked = !1, X;
        const { isModulo: it, hasSpace: Je } = ge(D);
        if (it)
          return Je ? p(N, 0, Jt(D)) : p(N, 4, Kt(D));
        if (re(D))
          return p(N, 0, Jt(D));
        break;
      }
    }
    return X;
  }
  function oa() {
    const { currentType: D, offset: N, startLoc: X, endLoc: le } = l;
    return l.lastType = D, l.lastOffset = N, l.lastStartLoc = X, l.lastEndLoc = le, l.offset = a(), l.startLoc = o(), i.currentChar() === Co ? p(
      l,
      14
      /* TokenTypes.EOF */
    ) : oi(i, l);
  }
  return {
    nextToken: oa,
    currentOffset: a,
    currentPosition: o,
    context: h
  };
}
const $6 = "parser", V6 = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function U6(n, e, t) {
  switch (n) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const i = parseInt(e || t, 16);
      return i <= 55295 || i >= 57344 ? String.fromCodePoint(i) : "ï¿½";
    }
  }
}
function q6(n = {}) {
  const e = n.location !== !1, { onError: t, onWarn: i } = n;
  function a(T, S, A, x, ...M) {
    const P = T.currentPosition();
    if (P.offset += x, P.column += x, t) {
      const Y = e ? ed(A, P) : null, te = ru(S, Y, {
        domain: $6,
        args: M
      });
      t(te);
    }
  }
  function o(T, S, A, x, ...M) {
    const P = T.currentPosition();
    if (P.offset += x, P.column += x, i) {
      const Y = e ? ed(A, P) : null;
      i(F6(S, Y, M));
    }
  }
  function r(T, S, A) {
    const x = { type: T };
    return e && (x.start = S, x.end = S, x.loc = { start: A, end: A }), x;
  }
  function s(T, S, A, x) {
    e && (T.end = S, T.loc && (T.loc.end = A));
  }
  function l(T, S) {
    const A = T.context(), x = r(3, A.offset, A.startLoc);
    return x.value = S, s(x, T.currentOffset(), T.currentPosition()), x;
  }
  function h(T, S) {
    const A = T.context(), { lastOffset: x, lastStartLoc: M } = A, P = r(5, x, M);
    return P.index = parseInt(S, 10), T.nextToken(), s(P, T.currentOffset(), T.currentPosition()), P;
  }
  function d(T, S, A) {
    const x = T.context(), { lastOffset: M, lastStartLoc: P } = x, Y = r(4, M, P);
    return Y.key = S, A === !0 && (Y.modulo = !0), T.nextToken(), s(Y, T.currentOffset(), T.currentPosition()), Y;
  }
  function f(T, S) {
    const A = T.context(), { lastOffset: x, lastStartLoc: M } = A, P = r(9, x, M);
    return P.value = S.replace(V6, U6), T.nextToken(), s(P, T.currentOffset(), T.currentPosition()), P;
  }
  function p(T) {
    const S = T.nextToken(), A = T.context(), { lastOffset: x, lastStartLoc: M } = A, P = r(8, x, M);
    return S.type !== 12 ? (a(T, je.UNEXPECTED_EMPTY_LINKED_MODIFIER, A.lastStartLoc, 0), P.value = "", s(P, x, M), {
      nextConsumeToken: S,
      node: P
    }) : (S.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, A.lastStartLoc, 0, zi(S)), P.value = S.value || "", s(P, T.currentOffset(), T.currentPosition()), {
      node: P
    });
  }
  function y(T, S) {
    const A = T.context(), x = r(7, A.offset, A.startLoc);
    return x.value = S, s(x, T.currentOffset(), T.currentPosition()), x;
  }
  function m(T) {
    const S = T.context(), A = r(6, S.offset, S.startLoc);
    let x = T.nextToken();
    if (x.type === 9) {
      const M = p(T);
      A.modifier = M.node, x = M.nextConsumeToken || T.nextToken();
    }
    switch (x.type !== 10 && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(x)), x = T.nextToken(), x.type === 2 && (x = T.nextToken()), x.type) {
      case 11:
        x.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(x)), A.key = y(T, x.value || "");
        break;
      case 5:
        x.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(x)), A.key = d(T, x.value || "");
        break;
      case 6:
        x.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(x)), A.key = h(T, x.value || "");
        break;
      case 7:
        x.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(x)), A.key = f(T, x.value || "");
        break;
      default: {
        a(T, je.UNEXPECTED_EMPTY_LINKED_KEY, S.lastStartLoc, 0);
        const M = T.context(), P = r(7, M.offset, M.startLoc);
        return P.value = "", s(P, M.offset, M.startLoc), A.key = P, s(A, M.offset, M.startLoc), {
          nextConsumeToken: x,
          node: A
        };
      }
    }
    return s(A, T.currentOffset(), T.currentPosition()), {
      node: A
    };
  }
  function w(T) {
    const S = T.context(), A = S.currentType === 1 ? T.currentOffset() : S.offset, x = S.currentType === 1 ? S.endLoc : S.startLoc, M = r(2, A, x);
    M.items = [];
    let P = null, Y = null;
    do {
      const re = P || T.nextToken();
      switch (P = null, re.type) {
        case 0:
          re.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(re)), M.items.push(l(T, re.value || ""));
          break;
        case 6:
          re.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(re)), M.items.push(h(T, re.value || ""));
          break;
        case 4:
          Y = !0;
          break;
        case 5:
          re.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(re)), M.items.push(d(T, re.value || "", !!Y)), Y && (o(T, Fd.USE_MODULO_SYNTAX, S.lastStartLoc, 0, zi(re)), Y = null);
          break;
        case 7:
          re.value == null && a(T, je.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, zi(re)), M.items.push(f(T, re.value || ""));
          break;
        case 8: {
          const me = m(T);
          M.items.push(me.node), P = me.nextConsumeToken || null;
          break;
        }
      }
    } while (S.currentType !== 14 && S.currentType !== 1);
    const te = S.currentType === 1 ? S.lastOffset : T.currentOffset(), ge = S.currentType === 1 ? S.lastEndLoc : T.currentPosition();
    return s(M, te, ge), M;
  }
  function v(T, S, A, x) {
    const M = T.context();
    let P = x.items.length === 0;
    const Y = r(1, S, A);
    Y.cases = [], Y.cases.push(x);
    do {
      const te = w(T);
      P || (P = te.items.length === 0), Y.cases.push(te);
    } while (M.currentType !== 14);
    return P && a(T, je.MUST_HAVE_MESSAGES_IN_PLURAL, A, 0), s(Y, T.currentOffset(), T.currentPosition()), Y;
  }
  function _(T) {
    const S = T.context(), { offset: A, startLoc: x } = S, M = w(T);
    return S.currentType === 14 ? M : v(T, A, x, M);
  }
  function L(T) {
    const S = z6(T, dT({}, n)), A = S.context(), x = r(0, A.offset, A.startLoc);
    return e && x.loc && (x.loc.source = T), x.body = _(S), n.onCacheKey && (x.cacheKey = n.onCacheKey(T)), A.currentType !== 14 && a(S, je.UNEXPECTED_LEXICAL_ANALYSIS, A.lastStartLoc, 0, T[A.offset] || ""), s(x, S.currentOffset(), S.currentPosition()), x;
  }
  return { parse: L };
}
function zi(n) {
  if (n.type === 14)
    return "EOF";
  const e = (n.value || "").replace(/\r?\n/gu, "\\n");
  return e.length > 10 ? e.slice(0, 9) + "â€¦" : e;
}
function e8(n, e = {}) {
  const t = {
    ast: n,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => t, helper: (o) => (t.helpers.add(o), o) };
}
function v1(n, e) {
  for (let t = 0; t < n.length; t++)
    Dy(n[t], e);
}
function Dy(n, e) {
  switch (n.type) {
    case 1:
      v1(n.cases, e), e.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      v1(n.items, e);
      break;
    case 6: {
      Dy(n.key, e), e.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), e.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function t8(n, e = {}) {
  const t = e8(n);
  t.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), n.body && Dy(n.body, t);
  const i = t.context();
  n.helpers = Array.from(i.helpers);
}
function n8(n) {
  const e = n.body;
  return e.type === 2 ? C1(e) : e.cases.forEach((t) => C1(t)), n;
}
function C1(n) {
  if (n.items.length === 1) {
    const e = n.items[0];
    (e.type === 3 || e.type === 9) && (n.static = e.value, delete e.value);
  } else {
    const e = [];
    for (let t = 0; t < n.items.length; t++) {
      const i = n.items[t];
      if (!(i.type === 3 || i.type === 9) || i.value == null)
        break;
      e.push(i.value);
    }
    if (e.length === n.items.length) {
      n.static = gT(e);
      for (let t = 0; t < n.items.length; t++) {
        const i = n.items[t];
        (i.type === 3 || i.type === 9) && delete i.value;
      }
    }
  }
}
const i8 = "minifier";
function ws(n) {
  switch (n.t = n.type, n.type) {
    case 0: {
      const e = n;
      ws(e.body), e.b = e.body, delete e.body;
      break;
    }
    case 1: {
      const e = n, t = e.cases;
      for (let i = 0; i < t.length; i++)
        ws(t[i]);
      e.c = t, delete e.cases;
      break;
    }
    case 2: {
      const e = n, t = e.items;
      for (let i = 0; i < t.length; i++)
        ws(t[i]);
      e.i = t, delete e.items, e.static && (e.s = e.static, delete e.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const e = n;
      e.value && (e.v = e.value, delete e.value);
      break;
    }
    case 6: {
      const e = n;
      ws(e.key), e.k = e.key, delete e.key, e.modifier && (ws(e.modifier), e.m = e.modifier, delete e.modifier);
      break;
    }
    case 5: {
      const e = n;
      e.i = e.index, delete e.index;
      break;
    }
    case 4: {
      const e = n;
      e.k = e.key, delete e.key;
      break;
    }
    default:
      throw ru(je.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: i8,
        args: [n.type]
      });
  }
  delete n.type;
}
const a8 = "parser";
function o8(n, e) {
  const { sourceMap: t, filename: i, breakLineCode: a, needIndent: o } = e, r = e.location !== !1, s = {
    filename: i,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: a,
    needIndent: o,
    indentLevel: 0
  };
  r && n.loc && (s.source = n.loc.source);
  const l = () => s;
  function h(v, _) {
    s.code += v;
  }
  function d(v, _ = !0) {
    const L = _ ? a : "";
    h(o ? L + "  ".repeat(v) : L);
  }
  function f(v = !0) {
    const _ = ++s.indentLevel;
    v && d(_);
  }
  function p(v = !0) {
    const _ = --s.indentLevel;
    v && d(_);
  }
  function y() {
    d(s.indentLevel);
  }
  return {
    context: l,
    push: h,
    indent: f,
    deindent: p,
    newline: y,
    helper: (v) => `_${v}`,
    needIndent: () => s.needIndent
  };
}
function r8(n, e) {
  const { helper: t } = n;
  n.push(`${t(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), $s(n, e.key), e.modifier ? (n.push(", "), $s(n, e.modifier), n.push(", _type")) : n.push(", undefined, _type"), n.push(")");
}
function s8(n, e) {
  const { helper: t, needIndent: i } = n;
  n.push(`${t(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), n.indent(i());
  const a = e.items.length;
  for (let o = 0; o < a && ($s(n, e.items[o]), o !== a - 1); o++)
    n.push(", ");
  n.deindent(i()), n.push("])");
}
function u8(n, e) {
  const { helper: t, needIndent: i } = n;
  if (e.cases.length > 1) {
    n.push(`${t(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), n.indent(i());
    const a = e.cases.length;
    for (let o = 0; o < a && ($s(n, e.cases[o]), o !== a - 1); o++)
      n.push(", ");
    n.deindent(i()), n.push("])");
  }
}
function l8(n, e) {
  e.body ? $s(n, e.body) : n.push("null");
}
function $s(n, e) {
  const { helper: t } = n;
  switch (e.type) {
    case 0:
      l8(n, e);
      break;
    case 1:
      u8(n, e);
      break;
    case 2:
      s8(n, e);
      break;
    case 6:
      r8(n, e);
      break;
    case 8:
      n.push(JSON.stringify(e.value), e);
      break;
    case 7:
      n.push(JSON.stringify(e.value), e);
      break;
    case 5:
      n.push(`${t(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${t(
        "list"
        /* HelperNameMap.LIST */
      )}(${e.index}))`, e);
      break;
    case 4:
      n.push(`${t(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${t(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(e.key)}))`, e);
      break;
    case 9:
      n.push(JSON.stringify(e.value), e);
      break;
    case 3:
      n.push(JSON.stringify(e.value), e);
      break;
    default:
      throw ru(je.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: a8,
        args: [e.type]
      });
  }
}
const c8 = (n, e = {}) => {
  const t = b1(e.mode) ? e.mode : "normal", i = b1(e.filename) ? e.filename : "message.intl", a = !!e.sourceMap, o = e.breakLineCode != null ? e.breakLineCode : t === "arrow" ? ";" : `
`, r = e.needIndent ? e.needIndent : t !== "arrow", s = n.helpers || [], l = o8(n, {
    mode: t,
    filename: i,
    sourceMap: a,
    breakLineCode: o,
    needIndent: r
  });
  l.push(t === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(r), s.length > 0 && (l.push(`const { ${gT(s.map((f) => `${f}: _${f}`), ", ")} } = ctx`), l.newline()), l.push("return "), $s(l, n), l.deindent(r), l.push("}"), delete n.helpers;
  const { code: h, map: d } = l.context();
  return {
    ast: n,
    code: h,
    map: d ? d.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function h8(n, e = {}) {
  const t = dT({}, e), i = !!t.jit, a = !!t.minify, o = t.optimize == null ? !0 : t.optimize, s = q6(t).parse(n);
  return i ? (o && n8(s), a && ws(s), { ast: s, code: "" }) : (t8(s, t), c8(s, t));
}
/*!
  * core-base v9.14.0
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function d8() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Ka().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Ka().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Ka().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1);
}
const qo = [];
qo[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
qo[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
qo[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
qo[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
qo[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
qo[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
qo[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const g8 = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function f8(n) {
  return g8.test(n);
}
function p8(n) {
  const e = n.charCodeAt(0), t = n.charCodeAt(n.length - 1);
  return e === t && (e === 34 || e === 39) ? n.slice(1, -1) : n;
}
function m8(n) {
  if (n == null)
    return "o";
  switch (n.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return n;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function y8(n) {
  const e = n.trim();
  return n.charAt(0) === "0" && isNaN(parseInt(n)) ? !1 : f8(e) ? p8(e) : "*" + e;
}
function b8(n) {
  const e = [];
  let t = -1, i = 0, a = 0, o, r, s, l, h, d, f;
  const p = [];
  p[
    0
    /* Actions.APPEND */
  ] = () => {
    r === void 0 ? r = s : r += s;
  }, p[
    1
    /* Actions.PUSH */
  ] = () => {
    r !== void 0 && (e.push(r), r = void 0);
  }, p[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    p[
      0
      /* Actions.APPEND */
    ](), a++;
  }, p[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (a > 0)
      a--, i = 4, p[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (a = 0, r === void 0 || (r = y8(r), r === !1))
        return !1;
      p[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function y() {
    const m = n[t + 1];
    if (i === 5 && m === "'" || i === 6 && m === '"')
      return t++, s = "\\" + m, p[
        0
        /* Actions.APPEND */
      ](), !0;
  }
  for (; i !== null; )
    if (t++, o = n[t], !(o === "\\" && y())) {
      if (l = m8(o), f = qo[i], h = f[l] || f.l || 8, h === 8 || (i = h[0], h[1] !== void 0 && (d = p[h[1]], d && (s = o, d() === !1))))
        return;
      if (i === 7)
        return e;
    }
}
const S1 = /* @__PURE__ */ new Map();
function w8(n, e) {
  return st(n) ? n[e] : null;
}
function v8(n, e) {
  if (!st(n))
    return null;
  let t = S1.get(e);
  if (t || (t = b8(e), t && S1.set(e, t)), !t)
    return null;
  const i = t.length;
  let a = n, o = 0;
  for (; o < i; ) {
    const r = a[t[o]];
    if (r === void 0 || jt(a))
      return null;
    a = r, o++;
  }
  return a;
}
const C8 = (n) => n, S8 = (n) => "", k8 = "text", _8 = (n) => n.length === 0 ? "" : M6(n), j8 = D6;
function k1(n, e) {
  return n = Math.abs(n), e === 2 ? n ? n > 1 ? 1 : 0 : 1 : n ? Math.min(n, 2) : 0;
}
function T8(n) {
  const e = _n(n.pluralIndex) ? n.pluralIndex : -1;
  return n.named && (_n(n.named.count) || _n(n.named.n)) ? _n(n.named.count) ? n.named.count : _n(n.named.n) ? n.named.n : e : e;
}
function L8(n, e) {
  e.count || (e.count = n), e.n || (e.n = n);
}
function x8(n = {}) {
  const e = n.locale, t = T8(n), i = st(n.pluralRules) && de(e) && jt(n.pluralRules[e]) ? n.pluralRules[e] : k1, a = st(n.pluralRules) && de(e) && jt(n.pluralRules[e]) ? k1 : void 0, o = (_) => _[i(t, _.length, a)], r = n.list || [], s = (_) => r[_], l = n.named || {};
  _n(n.pluralIndex) && L8(t, l);
  const h = (_) => l[_];
  function d(_) {
    const L = jt(n.messages) ? n.messages(_) : st(n.messages) ? n.messages[_] : !1;
    return L || (n.parent ? n.parent.message(_) : S8);
  }
  const f = (_) => n.modifiers ? n.modifiers[_] : C8, p = Ke(n.processor) && jt(n.processor.normalize) ? n.processor.normalize : _8, y = Ke(n.processor) && jt(n.processor.interpolate) ? n.processor.interpolate : j8, m = Ke(n.processor) && de(n.processor.type) ? n.processor.type : k8, v = {
    list: s,
    named: h,
    plural: o,
    linked: (_, ...L) => {
      const [T, S] = L;
      let A = "text", x = "";
      L.length === 1 ? st(T) ? (x = T.modifier || x, A = T.type || A) : de(T) && (x = T || x) : L.length === 2 && (de(T) && (x = T || x), de(S) && (A = S || A));
      const M = d(_)(v), P = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        A === "vnode" && Qt(M) && x ? M[0] : M
      );
      return x ? f(x)(P, A) : P;
    },
    message: d,
    type: m,
    interpolate: y,
    normalize: p,
    values: Tn({}, r, l)
  };
  return v;
}
let Dl = null;
function E8(n) {
  Dl = n;
}
function D8(n, e, t) {
  Dl && Dl.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: n,
    version: e,
    meta: t
  });
}
const M8 = /* @__PURE__ */ N8(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function N8(n) {
  return (e) => Dl && Dl.emit(n, e);
}
const fT = Fd.__EXTEND_POINT__, cr = Rd(fT), Yn = {
  NOT_FOUND_KEY: fT,
  // 2
  FALLBACK_TO_TRANSLATE: cr(),
  // 3
  CANNOT_FORMAT_NUMBER: cr(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: cr(),
  // 5
  CANNOT_FORMAT_DATE: cr(),
  // 6
  FALLBACK_TO_DATE_FORMAT: cr(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: cr(),
  // 8
  __EXTEND_POINT__: cr()
  // 9
}, O8 = {
  [Yn.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [Yn.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [Yn.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [Yn.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [Yn.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [Yn.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
  [Yn.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
};
function Ir(n, ...e) {
  return Ey(O8[n], ...e);
}
const pT = je.__EXTEND_POINT__, hr = Rd(pT), nn = {
  INVALID_ARGUMENT: pT,
  // 17
  INVALID_DATE_ARGUMENT: hr(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: hr(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: hr(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: hr(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: hr(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: hr(),
  // 23
  __EXTEND_POINT__: hr()
  // 24
};
function wa(n) {
  return ru(n, null, process.env.NODE_ENV !== "production" ? { messages: A8 } : void 0);
}
const A8 = {
  [nn.INVALID_ARGUMENT]: "Invalid arguments",
  [nn.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [nn.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [nn.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [nn.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [nn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [nn.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function My(n, e) {
  return e.locale != null ? _1(e.locale) : _1(n.locale);
}
let qf;
function _1(n) {
  if (de(n))
    return n;
  if (jt(n)) {
    if (n.resolvedOnce && qf != null)
      return qf;
    if (n.constructor.name === "Function") {
      const e = n();
      if (E6(e))
        throw wa(nn.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return qf = e;
    } else
      throw wa(nn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw wa(nn.NOT_SUPPORT_LOCALE_TYPE);
}
function Y8(n, e, t) {
  return [.../* @__PURE__ */ new Set([
    t,
    ...Qt(e) ? e : st(e) ? Object.keys(e) : de(e) ? [e] : [t]
  ])];
}
function mT(n, e, t) {
  const i = de(t) ? t : Ml, a = n;
  a.__localeChainCache || (a.__localeChainCache = /* @__PURE__ */ new Map());
  let o = a.__localeChainCache.get(i);
  if (!o) {
    o = [];
    let r = [t];
    for (; Qt(r); )
      r = j1(o, r, e);
    const s = Qt(e) || !Ke(e) ? e : e.default ? e.default : null;
    r = de(s) ? [s] : s, Qt(r) && j1(o, r, !1), a.__localeChainCache.set(i, o);
  }
  return o;
}
function j1(n, e, t) {
  let i = !0;
  for (let a = 0; a < e.length && bt(i); a++) {
    const o = e[a];
    de(o) && (i = P8(n, e[a], t));
  }
  return i;
}
function P8(n, e, t) {
  let i;
  const a = e.split("-");
  do {
    const o = a.join("-");
    i = R8(n, o, t), a.splice(-1, 1);
  } while (a.length && i === !0);
  return i;
}
function R8(n, e, t) {
  let i = !1;
  if (!n.includes(e) && (i = !0, e)) {
    i = e[e.length - 1] !== "!";
    const a = e.replace(/!/g, "");
    n.push(a), (Qt(t) || Ke(t)) && t[a] && (i = t[a]);
  }
  return i;
}
const F8 = "9.14.0", Id = -1, Ml = "en-US", td = "", T1 = (n) => `${n.charAt(0).toLocaleUpperCase()}${n.substr(1)}`;
function I8() {
  return {
    upper: (n, e) => e === "text" && de(n) ? n.toUpperCase() : e === "vnode" && st(n) && "__v_isVNode" in n ? n.children.toUpperCase() : n,
    lower: (n, e) => e === "text" && de(n) ? n.toLowerCase() : e === "vnode" && st(n) && "__v_isVNode" in n ? n.children.toLowerCase() : n,
    capitalize: (n, e) => e === "text" && de(n) ? T1(n) : e === "vnode" && st(n) && "__v_isVNode" in n ? T1(n.children) : n
  };
}
let yT;
function L1(n) {
  yT = n;
}
let bT;
function J8(n) {
  bT = n;
}
let wT;
function Z8(n) {
  wT = n;
}
let vT = null;
const B8 = /* @__NO_SIDE_EFFECTS__ */ (n) => {
  vT = n;
}, H8 = /* @__NO_SIDE_EFFECTS__ */ () => vT;
let CT = null;
const x1 = (n) => {
  CT = n;
}, X8 = () => CT;
let E1 = 0;
function G8(n = {}) {
  const e = jt(n.onWarn) ? n.onWarn : uo, t = de(n.version) ? n.version : F8, i = de(n.locale) || jt(n.locale) ? n.locale : Ml, a = jt(i) ? Ml : i, o = Qt(n.fallbackLocale) || Ke(n.fallbackLocale) || de(n.fallbackLocale) || n.fallbackLocale === !1 ? n.fallbackLocale : a, r = Ke(n.messages) ? n.messages : { [a]: {} }, s = Ke(n.datetimeFormats) ? n.datetimeFormats : { [a]: {} }, l = Ke(n.numberFormats) ? n.numberFormats : { [a]: {} }, h = Tn({}, n.modifiers || {}, I8()), d = n.pluralRules || {}, f = jt(n.missing) ? n.missing : null, p = bt(n.missingWarn) || zs(n.missingWarn) ? n.missingWarn : !0, y = bt(n.fallbackWarn) || zs(n.fallbackWarn) ? n.fallbackWarn : !0, m = !!n.fallbackFormat, w = !!n.unresolving, v = jt(n.postTranslation) ? n.postTranslation : null, _ = Ke(n.processor) ? n.processor : null, L = bt(n.warnHtmlMessage) ? n.warnHtmlMessage : !0, T = !!n.escapeParameter, S = jt(n.messageCompiler) ? n.messageCompiler : yT;
  process.env.NODE_ENV !== "production" && jt(n.messageCompiler) && cT(Ir(Yn.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  const A = jt(n.messageResolver) ? n.messageResolver : bT || w8, x = jt(n.localeFallbacker) ? n.localeFallbacker : wT || Y8, M = st(n.fallbackContext) ? n.fallbackContext : void 0, P = n, Y = st(P.__datetimeFormatters) ? P.__datetimeFormatters : /* @__PURE__ */ new Map(), te = st(P.__numberFormatters) ? P.__numberFormatters : /* @__PURE__ */ new Map(), ge = st(P.__meta) ? P.__meta : {};
  E1++;
  const re = {
    version: t,
    cid: E1,
    locale: i,
    fallbackLocale: o,
    messages: r,
    modifiers: h,
    pluralRules: d,
    missing: f,
    missingWarn: p,
    fallbackWarn: y,
    fallbackFormat: m,
    unresolving: w,
    postTranslation: v,
    processor: _,
    warnHtmlMessage: L,
    escapeParameter: T,
    messageCompiler: S,
    messageResolver: A,
    localeFallbacker: x,
    fallbackContext: M,
    onWarn: e,
    __meta: ge
  };
  return re.datetimeFormats = s, re.numberFormats = l, re.__datetimeFormatters = Y, re.__numberFormatters = te, process.env.NODE_ENV !== "production" && (re.__v_emitter = P.__v_emitter != null ? P.__v_emitter : void 0), (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) && D8(re, t, ge), re;
}
function Jd(n, e) {
  return n instanceof RegExp ? n.test(e) : n;
}
function ST(n, e) {
  return n instanceof RegExp ? n.test(e) : n;
}
function Ny(n, e, t, i, a) {
  const { missing: o, onWarn: r } = n;
  if (process.env.NODE_ENV !== "production") {
    const s = n.__v_emitter;
    s && s.emit("missing", {
      locale: t,
      key: e,
      type: a,
      groupId: `${a}:${e}`
    });
  }
  if (o !== null) {
    const s = o(n, t, e, a);
    return de(s) ? s : e;
  } else
    return process.env.NODE_ENV !== "production" && ST(i, e) && r(Ir(Yn.NOT_FOUND_KEY, { key: e, locale: t })), e;
}
function Pu(n, e, t) {
  const i = n;
  i.__localeChainCache = /* @__PURE__ */ new Map(), n.localeFallbacker(n, t, e);
}
function kT(n, e) {
  return n === e ? !1 : n.split("-")[0] === e.split("-")[0];
}
function W8(n, e) {
  const t = e.indexOf(n);
  if (t === -1)
    return !1;
  for (let i = t + 1; i < e.length; i++)
    if (kT(n, e[i]))
      return !0;
  return !1;
}
function ep(n) {
  return (t) => Q8(t, n);
}
function Q8(n, e) {
  const t = e.b || e.body;
  if ((t.t || t.type) === 1) {
    const i = t, a = i.c || i.cases;
    return n.plural(a.reduce((o, r) => [
      ...o,
      D1(n, r)
    ], []));
  } else
    return D1(n, t);
}
function D1(n, e) {
  const t = e.s || e.static;
  if (t)
    return n.type === "text" ? t : n.normalize([t]);
  {
    const i = (e.i || e.items).reduce((a, o) => [...a, lm(n, o)], []);
    return n.normalize(i);
  }
}
function lm(n, e) {
  const t = e.t || e.type;
  switch (t) {
    case 3: {
      const i = e;
      return i.v || i.value;
    }
    case 9: {
      const i = e;
      return i.v || i.value;
    }
    case 4: {
      const i = e;
      return n.interpolate(n.named(i.k || i.key));
    }
    case 5: {
      const i = e;
      return n.interpolate(n.list(i.i != null ? i.i : i.index));
    }
    case 6: {
      const i = e, a = i.m || i.modifier;
      return n.linked(lm(n, i.k || i.key), a ? lm(n, a) : void 0, n.type);
    }
    case 7: {
      const i = e;
      return i.v || i.value;
    }
    case 8: {
      const i = e;
      return i.v || i.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${t}`);
  }
}
const K8 = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function _T(n, e) {
  e && B6(n) && uo(Ey(K8, { source: n }));
}
const jT = (n) => n;
let Ls = /* @__PURE__ */ Object.create(null);
function TT(n) {
  n.code === Fd.USE_MODULO_SYNTAX && uo(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${n.message})`);
}
const Jr = (n) => st(n) && (n.t === 0 || n.type === 0) && ("b" in n || "body" in n);
function LT(n, e = {}) {
  let t = !1;
  const i = e.onError || J6;
  return e.onError = (a) => {
    t = !0, i(a);
  }, { ...h8(n, e), detectError: t };
}
const z8 = /* @__NO_SIDE_EFFECTS__ */ (n, e) => {
  if (!de(n))
    throw wa(nn.NOT_SUPPORT_NON_STRING_MESSAGE);
  process.env.NODE_ENV !== "production" && (e.onWarn = TT);
  {
    const t = bt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && _T(n, t);
    const a = (e.onCacheKey || jT)(n), o = Ls[a];
    if (o)
      return o;
    const { code: r, detectError: s } = LT(n, e), l = new Function(`return ${r}`)();
    return s ? l : Ls[a] = l;
  }
};
function $8(n, e) {
  if (process.env.NODE_ENV !== "production" && (e.onWarn = TT), __INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && de(n)) {
    const t = bt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && _T(n, t);
    const a = (e.onCacheKey || jT)(n), o = Ls[a];
    if (o)
      return o;
    const { ast: r, detectError: s } = LT(n, {
      ...e,
      location: process.env.NODE_ENV !== "production",
      jit: !0
    }), l = ep(r);
    return s ? l : Ls[a] = l;
  } else {
    if (process.env.NODE_ENV !== "production" && !Jr(n))
      return uo(`the message that is resolve with key '${e.key}' is not supported for jit compilation`), () => n;
    const t = n.cacheKey;
    if (t) {
      const i = Ls[t];
      return i || (Ls[t] = ep(n));
    } else
      return ep(n);
  }
}
const M1 = () => "", Yi = (n) => jt(n);
function N1(n, ...e) {
  const { fallbackFormat: t, postTranslation: i, unresolving: a, messageCompiler: o, fallbackLocale: r, messages: s } = n, [l, h] = cm(...e), d = bt(h.missingWarn) ? h.missingWarn : n.missingWarn, f = bt(h.fallbackWarn) ? h.fallbackWarn : n.fallbackWarn, p = bt(h.escapeParameter) ? h.escapeParameter : n.escapeParameter, y = !!h.resolvedMessage, m = de(h.default) || bt(h.default) ? bt(h.default) ? o ? l : () => l : h.default : t ? o ? l : () => l : "", w = t || m !== "", v = My(n, h);
  p && V8(h);
  let [_, L, T] = y ? [
    l,
    v,
    s[v] || {}
  ] : xT(n, l, v, r, f, d), S = _, A = l;
  if (!y && !(de(S) || Jr(S) || Yi(S)) && w && (S = m, A = S), !y && (!(de(S) || Jr(S) || Yi(S)) || !de(L)))
    return a ? Id : l;
  if (process.env.NODE_ENV !== "production" && de(S) && n.messageCompiler == null)
    return uo(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${l}'.`), l;
  let x = !1;
  const M = () => {
    x = !0;
  }, P = Yi(S) ? S : ET(n, l, L, S, A, M);
  if (x)
    return S;
  const Y = tz(n, L, T, h), te = x8(Y), ge = U8(n, P, te), re = i ? i(ge, l) : ge;
  if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
    const me = {
      timestamp: Date.now(),
      key: de(l) ? l : Yi(S) ? S.key : "",
      locale: L || (Yi(S) ? S.locale : ""),
      format: de(S) ? S : Yi(S) ? S.source : "",
      message: re
    };
    me.meta = Tn({}, n.__meta, /* @__PURE__ */ H8() || {}), M8(me);
  }
  return re;
}
function V8(n) {
  Qt(n.list) ? n.list = n.list.map((e) => de(e) ? p1(e) : e) : st(n.named) && Object.keys(n.named).forEach((e) => {
    de(n.named[e]) && (n.named[e] = p1(n.named[e]));
  });
}
function xT(n, e, t, i, a, o) {
  const { messages: r, onWarn: s, messageResolver: l, localeFallbacker: h } = n, d = h(n, i, t);
  let f = {}, p, y = null, m = t, w = null;
  const v = "translate";
  for (let _ = 0; _ < d.length; _++) {
    if (p = w = d[_], process.env.NODE_ENV !== "production" && t !== p && !kT(t, p) && Jd(a, e) && s(Ir(Yn.FALLBACK_TO_TRANSLATE, {
      key: e,
      target: p
    })), process.env.NODE_ENV !== "production" && t !== p) {
      const A = n.__v_emitter;
      A && A.emit("fallback", {
        type: v,
        key: e,
        from: m,
        to: w,
        groupId: `${v}:${e}`
      });
    }
    f = r[p] || {};
    let L = null, T, S;
    if (process.env.NODE_ENV !== "production" && io && (L = window.performance.now(), T = "intlify-message-resolve-start", S = "intlify-message-resolve-end", mi && mi(T)), (y = l(f, e)) === null && (y = f[e]), process.env.NODE_ENV !== "production" && io) {
      const A = window.performance.now(), x = n.__v_emitter;
      x && L && y && x.emit("message-resolve", {
        type: "message-resolve",
        key: e,
        message: y,
        time: A - L,
        groupId: `${v}:${e}`
      }), T && S && mi && Fr && (mi(S), Fr("intlify message resolve", T, S));
    }
    if (de(y) || Jr(y) || Yi(y))
      break;
    if (!W8(p, d)) {
      const A = Ny(
        n,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        e,
        p,
        o,
        v
      );
      A !== e && (y = A);
    }
    m = w;
  }
  return [y, p, f];
}
function ET(n, e, t, i, a, o) {
  const { messageCompiler: r, warnHtmlMessage: s } = n;
  if (Yi(i)) {
    const p = i;
    return p.locale = p.locale || t, p.key = p.key || e, p;
  }
  if (r == null) {
    const p = () => i;
    return p.locale = t, p.key = e, p;
  }
  let l = null, h, d;
  process.env.NODE_ENV !== "production" && io && (l = window.performance.now(), h = "intlify-message-compilation-start", d = "intlify-message-compilation-end", mi && mi(h));
  const f = r(i, q8(n, t, a, i, s, o));
  if (process.env.NODE_ENV !== "production" && io) {
    const p = window.performance.now(), y = n.__v_emitter;
    y && l && y.emit("message-compilation", {
      type: "message-compilation",
      message: i,
      time: p - l,
      groupId: `translate:${e}`
    }), h && d && mi && Fr && (mi(d), Fr("intlify message compilation", h, d));
  }
  return f.locale = t, f.key = e, f.source = i, f;
}
function U8(n, e, t) {
  let i = null, a, o;
  process.env.NODE_ENV !== "production" && io && (i = window.performance.now(), a = "intlify-message-evaluation-start", o = "intlify-message-evaluation-end", mi && mi(a));
  const r = e(t);
  if (process.env.NODE_ENV !== "production" && io) {
    const s = window.performance.now(), l = n.__v_emitter;
    l && i && l.emit("message-evaluation", {
      type: "message-evaluation",
      value: r,
      time: s - i,
      groupId: `translate:${e.key}`
    }), a && o && mi && Fr && (mi(o), Fr("intlify message evaluation", a, o));
  }
  return r;
}
function cm(...n) {
  const [e, t, i] = n, a = {};
  if (!de(e) && !_n(e) && !Yi(e) && !Jr(e))
    throw wa(nn.INVALID_ARGUMENT);
  const o = _n(e) ? String(e) : (Yi(e), e);
  return _n(t) ? a.plural = t : de(t) ? a.default = t : Ke(t) && !Pd(t) ? a.named = t : Qt(t) && (a.list = t), _n(i) ? a.plural = i : de(i) ? a.default = i : Ke(i) && Tn(a, i), [o, a];
}
function q8(n, e, t, i, a, o) {
  return {
    locale: e,
    key: t,
    warnHtmlMessage: a,
    onError: (r) => {
      if (o && o(r), process.env.NODE_ENV !== "production") {
        const s = ez(i), l = `Message compilation error: ${r.message}`, h = r.location && s && N6(s, r.location.start.offset, r.location.end.offset), d = n.__v_emitter;
        d && s && d.emit("compile-error", {
          message: s,
          error: r.message,
          start: r.location && r.location.start.offset,
          end: r.location && r.location.end.offset,
          groupId: `translate:${t}`
        }), console.error(h ? `${l}
${h}` : l);
      } else
        throw r;
    },
    onCacheKey: (r) => j6(e, t, r)
  };
}
function ez(n) {
  if (de(n))
    return n;
  if (n.loc && n.loc.source)
    return n.loc.source;
}
function tz(n, e, t, i) {
  const { modifiers: a, pluralRules: o, messageResolver: r, fallbackLocale: s, fallbackWarn: l, missingWarn: h, fallbackContext: d } = n, p = {
    locale: e,
    modifiers: a,
    pluralRules: o,
    messages: (y) => {
      let m = r(t, y);
      if (m == null && d) {
        const [, , w] = xT(d, y, e, s, l, h);
        m = r(w, y);
      }
      if (de(m) || Jr(m)) {
        let w = !1;
        const _ = ET(n, y, e, m, y, () => {
          w = !0;
        });
        return w ? M1 : _;
      } else return Yi(m) ? m : M1;
    }
  };
  return n.processor && (p.processor = n.processor), i.list && (p.list = i.list), i.named && (p.named = i.named), _n(i.plural) && (p.pluralIndex = i.plural), p;
}
const O1 = typeof Intl < "u", DT = {
  dateTimeFormat: O1 && typeof Intl.DateTimeFormat < "u",
  numberFormat: O1 && typeof Intl.NumberFormat < "u"
};
function A1(n, ...e) {
  const { datetimeFormats: t, unresolving: i, fallbackLocale: a, onWarn: o, localeFallbacker: r } = n, { __datetimeFormatters: s } = n;
  if (process.env.NODE_ENV !== "production" && !DT.dateTimeFormat)
    return o(Ir(Yn.CANNOT_FORMAT_DATE)), td;
  const [l, h, d, f] = hm(...e), p = bt(d.missingWarn) ? d.missingWarn : n.missingWarn, y = bt(d.fallbackWarn) ? d.fallbackWarn : n.fallbackWarn, m = !!d.part, w = My(n, d), v = r(
    n,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    a,
    w
  );
  if (!de(l) || l === "")
    return new Intl.DateTimeFormat(w, f).format(h);
  let _ = {}, L, T = null, S = w, A = null;
  const x = "datetime format";
  for (let Y = 0; Y < v.length; Y++) {
    if (L = A = v[Y], process.env.NODE_ENV !== "production" && w !== L && Jd(y, l) && o(Ir(Yn.FALLBACK_TO_DATE_FORMAT, {
      key: l,
      target: L
    })), process.env.NODE_ENV !== "production" && w !== L) {
      const te = n.__v_emitter;
      te && te.emit("fallback", {
        type: x,
        key: l,
        from: S,
        to: A,
        groupId: `${x}:${l}`
      });
    }
    if (_ = t[L] || {}, T = _[l], Ke(T))
      break;
    Ny(n, l, L, p, x), S = A;
  }
  if (!Ke(T) || !de(L))
    return i ? Id : l;
  let M = `${L}__${l}`;
  Pd(f) || (M = `${M}__${JSON.stringify(f)}`);
  let P = s.get(M);
  return P || (P = new Intl.DateTimeFormat(L, Tn({}, T, f)), s.set(M, P)), m ? P.formatToParts(h) : P.format(h);
}
const MT = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function hm(...n) {
  const [e, t, i, a] = n, o = {};
  let r = {}, s;
  if (de(e)) {
    const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!l)
      throw wa(nn.INVALID_ISO_DATE_ARGUMENT);
    const h = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
    s = new Date(h);
    try {
      s.toISOString();
    } catch {
      throw wa(nn.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (L6(e)) {
    if (isNaN(e.getTime()))
      throw wa(nn.INVALID_DATE_ARGUMENT);
    s = e;
  } else if (_n(e))
    s = e;
  else
    throw wa(nn.INVALID_ARGUMENT);
  return de(t) ? o.key = t : Ke(t) && Object.keys(t).forEach((l) => {
    MT.includes(l) ? r[l] = t[l] : o[l] = t[l];
  }), de(i) ? o.locale = i : Ke(i) && (r = i), Ke(a) && (r = a), [o.key || "", s, o, r];
}
function Y1(n, e, t) {
  const i = n;
  for (const a in t) {
    const o = `${e}__${a}`;
    i.__datetimeFormatters.has(o) && i.__datetimeFormatters.delete(o);
  }
}
function P1(n, ...e) {
  const { numberFormats: t, unresolving: i, fallbackLocale: a, onWarn: o, localeFallbacker: r } = n, { __numberFormatters: s } = n;
  if (process.env.NODE_ENV !== "production" && !DT.numberFormat)
    return o(Ir(Yn.CANNOT_FORMAT_NUMBER)), td;
  const [l, h, d, f] = dm(...e), p = bt(d.missingWarn) ? d.missingWarn : n.missingWarn, y = bt(d.fallbackWarn) ? d.fallbackWarn : n.fallbackWarn, m = !!d.part, w = My(n, d), v = r(
    n,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    a,
    w
  );
  if (!de(l) || l === "")
    return new Intl.NumberFormat(w, f).format(h);
  let _ = {}, L, T = null, S = w, A = null;
  const x = "number format";
  for (let Y = 0; Y < v.length; Y++) {
    if (L = A = v[Y], process.env.NODE_ENV !== "production" && w !== L && Jd(y, l) && o(Ir(Yn.FALLBACK_TO_NUMBER_FORMAT, {
      key: l,
      target: L
    })), process.env.NODE_ENV !== "production" && w !== L) {
      const te = n.__v_emitter;
      te && te.emit("fallback", {
        type: x,
        key: l,
        from: S,
        to: A,
        groupId: `${x}:${l}`
      });
    }
    if (_ = t[L] || {}, T = _[l], Ke(T))
      break;
    Ny(n, l, L, p, x), S = A;
  }
  if (!Ke(T) || !de(L))
    return i ? Id : l;
  let M = `${L}__${l}`;
  Pd(f) || (M = `${M}__${JSON.stringify(f)}`);
  let P = s.get(M);
  return P || (P = new Intl.NumberFormat(L, Tn({}, T, f)), s.set(M, P)), m ? P.formatToParts(h) : P.format(h);
}
const NT = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function dm(...n) {
  const [e, t, i, a] = n, o = {};
  let r = {};
  if (!_n(e))
    throw wa(nn.INVALID_ARGUMENT);
  const s = e;
  return de(t) ? o.key = t : Ke(t) && Object.keys(t).forEach((l) => {
    NT.includes(l) ? r[l] = t[l] : o[l] = t[l];
  }), de(i) ? o.locale = i : Ke(i) && (r = i), Ke(a) && (r = a), [o.key || "", s, o, r];
}
function R1(n, e, t) {
  const i = n;
  for (const a in t) {
    const o = `${e}__${a}`;
    i.__numberFormatters.has(o) && i.__numberFormatters.delete(o);
  }
}
d8();
/*!
  * vue-i18n v9.14.0
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const nz = "9.14.0";
function iz() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Ka().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Ka().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Ka().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Ka().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Ka().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const OT = Yn.__EXTEND_POINT__, Ba = Rd(OT), $n = {
  FALLBACK_TO_ROOT: OT,
  // 9
  NOT_SUPPORTED_PRESERVE: Ba(),
  // 10
  NOT_SUPPORTED_FORMATTER: Ba(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: Ba(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: Ba(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: Ba(),
  // 14
  NOT_FOUND_PARENT_SCOPE: Ba(),
  // 15
  IGNORE_OBJ_FLATTEN: Ba(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: Ba(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: Ba()
  // 18
}, az = {
  [$n.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [$n.NOT_SUPPORTED_PRESERVE]: "Not supported 'preserve'.",
  [$n.NOT_SUPPORTED_FORMATTER]: "Not supported 'formatter'.",
  [$n.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: "Not supported 'preserveDirectiveContent'.",
  [$n.NOT_SUPPORTED_GET_CHOICE_INDEX]: "Not supported 'getChoiceIndex'.",
  [$n.COMPONENT_NAME_LEGACY_COMPATIBLE]: "Component name legacy compatible: '{name}' -> 'i18n'",
  [$n.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
  [$n.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
  [$n.NOTICE_DROP_ALLOW_COMPOSITION]: "'allowComposition' option will be dropped in the next major version. For more information, please see ðŸ‘‰ https://tinyurl.com/2p97mcze",
  [$n.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: "'translateExistCompatible' option will be dropped in the next major version."
};
function nd(n, ...e) {
  return Ey(az[n], ...e);
}
const AT = nn.__EXTEND_POINT__, Kn = Rd(AT), Ot = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: AT,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: Kn(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: Kn(),
  // 26
  NOT_INSTALLED: Kn(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: Kn(),
  // 28
  // directive module errors
  REQUIRED_VALUE: Kn(),
  // 29
  INVALID_VALUE: Kn(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Kn(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: Kn(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: Kn(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: Kn(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: Kn(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Kn(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Kn(),
  // 37
  // for enhancement
  __EXTEND_POINT__: Kn()
  // 38
};
function Io(n, ...e) {
  return ru(n, null, process.env.NODE_ENV !== "production" ? { messages: oz, args: e } : void 0);
}
const oz = {
  [Ot.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [Ot.INVALID_ARGUMENT]: "Invalid argument",
  [Ot.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [Ot.NOT_INSTALLED]: "Need to install with `app.use` function",
  [Ot.UNEXPECTED_ERROR]: "Unexpected error",
  [Ot.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [Ot.REQUIRED_VALUE]: "Required in value: {0}",
  [Ot.INVALID_VALUE]: "Invalid value",
  [Ot.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [Ot.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [Ot.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [Ot.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [Ot.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define â€˜i18nâ€™ option or custom block in Composition API with using local scope in Legacy API mode",
  [Ot.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
}, gm = /* @__PURE__ */ so("__translateVNode"), fm = /* @__PURE__ */ so("__datetimeParts"), pm = /* @__PURE__ */ so("__numberParts"), mm = /* @__PURE__ */ so("__enableEmitter"), ym = /* @__PURE__ */ so("__disableEmitter"), rz = so("__setPluralRules"), YT = /* @__PURE__ */ so("__injectWithOption"), bm = /* @__PURE__ */ so("__dispose");
function Nl(n) {
  if (!st(n))
    return n;
  for (const e in n)
    if (qh(n, e))
      if (!e.includes("."))
        st(n[e]) && Nl(n[e]);
      else {
        const t = e.split("."), i = t.length - 1;
        let a = n, o = !1;
        for (let r = 0; r < i; r++) {
          if (t[r] in a || (a[t[r]] = {}), !st(a[t[r]])) {
            process.env.NODE_ENV !== "production" && uo(nd($n.IGNORE_OBJ_FLATTEN, {
              key: t[r]
            })), o = !0;
            break;
          }
          a = a[t[r]];
        }
        o || (a[t[i]] = n[e], delete n[e]), st(a[t[i]]) && Nl(a[t[i]]);
      }
  return n;
}
function Oy(n, e) {
  const { messages: t, __i18n: i, messageResolver: a, flatJson: o } = e, r = Ke(t) ? t : Qt(i) ? {} : { [n]: {} };
  if (Qt(i) && i.forEach((s) => {
    if ("locale" in s && "resource" in s) {
      const { locale: l, resource: h } = s;
      l ? (r[l] = r[l] || {}, Sh(h, r[l])) : Sh(h, r);
    } else
      de(s) && Sh(JSON.parse(s), r);
  }), a == null && o)
    for (const s in r)
      qh(r, s) && Nl(r[s]);
  return r;
}
function PT(n) {
  return n.type;
}
function sz(n, e, t) {
  let i = st(e.messages) ? e.messages : {};
  "__i18nGlobal" in t && (i = Oy(n.locale.value, {
    messages: i,
    __i18n: t.__i18nGlobal
  }));
  const a = Object.keys(i);
  a.length && a.forEach((o) => {
    n.mergeLocaleMessage(o, i[o]);
  });
  {
    if (st(e.datetimeFormats)) {
      const o = Object.keys(e.datetimeFormats);
      o.length && o.forEach((r) => {
        n.mergeDateTimeFormat(r, e.datetimeFormats[r]);
      });
    }
    if (st(e.numberFormats)) {
      const o = Object.keys(e.numberFormats);
      o.length && o.forEach((r) => {
        n.mergeNumberFormat(r, e.numberFormats[r]);
      });
    }
  }
}
function F1(n) {
  return V(CA, null, n, 0);
}
const I1 = "__INTLIFY_META__", J1 = () => [], uz = () => !1;
let Z1 = 0;
function B1(n) {
  return (e, t, i, a) => n(t, i, Zr() || void 0, a);
}
const lz = /* @__NO_SIDE_EFFECTS__ */ () => {
  const n = Zr();
  let e = null;
  return n && (e = PT(n)[I1]) ? { [I1]: e } : null;
};
function cz(n = {}, e) {
  const { __root: t, __injectWithOption: i } = n, a = t === void 0, o = n.flatJson, r = io ? vn : wm, s = !!n.translateExistCompatible;
  process.env.NODE_ENV !== "production" && s && cT(nd($n.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
  let l = bt(n.inheritLocale) ? n.inheritLocale : !0;
  const h = r(
    // prettier-ignore
    t && l ? t.locale.value : de(n.locale) ? n.locale : Ml
  ), d = r(
    // prettier-ignore
    t && l ? t.fallbackLocale.value : de(n.fallbackLocale) || Qt(n.fallbackLocale) || Ke(n.fallbackLocale) || n.fallbackLocale === !1 ? n.fallbackLocale : h.value
  ), f = r(Oy(h.value, n)), p = r(Ke(n.datetimeFormats) ? n.datetimeFormats : { [h.value]: {} }), y = r(Ke(n.numberFormats) ? n.numberFormats : { [h.value]: {} });
  let m = t ? t.missingWarn : bt(n.missingWarn) || zs(n.missingWarn) ? n.missingWarn : !0, w = t ? t.fallbackWarn : bt(n.fallbackWarn) || zs(n.fallbackWarn) ? n.fallbackWarn : !0, v = t ? t.fallbackRoot : bt(n.fallbackRoot) ? n.fallbackRoot : !0, _ = !!n.fallbackFormat, L = jt(n.missing) ? n.missing : null, T = jt(n.missing) ? B1(n.missing) : null, S = jt(n.postTranslation) ? n.postTranslation : null, A = t ? t.warnHtmlMessage : bt(n.warnHtmlMessage) ? n.warnHtmlMessage : !0, x = !!n.escapeParameter;
  const M = t ? t.modifiers : Ke(n.modifiers) ? n.modifiers : {};
  let P = n.pluralRules || t && t.pluralRules, Y;
  Y = (() => {
    a && x1(null);
    const Z = {
      version: nz,
      locale: h.value,
      fallbackLocale: d.value,
      messages: f.value,
      modifiers: M,
      pluralRules: P,
      missing: T === null ? void 0 : T,
      missingWarn: m,
      fallbackWarn: w,
      fallbackFormat: _,
      unresolving: !0,
      postTranslation: S === null ? void 0 : S,
      warnHtmlMessage: A,
      escapeParameter: x,
      messageResolver: n.messageResolver,
      messageCompiler: n.messageCompiler,
      __meta: { framework: "vue" }
    };
    Z.datetimeFormats = p.value, Z.numberFormats = y.value, Z.__datetimeFormatters = Ke(Y) ? Y.__datetimeFormatters : void 0, Z.__numberFormatters = Ke(Y) ? Y.__numberFormatters : void 0, process.env.NODE_ENV !== "production" && (Z.__v_emitter = Ke(Y) ? Y.__v_emitter : void 0);
    const z = G8(Z);
    return a && x1(z), z;
  })(), Pu(Y, h.value, d.value);
  function ge() {
    return [
      h.value,
      d.value,
      f.value,
      p.value,
      y.value
    ];
  }
  const re = wt({
    get: () => h.value,
    set: (Z) => {
      h.value = Z, Y.locale = h.value;
    }
  }), me = wt({
    get: () => d.value,
    set: (Z) => {
      d.value = Z, Y.fallbackLocale = d.value, Pu(Y, h.value, Z);
    }
  }), ut = wt(() => f.value), ht = /* @__PURE__ */ wt(() => p.value), ze = /* @__PURE__ */ wt(() => y.value);
  function Ge() {
    return jt(S) ? S : null;
  }
  function Ae(Z) {
    S = Z, Y.postTranslation = Z;
  }
  function It() {
    return L;
  }
  function xt(Z) {
    Z !== null && (T = B1(Z)), L = Z, Y.missing = T;
  }
  function ft(Z, z) {
    return Z !== "translate" || !z.resolvedMessage;
  }
  const gt = (Z, z, Be, mt, Bn, ra) => {
    ge();
    let ki;
    try {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, a || (Y.fallbackContext = t ? X8() : void 0), ki = Z(Y);
    } finally {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, a || (Y.fallbackContext = void 0);
    }
    if (Be !== "translate exists" && // for not `te` (e.g `t`)
    _n(ki) && ki === Id || Be === "translate exists" && !ki) {
      const [B, he] = z();
      if (process.env.NODE_ENV !== "production" && t && de(B) && ft(Be, he) && (v && (Jd(w, B) || ST(m, B)) && uo(nd($n.FALLBACK_TO_ROOT, {
        key: B,
        type: Be
      })), process.env.NODE_ENV !== "production")) {
        const { __v_emitter: ve } = Y;
        ve && v && ve.emit("fallback", {
          type: Be,
          key: B,
          to: "global",
          groupId: `${Be}:${B}`
        });
      }
      return t && v ? mt(t) : Bn(B);
    } else {
      if (ra(ki))
        return ki;
      throw Io(Ot.UNEXPECTED_RETURN_TYPE);
    }
  };
  function Kt(...Z) {
    return gt((z) => Reflect.apply(N1, null, [z, ...Z]), () => cm(...Z), "translate", (z) => Reflect.apply(z.t, z, [...Z]), (z) => z, (z) => de(z));
  }
  function Jt(...Z) {
    const [z, Be, mt] = Z;
    if (mt && !st(mt))
      throw Io(Ot.INVALID_ARGUMENT);
    return Kt(z, Be, Tn({ resolvedMessage: !0 }, mt || {}));
  }
  function pt(...Z) {
    return gt((z) => Reflect.apply(A1, null, [z, ...Z]), () => hm(...Z), "datetime format", (z) => Reflect.apply(z.d, z, [...Z]), () => td, (z) => de(z));
  }
  function Ee(...Z) {
    return gt((z) => Reflect.apply(P1, null, [z, ...Z]), () => dm(...Z), "number format", (z) => Reflect.apply(z.n, z, [...Z]), () => td, (z) => de(z));
  }
  function xn(Z) {
    return Z.map((z) => de(z) || _n(z) || bt(z) ? F1(String(z)) : z);
  }
  const en = {
    normalize: xn,
    interpolate: (Z) => Z,
    type: "vnode"
  };
  function hn(...Z) {
    return gt(
      (z) => {
        let Be;
        const mt = z;
        try {
          mt.processor = en, Be = Reflect.apply(N1, null, [mt, ...Z]);
        } finally {
          mt.processor = null;
        }
        return Be;
      },
      () => cm(...Z),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (z) => z[gm](...Z),
      (z) => [F1(z)],
      (z) => Qt(z)
    );
  }
  function dn(...Z) {
    return gt(
      (z) => Reflect.apply(P1, null, [z, ...Z]),
      () => dm(...Z),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (z) => z[pm](...Z),
      J1,
      (z) => de(z) || Qt(z)
    );
  }
  function En(...Z) {
    return gt(
      (z) => Reflect.apply(A1, null, [z, ...Z]),
      () => hm(...Z),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (z) => z[fm](...Z),
      J1,
      (z) => de(z) || Qt(z)
    );
  }
  function Zn(Z) {
    P = Z, Y.pluralRules = P;
  }
  function $(Z, z) {
    return gt(() => {
      if (!Z)
        return !1;
      const Be = de(z) ? z : h.value, mt = Mt(Be), Bn = Y.messageResolver(mt, Z);
      return s ? Bn != null : Jr(Bn) || Yi(Bn) || de(Bn);
    }, () => [Z], "translate exists", (Be) => Reflect.apply(Be.te, Be, [Z, z]), uz, (Be) => bt(Be));
  }
  function Oe(Z) {
    let z = null;
    const Be = mT(Y, d.value, h.value);
    for (let mt = 0; mt < Be.length; mt++) {
      const Bn = f.value[Be[mt]] || {}, ra = Y.messageResolver(Bn, Z);
      if (ra != null) {
        z = ra;
        break;
      }
    }
    return z;
  }
  function ai(Z) {
    const z = Oe(Z);
    return z ?? (t ? t.tm(Z) || {} : {});
  }
  function Mt(Z) {
    return f.value[Z] || {};
  }
  function oi(Z, z) {
    if (o) {
      const Be = { [Z]: z };
      for (const mt in Be)
        qh(Be, mt) && Nl(Be[mt]);
      z = Be[Z];
    }
    f.value[Z] = z, Y.messages = f.value;
  }
  function oa(Z, z) {
    f.value[Z] = f.value[Z] || {};
    const Be = { [Z]: z };
    if (o)
      for (const mt in Be)
        qh(Be, mt) && Nl(Be[mt]);
    z = Be[Z], Sh(z, f.value[Z]), Y.messages = f.value;
  }
  function D(Z) {
    return p.value[Z] || {};
  }
  function N(Z, z) {
    p.value[Z] = z, Y.datetimeFormats = p.value, Y1(Y, Z, z);
  }
  function X(Z, z) {
    p.value[Z] = Tn(p.value[Z] || {}, z), Y.datetimeFormats = p.value, Y1(Y, Z, z);
  }
  function le(Z) {
    return y.value[Z] || {};
  }
  function it(Z, z) {
    y.value[Z] = z, Y.numberFormats = y.value, R1(Y, Z, z);
  }
  function Je(Z, z) {
    y.value[Z] = Tn(y.value[Z] || {}, z), Y.numberFormats = y.value, R1(Y, Z, z);
  }
  Z1++, t && io && (Ua(t.locale, (Z) => {
    l && (h.value = Z, Y.locale = Z, Pu(Y, h.value, d.value));
  }), Ua(t.fallbackLocale, (Z) => {
    l && (d.value = Z, Y.fallbackLocale = Z, Pu(Y, h.value, d.value));
  }));
  const We = {
    id: Z1,
    locale: re,
    fallbackLocale: me,
    get inheritLocale() {
      return l;
    },
    set inheritLocale(Z) {
      l = Z, Z && t && (h.value = t.locale.value, d.value = t.fallbackLocale.value, Pu(Y, h.value, d.value));
    },
    get availableLocales() {
      return Object.keys(f.value).sort();
    },
    messages: ut,
    get modifiers() {
      return M;
    },
    get pluralRules() {
      return P || {};
    },
    get isGlobal() {
      return a;
    },
    get missingWarn() {
      return m;
    },
    set missingWarn(Z) {
      m = Z, Y.missingWarn = m;
    },
    get fallbackWarn() {
      return w;
    },
    set fallbackWarn(Z) {
      w = Z, Y.fallbackWarn = w;
    },
    get fallbackRoot() {
      return v;
    },
    set fallbackRoot(Z) {
      v = Z;
    },
    get fallbackFormat() {
      return _;
    },
    set fallbackFormat(Z) {
      _ = Z, Y.fallbackFormat = _;
    },
    get warnHtmlMessage() {
      return A;
    },
    set warnHtmlMessage(Z) {
      A = Z, Y.warnHtmlMessage = Z;
    },
    get escapeParameter() {
      return x;
    },
    set escapeParameter(Z) {
      x = Z, Y.escapeParameter = Z;
    },
    t: Kt,
    getLocaleMessage: Mt,
    setLocaleMessage: oi,
    mergeLocaleMessage: oa,
    getPostTranslationHandler: Ge,
    setPostTranslationHandler: Ae,
    getMissingHandler: It,
    setMissingHandler: xt,
    [rz]: Zn
  };
  return We.datetimeFormats = ht, We.numberFormats = ze, We.rt = Jt, We.te = $, We.tm = ai, We.d = pt, We.n = Ee, We.getDateTimeFormat = D, We.setDateTimeFormat = N, We.mergeDateTimeFormat = X, We.getNumberFormat = le, We.setNumberFormat = it, We.mergeNumberFormat = Je, We[YT] = i, We[gm] = hn, We[fm] = En, We[pm] = dn, process.env.NODE_ENV !== "production" && (We[mm] = (Z) => {
    Y.__v_emitter = Z;
  }, We[ym] = () => {
    Y.__v_emitter = void 0;
  }), We;
}
const Ay = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (n) => n === "parent" || n === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function hz({ slots: n }, e) {
  return e.length === 1 && e[0] === "default" ? (n.default ? n.default() : []).reduce((i, a) => [
    ...i,
    // prettier-ignore
    ...a.type === Ht ? a.children : [a]
  ], []) : e.reduce((t, i) => {
    const a = n[i];
    return a && (t[i] = a()), t;
  }, {});
}
function RT(n) {
  return Ht;
}
Tn({
  keypath: {
    type: String,
    required: !0
  },
  plural: {
    type: [Number, String],
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validator: (n) => _n(n) || !isNaN(n)
  }
}, Ay);
function dz(n) {
  return Qt(n) && !de(n[0]);
}
function FT(n, e, t, i) {
  const { slots: a, attrs: o } = e;
  return () => {
    const r = { part: !0 };
    let s = {};
    n.locale && (r.locale = n.locale), de(n.format) ? r.key = n.format : st(n.format) && (de(n.format.key) && (r.key = n.format.key), s = Object.keys(n.format).reduce((p, y) => t.includes(y) ? Tn({}, p, { [y]: n.format[y] }) : p, {}));
    const l = i(n.value, r, s);
    let h = [r.key];
    Qt(l) ? h = l.map((p, y) => {
      const m = a[p.type], w = m ? m({ [p.type]: p.value, index: y, parts: l }) : [p.value];
      return dz(w) && (w[0].key = `${p.type}-${y}`), w;
    }) : de(l) && (h = [l]);
    const d = Tn({}, o), f = de(n.tag) || st(n.tag) ? n.tag : RT();
    return ao(f, d, h);
  };
}
Tn({
  value: {
    type: Number,
    required: !0
  },
  format: {
    type: [String, Object]
  }
}, Ay);
Tn({
  value: {
    type: [Number, Date],
    required: !0
  },
  format: {
    type: [String, Object]
  }
}, Ay);
function H1(n, e) {
}
const gz = /* @__PURE__ */ so("global-vue-i18n");
function Zd(n = {}) {
  const e = Zr();
  if (e == null)
    throw Io(Ot.MUST_BE_CALL_SETUP_TOP);
  if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
    throw Io(Ot.NOT_INSTALLED);
  const t = fz(e), i = mz(t), a = PT(e), o = pz(n, a);
  if (__VUE_I18N_LEGACY_API__ && t.mode === "legacy" && !n.__useComponent) {
    if (!t.allowComposition)
      throw Io(Ot.NOT_AVAILABLE_IN_LEGACY_MODE);
    return vz(e, o, i, n);
  }
  if (o === "global")
    return sz(i, n, a), i;
  if (o === "parent") {
    let l = yz(t, e, n.__useComponent);
    return l == null && (process.env.NODE_ENV !== "production" && uo(nd($n.NOT_FOUND_PARENT_SCOPE)), l = i), l;
  }
  const r = t;
  let s = r.__getInstance(e);
  if (s == null) {
    const l = Tn({}, n);
    "__i18n" in a && (l.__i18n = a.__i18n), i && (l.__root = i), s = cz(l), r.__composerExtend && (s[bm] = r.__composerExtend(s)), wz(r, e, s), r.__setInstance(e, s);
  }
  return s;
}
function fz(n) {
  {
    const e = wA(n.isCE ? gz : n.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e)
      throw Io(n.isCE ? Ot.NOT_INSTALLED_WITH_PROVIDE : Ot.UNEXPECTED_ERROR);
    return e;
  }
}
function pz(n, e) {
  return Pd(n) ? "__i18n" in e ? "local" : "global" : n.useScope ? n.useScope : "local";
}
function mz(n) {
  return n.mode === "composition" ? n.global : n.global.__composer;
}
function yz(n, e, t = !1) {
  let i = null;
  const a = e.root;
  let o = bz(e, t);
  for (; o != null; ) {
    const r = n;
    if (n.mode === "composition")
      i = r.__getInstance(o);
    else if (__VUE_I18N_LEGACY_API__) {
      const s = r.__getInstance(o);
      s != null && (i = s.__composer, t && i && !i[YT] && (i = null));
    }
    if (i != null || a === o)
      break;
    o = o.parent;
  }
  return i;
}
function bz(n, e = !1) {
  return n == null ? null : e && n.vnode.ctx || n.parent;
}
function wz(n, e, t) {
  let i = null;
  Vs(() => {
    if (process.env.NODE_ENV !== "production" && e.vnode.el) {
      e.vnode.el.__VUE_I18N__ = t, i = O6();
      const a = t;
      a[mm] && a[mm](i), i.on("*", H1);
    }
  }, e), Q1(() => {
    const a = t;
    process.env.NODE_ENV !== "production" && e.vnode.el && e.vnode.el.__VUE_I18N__ && (i && i.off("*", H1), a[ym] && a[ym](), delete e.vnode.el.__VUE_I18N__), n.__deleteInstance(e);
    const o = a[bm];
    o && (o(), delete a[bm]);
  }, e);
}
function vz(n, e, t, i = {}) {
  const a = e === "local", o = wm(null);
  if (a && n.proxy && !(n.proxy.$options.i18n || n.proxy.$options.__i18n))
    throw Io(Ot.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  const r = bt(i.inheritLocale) ? i.inheritLocale : !de(i.locale), s = vn(
    // prettier-ignore
    !a || r ? t.locale.value : de(i.locale) ? i.locale : Ml
  ), l = vn(
    // prettier-ignore
    !a || r ? t.fallbackLocale.value : de(i.fallbackLocale) || Qt(i.fallbackLocale) || Ke(i.fallbackLocale) || i.fallbackLocale === !1 ? i.fallbackLocale : s.value
  ), h = vn(Oy(s.value, i)), d = vn(Ke(i.datetimeFormats) ? i.datetimeFormats : { [s.value]: {} }), f = vn(Ke(i.numberFormats) ? i.numberFormats : { [s.value]: {} }), p = a ? t.missingWarn : bt(i.missingWarn) || zs(i.missingWarn) ? i.missingWarn : !0, y = a ? t.fallbackWarn : bt(i.fallbackWarn) || zs(i.fallbackWarn) ? i.fallbackWarn : !0, m = a ? t.fallbackRoot : bt(i.fallbackRoot) ? i.fallbackRoot : !0, w = !!i.fallbackFormat, v = jt(i.missing) ? i.missing : null, _ = jt(i.postTranslation) ? i.postTranslation : null, L = a ? t.warnHtmlMessage : bt(i.warnHtmlMessage) ? i.warnHtmlMessage : !0, T = !!i.escapeParameter, S = a ? t.modifiers : Ke(i.modifiers) ? i.modifiers : {}, A = i.pluralRules || a && t.pluralRules;
  function x() {
    return [
      s.value,
      l.value,
      h.value,
      d.value,
      f.value
    ];
  }
  const M = wt({
    get: () => o.value ? o.value.locale.value : s.value,
    set: ($) => {
      o.value && (o.value.locale.value = $), s.value = $;
    }
  }), P = wt({
    get: () => o.value ? o.value.fallbackLocale.value : l.value,
    set: ($) => {
      o.value && (o.value.fallbackLocale.value = $), l.value = $;
    }
  }), Y = wt(() => o.value ? o.value.messages.value : h.value), te = wt(() => d.value), ge = wt(() => f.value);
  function re() {
    return o.value ? o.value.getPostTranslationHandler() : _;
  }
  function me($) {
    o.value && o.value.setPostTranslationHandler($);
  }
  function ut() {
    return o.value ? o.value.getMissingHandler() : v;
  }
  function ht($) {
    o.value && o.value.setMissingHandler($);
  }
  function ze($) {
    return x(), $();
  }
  function Ge(...$) {
    return o.value ? ze(() => Reflect.apply(o.value.t, null, [...$])) : ze(() => "");
  }
  function Ae(...$) {
    return o.value ? Reflect.apply(o.value.rt, null, [...$]) : "";
  }
  function It(...$) {
    return o.value ? ze(() => Reflect.apply(o.value.d, null, [...$])) : ze(() => "");
  }
  function xt(...$) {
    return o.value ? ze(() => Reflect.apply(o.value.n, null, [...$])) : ze(() => "");
  }
  function ft($) {
    return o.value ? o.value.tm($) : {};
  }
  function gt($, Oe) {
    return o.value ? o.value.te($, Oe) : !1;
  }
  function Kt($) {
    return o.value ? o.value.getLocaleMessage($) : {};
  }
  function Jt($, Oe) {
    o.value && (o.value.setLocaleMessage($, Oe), h.value[$] = Oe);
  }
  function pt($, Oe) {
    o.value && o.value.mergeLocaleMessage($, Oe);
  }
  function Ee($) {
    return o.value ? o.value.getDateTimeFormat($) : {};
  }
  function xn($, Oe) {
    o.value && (o.value.setDateTimeFormat($, Oe), d.value[$] = Oe);
  }
  function Xt($, Oe) {
    o.value && o.value.mergeDateTimeFormat($, Oe);
  }
  function en($) {
    return o.value ? o.value.getNumberFormat($) : {};
  }
  function hn($, Oe) {
    o.value && (o.value.setNumberFormat($, Oe), f.value[$] = Oe);
  }
  function dn($, Oe) {
    o.value && o.value.mergeNumberFormat($, Oe);
  }
  const En = {
    get id() {
      return o.value ? o.value.id : -1;
    },
    locale: M,
    fallbackLocale: P,
    messages: Y,
    datetimeFormats: te,
    numberFormats: ge,
    get inheritLocale() {
      return o.value ? o.value.inheritLocale : r;
    },
    set inheritLocale($) {
      o.value && (o.value.inheritLocale = $);
    },
    get availableLocales() {
      return o.value ? o.value.availableLocales : Object.keys(h.value);
    },
    get modifiers() {
      return o.value ? o.value.modifiers : S;
    },
    get pluralRules() {
      return o.value ? o.value.pluralRules : A;
    },
    get isGlobal() {
      return o.value ? o.value.isGlobal : !1;
    },
    get missingWarn() {
      return o.value ? o.value.missingWarn : p;
    },
    set missingWarn($) {
      o.value && (o.value.missingWarn = $);
    },
    get fallbackWarn() {
      return o.value ? o.value.fallbackWarn : y;
    },
    set fallbackWarn($) {
      o.value && (o.value.missingWarn = $);
    },
    get fallbackRoot() {
      return o.value ? o.value.fallbackRoot : m;
    },
    set fallbackRoot($) {
      o.value && (o.value.fallbackRoot = $);
    },
    get fallbackFormat() {
      return o.value ? o.value.fallbackFormat : w;
    },
    set fallbackFormat($) {
      o.value && (o.value.fallbackFormat = $);
    },
    get warnHtmlMessage() {
      return o.value ? o.value.warnHtmlMessage : L;
    },
    set warnHtmlMessage($) {
      o.value && (o.value.warnHtmlMessage = $);
    },
    get escapeParameter() {
      return o.value ? o.value.escapeParameter : T;
    },
    set escapeParameter($) {
      o.value && (o.value.escapeParameter = $);
    },
    t: Ge,
    getPostTranslationHandler: re,
    setPostTranslationHandler: me,
    getMissingHandler: ut,
    setMissingHandler: ht,
    rt: Ae,
    d: It,
    n: xt,
    tm: ft,
    te: gt,
    getLocaleMessage: Kt,
    setLocaleMessage: Jt,
    mergeLocaleMessage: pt,
    getDateTimeFormat: Ee,
    setDateTimeFormat: xn,
    mergeDateTimeFormat: Xt,
    getNumberFormat: en,
    setNumberFormat: hn,
    mergeNumberFormat: dn
  };
  function Zn($) {
    $.locale.value = s.value, $.fallbackLocale.value = l.value, Object.keys(h.value).forEach((Oe) => {
      $.mergeLocaleMessage(Oe, h.value[Oe]);
    }), Object.keys(d.value).forEach((Oe) => {
      $.mergeDateTimeFormat(Oe, d.value[Oe]);
    }), Object.keys(f.value).forEach((Oe) => {
      $.mergeNumberFormat(Oe, f.value[Oe]);
    }), $.escapeParameter = T, $.fallbackFormat = w, $.fallbackRoot = m, $.fallbackWarn = y, $.missingWarn = p, $.warnHtmlMessage = L;
  }
  return vA(() => {
    if (n.proxy == null || n.proxy.$i18n == null)
      throw Io(Ot.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    const $ = o.value = n.proxy.$i18n.__composer;
    e === "global" ? (s.value = $.locale.value, l.value = $.fallbackLocale.value, h.value = $.messages.value, d.value = $.datetimeFormats.value, f.value = $.numberFormats.value) : a && Zn($);
  }), En;
}
iz();
__INTLIFY_JIT_COMPILATION__ ? L1($8) : L1(z8);
J8(v8);
Z8(mT);
if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
  const n = Ka();
  n.__INTLIFY__ = !0, E8(n.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
process.env.NODE_ENV;
const Cz = {}, Sz = { class: "text-lg font-bold" };
function kz(n, e) {
  return q(), ie("span", Sz, [
    Ri(n.$slots, "default")
  ]);
}
const _z = /* @__PURE__ */ fd(Cz, [["render", kz]]), jz = { class: "flex gap-1" }, Tz = {
  key: 0,
  class: "TheMapAsText"
}, Lz = ["innerHTML"], xz = /* @__PURE__ */ Xe({
  __name: "TheMapAsText",
  setup(n) {
    const { mapFile: e, mapCurrent: t } = qt(), {
      guest: i,
      patron: a,
      textOf: o,
      textNlAsBr: r,
      textWithoutHTML: s
    } = vi(), l = e.currentMap(new qe()).ref(), h = Ms(""), d = Ms([]);
    t.objects(
      a.create(
        i.create(qs((_) => {
          d.value = _, r.create(
            o.create(
              _.map((L) => `<div class="TheMapAsText-Item">
                <h3>${L.name}</h3><p>${L.additionalName || ""}</p><p>${L.description || ""}</p><p>${L.additionalFields && Object.values(L.additionalFields).join("</p><p>")}</p></div>`).join("")
            )
          ).asString(
            i.create((L) => {
              h.value = L;
            })
          );
        }, 500))
      )
    );
    const f = Zd(), { share: p, isSupported: y } = tY(), m = () => {
      y.value || alert(f.t("general.notifications.sharingDontSupported")), s.create(
        o.create(
          h.value
        )
      ).asString(
        i.create((_) => {
          p({
            text: _
          });
        })
      );
    }, w = Ms(), v = () => {
      var _, L;
      if (l.value) {
        const T = new Range();
        T.setStart(w.value, 0), T.setEnd(w.value, Object.values(d.value).length), (_ = document.getSelection()) == null || _.removeAllRanges(), (L = document.getSelection()) == null || L.addRange(T);
      }
    };
    return (_, L) => (q(), ln(ou, { name: "mapAsText" }, {
      header: se(() => [
        V(_z, { class: "block mb-3" }, {
          default: se(() => [
            Ue(we(_.$t("general.mapAsText")) + " ", 1),
            ae("div", jz, [
              V(kt, {
                size: "sm",
                type: "success",
                class: "font-normal",
                onClick: m
              }, {
                default: se(() => [
                  Ue(we(_.$t("general.share")), 1)
                ]),
                _: 1
              }),
              V(kt, {
                size: "sm",
                type: "primary",
                class: "font-normal",
                onClick: v
              }, {
                default: se(() => [
                  Ue(we(_.$t("general.selectAll")), 1)
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        })
      ]),
      default: se(() => [
        I(l) ? (q(), ie("article", Tz, [
          ae("div", {
            ref_key: "textRef",
            ref: w,
            innerHTML: I(h)
          }, null, 8, Lz)
        ])) : tt("", !0)
      ]),
      _: 1
    }));
  }
}), Ez = { class: "AppSearch" }, Dz = {
  key: 0,
  class: "AppSearch-Items"
}, Mz = ["onClick"], Nz = ["innerHTML"], Oz = ["innerHTML"], Az = ["innerHTML"], Yz = { key: 1 }, Pz = { key: 2 }, Rz = /* @__PURE__ */ Xe({
  __name: "AppSearch",
  setup(n) {
    const {
      objectsMatchedToQuery: e,
      controlCombo: t,
      modal: i,
      stagePosition: a
    } = qt(), { guest: o, patron: r } = vi(), s = Ms(), l = Ie.debug("app:AppSearch");
    i.isOpenedByName(
      "search",
      r.create(o.create((f) => {
        setTimeout(() => {
          f && s.value && (l("search is opened", f), s.value.$el.focus());
        }, 500);
      }))
    );
    const h = Ms(""), d = e.objects(
      new Zm(h),
      new qe([])
    ).ref();
    return t.happened(
      "KeyF",
      r.create(o.create(() => {
        i.give("search");
      }))
    ), (f, p) => (q(), ln(ou, { name: "search" }, {
      default: se(() => [
        ae("div", Ez, [
          V(ga, {
            ref_key: "inputRef",
            ref: s,
            modelValue: I(h),
            "onUpdate:modelValue": p[0] || (p[0] = (y) => Ol(h) ? h.value = y : null),
            class: "mb-2 e2e-query-input",
            placeholder: f.$t("general.specifyQuery")
          }, null, 8, ["modelValue", "placeholder"]),
          I(d).length ? (q(), ie("div", Dz, [
            (q(!0), ie(Ht, null, Un(I(d), (y) => (q(), ie("div", {
              key: y.name,
              class: "cursor-pointer",
              onClick: Us((m) => {
                I(a).give(y), I(i).give("");
              }, ["prevent"])
            }, [
              ae("b", {
                class: "AppSearch-ItemName",
                innerHTML: y.name
              }, null, 8, Nz),
              y.additionalName ? (q(), ie("b", {
                key: 0,
                class: "AppSearch-ItemName",
                innerHTML: y.additionalName
              }, null, 8, Oz)) : tt("", !0),
              y.additionalFields ? (q(), ie("div", {
                key: 1,
                innerHTML: Object.values(y.additionalFields).join(" ")
              }, null, 8, Az)) : tt("", !0)
            ], 8, Mz))), 128))
          ])) : I(h) ? (q(), ie("div", Yz, we(f.$t("general.noResults")), 1)) : (q(), ie("div", Pz, we(f.$t("general.resultsWillBeHere")), 1))
        ])
      ]),
      _: 1
    }));
  }
}), Fz = ["onClick"], Iz = /* @__PURE__ */ Xe({
  __name: "AppFileMaps",
  setup(n) {
    const {
      mapFile: e,
      mapCurrentID: t,
      drawer: i,
      mapRemoved: a
    } = qt(), o = e.mapFile(new qe()).ref(), r = t.id(new qe()).ref(), s = (l) => {
      confirm("Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹?") && a.give(l);
    };
    return (l, h) => (q(), ln(Um, {
      direction: "rtl",
      name: "fileMaps"
    }, {
      header: se(() => h[0] || (h[0] = [
        ae("h2", { class: "text-lg font-bold" }, " ÐšÐ°Ñ€Ñ‚Ñ‹ Ð² Ñ„Ð°Ð¹Ð»Ðµ ", -1)
      ])),
      default: se(() => [
        ae("div", null, [
          (q(!0), ie(Ht, null, Un(I(o), (d, f) => (q(), ie("div", {
            key: f,
            class: "flex items-center gap-2"
          }, [
            ae("a", {
              href: "#",
              class: va({ "font-bold": I(r) === f }),
              onClick: Us((p) => {
                I(t).give(f), I(i).give("");
              }, ["prevent"])
            }, we(d.settings.title), 11, Fz),
            V(gi, {
              onClick: (p) => s(f),
              class: "text-danger-second cursor-pointer",
              title: "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ ÐºÐ°Ñ€Ñ‚Ñƒ",
              icon: "fa-close"
            }, null, 8, ["onClick"])
          ]))), 128))
        ])
      ]),
      _: 1
    }));
  }
}), Jz = { class: "grid grid-cols-[200px_1fr] grid-rows-[50px_1fr] h-dvh relative" }, Kz = /* @__PURE__ */ Xe({
  __name: "PatronSchemeEditor",
  props: {
    modelValue: {
      type: String,
      required: !0
    }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: e }) {
    const t = n, i = e, { fileContent: a } = qt(), { guest: o, patron: r } = vi();
    return Ua(() => t.modelValue, (s) => {
      a.value(o.create((l) => {
        s !== l && a.give(s);
      }));
    }, {
      immediate: !0
    }), a.value(r.create((s) => {
      i("update:modelValue", s);
    })), (s, l) => (q(), ie(Ht, null, [
      ae("div", Jz, [
        V(hZ, { class: "col-span-2" }),
        V(_Z),
        V(HZ, { class: "w-auto col-auto h-full" }),
        V(GZ)
      ]),
      V(ZK),
      V(VK),
      V(s6),
      V(d6),
      V(y6),
      V(k6),
      V(xz),
      V(Rz),
      V(Iz)
    ], 64));
  }
}), X1 = Ie.debug("FileSystemContent");
class zz {
  constructor(e, t, i) {
    xe(this, "contentPatrons");
    xe(this, "fileHandler", null);
    this.launchQueue = e, this.notification = t, this.factories = i, this.contentPatrons = i.pool.create(this);
  }
  content(e) {
    const t = this.factories.guest.create((i) => {
      this.fileHandler = i, this.factories.fileHandlerContent.create(i).content(
        this.factories.guest.create((a) => {
          this.contentPatrons.distribute(a, e);
        })
      );
    });
    return this.fileHandler ? t.give(this.fileHandler) : this.launchQueue.fileHandler(t), this;
  }
  give(e) {
    if (X1("save file as content string", e), !this.fileHandler)
      throw new cl("Cant save file because no fileHandler");
    try {
      return this.factories.browserFileSaved.create(this.fileHandler).save(e), this.contentPatrons.give(e), this;
    } catch (t) {
      throw new cl("Cant handle receive for map file FS", { cause: t });
    } finally {
      this.notification.give({
        type: "success",
        text: "Ð£ÑÐ¿ÐµÑˆÐ½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½ Ñ„Ð°Ð¹Ð» ÐºÐ°Ñ€Ñ‚Ñ‹!"
      });
    }
  }
  canBeUsed(e) {
    const t = "launchQueue" in window;
    X1("can be used", t);
    const i = window.matchMedia("(display-mode: standalone)");
    return e.give(t && i.matches), e;
  }
}
const G1 = Ie.debug("FirstPossibleFileContent");
class $z {
  constructor(e, t) {
    xe(this, "firstPossibleFileContent", null);
    e.forEach((i) => {
      i.canBeUsed(
        t.guest.create((a) => {
          a && !this.firstPossibleFileContent && (this.firstPossibleFileContent = i);
        })
      );
    });
  }
  canBeUsed(e) {
    return G1("can be used to", this.firstPossibleFileContent), this.firstPossibleFileContent && this.firstPossibleFileContent.canBeUsed(e), e;
  }
  content(e) {
    return G1("content to", this.firstPossibleFileContent), this.firstPossibleFileContent && this.firstPossibleFileContent.content(e), this;
  }
  give(e) {
    return this.firstPossibleFileContent && this.firstPossibleFileContent.give(e), this;
  }
}
const tp = Ie.debug("UrlContent");
class Vz {
  constructor(e, t) {
    xe(this, "contentCache");
    this.notification = e, this.factories = t, this.contentCache = t.sourceEmpty.create();
  }
  canBeUsed(e) {
    const t = window.location.search.indexOf("?view=") > -1;
    if (tp("can be used", t), e.give(window.location.search.indexOf("?view=") > -1), t) {
      const i = window.location.search.split("=")[1] ?? "";
      fetch(i, { redirect: "follow" }).then((a) => a.text()).then((a) => {
        tp("received text", a), this.contentCache.give(a);
      });
    }
    return e;
  }
  content(e) {
    const t = window.location.search.split("=")[1] ?? "";
    return tp("visit url", t), this.contentCache.value(this.factories.patronOnce.create(e)), this;
  }
  give() {
    return this.notification.give({
      type: "error",
      text: "ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÐºÐ°Ñ€Ñ‚Ñƒ, Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑƒÑŽ Ð¿Ð¾ ÑÑÑ‹Ð»ÐºÐµ!"
    }), this;
  }
}
class Uz {
  constructor(e = window.launchQueue, t = "launchQueue" in window) {
    this.launchQueue = e, this.isLaunchQueueSupported = t;
  }
  fileHandler(e) {
    return this.isLaunchQueueSupported && this.launchQueue.setConsumer((t) => {
      if (t.files && t.files.length) {
        const [i] = t.files;
        e.give(i);
      }
    }), this;
  }
}
export {
  Uz as BrowserLaunchQueue,
  zz as FileSystemContent,
  $z as FirstPossibleFileContent,
  Kz as PatronSchemeEditor,
  Vz as UrlContent,
  qe as VueRefPatron,
  qt as useApplication,
  vi as useFactories
};
